[
  {
    "name": "crowdin-editor-right-panel",
    "language": "typescript",
    "frameworks": [
      "@dnd-kit",
      "@hookform/resolvers",
      "autoprefixer",
      "class-variance-authority",
      "cloudflare",
      "clsx",
      "cmdk",
      "date-fns",
      "express",
      "framer-motion",
      "immer",
      "input-otp",
      "next",
      "postcss",
      "react",
      "recharts",
      "sonner",
      "tailwind",
      "tw-animate-css",
      "typescript",
      "vaul",
      "vite",
      "wrangler",
      "zod",
      "zustand"
    ],
    "description": {
      "selection": "# Template Selection\n\nCrowdin app with Editor Right Panel module.\n\nUse when:\n- Building translation assistance tools and helpers\n- Creating context-aware editor extensions\n- Developing quality assurance and validation tools\n- Building translation suggestion and auto-completion tools\n- Creating custom translation workflows\n- Adding glossary, terminology, or reference tools\n\nAvoid when:\n- Integrating custom AI providers (use AI Provider instead)\n- Building machine translation integrations (use Custom MT instead)\n- Transforming files during import/export (use File Processing instead)\n- Building organization-wide tools (use Organization Menu instead)\n- Building user profile tools (use Profile Resources Menu instead)\n- Building project-specific tools (use Project Tools instead)\n\nBuilt with:\n- Crowdin Apps JS API\n- Crowdin Apps SDK (@crowdin/app-project-module)\n- React\n- ShadCN UI\n- Tailwind\n- Lucide Icons\n- ESLint\n- Vite\n- TypeScript\n- Express.js\n- Cloudflare Workers",
      "usage": "# Usage\n\n## Overview\nCrowdin app with Editor Right Panel module for translation editor extensions.\n- Backend: TypeScript with Express.js and Crowdin Apps SDK\n- Frontend: React + TypeScript + ShadCN UI + Crowdin Apps JS API\n\n## Tech Stack\n- Crowdin Apps JS API\n- Crowdin Apps SDK (@crowdin/app-project-module)\n- React\n- ShadCN UI\n- Tailwind\n- Lucide Icons\n- ESLint\n- Vite\n- TypeScript\n- Express.js\n- Cloudflare Workers\n\n## Development Restrictions\n- **Tailwind Colors**: Hardcode custom colors in `tailwind.config.js`, NOT in `index.css`\n- **Components**: Use existing ShadCN components instead of writing custom ones\n- **Icons**: Import from `lucide-react` directly\n- **Error Handling**: ErrorBoundary components are pre-implemented\n- **Authentication**: Always use JWT tokens from Crowdin for API requests\n- **Editor Right Panel Configuration**: Don't modify the editorRightPanel configuration structure\n- **Scopes**: Ensure your app has appropriate API scopes\n- **Storage Keys**: Always include organizationId in metadata keys to isolate data per organization\n- **Panel Width**: Design for 300-400px width (sidebar constraint)\n- **Editor Modes**: Panel appears only in specified editor modes (comfortable, side-by-side, multilingual, review, assets)\n- **Event Handling**: Listen to editor events for real-time updates\n\n## Styling\n- Responsive, accessible\n- Prefer ShadCN components; Tailwind for layout/spacing/typography\n- Use framer-motion sparingly for micro-interactions\n\n## Project Structure\n\n### Backend Structure\n- `worker/app.ts` - Express app factory with Editor Right Panel configuration\n- `worker/index.ts` - Cloudflare Worker entry point (HTTP handler, cron scheduler, middleware)\n- `worker/types/` - Backend TypeScript type definitions\n  - `cloudflare-env.d.ts` - Cloudflare environment types (KV storage, secrets)\n\n### Frontend Structure\n- `index.html` - HTML entry point with Crowdin Apps JS API script\n- `src/main.tsx` - React entry point with ErrorBoundary wrapper\n- `src/index.css` - Global styles and Tailwind CSS customizations\n- `src/components/` - React components\n  - `app-sidebar.tsx` - Application sidebar navigation\n  - `ErrorBoundary.tsx` - React error boundary with backend error reporting\n  - `ErrorFallback.tsx` - Fallback UI component for error states\n  - `RouteErrorBoundary.tsx` - Error boundary for routing errors\n  - `layout/` - Layout components\n    - `AppLayout.tsx` - Main application layout wrapper\n  - `ui/` - ShadCN UI components (button, card, sonner, etc.)\n- `src/pages/` - Page components\n  - `HomePage.tsx` - Home page component (main entry point for your app logic)\n- `src/hooks/` - Custom React hooks\n  - `use-mobile.tsx` - Hook for detecting mobile breakpoints\n- `src/lib/` - Utility modules\n  - `utils.ts` - Tailwind utility functions (`cn` for class merging)\n  - `errorReporter.ts` - Client-side error reporting to backend\n  - `apiClient.ts` - Generic API call wrapper with JWT token handling\n- `src/types/` - TypeScript type definitions\n  - `global.d.ts` - Global type declarations\n  - `vite-env.d.ts` - Vite environment types\n\n## Backend Development\n\n### App Configuration\n\nConfigure your app identity in `worker/app.ts`:\n\n```typescript\nconst configuration: ClientConfig = {\n    name: \"Your App Name\",                    // Display name shown in Crowdin UI\n    identifier: \"your-unique-app-identifier\", // Unique ID (lowercase, hyphens)\n    description: \"Your app description\",      // Brief description of functionality\n    // ... rest of configuration\n}\n```\n\n**Guidelines:**\n- **identifier**: Must be unique across all Crowdin apps. Format: `company-editor-tool`\n- **name**: User-friendly display name (e.g., \"Translation Helper\")\n- **description**: Brief explanation of what your app does\n\n#### Required Scopes\n\nAdd scopes to configuration in `worker/app.ts` based on your app's functionality.\n\n**‚ö†Ô∏è IMPORTANT**: Only use scopes from the list below. Do not invent or use non-existent scopes!\n\n```typescript\nconst configuration: ClientConfig = {\n    // ... other configuration ...\n    scopes: [\n        // Choose from the following valid scopes:\n        \n        // General scopes\n        crowdinModule.Scope.NOTIFICATIONS,               // 'notification' - Notifications management\n        \n        // Project-level scopes\n        crowdinModule.Scope.PROJECTS,                    // 'project' - Project management\n        crowdinModule.Scope.TASKS,                       // 'project.task' - Project tasks\n        crowdinModule.Scope.REPORTS,                     // 'project.report' - Project reports\n        crowdinModule.Scope.TRANSLATION_STATUS,          // 'project.status' - Translation status\n        crowdinModule.Scope.SOURCE_FILES_AND_STRINGS,    // 'project.source' - Source files and strings\n        crowdinModule.Scope.WEBHOOKS,                    // 'project.webhook' - Project webhooks\n        crowdinModule.Scope.TRANSLATIONS,                // 'project.translation' - Translations\n        crowdinModule.Scope.SCREENSHOTS,                 // 'project.screenshot' - Screenshots\n        \n        // Organization-level scopes\n        crowdinModule.Scope.USERS,                       // 'user' - User management\n        crowdinModule.Scope.TEAMS,                       // 'team' - Team management\n        crowdinModule.Scope.GROUPS,                      // 'group' - Group management\n        crowdinModule.Scope.ORGANIZATION_WEBHOOKS,       // 'webhook' - Organization webhooks\n        crowdinModule.Scope.VENDORS,                     // 'vendor' - Vendor management\n        crowdinModule.Scope.FIELDS,                      // 'field' - Custom fields\n        crowdinModule.Scope.SECURITY_LOGS,               // 'security-log' - Security logs\n        crowdinModule.Scope.APPLICATIONS,                // 'application' - Applications management\n        \n        // Resources\n        crowdinModule.Scope.TRANSLATION_MEMORIES,        // 'tm' - Translation memories\n        crowdinModule.Scope.MACHINE_TRANSLATION_ENGINES, // 'mt' - Machine translation engines\n        crowdinModule.Scope.GLOSSARIES,                  // 'glossary' - Glossaries\n        \n        // AI-related scopes\n        crowdinModule.Scope.AI,                          // 'ai' - AI features\n        crowdinModule.Scope.AI_PROVIDERS,                // 'ai.provider' - AI providers\n        crowdinModule.Scope.AI_PROMPTS,                  // 'ai.prompt' - AI prompts\n        crowdinModule.Scope.AI_PROXIES,                  // 'ai.proxy' - AI proxies\n    ]\n}\n```\n\n### Editor Right Panel Module Configuration\n\nConfigure the Editor Right Panel module in `worker/app.ts`:\n\n```typescript\nconst configuration: ClientConfig = {\n    // ... other configuration ...\n\n    editorRightPanel: {\n      fileName: 'index.html',\n      uiPath: '/',\n      modes: [EditorMode.COMFORTABLE, EditorMode.SIDE_BY_SIDE], // Specify editor modes where panel appears\n      supportsMultipleStrings: true // Handle multiple string selection\n    }\n}\n```\n\n#### Editor Modes\n\n```typescript\nimport { EditorMode } from '@crowdin/app-project-module/out/types';\n\n// Available editor modes:\nEditorMode.COMFORTABLE   // Comfortable mode (most common)\nEditorMode.SIDE_BY_SIDE  // Side-by-side mode (most common)\nEditorMode.MULTILINGUAL  // Multilingual mode\nEditorMode.REVIEW        // Review mode\nEditorMode.ASSETS        // Assets mode\n```\n\n**Recommended:** Use `[EditorMode.COMFORTABLE, EditorMode.SIDE_BY_SIDE]` for most use cases.\n\n### API Endpoints Best Practices\n\n#### Common Examples\n\n**Standard Endpoint:**\n```typescript\napp.post('/api/process-data', async (req: Request, res: Response) => {\n    try {\n        const jwt = req.query.jwt as string;\n        const { data } = req.body;\n        \n        if (!jwt) {\n            return res.status(400).json({ success: false, error: 'JWT token is required' });\n        }\n        if (!data) {\n            return res.status(400).json({ success: false, error: 'Data is required' });\n        }\n\n        const connection = await crowdinApp.establishCrowdinConnection(jwt, undefined);\n        \n        // Your async logic here\n        const result = await processData(data);\n        \n        res.json({ \n            success: true, \n            result\n        });\n    } catch (error) {\n        console.error('Error:', error);\n        res.status(500).json({ success: false, error: 'Operation failed' });\n    }\n});\n```\n\n#### Best Practices\n\n1. **Always await async operations**\n   ```typescript\n   // ‚úÖ CORRECT - all operations are awaited\n   app.post('/api/save-config', async (req: Request, res: Response) => {\n       const jwt = req.query.jwt as string;\n       const connection = await crowdinApp.establishCrowdinConnection(jwt, undefined);\n       \n       await crowdinApp.saveMetadata(key, data, connection.context.crowdinId);\n       \n       res.json({ success: true });\n   });\n   \n   // ‚ùå WRONG - missing await, operation will NOT complete\n   app.post('/api/save-config', async (req: Request, res: Response) => {\n       const jwt = req.query.jwt as string;\n       const connection = await crowdinApp.establishCrowdinConnection(jwt, undefined);\n       \n       // This will NOT save! Response is sent before operation completes\n       crowdinApp.saveMetadata(key, data, connection.context.crowdinId);\n       \n       res.json({ success: true });\n   });\n   ```\n\n2. **Always return response after all operations complete**\n   ```typescript\n   // ‚úÖ CORRECT - response sent after all operations\n   app.post('/api/update', async (req: Request, res: Response) => {\n       const connection = await crowdinApp.establishCrowdinConnection(jwt, undefined);\n       \n       await operation1();\n       await operation2();\n       await operation3();\n       \n       res.json({ success: true }); // All operations completed\n   });\n   \n   // ‚ùå WRONG - response sent too early\n   app.post('/api/update', async (req: Request, res: Response) => {\n       const connection = await crowdinApp.establishCrowdinConnection(jwt, undefined);\n       \n       res.json({ success: true }); // Sent immediately\n       \n       await operation1(); // These will NOT execute\n       await operation2();\n       await operation3();\n   });\n   ```\n\n3. **Use Promise.all for independent parallel operations**\n   ```typescript\n   // ‚úÖ CORRECT - parallel operations (faster)\n   const [result1, result2, result3] = await Promise.all([\n       connection.client.projectsGroupsApi.getProject(id1),\n       connection.client.projectsGroupsApi.getProject(id2),\n       connection.client.projectsGroupsApi.getProject(id3)\n   ]);\n   \n   // ‚ùå WRONG - sequential operations (slower)\n   const result1 = await connection.client.projectsGroupsApi.getProject(id1);\n   const result2 = await connection.client.projectsGroupsApi.getProject(id2);\n   const result3 = await connection.client.projectsGroupsApi.getProject(id3);\n   ```\n\n4. **Wrap all async code in try-catch**\n   ```typescript\n   // ‚úÖ CORRECT - comprehensive error handling\n   app.get('/api/data', async (req: Request, res: Response) => {\n       try {\n           const connection = await crowdinApp.establishCrowdinConnection(jwt, undefined);\n           const data = await fetchData();\n           res.json({ success: true, data });\n       } catch (error) {\n           console.error('Error:', error);\n           res.status(500).json({ success: false, error: 'Operation failed' });\n       }\n   });\n   \n   // ‚ùå WRONG - no error handling\n   app.get('/api/data', async (req: Request, res: Response) => {\n       const connection = await crowdinApp.establishCrowdinConnection(jwt, undefined);\n       const data = await fetchData(); // May throw unhandled error\n       res.json({ success: true, data });\n   });\n   ```\n\n5. **Never use setTimeout without proper promise wrapper**\n   ```typescript\n   // ‚úÖ CORRECT - setTimeout with promise wrapper\n   app.get('/api/delayed', async (req: Request, res: Response) => {\n       await new Promise((resolve) => {\n           setTimeout(async () => {\n               await saveData();\n               resolve(undefined);\n           }, 1000);\n       });\n       \n       res.json({ success: true });\n   });\n   \n   // ‚ùå WRONG - setTimeout without await (will NOT execute)\n   app.get('/api/delayed', async (req: Request, res: Response) => {\n       setTimeout(async () => {\n           await saveData(); // This will NOT execute\n       }, 1000);\n       \n       res.json({ success: true }); // Sent immediately\n   });\n   ```\n\n6. **Always check for required parameters early**\n   ```typescript\n   // ‚úÖ CORRECT - validate parameters first\n   app.post('/api/process', async (req: Request, res: Response) => {\n       const jwt = req.query.jwt as string;\n       const { projectId, data } = req.body;\n       \n       // Validate early\n       if (!jwt) {\n           return res.status(400).json({ error: 'JWT token is required' });\n       }\n       if (!projectId) {\n           return res.status(400).json({ error: 'Project ID is required' });\n       }\n       if (!data) {\n           return res.status(400).json({ error: 'Data is required' });\n       }\n       \n       // Continue with processing\n       const connection = await crowdinApp.establishCrowdinConnection(jwt, undefined);\n       // ... rest of the logic\n   });\n   ```\n\n### Crowdin API Client\n\n#### Official Documentation\n\nThe `connection.client` object is an instance of `@crowdin/crowdin-api-client`.\n\n**üìö Complete API Reference:** https://crowdin.github.io/crowdin-api-client-js/modules.html\n\n**‚ö†Ô∏è CRITICAL**: Only use methods documented in the official API reference. Do NOT invent or assume methods exist.\n\n#### Common Examples\n\n**Standard Endpoint Template:**\n```typescript\napp.get('/api/your-endpoint', async (req: Request, res: Response) => {\n    try {\n        const jwt = req.query.jwt as string;\n        if (!jwt) {\n            return res.status(400).json({ success: false, error: 'JWT token is required' });\n        }\n\n        if (!crowdinApp.establishCrowdinConnection) {\n            return res.status(500).json({ success: false, error: 'Crowdin connection method not available' });\n        }\n\n        const connection = await crowdinApp.establishCrowdinConnection(jwt, undefined);\n\n        if (!connection.client) {\n            return res.status(500).json({ success: false, error: 'Crowdin API client not available' });\n        }\n\n        const userId = connection.context.jwtPayload.context.user_id;\n        const organizationId = connection.context.jwtPayload.context.organization_id;\n\n        // Your logic here using connection.client API\n        \n        res.status(200).json({ success: true, data: result });\n    } catch (error) {\n        console.error('Error:', error);\n        res.status(500).json({ success: false, error: 'Operation failed' });\n    }\n});\n```\n\n**Get Project Details:**\n```typescript\nconst response = await connection.client.projectsGroupsApi.getProject(projectId);\n\n// Access project properties\nconst project = response.data;\nconst projectName = project.name;                    // string\nconst sourceLanguageId = project.sourceLanguageId;   // string\nconst targetLanguageIds = project.targetLanguageIds; // string[]\nconst description = project.description;             // string | null\n```\n\n**List All Projects (with pagination):**\n```typescript\nconst response = await connection.client.projectsGroupsApi.withFetchAll().listProjects();\n\n// Iterate through all projects\nresponse.data.forEach((projectItem: ResponseObject<ProjectsGroupsModel.Project>) => {\n  const projectId = projectItem.data.id;\n  const projectName = projectItem.data.name;\n  const groupId = projectItem.data.groupId; // number | null\n});\n```\n\n**Get Supported Languages:**\n```typescript\nconst response = await connection.client.languagesApi.withFetchAll().listSupportedLanguages();\n\n// Filter languages\nconst targetLanguageIds = ['uk', 'pl', 'de'];\nconst projectLanguages = response.data.filter(\n  (lang: ResponseObject<LanguagesModel.Language>) => targetLanguageIds.includes(lang.data.id)\n);\n\n// Map to simpler structure\nconst languages = projectLanguages.map((lang: ResponseObject<LanguagesModel.Language>) => ({\n  id: lang.data.id,           // string: \"uk\"\n  name: lang.data.name,       // string: \"Ukrainian\"\n  locale: lang.data.locale,   // string: \"uk-UA\"\n  osxLocale: lang.data.osxLocale // string\n}));\n```\n\n**List Source Files:**\n```typescript\nconst response = await connection.client.sourceFilesApi.withFetchAll().listProjectFiles(projectId);\n\nresponse.data.forEach((fileItem: ResponseObject<SourceFilesModel.File>) => {\n  const file = fileItem.data;\n  const fileId = file.id;             // number\n  const fileName = file.name;         // string\n  const branchId = file.branchId;     // number | null\n  const directoryId = file.directoryId; // number | null\n});\n```\n\n#### Best Practices\n\n1. **Always access data via `.data` property**\n   ```typescript\n   // ‚úÖ CORRECT\n   const project = response.data;\n   const projectName = response.data.name;\n   \n   // ‚ùå WRONG - will be undefined\n   const projectName = response.name;\n   ```\n\n2. **Use withFetchAll() for complete data**\n   ```typescript\n   // ‚úÖ CORRECT - gets all items\n   const response = await connection.client.languagesApi.withFetchAll().listSupportedLanguages();\n   \n   // ‚ö†Ô∏è PARTIAL - only first page (25 items)\n   const response = await connection.client.languagesApi.listSupportedLanguages();\n   ```\n\n3. **Handle nullable properties**\n   ```typescript\n   const description = response.data.description || 'No description';\n   const groupId = response.data.groupId ?? null;\n   ```\n\n4. **Handle errors properly**\n   ```typescript\n   try {\n     const response = await connection.client.projectsGroupsApi.getProject(projectId);\n     const project = response.data;\n     // Use project data\n   } catch (error: any) {\n     console.error('Crowdin API Error:', error);\n\n     // API errors have specific structure\n     if (error.code === 404) {\n       return res.status(404).json({ error: 'Project not found' });\n     }\n     \n     return res.status(500).json({\n       error: 'API request failed',\n       details: error.message\n     });\n   }\n   ```\n\n5. **Use TypeScript types**\n   ```typescript\n   import type { ResponseObject, ProjectsGroupsModel } from '@crowdin/crowdin-api-client';\n   \n   // Use in your code\n   const response: ResponseObject<ProjectsGroupsModel.Project> = await connection.client.projectsGroupsApi.getProject(projectId);\n   const project: ProjectsGroupsModel.Project = response.data;\n   ```\n\n6. **Always sort data explicitly when order matters**\n   ```typescript\n   // ‚úÖ CORRECT - sort projects by creation date (newest first)\n   const response = await connection.client.projectsGroupsApi.withFetchAll().listProjects();\n   const sortedByDate = response.data.sort(\n     (a: ResponseObject<ProjectsGroupsModel.Project>, b: ResponseObject<ProjectsGroupsModel.Project>) => {\n       const dateA = new Date(a.data.createdAt).getTime();\n       const dateB = new Date(b.data.createdAt).getTime();\n       return dateB - dateA; // Descending order (newest first)\n     }\n   );\n   \n   // ‚ùå WRONG - assuming data is already sorted by date\n   const response = await connection.client.projectsGroupsApi.withFetchAll().listProjects();\n   // Directly using response.data without sorting - order is not guaranteed!\n   ```\n\n7. **Never use CroQL - fetch all data and filter manually**\n   ```typescript\n   // ‚úÖ CORRECT - fetch all strings and filter manually\n   const allStrings = await connection.client.sourceStringsApi.withFetchAll().listProjectStrings(projectId);\n   \n   // Filter for specific criteria\n   const filteredStrings = allStrings.data.filter(\n     (item: ResponseObject<SourceStringsModel.String>) => {\n       const str = item.data;\n       return str.text.includes('welcome') && !str.isHidden;\n     }\n   );\n   \n   // ‚ùå WRONG - using CroQL queries\n   const response = await connection.client.sourceStringsApi.listProjectStrings(projectId, {\n     croql: 'text contains \"welcome\" AND isHidden = false'\n   });\n   // CroQL should be avoided - fetch all data and filter in your code instead\n   ```\n\n#### Complete Type Definitions\n\n**‚ö†Ô∏è CRITICAL**: Only use methods and types from `@crowdin/crowdin-api-client` definitions below.\n\n**Do NOT invent methods or properties that are not listed here.**\n\n<!-- CROWDIN_API_CLIENT_TYPES_START -->\n\n##### ai/index.d.ts\n\n```typescript\nimport { CrowdinApi, DownloadLink, PaginationOptions, PatchRequest, PlainObject, ResponseList, ResponseObject, Status } from '../core';\nexport declare class Ai extends CrowdinApi {\n    listAiOrganizationCustomPlaceholders(options?: PaginationOptions): Promise<ResponseList<AiModel.CustomPlaceholder>>;\n    addAiOrganizationCustomPlaceholder(request: AiModel.AddCustomPlaceholderRequest): Promise<ResponseObject<AiModel.CustomPlaceholder>>;\n    getAiOrganizationCustomPlaceholder(aiCustomPlaceholderId: number): Promise<ResponseObject<AiModel.CustomPlaceholder>>;\n    deleteAiOrganizationCustomPlaceholder(aiCustomPlaceholderId: number): Promise<void>;\n    editAiOrganizationCustomPlaceholder(aiCustomPlaceholderId: number, request: PatchRequest[]): Promise<ResponseObject<AiModel.CustomPlaceholder>>;\n    generateAiOrganizationPromptFineTuningDataset(aiPromptId: number, request: AiModel.GenerateFineTuningDataset): Promise<ResponseObject<Status<AiModel.FineTuningDataset>>>;\n    getAiOrganizationPromptFineTuningDatasetStatus(aiPromptId: number, jobIdentifier: string): Promise<ResponseObject<Status<AiModel.FineTuningDataset>>>;\n    listAiOrganizationPromptFineTuningEvents(aiPromptId: number, jobIdentifier: string, options?: PaginationOptions): Promise<ResponseList<AiModel.PromptFineTuningEvent>>;\n    listAiOrganizationPromptFineTuningJobs(options?: AiModel.ListPromptFineTuningJobsOptions): Promise<ResponseList<Status<AiModel.FineTuningJob>>>;\n    createAiOrganizationPromptFineTuningJob(aiPromptId: number, request: AiModel.GenerateFineTuningJob): Promise<ResponseObject<Status<AiModel.FineTuningJob>>>;\n    getAiOrganizationPromptFineTuningJobStatus(aiPromptId: number, jobIdentifier: string): Promise<ResponseObject<Status<AiModel.FineTuningJob>>>;\n    downloadAiOrganizationPromptFineTuningDataset(aiPromptId: number, jobIdentifier: string): Promise<ResponseObject<DownloadLink>>;\n    cloneAiOrganizationPrompt(aiPromptId: number, request?: {\n        name?: string;\n    }): Promise<ResponseObject<AiModel.AiPromptResponse>>;\n    listAiOrganizationPrompts(options?: AiModel.ListAiPromptsOptions): Promise<ResponseList<AiModel.AiPromptResponse>>;\n    addAiOrganizationPrompt(request: AiModel.AddAiPromptRequest): Promise<ResponseObject<AiModel.AiPromptResponse>>;\n    generateAiOrganizationPromptCompletion(aiPromptId: number, request: AiModel.GenerateAiPromptCompletionRequest): Promise<ResponseObject<Status<AiModel.AiPromptCompletionAttribute>>>;\n    getAiOrganizationPromptCompletionStatus(aiPromptId: number, completionId: string): Promise<ResponseObject<Status<AiModel.AiPromptCompletionAttribute>>>;\n    cancelAiOrganizationPromptCompletion(aiPromptId: number, completionId: string): Promise<void>;\n    downloadAiOrganizationPromptCompletion(aiPromptId: number, completionId: string): Promise<ResponseObject<DownloadLink>>;\n    getAiOrganizationPrompt(aiPromptId: number): Promise<ResponseObject<AiModel.AiPromptResponse>>;\n    deleteAiOrganizationPrompt(aiPromptId: number): Promise<void>;\n    editAiOrganizationPrompt(aiPromptId: number, request: PatchRequest[]): Promise<ResponseObject<AiModel.AiPromptResponse>>;\n    listAiOrganizationProviders(options?: PaginationOptions): Promise<ResponseList<AiModel.AiProviderResponse>>;\n    addAiOrganizationProvider(request: AiModel.AddAiProviderRequest): Promise<ResponseObject<AiModel.AiProviderResponse>>;\n    getAiOrganizationProvider(aiProviderId: number): Promise<ResponseObject<AiModel.AiProviderResponse>>;\n    deleteAiOrganizationProvider(aiProviderId: number): Promise<void>;\n    editAiOrganizationProvider(aiProviderId: number, request: PatchRequest[]): Promise<ResponseObject<AiModel.AiProviderResponse>>;\n    listAiOrganizationProviderModels(aiProviderId: number, options?: PaginationOptions): Promise<ResponseList<AiModel.AiProviderModelResponse>>;\n    listAiOrganizationAllProviderModels(options?: PaginationOptions): Promise<ResponseList<AiModel.AiProviderModelResponse>>;\n    createAiOrganizationProxyChatCompletion(aiProviderId: number, request?: AiModel.OtherChatCompletionRequest | AiModel.GoogleGeminiChatCompletionRequest): Promise<ResponseObject<AiModel.AiProviderProxyResponseData>>;\n    generateAiOrganizationReport(request: AiModel.AiReport): Promise<ResponseObject<Status<AiModel.AiReport>>>;\n    checkAiOrganizationReportStatus(aiReportId: string): Promise<ResponseObject<Status<AiModel.AiReport>>>;\n    downloadAiOrganizationReport(aiReportId: string): Promise<ResponseObject<DownloadLink>>;\n    getAiOrganizationSettings(): Promise<ResponseObject<AiModel.AiSettings>>;\n    editAiOrganizationSettings(request: PatchRequest[]): Promise<ResponseObject<AiModel.AiSettings>>;\n    listAiUserCustomPlaceholders(userId: number, options?: PaginationOptions): Promise<ResponseList<AiModel.CustomPlaceholder>>;\n    addAiUserCustomPlaceholder(userId: number, request: AiModel.AddCustomPlaceholderRequest): Promise<ResponseObject<AiModel.CustomPlaceholder>>;\n    getAiUserCustomPlaceholder(userId: number, aiCustomPlaceholderId: number): Promise<ResponseObject<AiModel.CustomPlaceholder>>;\n    deleteAiUserCustomPlaceholder(userId: number, aiCustomPlaceholderId: number): Promise<void>;\n    editAiUserCustomPlaceholder(userId: number, aiCustomPlaceholderId: number, request: PatchRequest[]): Promise<ResponseObject<AiModel.CustomPlaceholder>>;\n    generateAiUserPromptFineTuningDataset(userId: number, aiPromptId: number, request: AiModel.GenerateFineTuningDataset): Promise<ResponseObject<Status<AiModel.FineTuningDataset>>>;\n    getAiUserPromptFineTuningDatasetStatus(userId: number, aiPromptId: number, jobIdentifier: string): Promise<ResponseObject<Status<AiModel.FineTuningDataset>>>;\n    listAiUserPromptFineTuningEvents(userId: number, aiPromptId: number, jobIdentifier: string, options?: PaginationOptions): Promise<ResponseList<AiModel.PromptFineTuningEvent>>;\n    listAiUserPromptFineTuningJobs(userId: number, options?: AiModel.ListPromptFineTuningJobsOptions): Promise<ResponseList<Status<AiModel.FineTuningJob>>>;\n    createAiUserPromptFineTuningJob(userId: number, aiPromptId: number, request: AiModel.GenerateFineTuningJob): Promise<ResponseObject<Status<AiModel.FineTuningJob>>>;\n    getAiUserPromptFineTuningJobStatus(userId: number, aiPromptId: number, jobIdentifier: string): Promise<ResponseObject<Status<AiModel.FineTuningJob>>>;\n    downloadAiUserPromptFineTuningDataset(userId: number, aiPromptId: number, jobIdentifier: string): Promise<ResponseObject<DownloadLink>>;\n    cloneAiUserPrompt(userId: number, aiPromptId: number, request?: {\n        name?: string;\n    }): Promise<ResponseObject<AiModel.AiPromptResponse>>;\n    listAiUserPrompts(userId: number, options?: AiModel.ListAiPromptsOptions): Promise<ResponseList<AiModel.AiPromptResponse>>;\n    addAiUserPrompt(userId: number, request: AiModel.AddAiPromptRequest): Promise<ResponseObject<AiModel.AiPromptResponse>>;\n    generateAiUserPromptCompletion(userId: number, aiPromptId: number, request: AiModel.GenerateAiPromptCompletionRequest): Promise<ResponseObject<Status<AiModel.AiPromptCompletionAttribute>>>;\n    getAiUserPromptCompletionStatus(userId: number, aiPromptId: number, completionId: string): Promise<ResponseObject<Status<AiModel.AiPromptCompletionAttribute>>>;\n    cancelAiUserPromptCompletion(userId: number, aiPromptId: number, completionId: string): Promise<void>;\n    downloadAiUserPromptCompletion(userId: number, aiPromptId: number, completionId: string): Promise<ResponseObject<DownloadLink>>;\n    getAiUserPrompt(userId: number, aiPromptId: number): Promise<ResponseObject<AiModel.AiPromptResponse>>;\n    deleteAiUserPrompt(userId: number, aiPromptId: number): Promise<void>;\n    editAiUserPrompt(userId: number, aiPromptId: number, request: PatchRequest[]): Promise<ResponseObject<AiModel.AiPromptResponse>>;\n    listAiUserProviders(userId: number, options?: PaginationOptions): Promise<ResponseList<AiModel.AiProviderResponse>>;\n    addAiUserProvider(userId: number, request: AiModel.AddAiProviderRequest): Promise<ResponseObject<AiModel.AiProviderResponse>>;\n    getAiUserProvider(userId: number, aiProviderId: number): Promise<ResponseObject<AiModel.AiProviderResponse>>;\n    deleteAiUserProvider(userId: number, aiProviderId: number): Promise<void>;\n    editAiUserProvider(userId: number, aiProviderId: number, request: PatchRequest[]): Promise<ResponseObject<AiModel.AiProviderResponse>>;\n    listAiUserProviderModels(userId: number, aiProviderId: number, options?: PaginationOptions): Promise<ResponseList<AiModel.AiProviderModelResponse>>;\n    listAiUserAllProviderModels(userId: number, options?: PaginationOptions): Promise<ResponseList<AiModel.AiProviderModelResponse>>;\n    createAiUserProxyChatCompletion(userId: number, aiProviderId: number, request?: AiModel.OtherChatCompletionRequest | AiModel.GoogleGeminiChatCompletionRequest): Promise<ResponseObject<AiModel.AiProviderProxyResponseData>>;\n    generateAiUserReport(userId: number, request: AiModel.AiReport): Promise<ResponseObject<Status<AiModel.AiReport>>>;\n    checkAiUserReportStatus(userId: number, aiReportId: string): Promise<ResponseObject<Status<AiModel.AiReport>>>;\n    downloadAiUserReport(userId: number, aiReportId: string): Promise<ResponseObject<DownloadLink>>;\n    getAiUsertSettings(userId: number): Promise<ResponseObject<AiModel.AiSettings>>;\n    editAiUserSettings(userId: number, request: PatchRequest[]): Promise<ResponseObject<AiModel.AiSettings>>;\n}\nexport declare namespace AiModel {\n    interface CustomPlaceholder {\n        id: number;\n        description: string;\n        placeholder: string;\n        value: string;\n        createdAt: string;\n        updatedAt: string;\n    }\n    interface AddCustomPlaceholderRequest {\n        description: string;\n        placeholder: string;\n        value: string;\n    }\n    interface FineTuningDataset {\n        projectIds: number[];\n        tmIds: number[];\n        purpose: 'training' | 'validation';\n        dateFrom: string;\n        dateTo: string;\n        maxFileSize: number;\n        minExamplesCount: number;\n        maxExamplesCount: number;\n    }\n    interface GenerateFineTuningDataset {\n        projectIds?: number[];\n        tmIds?: number[];\n        purpose?: 'training' | 'validation';\n        dateFrom?: string;\n        dateTo?: string;\n        maxFileSize?: number;\n        minExamplesCount?: number;\n        maxExamplesCount?: number;\n    }\n    interface GenerateFineTuningJob {\n        dryRun?: boolean;\n        hyperparameters?: {\n            batchSize: number;\n            learningRateMultiplier: number;\n            nEpochs: number;\n        };\n        trainingOptions: Omit<GenerateFineTuningDataset, 'purpose'>;\n        validationOptions?: Omit<GenerateFineTuningDataset, 'purpose'>;\n    }\n    interface FineTuningJob {\n        dryRun: boolean;\n        aiPromptId: number;\n        hyperparameters: {\n            batchSize: number;\n            learningRateMultiplier: number;\n            nEpochs: number;\n        };\n        trainingOptions: Omit<GenerateFineTuningDataset, 'purpose'>;\n        validationOptions: Omit<GenerateFineTuningDataset, 'purpose'>;\n        baseModel: string;\n        fineTunedModel: string;\n        trainedTokensCount: number;\n        trainingDatasetUrl: string;\n        validationDatasetUrl: string;\n        metadata: PlainObject;\n    }\n    interface PromptFineTuningEvent {\n        id: string;\n        type: string;\n        message: string;\n        data: {\n            step: number;\n            totalSteps: number;\n            trainingLoss: number;\n            validationLoss: number;\n            fullValidationLoss: number;\n        };\n        createdAt: string;\n    }\n    interface ListPromptFineTuningJobsOptions extends PaginationOptions {\n        statuses: string;\n        orderBy: string;\n    }\n    interface ListAiPromptsOptions extends PaginationOptions {\n        projectId?: number;\n        action?: Action;\n    }\n    interface AiPromptResponse {\n        id: number;\n        name: string;\n        action: Action;\n        aiProviderId: number;\n        aiModelId: string;\n        isEnabled: boolean;\n        enabledProjectIds: number[];\n        config: AiModel.AiPromptConfigBasicPreTranslate | AiModel.AiPromptConfigBasicAssistAction | AiModel.AiPromptConfigBasicAligmentAction | AiModel.AiPromptConfigAdvanced | AiModel.AiPromptConfigExternal;\n        promptPreview: string;\n        isFineTuningAvailable: boolean;\n        createdAt: string;\n        updatedAt: string;\n    }\n    interface AiPromptConfigBasicOtherLanguageTranslations {\n        isEnabled?: boolean;\n        languageIds?: string[];\n    }\n    interface AiPromptConfigBasicPreTranslate {\n        mode: 'basic';\n        companyDescription?: string;\n        projectDescription?: string;\n        audienceDescription?: string;\n        customPlaceholders?: string[];\n        otherLanguageTranslations?: AiModel.AiPromptConfigBasicOtherLanguageTranslations;\n        glossaryTerms?: boolean;\n        tmSuggestions?: boolean;\n        fileContent?: boolean;\n        fileContext?: boolean;\n        screenshots?: boolean;\n        publicProjectDescription?: boolean;\n        siblingsStrings?: boolean;\n    }\n    interface AiPromptConfigBasicAssistAction {\n        mode: 'basic';\n        companyDescription?: string;\n        projectDescription?: string;\n        audienceDescription?: string;\n        otherLanguageTranslations?: AiModel.AiPromptConfigBasicOtherLanguageTranslations;\n        glossaryTerms?: boolean;\n        tmSuggestions?: boolean;\n        fileContext?: boolean;\n        screenshots?: boolean;\n        publicProjectDescription?: boolean;\n        siblingsStrings?: boolean;\n        filteredStrings?: boolean;\n    }\n    interface AiPromptConfigBasicAligmentAction {\n        mode: 'basic';\n        customPlaceholders?: string[];\n        publicProjectDescription?: boolean;\n    }\n    interface AiPromptConfigAdvanced {\n        mode: 'advanced';\n        screenshots?: boolean;\n        prompt: string;\n        otherLanguageTranslations?: AiModel.AiPromptConfigBasicOtherLanguageTranslations;\n    }\n    interface AiPromptConfigExternal {\n        mode: 'external';\n        identifier: string;\n        key: string;\n        options?: any;\n    }\n    interface AddAiPromptRequest {\n        name: string;\n        action: Action;\n        aiProviderId?: number;\n        aiModelId?: string;\n        isEnabled?: boolean;\n        enabledProjectIds?: number[];\n        config: AiModel.AiPromptConfigBasicPreTranslate | AiModel.AiPromptConfigBasicAssistAction | AiModel.AiPromptConfigBasicAligmentAction | AiModel.AiPromptConfigAdvanced | AiPromptConfigExternal;\n    }\n    interface GenerateAiPromptCompletionRequest {\n        resources: AiModel.AiPromptResourceWithPreTranslate | AiModel.AiPromptResourceWithAssist | AiModel.AiPromptResourceWithAlignment | AiModel.AiPromptResourceWithCustom;\n        tools?: {\n            tool: {\n                type: 'function';\n                function: {\n                    description?: string;\n                    name: string;\n                    parameters?: PlainObject;\n                };\n            };\n        }[];\n        tool_choice?: string | PlainObject;\n    }\n    interface AiPromptCompletionAttribute {\n        aiPromptId: number;\n    }\n    interface AiPromptResourceWithPreTranslate {\n        projectId: number;\n        sourceLanguageId?: string;\n        targetLanguageId?: string;\n        stringIds?: number[];\n        overridePromptValues?: OverridePromptValues;\n    }\n    interface AiPromptResourceWithAlignment {\n        projectId: number;\n        sourceLanguageId?: string;\n        targetLanguageId?: string;\n        stringIds?: number[];\n        overridePromptValues?: OverridePromptValues;\n    }\n    interface AiPromptResourceWithAssist {\n        projectId: number;\n        sourceLanguageId?: string;\n        targetLanguageId?: string;\n        stringIds?: number[];\n        filteredStringsIds?: number[];\n        overridePromptValues?: OverridePromptValues;\n    }\n    interface AiPromptResourceWithCustom {\n        projectId: number;\n        sourceLanguageId?: string;\n        targetLanguageId?: string;\n        stringIds?: number[];\n        overridePromptValues?: OverridePromptValues;\n        customInstruction?: string;\n    }\n    interface OverridePromptValues {\n        [key: string]: any;\n    }\n    interface AiProviderResponse {\n        id: number;\n        name: string;\n        type: ProviderType;\n        credentials: AiModel.AiProviderCredentialsBasic | AiModel.AiProviderCredentialsAzureOpenAi | AiProviderCredentialsGoogleGemini | AiProviderCredentialsCustom;\n        config: AiModel.AiProviderConfig;\n        isEnabled: boolean;\n        useSystemCredentials: boolean;\n        createdAt: string;\n        updatedAt: string;\n        promptsCount: string;\n    }\n    interface AiProviderCredentialsBasic {\n        apiKey: string;\n    }\n    interface AiProviderCredentialsAzureOpenAi extends AiProviderCredentialsBasic {\n        resourceName: string;\n        deploymentName: string;\n        apiVersion: string;\n    }\n    interface AiProviderCredentialsGoogleGemini {\n        project: string;\n        region: string;\n        serviceAccountKey: string;\n    }\n    interface AiProviderCredentialsWatsonx {\n        apiKey: string;\n        projectId: string;\n        region: string;\n    }\n    interface AiProviderCredentialsCustom {\n        identifier: string;\n        key: string;\n    }\n    interface AiProviderConfig {\n        actionRules?: AiModel.AiProviderConfigActionRule[];\n    }\n    interface AiProviderConfigActionRule {\n        action?: 'pre_translate' | 'assist';\n        availableAiModelIds?: string[];\n    }\n    interface AddAiProviderRequest {\n        name: string;\n        type: ProviderType;\n        credentials?: AiModel.AiProviderCredentialsBasic | AiModel.AiProviderCredentialsAzureOpenAi | AiProviderCredentialsGoogleGemini | AiProviderCredentialsWatsonx | AiProviderCredentialsCustom;\n        config?: AiModel.AiProviderConfig;\n        isEnabled?: boolean;\n        useSystemCredentials?: boolean;\n    }\n    interface AiProviderModelResponse {\n        id: string;\n    }\n    interface AiProviderProxyResponseData {\n        data: object;\n    }\n    interface OtherChatCompletionRequest {\n        stream?: boolean;\n        [key: string]: any;\n    }\n    interface GoogleGeminiChatCompletionRequest extends OtherChatCompletionRequest {\n        model: string;\n    }\n    type AiReport = AiReportTokenUsage;\n    interface AiReportTokenUsage {\n        type: 'tokens-usage-raw-data';\n        schema: AiReportGeneralSchema;\n    }\n    interface AiReportGeneralSchema {\n        dateFrom: string;\n        dateTo: string;\n        format?: 'json' | 'csv';\n        projectIds?: number[];\n        promptIds?: number[];\n        userIds?: number[];\n    }\n    interface AiSettings {\n        assistActionAiPromptId: number;\n        showSuggestion: boolean;\n        shortcuts: {\n            name: string;\n            prompt: string;\n            enabled: boolean;\n        }[];\n    }\n    type Action = 'pre_translate' | 'assist';\n    type ProviderType = 'open_ai' | 'azure_open_ai' | 'google_gemini' | 'mistral_ai' | 'anthropic' | 'custom_ai' | 'x_ai' | 'deepseek' | 'watsonx';\n}\n```\n\n##### applications/index.d.ts\n\n```typescript\nimport { CrowdinApi, ResponseObject, PatchRequest, Pagination, ResponseList } from '../core';\nexport declare class Applications extends CrowdinApi {\n    listApplicationInstallations(options?: Pagination): Promise<ResponseList<ApplicationsModel.Application>>;\n    installApplication(request: ApplicationsModel.InstallApplication): Promise<ResponseObject<ApplicationsModel.Application>>;\n    getApplicationInstallation(applicationId: string): Promise<ResponseObject<ApplicationsModel.Application>>;\n    deleteApplicationInstallation(applicationId: string, force?: boolean): Promise<ResponseObject<ApplicationsModel.Application>>;\n    editApplicationInstallation(applicationId: string, request: PatchRequest[]): Promise<ResponseObject<ApplicationsModel.Application>>;\n    getApplicationData(applicationId: string, path: string): Promise<ResponseObject<any>>;\n    updateOrRestoreApplicationData(applicationId: string, path: string, request: any): Promise<ResponseObject<any>>;\n    addApplicationData(applicationId: string, path: string, request: any): Promise<ResponseObject<any>>;\n    deleteApplicationData(applicationId: string, path: string): Promise<void>;\n    editApplicationData(applicationId: string, path: string, request: any): Promise<ResponseObject<any>>;\n}\nexport declare namespace ApplicationsModel {\n    interface Application {\n        identifier: string;\n        name: string;\n        description: string;\n        logo: string;\n        baseUrl: string;\n        manifestUrl: string;\n        createdAt: string;\n        modules: ApplicationModule[];\n        scopes: string[];\n        permissions: ApplicationPermissions;\n        defaultPermissions: any;\n        limitReached: boolean;\n    }\n    interface InstallApplication {\n        url: string;\n        permissions?: ApplicationPermissions;\n        modules?: ApplicationModule[];\n    }\n    interface ApplicationPermissions {\n        user: {\n            value: 'all' | 'owner' | 'managers' | 'guests' | 'restricted';\n            ids: number[];\n        };\n        project: {\n            value: 'own' | 'restricted';\n            ids: number[];\n        };\n    }\n    interface ApplicationModule {\n        key: string;\n        type?: string;\n        data?: any;\n        authenticationType?: string;\n        permissions: Omit<ApplicationPermissions, 'project'>;\n    }\n}\n```\n\n##### bundles/index.d.ts\n\n```typescript\nimport { CrowdinApi, DownloadLink, PaginationOptions, PatchRequest, ResponseList, ResponseObject, Status } from '../core';\nimport { SourceFilesModel } from '../sourceFiles';\nexport declare class Bundles extends CrowdinApi {\n    listBundles(projectId: number, options?: PaginationOptions): Promise<ResponseList<BundlesModel.Bundle>>;\n    addBundle(projectId: number, request: BundlesModel.CreateBundleRequest): Promise<ResponseObject<BundlesModel.Bundle>>;\n    getBundle(projectId: number, bundleId: number): Promise<ResponseObject<BundlesModel.Bundle>>;\n    deleteBundle(projectId: number, bundleId: number): Promise<void>;\n    editBundle(projectId: number, bundleId: number, request: PatchRequest[]): Promise<ResponseObject<BundlesModel.Bundle>>;\n    downloadBundle(projectId: number, bundleId: number, exportId: string): Promise<ResponseObject<DownloadLink>>;\n    exportBundle(projectId: number, bundleId: number): Promise<ResponseObject<Status<BundlesModel.ExportAttributes>>>;\n    checkBundleExportStatus(projectId: number, bundleId: number, exportId: string): Promise<ResponseObject<Status<BundlesModel.ExportAttributes>>>;\n    listBundleFiles(projectId: number, bundleId: number, options?: PaginationOptions): Promise<ResponseList<SourceFilesModel.File>>;\n    listBundleBranches(projectId: number, bundleId: number, options?: PaginationOptions): Promise<ResponseList<SourceFilesModel.Branch>>;\n}\nexport declare namespace BundlesModel {\n    interface Bundle {\n        id: number;\n        name: string;\n        format: string;\n        sourcePatterns: string[];\n        ignorePatterns: string[];\n        exportPattern: string;\n        isMultilingual: boolean;\n        includeProjectSourceLanguage: boolean;\n        labelIds: number[];\n        excludeLabelIds: number[];\n        createdAt: string;\n        webUrl: string;\n        updatedAt: string;\n    }\n    interface CreateBundleRequest {\n        name: string;\n        format: string;\n        sourcePatterns: string[];\n        ignorePatterns?: string[];\n        exportPattern: string;\n        isMultilingual?: boolean;\n        includeProjectSourceLanguage?: boolean;\n        includeInContextPseudoLanguage?: boolean;\n        labelIds?: number[];\n        excludeLabelIds?: number[];\n    }\n    interface ExportAttributes {\n        bundleId: number;\n    }\n}\n```\n\n##### clients/index.d.ts\n\n```typescript\nimport { CrowdinApi, PaginationOptions, ResponseList } from '../core';\nexport declare class Clients extends CrowdinApi {\n    listClients(options?: PaginationOptions): Promise<ResponseList<ClientsModel.Client>>;\n}\nexport declare namespace ClientsModel {\n    interface Client {\n        id: number;\n        name: string;\n        description: string;\n        status: 'pending' | 'confirmed' | 'rejected';\n        webUrl: string;\n    }\n}\n```\n\n##### core/http-client-error.d.ts\n\n```typescript\nimport { AxiosError } from 'axios';\nimport { FetchClientJsonPayloadError } from './internal/fetch/fetchClientError';\nexport type HttpClientError = AxiosError | FetchClientJsonPayloadError | Error;\nexport declare const toHttpClientError: (error?: unknown) => HttpClientError;\n```\n\n##### core/index.d.ts\n\n```typescript\nimport { HttpClientError } from './http-client-error';\nimport { RetryConfig, RetryService } from './internal/retry';\nexport interface HttpClient {\n    get<T>(url: string, config?: {\n        headers: Record<string, string>;\n    }): Promise<T>;\n    delete<T>(url: string, config?: {\n        headers: Record<string, string>;\n    }): Promise<T>;\n    head<T>(url: string, config?: {\n        headers: Record<string, string>;\n    }): Promise<T>;\n    post<T>(url: string, data?: unknown, config?: {\n        headers: Record<string, string>;\n    }): Promise<T>;\n    put<T>(url: string, data?: unknown, config?: {\n        headers: Record<string, string>;\n    }): Promise<T>;\n    patch<T>(url: string, data?: unknown, config?: {\n        headers: Record<string, string>;\n    }): Promise<T>;\n}\nexport type HttpClientType = 'axios' | 'fetch';\nexport interface Credentials {\n    token: string;\n    organization?: string;\n    baseUrl?: string;\n}\nexport interface ClientConfig {\n    httpClientType?: HttpClientType;\n    httpClient?: HttpClient;\n    userAgent?: string;\n    integrationUserAgent?: string;\n    retryConfig?: RetryConfig;\n    httpRequestTimeout?: number;\n}\nexport interface ResponseList<T> {\n    data: ResponseObject<T>[];\n    pagination: Pagination;\n}\nexport interface ResponseObject<T> {\n    data: T;\n}\nexport interface Pagination {\n    offset: number;\n    limit: number;\n}\nexport type PaginationOptions = Partial<Pagination>;\nexport interface PatchRequest {\n    value?: any;\n    op: PatchOperation;\n    path: string;\n}\nexport type PatchOperation = 'add' | 'remove' | 'replace' | 'move' | 'copy' | 'test';\nexport type ProjectRoles = 'manager' | 'developer' | 'translator' | 'proofreader' | 'language_coordinator' | 'member';\nexport interface DownloadLink {\n    url: string;\n    expireIn: string;\n}\nexport declare enum BooleanInt {\n    TRUE = 1,\n    FALSE = 0\n}\nexport interface Status<T> {\n    identifier: string;\n    status: string;\n    progress: number;\n    attributes: T;\n    createdAt: string;\n    updatedAt: string;\n    startedAt: string;\n    finishedAt: string;\n    eta: string;\n}\nexport interface Attribute {\n    [key: string]: string;\n}\nexport type PlainObject = Record<string, any>;\nexport declare class CrowdinError extends Error {\n    apiError: any;\n    code: number;\n    constructor(message: string, code: number, apiError: any);\n}\nexport declare class CrowdinValidationError extends CrowdinError {\n    validationCodes: {\n        key: string;\n        codes: string[];\n    }[];\n    constructor(message: string, validationCodes: {\n        key: string;\n        codes: string[];\n    }[], apiError: any);\n}\nexport declare function handleHttpClientError(error: HttpClientError): never;\nexport declare abstract class CrowdinApi {\n    private static readonly CROWDIN_URL_SUFFIX;\n    private static readonly AXIOS_INSTANCE;\n    private static readonly FETCH_INSTANCE;\n    readonly token: string;\n    readonly organization?: string;\n    readonly url: string;\n    readonly config: ClientConfig | undefined;\n    readonly retryService: RetryService;\n    protected fetchAllFlag: boolean;\n    protected maxLimit: number | undefined;\n    constructor(credentials: Credentials, config?: ClientConfig);\n    graphql<T>(req: {\n        query: string;\n        operationName?: string;\n        variables?: any;\n    }, config?: {\n        url?: string;\n    }): Promise<ResponseObject<T>>;\n    protected addQueryParam(url: string, name: string, value?: string | number): string;\n    protected defaultConfig(): {\n        headers: Record<string, string>;\n    };\n    get httpClient(): HttpClient;\n    withFetchAll(maxLimit?: number): this;\n    protected getList<T = any>(url: string, limit?: number, offset?: number, config?: {\n        headers: Record<string, string>;\n    }): Promise<ResponseList<T>>;\n    protected fetchAll<T>(url: string, config: {\n        headers: Record<string, string>;\n    }, maxAmount?: number): Promise<ResponseList<T>>;\n    protected encodeUrlParam(param: string | number | boolean): string;\n    protected get<T>(url: string, config?: {\n        headers: Record<string, string>;\n    }): Promise<T>;\n    protected delete<T>(url: string, config?: {\n        headers: Record<string, string>;\n    }): Promise<T>;\n    protected head<T>(url: string, config?: {\n        headers: Record<string, string>;\n    }): Promise<T>;\n    protected post<T>(url: string, data?: unknown, config?: {\n        headers: Record<string, string>;\n    }): Promise<T>;\n    protected put<T>(url: string, data?: unknown, config?: {\n        headers: Record<string, string>;\n    }): Promise<T>;\n    protected patch<T>(url: string, data?: unknown, config?: {\n        headers: Record<string, string>;\n    }): Promise<T>;\n}\nexport declare function isOptionalString(parameter: string | unknown, parameterInArgs: boolean): parameter is string | undefined;\nexport declare function isOptionalNumber(parameter: number | unknown, parameterInArgs: boolean): parameter is number | undefined;\nexport interface ProjectRole {\n    name: string;\n    permissions: ProjectRolePermissions;\n}\nexport interface ProjectRolePermissions {\n    allLanguages: boolean;\n    languagesAccess: {\n        [lang: string]: {\n            allContent: boolean;\n            workflowStepIds: number[];\n        };\n    };\n}\n```\n\n##### dictionaries/index.d.ts\n\n```typescript\nimport { CrowdinApi, PatchRequest, ResponseList, ResponseObject } from '../core';\nexport declare class Dictionaries extends CrowdinApi {\n    listDictionaries(projectId: number, options?: DictionariesModel.ListDictionariesOptions): Promise<ResponseList<DictionariesModel.Dictionary>>;\n    listDictionaries(projectId: number, languageIds?: string): Promise<ResponseList<DictionariesModel.Dictionary>>;\n    editDictionary(projectId: number, languageId: string, request: PatchRequest[]): Promise<ResponseObject<DictionariesModel.Dictionary>>;\n}\nexport declare namespace DictionariesModel {\n    interface Dictionary {\n        languageId: string;\n        words: string[];\n    }\n    interface ListDictionariesOptions {\n        languageIds?: string;\n    }\n}\n```\n\n##### distributions/index.d.ts\n\n```typescript\nimport { CrowdinApi, PaginationOptions, PatchRequest, ResponseList, ResponseObject } from '../core';\nexport declare class Distributions extends CrowdinApi {\n    listDistributions(projectId: number, options?: PaginationOptions): Promise<ResponseList<DistributionsModel.Distribution>>;\n    listDistributions(projectId: number, limit?: number, offset?: number): Promise<ResponseList<DistributionsModel.Distribution>>;\n    createDistribution(projectId: number, request: DistributionsModel.CreateDistributionRequest | DistributionsModel.CreateDistributionStringsBasedRequest): Promise<ResponseObject<DistributionsModel.Distribution>>;\n    getDistribution(projectId: number, hash: string): Promise<ResponseObject<DistributionsModel.Distribution>>;\n    deleteDistribution(projectId: number, hash: string): Promise<void>;\n    editDistribution(projectId: number, hash: string, request: PatchRequest[]): Promise<ResponseObject<DistributionsModel.Distribution>>;\n    getDistributionRelease(projectId: number, hash: string): Promise<ResponseObject<DistributionsModel.DistributionRelease | DistributionsModel.DistributionStringsBasedRelease>>;\n    createDistributionRelease(projectId: number, hash: string): Promise<ResponseObject<DistributionsModel.DistributionRelease | DistributionsModel.DistributionStringsBasedRelease>>;\n}\nexport declare namespace DistributionsModel {\n    interface Distribution {\n        hash: string;\n        manifestUrl: string;\n        name: string;\n        bundleIds: number[];\n        createdAt: string;\n        updatedAt: string;\n        exportMode: ExportMode;\n        fileIds: number[];\n    }\n    interface CreateDistributionRequest {\n        exportMode?: ExportMode;\n        name: string;\n        fileIds?: number[];\n        bundleIds?: number[];\n    }\n    interface CreateDistributionStringsBasedRequest {\n        name: string;\n        bundleIds: number[];\n    }\n    interface DistributionRelease {\n        status: string;\n        progress: number;\n        currentLanguageId: string;\n        currentFileId: number;\n        date: string;\n    }\n    interface DistributionStringsBasedRelease {\n        status: string;\n        progress: number;\n        currentLanguageId: string;\n        currentBranchId: number;\n        date: string;\n    }\n    type ExportMode = 'default' | 'bundle';\n}\n```\n\n##### fields/index.d.ts\n\n```typescript\nimport { CrowdinApi, PaginationOptions, PatchRequest, ResponseList, ResponseObject } from '../core';\nexport declare class Fields extends CrowdinApi {\n    listFields(options?: FieldsModel.ListFieldsParams): Promise<ResponseList<FieldsModel.Field>>;\n    addField(request: FieldsModel.AddFieldRequest): Promise<ResponseObject<FieldsModel.Field>>;\n    getField(fieldId: number): Promise<ResponseObject<FieldsModel.Field>>;\n    deleteField(fieldId: number): Promise<void>;\n    editField(fieldId: number, request: PatchRequest[]): Promise<ResponseObject<FieldsModel.Field>>;\n}\nexport declare namespace FieldsModel {\n    type Entity = 'project' | 'user' | 'task' | 'file' | 'translation' | 'string';\n    type Type = 'checkbox' | 'radiobuttons' | 'date' | 'datetime' | 'number' | 'labels' | 'select' | 'multiselect' | 'text' | 'textarea' | 'url';\n    type Place = 'projectCreateModal' | 'projectHeader' | 'projectDetails' | 'projectCrowdsourceDetails' | 'projectSettings' | 'projectTaskEditCreate' | 'projectTaskDetails' | 'projectTaskBoardCard' | 'fileDetails' | 'fileSettings' | 'userEditModal' | 'userDetails' | 'userPopover' | 'stringEditModal' | 'stringDetails' | 'translationUnderContent';\n    interface Location {\n        place: Place;\n    }\n    interface Option {\n        label: string;\n        value: string;\n    }\n    interface OtherFieldConfig {\n        locations: Location[];\n    }\n    interface ListFieldConfig extends OtherFieldConfig {\n        options: Option[];\n    }\n    interface NumberFieldConfig extends OtherFieldConfig {\n        min: number;\n        max: number;\n        units: string;\n    }\n    type Config = ListFieldConfig | NumberFieldConfig | OtherFieldConfig;\n    interface ListFieldsParams extends PaginationOptions {\n        search?: string;\n        entity?: Entity;\n        type?: Type;\n    }\n    interface Field {\n        id: number;\n        name: string;\n        slug: string;\n        type: Type;\n        description: string;\n        entities: Entity[];\n        config: Config;\n        createdAt: string;\n        updatedAt: string;\n    }\n    interface AddFieldRequest {\n        name: string;\n        slug: string;\n        type: Type;\n        description?: string;\n        entities: Entity[];\n        config?: Config;\n    }\n}\n```\n\n##### glossaries/index.d.ts\n\n```typescript\nimport { CrowdinApi, DownloadLink, PaginationOptions, PatchRequest, ResponseList, ResponseObject, Status } from '../core';\nexport declare class Glossaries extends CrowdinApi {\n    listGlossaries(options?: GlossariesModel.ListGlossariesOptions): Promise<ResponseList<GlossariesModel.Glossary>>;\n    listGlossaries(groupId?: number, limit?: number, offset?: number): Promise<ResponseList<GlossariesModel.Glossary>>;\n    addGlossary(request: GlossariesModel.CreateGlossaryRequest): Promise<ResponseObject<GlossariesModel.Glossary>>;\n    getGlossary(glossaryId: number): Promise<ResponseObject<GlossariesModel.Glossary>>;\n    deleteGlossary(glossaryId: number): Promise<void>;\n    editGlossary(glossaryId: number, request: PatchRequest[]): Promise<ResponseObject<GlossariesModel.Glossary>>;\n    exportGlossary(glossaryId: number, request: GlossariesModel.ExportGlossaryRequest): Promise<ResponseObject<Status<GlossariesModel.GlossaryExportStatusAttribute>>>;\n    checkGlossaryExportStatus(glossaryId: number, exportId: string): Promise<ResponseObject<Status<GlossariesModel.GlossaryExportStatusAttribute>>>;\n    downloadGlossary(glossaryId: number, exportId: string): Promise<ResponseObject<DownloadLink>>;\n    importGlossaryFile(glossaryId: number, request: GlossariesModel.GlossaryFile): Promise<ResponseObject<Status<GlossariesModel.GlossaryImportStatusAttribute>>>;\n    checkGlossaryImportStatus(glossaryId: number, importId: string): Promise<ResponseObject<Status<GlossariesModel.GlossaryImportStatusAttribute>>>;\n    listTerms(glossaryId: number, options?: GlossariesModel.ListTermsOptions): Promise<ResponseList<GlossariesModel.Term>>;\n    listTerms(glossaryId: number, userId?: number, limit?: number, offset?: number, languageId?: string, translationOfTermId?: number, conceptId?: number): Promise<ResponseList<GlossariesModel.Term>>;\n    addTerm(glossaryId: number, request: GlossariesModel.CreateTermRequest): Promise<ResponseObject<GlossariesModel.Term>>;\n    clearGlossary(glossaryId: number, options?: GlossariesModel.ClearGlossaryOptions): Promise<ResponseObject<GlossariesModel.Term>>;\n    clearGlossary(glossaryId: number, languageId?: number, translationOfTermId?: number, conceptId?: number): Promise<ResponseObject<GlossariesModel.Term>>;\n    getTerm(glossaryId: number, termId: number): Promise<ResponseObject<GlossariesModel.Term>>;\n    deleteTerm(glossaryId: number, termId: number): Promise<void>;\n    editTerm(glossaryId: number, termId: number, request: PatchRequest[]): Promise<ResponseObject<GlossariesModel.Term>>;\n    listConcepts(glossaryId: number, options?: {\n        orderBy?: string;\n    } & PaginationOptions): Promise<ResponseList<GlossariesModel.Concept>>;\n    getConcept(glossaryId: number, conceptId: number): Promise<ResponseObject<GlossariesModel.Concept>>;\n    updateConcept(glossaryId: number, conceptId: number, request: GlossariesModel.UpdateConceptRequest): Promise<ResponseObject<GlossariesModel.Concept>>;\n    deleteConcept(glossaryId: number, conceptId: number): Promise<void>;\n    concordanceSearch(projectId: number, request: GlossariesModel.ConcordanceSearchRequest): Promise<ResponseList<GlossariesModel.ConcordanceSearchResponse>>;\n}\nexport declare namespace GlossariesModel {\n    interface Glossary {\n        id: number;\n        name: string;\n        groupId: number;\n        userId: number;\n        terms: number;\n        languageId: string;\n        languageIds: string[];\n        defaultProjectIds: number[];\n        projectIds: number[];\n        webUrl: string;\n        createdAt: string;\n    }\n    interface CreateGlossaryRequest {\n        name: string;\n        languageId: string;\n        groupId?: number;\n    }\n    type ExportField = 'term' | 'description' | 'partOfSpeech' | 'type' | 'status' | 'gender' | 'note' | 'url' | 'conceptDefinition' | 'conceptSubject' | 'conceptNote' | 'conceptUrl' | 'conceptFigure';\n    interface ExportGlossaryRequest {\n        format?: GlossaryFormat;\n        exportFields?: ExportField[];\n    }\n    interface GlossaryExportStatusAttribute {\n        format: string;\n        exportFields: ExportField[];\n    }\n    interface GlossaryImportStatusAttribute {\n        storageId: number;\n        scheme: unknown;\n        firstLineContainsHeader: boolean;\n    }\n    interface GlossaryFile {\n        storageId: number;\n        scheme?: GlossaryFileScheme;\n        firstLineContainsHeader?: boolean;\n    }\n    interface ListTermsOptions extends PaginationOptions {\n        userId?: number;\n        languageId?: string;\n        conceptId?: number;\n        orderBy?: string;\n        croql?: string;\n        translationOfTermId?: number;\n    }\n    interface Term {\n        id: number;\n        userId: number;\n        glossaryId: number;\n        languageId: string;\n        text: string;\n        description: string;\n        partOfSpeech: PartOfSpeech;\n        status: Status;\n        type: Type;\n        gender: Gender;\n        note: string;\n        url: string;\n        conceptId: number;\n        lemma: string;\n        createdAt: string;\n        updatedAt: string;\n    }\n    interface CreateTermRequest {\n        languageId: string;\n        text: string;\n        description?: string;\n        partOfSpeech?: PartOfSpeech;\n        status?: Status;\n        type?: Type;\n        gender?: Gender;\n        note?: string;\n        url?: string;\n        conceptId?: number;\n        translationOfTermId?: number;\n    }\n    interface ConcordanceSearchRequest extends PaginationOptions {\n        sourceLanguageId: string;\n        targetLanguageId: string;\n        expressions: string[];\n        expression?: string;\n    }\n    interface ConcordanceSearchResponse {\n        glossary: Glossary;\n        concept: Concept;\n        sourceTerms: Term[];\n        targetTerms: Term[];\n    }\n    type Status = 'preferred' | 'admitted' | 'not recommended' | 'obsolete';\n    type Type = 'full form' | 'acronym' | 'abbreviation' | 'short form' | 'phrase' | 'variant';\n    type Gender = 'masculine' | 'feminine' | 'neuter' | 'other';\n    type GlossaryFormat = 'tbx' | 'tbx_v3' | 'csv' | 'xlsx';\n    interface GlossaryFileScheme {\n        [key: string]: number;\n    }\n    type PartOfSpeech = 'adjective' | 'adposition' | 'adverb' | 'auxiliary' | 'coordinating conjunction' | 'determiner' | 'interjection' | 'noun' | 'numeral' | 'particle' | 'pronoun' | 'proper noun' | 'subordinating conjunction' | 'verb' | 'other';\n    interface ListGlossariesOptions extends PaginationOptions {\n        groupId?: number;\n        userId?: number;\n        orderBy?: string;\n    }\n    interface ClearGlossaryOptions {\n        languageId?: number;\n        translationOfTermId?: number;\n        conceptId?: number;\n    }\n    interface Concept {\n        id: number;\n        userId: number;\n        glossaryId: number;\n        subject: string;\n        definition: string;\n        translatable: boolean;\n        note: string;\n        url: string;\n        figure: string;\n        languagesDetails: LanguageDetails[];\n        createdAt: string;\n        updatedAt: string;\n    }\n    interface LanguageDetails {\n        languageId: string;\n        userId: number;\n        definition: string;\n        note: string;\n        createdAt: string;\n        updatedAt: string;\n    }\n    interface UpdateConceptRequest {\n        subject?: string;\n        definition?: string;\n        translatable?: boolean;\n        note?: string;\n        url?: string;\n        figure?: string;\n        languagesDetails?: {\n            languageId: string;\n            definition: string;\n            note?: string;\n        }[];\n    }\n}\n```\n\n##### index.d.ts\n\n```typescript\nimport { Ai } from './ai';\nimport { Applications } from './applications';\nimport { Bundles } from './bundles';\nimport { Clients } from './clients';\nimport { ClientConfig, Credentials, CrowdinApi } from './core';\nimport { Dictionaries } from './dictionaries';\nimport { Distributions } from './distributions';\nimport { Fields } from './fields';\nimport { Glossaries } from './glossaries';\nimport { Issues } from './issues';\nimport { Labels } from './labels';\nimport { Languages } from './languages';\nimport { MachineTranslation } from './machineTranslation';\nimport { Notifications } from './notifications';\nimport { OrganizationWebhooks } from './organizationWebhooks';\nimport { ProjectsGroups } from './projectsGroups';\nimport { Reports } from './reports';\nimport { Screenshots } from './screenshots';\nimport { SecurityLogs } from './securityLogs';\nimport { SourceFiles } from './sourceFiles';\nimport { SourceStrings } from './sourceStrings';\nimport { StringComments } from './stringComments';\nimport { StringCorrections } from './stringCorrections';\nimport { StringTranslations } from './stringTranslations';\nimport { Tasks } from './tasks';\nimport { Teams } from './teams';\nimport { TranslationMemory } from './translationMemory';\nimport { TranslationStatus } from './translationStatus';\nimport { Translations } from './translations';\nimport { UploadStorage } from './uploadStorage';\nimport { Users } from './users';\nimport { Vendors } from './vendors';\nimport { Webhooks } from './webhooks';\nimport { Workflows } from './workflows';\nexport * from './ai';\nexport * from './applications';\nexport * from './bundles';\nexport * from './clients';\nexport * from './core';\nexport * from './dictionaries';\nexport * from './distributions';\nexport * from './fields';\nexport * from './glossaries';\nexport * from './issues';\nexport * from './labels';\nexport * from './languages';\nexport * from './machineTranslation';\nexport * from './notifications';\nexport * from './organizationWebhooks';\nexport * from './projectsGroups';\nexport * from './reports';\nexport * from './screenshots';\nexport * from './securityLogs';\nexport * from './sourceFiles';\nexport * from './sourceStrings';\nexport * from './stringComments';\nexport * from './stringCorrections';\nexport * from './stringTranslations';\nexport * from './tasks';\nexport * from './teams';\nexport * from './translationMemory';\nexport * from './translationStatus';\nexport * from './translations';\nexport * from './uploadStorage';\nexport * from './users';\nexport * from './vendors';\nexport * from './webhooks';\nexport * from './workflows';\nexport default class Client extends CrowdinApi {\n    readonly aiApi: Ai;\n    readonly applicationsApi: Applications;\n    readonly sourceFilesApi: SourceFiles;\n    readonly glossariesApi: Glossaries;\n    readonly languagesApi: Languages;\n    readonly translationsApi: Translations;\n    readonly translationStatusApi: TranslationStatus;\n    readonly projectsGroupsApi: ProjectsGroups;\n    readonly reportsApi: Reports;\n    readonly screenshotsApi: Screenshots;\n    readonly sourceStringsApi: SourceStrings;\n    readonly uploadStorageApi: UploadStorage;\n    readonly tasksApi: Tasks;\n    readonly translationMemoryApi: TranslationMemory;\n    readonly webhooksApi: Webhooks;\n    readonly organizationWebhooksApi: OrganizationWebhooks;\n    readonly machineTranslationApi: MachineTranslation;\n    readonly stringTranslationsApi: StringTranslations;\n    readonly workflowsApi: Workflows;\n    readonly usersApi: Users;\n    readonly vendorsApi: Vendors;\n    readonly issuesApi: Issues;\n    readonly teamsApi: Teams;\n    readonly distributionsApi: Distributions;\n    readonly dictionariesApi: Dictionaries;\n    readonly labelsApi: Labels;\n    readonly stringCommentsApi: StringComments;\n    readonly bundlesApi: Bundles;\n    readonly notificationsApi: Notifications;\n    readonly clientsApi: Clients;\n    readonly securityLogsApi: SecurityLogs;\n    readonly fieldsApi: Fields;\n    readonly stringCorrectionsApi: StringCorrections;\n    constructor(credentials: Credentials, config?: ClientConfig);\n}\nexport { Client };\n```\n\n##### issues/index.d.ts\n\n```typescript\nimport { CrowdinApi, PaginationOptions, PatchRequest, ResponseList, ResponseObject } from '../core';\nexport declare class Issues extends CrowdinApi {\n    listReportedIssues(projectId: number, options?: IssuesModel.ListReportedIssuesOptions): Promise<ResponseList<IssuesModel.Issue>>;\n    listReportedIssues(projectId: number, limit?: number, offset?: number, type?: IssuesModel.Type, status?: IssuesModel.Status): Promise<ResponseList<IssuesModel.Issue>>;\n    editIssue(projectId: number, issueId: number, request: PatchRequest[]): Promise<ResponseObject<IssuesModel.Issue>>;\n}\nexport declare namespace IssuesModel {\n    type Type = 'all' | 'general_question' | 'translation_mistake' | 'context_request' | 'source_mistake';\n    type Status = 'all' | 'resolved' | 'unresolved';\n    interface Issue {\n        id: number;\n        text: string;\n        userId: number;\n        stringId: number;\n        user: User;\n        string: string;\n        languageId: string;\n        type: Type;\n        status: Status;\n        createdAt: string;\n    }\n    interface User {\n        id: number;\n        username: string;\n        fullName: string;\n        avatarUrl: string;\n    }\n    interface String {\n        id: number;\n        text: string;\n        type: string;\n        hasPlurals: boolean;\n        isIcu: boolean;\n        context: string;\n        fileId: number;\n    }\n    interface ListReportedIssuesOptions extends PaginationOptions {\n        type?: IssuesModel.Type;\n        status?: IssuesModel.Status;\n    }\n}\n```\n\n##### labels/index.d.ts\n\n```typescript\nimport { CrowdinApi, PaginationOptions, PatchRequest, ResponseList, ResponseObject } from '../core';\nimport { ScreenshotsModel } from '../screenshots';\nimport { SourceStringsModel } from '../sourceStrings';\nexport declare class Labels extends CrowdinApi {\n    listLabels(projectId: number, options?: LabelsModel.ListLabelsParams): Promise<ResponseList<LabelsModel.Label>>;\n    listLabels(projectId: number, limit?: number, offset?: number): Promise<ResponseList<LabelsModel.Label>>;\n    addLabel(projectId: number, request: LabelsModel.AddLabelRequest): Promise<ResponseObject<LabelsModel.Label>>;\n    getLabel(projectId: number, labelId: number): Promise<ResponseObject<LabelsModel.Label>>;\n    deleteLabel(projectId: number, labelId: number): Promise<void>;\n    editLabel(projectId: number, labelId: number, request: PatchRequest[]): Promise<ResponseObject<LabelsModel.Label>>;\n    assignLabelToScreenshots(projectId: number, labelId: number, request: LabelsModel.AssignLabelToScreenshotsRequet): Promise<ResponseList<ScreenshotsModel.Screenshot>>;\n    unassignLabelFromScreenshots(projectId: number, labelId: number, screenshotIds: string): Promise<ResponseList<ScreenshotsModel.Screenshot>>;\n    assignLabelToString(projectId: number, labelId: number, request: LabelsModel.AssignLabelToStringsRequet): Promise<ResponseList<SourceStringsModel.String>>;\n    unassignLabelFromString(projectId: number, labelId: number, stringIds: string): Promise<ResponseList<SourceStringsModel.String>>;\n}\nexport declare namespace LabelsModel {\n    interface ListLabelsParams extends PaginationOptions {\n        orderBy?: string;\n    }\n    interface Label {\n        id: number;\n        title: string;\n        isSystem?: boolean;\n    }\n    interface AddLabelRequest {\n        title: string;\n    }\n    interface AssignLabelToStringsRequet {\n        stringIds: number[];\n    }\n    interface AssignLabelToScreenshotsRequet {\n        screenshotIds: number[];\n    }\n}\n```\n\n##### languages/index.d.ts\n\n```typescript\nimport { CrowdinApi, PaginationOptions, PatchRequest, ResponseList, ResponseObject } from '../core';\nexport declare class Languages extends CrowdinApi {\n    listSupportedLanguages(options?: PaginationOptions): Promise<ResponseList<LanguagesModel.Language>>;\n    listSupportedLanguages(limit?: number, offset?: number): Promise<ResponseList<LanguagesModel.Language>>;\n    addCustomLanguage(request: LanguagesModel.AddLanguageRequest): Promise<ResponseObject<LanguagesModel.Language>>;\n    getLanguage(languageId: string): Promise<ResponseObject<LanguagesModel.Language>>;\n    deleteCustomLanguage(languageId: string): Promise<void>;\n    editCustomLanguage(languageId: string, request: PatchRequest[]): Promise<ResponseObject<LanguagesModel.Language>>;\n}\nexport declare namespace LanguagesModel {\n    interface Language {\n        id: string;\n        name: string;\n        editorCode: string;\n        twoLettersCode: string;\n        threeLettersCode: string;\n        locale: string;\n        androidCode: string;\n        osxCode: string;\n        osxLocale: string;\n        pluralCategoryNames: string[];\n        pluralRules: string;\n        pluralExamples: string[];\n        textDirection: TextDirection;\n        dialectOf: string;\n    }\n    interface AddLanguageRequest {\n        name: string;\n        code: string;\n        localeCode: string;\n        textDirection: TextDirection;\n        pluralCategoryNames: string[];\n        threeLettersCode: string;\n        twoLettersCode?: string;\n        dialectOf?: string;\n    }\n    type TextDirection = 'ltr' | 'rtl';\n}\n```\n\n##### machineTranslation/index.d.ts\n\n```typescript\nimport { CrowdinApi, PaginationOptions, PatchRequest, ResponseList, ResponseObject } from '../core';\nexport declare class MachineTranslation extends CrowdinApi {\n    listMts(options?: MachineTranslationModel.ListMTsOptions): Promise<ResponseList<MachineTranslationModel.MachineTranslation>>;\n    listMts(groupId?: number, limit?: number, offset?: number): Promise<ResponseList<MachineTranslationModel.MachineTranslation>>;\n    createMt(request: MachineTranslationModel.CreateMachineTranslationRequest): Promise<ResponseObject<MachineTranslationModel.MachineTranslation>>;\n    getMt(mtId: number): Promise<ResponseObject<MachineTranslationModel.MachineTranslation>>;\n    deleteMt(mtId: number): Promise<void>;\n    updateMt(mtId: number, request: PatchRequest[]): Promise<ResponseObject<MachineTranslationModel.MachineTranslation>>;\n    translate(mtId: number, request: MachineTranslationModel.TranslateRequest): Promise<ResponseObject<MachineTranslationModel.TranslateResponse>>;\n}\nexport declare namespace MachineTranslationModel {\n    interface MachineTranslation {\n        id: number;\n        groupId: number;\n        name: string;\n        type: number;\n        credentials: Credentials;\n        projectIds: number[];\n        supportedLanguageIds: string[];\n        supportedLanguagePairs: Record<string, string[]>;\n        enabledLanguageIds: string[];\n        enabledProjectIds: number[];\n        isEnabled: boolean;\n    }\n    type Credentials = {\n        apiKey: string;\n    } | {\n        credentials: string;\n    } | {\n        model: string;\n        apiKey: string;\n    } | {\n        isSystemCredentials: boolean;\n        apiKey: string;\n    } | {\n        endpoint: string;\n        apiKey: string;\n    } | {\n        url: string;\n    } | {\n        accessKey: string;\n        secretKey: string;\n    };\n    interface CreateMachineTranslationRequest {\n        name: string;\n        type: string;\n        credentials: Credentials;\n        groupId?: number;\n        enabledLanguageIds?: string[];\n        enabledProjectIds?: number[];\n        isEnabled?: boolean;\n    }\n    interface TranslateRequest {\n        languageRecognitionProvider?: LanguageRecognitionProvider;\n        sourceLanguageId?: string;\n        targetLanguageId: string;\n        strings?: string[];\n    }\n    interface TranslateResponse {\n        sourceLanguageId: string;\n        targetLanguageId: string;\n        strings: string[];\n        translations: string[];\n    }\n    type LanguageRecognitionProvider = 'crowdin' | 'engine';\n    interface ListMTsOptions extends PaginationOptions {\n        groupId?: number;\n    }\n}\n```\n\n##### notifications/index.d.ts\n\n```typescript\nimport { CrowdinApi } from '../core';\nexport declare class Notifications extends CrowdinApi {\n    sendNotificationToAuthenticatedUser(request: NotificationsModel.Notification): Promise<void>;\n    sendNotificationToProjectMembers(projectId: number, request: NotificationsModel.NotificationByUsers | NotificationsModel.NotificationByRole): Promise<void>;\n    sendNotificationToOrganizationMembers(request: NotificationsModel.Notification | NotificationsModel.NotificationByUsers | NotificationsModel.NotificationByRole): Promise<void>;\n}\nexport declare namespace NotificationsModel {\n    interface Notification {\n        message: string;\n    }\n    interface NotificationByUsers extends Notification {\n        userIds: number[];\n    }\n    interface NotificationByRole extends Notification {\n        role: 'owner' | 'admin';\n    }\n}\n```\n\n##### organizationWebhooks/index.d.ts\n\n```typescript\nimport { CrowdinApi, PaginationOptions, PatchRequest, ResponseList, ResponseObject } from '../core';\nimport { WebhooksModel } from '../webhooks';\nexport declare class OrganizationWebhooks extends CrowdinApi {\n    listWebhooks(options?: PaginationOptions): Promise<ResponseList<OrganizationWebhooksModel.OrganizationWebhook>>;\n    addWebhook(request: OrganizationWebhooksModel.AddOrganizationWebhookRequest): Promise<ResponseObject<OrganizationWebhooksModel.OrganizationWebhook>>;\n    getWebhook(webhookId: number): Promise<ResponseObject<OrganizationWebhooksModel.OrganizationWebhook>>;\n    deleteWebhook(webhookId: number): Promise<void>;\n    editWebhook(webhookId: number, request: PatchRequest[]): Promise<ResponseObject<OrganizationWebhooksModel.OrganizationWebhook>>;\n}\nexport declare namespace OrganizationWebhooksModel {\n    type OrganizationWebhook = Omit<WebhooksModel.Webhook, 'projectId' | 'events'> & {\n        events: Event[];\n    };\n    type AddOrganizationWebhookRequest = Omit<WebhooksModel.AddWebhookRequest, 'events'> & {\n        events: Event[];\n    };\n    type Event = 'group.created' | 'group.deleted' | 'project.created' | 'project.deleted';\n}\n```\n\n##### projectsGroups/index.d.ts\n\n```typescript\nimport { BooleanInt, CrowdinApi, DownloadLink, PaginationOptions, PatchRequest, ResponseList, ResponseObject } from '../core';\nimport { LanguagesModel } from '../languages';\nexport declare class ProjectsGroups extends CrowdinApi {\n    listGroups(options?: ProjectsGroupsModel.ListGroupsOptions): Promise<ResponseList<ProjectsGroupsModel.Group>>;\n    listGroups(parentId?: number, offset?: number, userId?: number, limit?: number): Promise<ResponseList<ProjectsGroupsModel.Group>>;\n    addGroup(request: ProjectsGroupsModel.AddGroupRequest): Promise<ResponseObject<ProjectsGroupsModel.Group>>;\n    getGroup(groupId: number): Promise<ResponseObject<ProjectsGroupsModel.Group>>;\n    deleteGroup(groupId: number): Promise<void>;\n    editGroup(groupId: number, request: PatchRequest[]): Promise<ResponseObject<ProjectsGroupsModel.Group>>;\n    listProjects(options?: ProjectsGroupsModel.ListProjectsOptions): Promise<ResponseList<ProjectsGroupsModel.Project | ProjectsGroupsModel.ProjectSettings>>;\n    listProjects(groupId?: number, hasManagerAccess?: BooleanInt, limit?: number, offset?: number): Promise<ResponseList<ProjectsGroupsModel.Project | ProjectsGroupsModel.ProjectSettings>>;\n    addProject(request: ProjectsGroupsModel.CreateProjectEnterpriseRequest | ProjectsGroupsModel.CreateProjectRequest): Promise<ResponseObject<ProjectsGroupsModel.Project | ProjectsGroupsModel.ProjectSettings>>;\n    getProject(projectId: number): Promise<ResponseObject<ProjectsGroupsModel.Project | ProjectsGroupsModel.ProjectSettings>>;\n    deleteProject(projectId: number): Promise<void>;\n    editProject(projectId: number, request: PatchRequest[]): Promise<ResponseObject<ProjectsGroupsModel.Project | ProjectsGroupsModel.ProjectSettings>>;\n    downloadProjectFileFormatSettingsCustomSegmentation(projectId: number, fileFormatSettingsId: number): Promise<ResponseObject<DownloadLink>>;\n    resetProjectFileFormatSettingsCustomSegmentation(projectId: number, fileFormatSettingsId: number): Promise<ResponseObject<DownloadLink>>;\n    listProjectFileFormatSettings(projectId: number, options?: PaginationOptions): Promise<ResponseList<ProjectsGroupsModel.ProjectFileFormatSettings>>;\n    addProjectFileFormatSettings(projectId: number, request: ProjectsGroupsModel.AddProjectFileFormatSettingsRequest): Promise<ResponseObject<ProjectsGroupsModel.ProjectFileFormatSettings>>;\n    getProjectFileFormatSettings(projectId: number, fileFormatSettingsId: number): Promise<ResponseObject<ProjectsGroupsModel.ProjectFileFormatSettings>>;\n    deleteProjectFileFormatSettings(projectId: number, fileFormatSettingsId: number): Promise<void>;\n    editProjectFileFormatSettings(projectId: number, fileFormatSettingsId: number, request: PatchRequest[]): Promise<ResponseObject<ProjectsGroupsModel.ProjectFileFormatSettings>>;\n    listProjectStringsExporterSettings(projectId: number, options?: PaginationOptions): Promise<ResponseList<ProjectsGroupsModel.ProjectStringsExporterSettings>>;\n    addProjectStringsExporterSettings(projectId: number, request: ProjectsGroupsModel.AddProjectStringsExporterSettingsRequest): Promise<ResponseObject<ProjectsGroupsModel.ProjectStringsExporterSettings>>;\n    getProjectStringsExporterSettings(projectId: number, systemStringsExporterSettingsId: number): Promise<ResponseObject<ProjectsGroupsModel.ProjectStringsExporterSettings>>;\n    deleteProjectStringsExporterSettings(projectId: number, systemStringsExporterSettingsId: number): Promise<void>;\n    editProjectStringsExporterSettings(projectId: number, systemStringsExporterSettingsId: number, request: ProjectsGroupsModel.AddProjectStringsExporterSettingsRequest): Promise<ResponseObject<ProjectsGroupsModel.ProjectStringsExporterSettings>>;\n}\nexport declare namespace ProjectsGroupsModel {\n    interface Group {\n        id: number;\n        name: string;\n        description: string;\n        parentId: number;\n        organizationId: number;\n        userId: number;\n        subgroupsCount: number;\n        projectsCount: number;\n        webUrl: string;\n        createdAt: string;\n        updatedAt: string;\n    }\n    interface AddGroupRequest {\n        name: string;\n        parentId?: number;\n        description?: string;\n    }\n    interface Project {\n        id: number;\n        type: Type;\n        userId: number;\n        sourceLanguageId: string;\n        targetLanguageIds: string[];\n        languageAccessPolicy: LanguageAccessPolicy;\n        name: string;\n        identifier: string;\n        description: string;\n        visibility: string;\n        logo: string;\n        publicDownloads: boolean;\n        createdAt: string;\n        updatedAt: string;\n        lastActivity: string;\n        sourceLanguage: LanguagesModel.Language;\n        targetLanguages: LanguagesModel.Language[];\n        webUrl: string;\n        savingsReportSettingsTemplateId: number;\n        fields: Record<string, any>;\n        cname: string;\n        groupId: number;\n        background: string;\n        isExternal: boolean;\n        externalType: string;\n        externalProjectId: number;\n        externalOrganizationId: number;\n        workflowId: number;\n        hasCrowdsourcing: boolean;\n        publicUrl: string;\n    }\n    interface CreateProjectRequest {\n        name: string;\n        identifier: string;\n        sourceLanguageId: string;\n        targetLanguageIds?: string[];\n        visibility?: JoinPolicy;\n        languageAccessPolicy?: LanguageAccessPolicy;\n        cname?: string;\n        description?: string;\n        tagDetection?: TagDetection;\n        isMtAllowed?: boolean;\n        taskBasedAccessControl?: boolean;\n        autoSubstitution?: boolean;\n        autoTranslateDialects?: boolean;\n        publicDownloads?: boolean;\n        hiddenStringsProofreadersAccess?: boolean;\n        useGlobalTm?: boolean;\n        showTmSuggestionsDialects?: boolean;\n        tmApprovedSuggestionsOnly?: boolean;\n        skipUntranslatedStrings?: boolean;\n        exportApprovedOnly?: boolean;\n        qaCheckIsActive?: boolean;\n        qaCheckCategories?: CheckCategories;\n        qaChecksIgnorableCategories?: CheckCategories;\n        languageMapping?: LanguageMapping;\n        glossaryAccess?: boolean;\n        glossaryAccessOption?: GlossaryAccessOption;\n        normalizePlaceholder?: boolean;\n        notificationSettings?: NotificationSettings;\n        tmPreTranslate?: ProjectSettings['tmPreTranslate'];\n        mtPreTranslate?: ProjectSettings['mtPreTranslate'];\n        aiPreTranslate?: ProjectSettings['aiPreTranslate'];\n        assistActionAiPromptId?: number;\n        editorSuggestionAiPromptId?: number;\n        savingsReportSettingsTemplateId?: number;\n        defaultTmId?: number;\n        defaultGlossaryId?: number;\n        inContext?: boolean;\n        inContextProcessHiddenStrings?: boolean;\n        inContextPseudoLanguageId?: string;\n        saveMetaInfoInSource?: boolean;\n        type?: BooleanInt;\n        skipUntranslatedFiles?: boolean;\n        tmContextType?: TmContextType;\n    }\n    interface CreateProjectEnterpriseRequest {\n        name: string;\n        sourceLanguageId: string;\n        templateId?: number;\n        steps?: WorkflowTemplateStepConfig[];\n        groupId?: number;\n        targetLanguageIds?: string[];\n        vendorId?: number;\n        mtEngineId?: number;\n        description?: string;\n        translateDuplicates?: TranslateDuplicates;\n        tagsDetection?: TagDetection;\n        isMtAllowed?: boolean;\n        taskBasedAccessControl?: boolean;\n        taskReviewerIds?: number[];\n        autoSubstitution?: boolean;\n        showTmSuggestionsDialects?: boolean;\n        tmApprovedSuggestionsOnly?: boolean;\n        autoTranslateDialects?: boolean;\n        publicDownloads?: boolean;\n        hiddenStringsProofreadersAccess?: boolean;\n        delayedWorkflowStart?: boolean;\n        skipUntranslatedStrings?: boolean;\n        exportWithMinApprovalsCount?: number;\n        exportStringsThatPassedWorkflow?: number;\n        normalizePlaceholder?: boolean;\n        qaCheckIsActive?: boolean;\n        qaApprovalsCount?: number;\n        qaCheckCategories?: CheckCategories;\n        qaChecksIgnorableCategories?: CheckCategories;\n        customQaCheckIds?: number[];\n        languageMapping?: LanguageMapping;\n        glossaryAccess?: boolean;\n        glossaryAccessOption?: GlossaryAccessOption;\n        notificationSettings?: NotificationSettings;\n        savingsReportSettingsTemplateId?: number;\n        fields?: Record<string, any>;\n        assistActionAiPromptId?: number;\n        editorSuggestionAiPromptId?: number;\n        alignmentActionAiPromptId?: number;\n        defaultTmId?: number;\n        defaultGlossaryId?: number;\n        inContext?: boolean;\n        inContextProcessHiddenStrings?: boolean;\n        inContextPseudoLanguageId?: string;\n        saveMetaInfoInSource?: boolean;\n        type?: BooleanInt;\n        skipUntranslatedFiles?: boolean;\n        tmContextType?: TmContextType;\n    }\n    type GlossaryAccessOption = 'readOnly' | 'fullAccess' | 'manageDrafts';\n    interface ProjectSettings extends Project {\n        translateDuplicates: TranslateDuplicates;\n        tagsDetection: TagDetection;\n        glossaryAccess: boolean;\n        glossaryAccessOption: GlossaryAccessOption;\n        isMtAllowed: boolean;\n        taskBasedAccessControl: boolean;\n        hiddenStringsProofreadersAccess: boolean;\n        autoSubstitution: boolean;\n        exportTranslatedOnly: boolean;\n        skipUntranslatedStrings: boolean;\n        exportApprovedOnly: boolean;\n        autoTranslateDialects: boolean;\n        useGlobalTm: boolean;\n        showTmSuggestionsDialects: boolean;\n        tmApprovedSuggestionsOnly: boolean;\n        isSuspended: boolean;\n        qaCheckIsActive: boolean;\n        qaCheckCategories: CheckCategories;\n        qaChecksIgnorableCategories: CheckCategories;\n        languageMapping: LanguageMapping;\n        notificationSettings: NotificationSettings;\n        defaultTmId: number;\n        defaultGlossaryId: number;\n        assignedTms: {\n            [id: string]: {\n                priority: number;\n            };\n        };\n        assignedGlossaries: number[];\n        tmPenalties: {\n            autoSubstitution: number;\n            tmPriority: {\n                priority: number;\n                penalty: number;\n            };\n            multipleTranslations: number;\n            timeSinceLastUsage: {\n                months: number;\n                penalty: number;\n            };\n            timeSinceLastModified: {\n                months: number;\n                penalty: number;\n            };\n        };\n        normalizePlaceholder: boolean;\n        tmPreTranslate: {\n            enabled: boolean;\n            autoApproveOption: 'all' | 'perfectMatchOnly' | 'exceptAutoSubstituted' | 'perfectMatchApprovedOnly' | 'none';\n            minimumMatchRatio: 'perfect' | '100';\n        };\n        mtPreTranslate: {\n            enabled: boolean;\n            mts: {\n                mtId: number;\n                languageIds: string[];\n            }[];\n        };\n        aiPreTranslate: {\n            enabled: boolean;\n            aiPrompts: {\n                aiPromptId: number;\n                languageIds: string[];\n            }[];\n        };\n        assistActionAiPromptId: number;\n        editorSuggestionAiPromptId: number;\n        inContext: boolean;\n        inContextProcessHiddenStrings: string;\n        inContextPseudoLanguageId: string;\n        inContextPseudoLanguage: LanguagesModel.Language;\n        saveMetaInfoInSource: boolean;\n        skipUntranslatedFiles: boolean;\n        tmContextType: TmContextType;\n        clientOrganizationId: number;\n        taskReviewerIds: number[];\n        exportWithMinApprovalsCount: number;\n        exportStringsThatPassedWorkflow: boolean;\n        qaApprovalsCount: number;\n        customQaCheckIds: number[];\n        externalQaCheckIds: number[];\n        delayedWorkflowStart: boolean;\n        alignmentActionAiPromptId: number;\n    }\n    enum Type {\n        FILES_BASED = 0,\n        STRINGS_BASED = 1\n    }\n    enum TagDetection {\n        AUTO = 0,\n        COUNT_TAGS = 1,\n        SKIP_TAGS = 2\n    }\n    type JoinPolicy = 'open' | 'private';\n    type LanguageAccessPolicy = 'open' | 'moderate';\n    interface CheckCategories {\n        empty: boolean;\n        size: boolean;\n        tags: boolean;\n        spaces: boolean;\n        variables: boolean;\n        punctuation: boolean;\n        symbolRegister: boolean;\n        specialSymbols: boolean;\n        wrongTranslation: boolean;\n        spellcheck: boolean;\n        icu: boolean;\n        terms: boolean;\n        duplicate: boolean;\n        ftl: boolean;\n        android: boolean;\n    }\n    interface LanguageMapping {\n        [key: string]: LanguageMappingEntity;\n    }\n    interface LanguageMappingEntity {\n        name: string;\n        two_letters_code: string;\n        three_letters_code: string;\n        locale: string;\n        locale_with_underscore: string;\n        android_code: string;\n        osx_code: string;\n        osx_locale: string;\n    }\n    enum TranslateDuplicates {\n        SHOW = 0,\n        HIDE_REGULAR_DETECTION = 1,\n        SHOW_AUTO_TRANSLATE = 2,\n        SHOW_WITHIN_VERION_BRANCH_REGULAR_DETECTION = 3,\n        HIDE_STRICT_DETECTION = 4,\n        SHOW_WITHIN_VERION_BRANCH_STRICT_DETECTION = 5\n    }\n    interface NotificationSettings {\n        translatorNewStrings?: boolean;\n        managerNewStrings?: boolean;\n        managerLanguageCompleted?: boolean;\n    }\n    interface ListGroupsOptions extends PaginationOptions {\n        parentId?: number;\n        userId?: number;\n        orderBy?: string;\n    }\n    interface ListProjectsOptions extends PaginationOptions {\n        groupId?: number;\n        hasManagerAccess?: BooleanInt;\n        orderBy?: string;\n        type?: BooleanInt;\n    }\n    type Settings = PropertyFileFormatSettings | CommonFileFormatSettings | XmlFileFormatSettings | MdxV2FormatSettings | FmHtmlFormatSettings | HtmlFormatSettings | JsonFormatSettings | MdxV1FormatSettings | JavaScriptFileFormatSettings | DocxFileFormatSettings;\n    interface ProjectFileFormatSettings {\n        id: number;\n        name: string;\n        format: string;\n        extensions: string[];\n        settings: Settings;\n        createdAt: string;\n        updatedAt: string;\n    }\n    interface AddProjectFileFormatSettingsRequest {\n        format: string;\n        settings: Settings;\n    }\n    interface PropertyFileFormatSettings {\n        escapeQuotes?: 0 | 1 | 2 | 3;\n        escapeSpecialCharacters?: 0 | 1;\n        exportPattern?: string;\n    }\n    interface JavaScriptFileFormatSettings {\n        exportPattern?: 'string';\n        exportQuotes?: 'single' | 'double';\n    }\n    interface CommonFileFormatSettings {\n        contentSegmentation?: boolean;\n        srxStorageId?: number;\n        exportPattern?: string;\n    }\n    interface XmlFileFormatSettings extends CommonFileFormatSettings {\n        translateContent?: boolean;\n        translateAttributes?: boolean;\n        translatableElements?: string[];\n    }\n    interface JsonFormatSettings extends CommonFileFormatSettings {\n        type?: 'i18next_json' | 'nestjs_i18n';\n    }\n    interface MdxV2FormatSettings extends CommonFileFormatSettings {\n        excludeCodeBlocks?: boolean;\n        excludedFrontMatterElements?: string[];\n    }\n    interface MdxV1FormatSettings extends CommonFileFormatSettings {\n        excludeCodeBlocks?: boolean;\n        excludedFrontMatterElements?: string[];\n        type?: 'mdx_v1' | 'mdx_v2';\n    }\n    interface FmHtmlFormatSettings extends CommonFileFormatSettings {\n        excludedElements?: boolean;\n        excludedFrontMatterElements?: string[];\n    }\n    interface HtmlFormatSettings extends CommonFileFormatSettings {\n        excludedElements?: boolean;\n    }\n    interface DocxFileFormatSettings extends CommonFileFormatSettings {\n        cleanTagsAggressively?: boolean;\n        translateHiddenText?: boolean;\n        translateHyperlinkUrls?: boolean;\n        translateHiddenRowsAndColumns?: boolean;\n        importNotes?: boolean;\n        importHiddenSlides?: boolean;\n    }\n    type TmContextType = 'segmentContext' | 'auto' | 'prevAndNextSegment';\n    type WorkflowTemplateStepConfig = WorkflowTemplateStepConfigTranslateProofread | WorkflowTemplateStepConfigVendor | WorkflowTemplateStepConfigTMPreTranslate | WorkflowTemplateStepConfigMTPreTranslate;\n    interface WorkflowTemplateStepConfigTranslateProofread {\n        id: number;\n        languages?: string[];\n        assignees?: number[];\n        config?: {\n            assignees: {\n                [key: string]: number[];\n            };\n        };\n    }\n    interface WorkflowTemplateStepConfigVendor {\n        id: number;\n        languages?: string[];\n        vendorId?: number;\n    }\n    interface WorkflowTemplateStepConfigTMPreTranslate {\n        id: number;\n        languages?: string[];\n        config?: {\n            minRelevant?: number;\n            autoSubstitution?: boolean;\n        };\n    }\n    interface WorkflowTemplateStepConfigMTPreTranslate {\n        id: number;\n        languages?: string[];\n        mtId?: number;\n    }\n    type StringsExporterSettings = AndroidStringsExporterSettings | MacOSXStringsExporterSettings | XliffStringsExporterSettings;\n    interface ProjectStringsExporterSettings {\n        id: number;\n        format: string;\n        settings: StringsExporterSettings;\n        createdAt: string;\n        updatedAt: string;\n    }\n    interface AndroidStringsExporterSettings {\n        convertPlaceholders?: boolean;\n        convertLineBreaks?: boolean;\n        useCdataForStringsWithTags?: boolean;\n    }\n    interface MacOSXStringsExporterSettings {\n        convertPlaceholders?: boolean;\n        convertLineBreaks?: boolean;\n    }\n    interface XliffStringsExporterSettings {\n        languagePairMapping?: {\n            [key: string]: {\n                sourceLanguageId: string;\n            };\n        };\n        copySourceToEmptyTarget?: boolean;\n        exportTranslatorsComment?: boolean;\n    }\n    interface AddProjectStringsExporterSettingsRequest {\n        format: string;\n        settings: StringsExporterSettings;\n    }\n}\n```\n\n##### reports/index.d.ts\n\n```typescript\nimport { CrowdinApi, DownloadLink, PaginationOptions, PatchRequest, ResponseList, ResponseObject, Status } from '../core';\nexport declare class Reports extends CrowdinApi {\n    listOrganizationReportArchives(options?: ReportsModel.ListReportArchiveParams): Promise<ResponseList<ReportsModel.ReportArchive>>;\n    getOrganizationReportArchive(archiveId: number): Promise<ResponseObject<ReportsModel.ReportArchive>>;\n    deleteOrganizationReportArchive(archiveId: number): Promise<void>;\n    exportOrganizationReportArchive(archiveId: number, request?: {\n        format?: ReportsModel.Format;\n    }): Promise<ResponseObject<Status<ReportsModel.ReportArchiveStatusAttribute>>>;\n    checkOrganizationReportArchiveStatus(archiveId: number, exportId: string): Promise<ResponseObject<Status<ReportsModel.ReportArchiveStatusAttribute>>>;\n    downloadOrganizationReportArchive(archiveId: number, exportId: string): Promise<ResponseObject<DownloadLink>>;\n    listUserReportArchives(userId: number, options?: ReportsModel.ListReportArchiveParams): Promise<ResponseList<ReportsModel.ReportArchive>>;\n    getUserReportArchive(userId: number, archiveId: number): Promise<ResponseObject<ReportsModel.ReportArchive>>;\n    deleteUserReportArchive(userId: number, archiveId: number): Promise<void>;\n    exportUserReportArchive(userId: number, archiveId: number, request?: {\n        format?: ReportsModel.Format;\n    }): Promise<ResponseObject<Status<ReportsModel.ReportArchiveStatusAttribute>>>;\n    checkUserReportArchiveStatus(userId: number, archiveId: number, exportId: string): Promise<ResponseObject<Status<ReportsModel.ReportArchiveStatusAttribute>>>;\n    downloadUserReportArchive(userId: number, archiveId: number, exportId: string): Promise<ResponseObject<DownloadLink>>;\n    generateGroupReport(groupId: number, request: ReportsModel.GenerateGroupReportRequest): Promise<ResponseObject<Status<ReportsModel.ReportStatusAttributes<ReportsModel.GroupReportSchema>>>>;\n    checkGroupReportStatus(groupId: number, reportId: string): Promise<ResponseObject<Status<ReportsModel.ReportStatusAttributes<ReportsModel.GroupReportSchema>>>>;\n    downloadGroupReport(groupId: number, reportId: string): Promise<ResponseObject<DownloadLink>>;\n    listOrganizationReportSettingsTemplates(options?: ReportsModel.ListOrganizationReportSettingsParams): Promise<ResponseList<ReportsModel.OrganizationReportSettings>>;\n    addOrganizationReportSettingsTemplate(request: ReportsModel.AddOrganizationReportSettingsRequest): Promise<ResponseObject<ReportsModel.OrganizationReportSettings>>;\n    getOrganizationReportSettingsTemplate(reportSettingsTemplateId: number): Promise<ResponseObject<ReportsModel.OrganizationReportSettings>>;\n    editOrganizationReportSettingsTemplate(reportSettingsTemplateId: number, request: PatchRequest[]): Promise<ResponseObject<ReportsModel.OrganizationReportSettings>>;\n    deleteOrganizationReportSettingsTemplate(reportSettingsTemplateId: number): Promise<void>;\n    generateOrganizationReport(request: ReportsModel.GenerateOrganizationReportRequest): Promise<ResponseObject<Status<ReportsModel.ReportStatusAttributes<ReportsModel.OrganizationReportSchema>>>>;\n    checkOrganizationReportStatus(reportId: string): Promise<ResponseObject<Status<ReportsModel.ReportStatusAttributes<ReportsModel.OrganizationReportSchema>>>>;\n    downloadOrganizationReport(reportId: string): Promise<ResponseObject<DownloadLink>>;\n    generateReport(projectId: number, request: ReportsModel.GenerateReportRequest): Promise<ResponseObject<Status<ReportsModel.ReportStatusAttributes<ReportsModel.ReportSchema>>>>;\n    checkReportStatus(projectId: number, reportId: string): Promise<ResponseObject<Status<ReportsModel.ReportStatusAttributes<ReportsModel.ReportSchema>>>>;\n    downloadReport(projectId: number, reportId: string): Promise<ResponseObject<DownloadLink>>;\n    listReportSettingsTemplates(projectId: number, options?: PaginationOptions): Promise<ResponseList<ReportsModel.ReportSettings>>;\n    addReportSettingsTemplate(projectId: number, request: ReportsModel.AddReportSettingsRequest): Promise<ResponseObject<ReportsModel.ReportSettings>>;\n    getReportSettingsTemplate(projectId: number, reportSettingsTemplateId: number): Promise<ResponseObject<ReportsModel.ReportSettings>>;\n    editReportSettingsTemplate(projectId: number, reportSettingsTemplateId: number, request: PatchRequest[]): Promise<ResponseObject<ReportsModel.ReportSettings>>;\n    deleteReportSettingsTemplate(projectId: number, reportSettingsTemplateId: number): Promise<void>;\n    listUserReportSettingsTemplates(userId: number, options?: PaginationOptions): Promise<ResponseList<ReportsModel.UserReportSettings>>;\n    addUserReportSettingsTemplate(userId: number, request: ReportsModel.AddUserReportSettingsRequest): Promise<ResponseObject<ReportsModel.UserReportSettings>>;\n    getUserReportSettingsTemplate(userId: number, reportSettingsTemplateId: number): Promise<ResponseObject<ReportsModel.UserReportSettings>>;\n    editUserReportSettingsTemplate(userId: number, reportSettingsTemplateId: number, request: PatchRequest[]): Promise<ResponseObject<ReportsModel.UserReportSettings>>;\n    deleteUserReportSettingsTemplate(userId: number, reportSettingsTemplateId: number): Promise<void>;\n}\nexport declare namespace ReportsModel {\n    interface ReportArchive {\n        id: number;\n        scopeType: string;\n        scopeId: number;\n        userId: number;\n        name: string;\n        webUrl: string;\n        scheme: any;\n        createdAt: string;\n    }\n    interface ListReportArchiveParams extends PaginationOptions {\n        scopeType: string;\n        scopeId: number;\n    }\n    interface ReportArchiveStatusAttribute {\n        format: Format;\n        reportName: string;\n        schema: any;\n    }\n    type GroupReportSchema = GroupTranslationCostsPostEditingSchema | GroupTopMembersSchema | GroupTaskUsageSchema | GroupQaCheckIssuesSchema | GroupTranslationActivitySchema;\n    type OrganizationReportSchema = GroupTranslationCostsPostEditingSchema | GroupTopMembersSchema | GroupTaskUsageSchema | GroupQaCheckIssuesSchema | GroupTranslationActivitySchema;\n    interface GenerateGroupReportRequest {\n        name: string;\n        schema: GroupReportSchema;\n    }\n    interface GenerateOrganizationReportRequest {\n        name: string;\n        schema: OrganizationReportSchema;\n    }\n    interface GroupTranslationCostsPostEditingSchema {\n        projectIds?: number[];\n        unit?: Unit;\n        currency?: Currency;\n        format?: Format;\n        baseRates: BaseRate;\n        individualRates: IndividualRate[];\n        netRateSchemes: NetRateSchemas;\n        excludeApprovalsForEditedTranslations?: boolean;\n        preTranslatedStringsCategorizationAdjustment?: boolean;\n        groupBy?: GroupBy;\n        dateFrom?: string;\n        dateTo?: string;\n        userIds?: number[];\n    }\n    interface GroupTranslationCostsPerEditingByTaskSchema {\n        unit?: Unit;\n        currency?: Currency;\n        format?: Format;\n        baseRates: BaseRate;\n        individualRates: IndividualRate[];\n        netRateSchemes: NetRateSchemas;\n        taskId?: number;\n    }\n    interface CostsEstimationSchema {\n        projectIds?: number[];\n        unit?: Unit;\n        currency?: Currency;\n        format?: Format;\n        baseRates: BaseRate;\n        individualRates: IndividualRate[];\n        netRateSchemes: NetRateSchemas;\n        calculateInternalMatches?: boolean;\n        includePreTranslatedStrings?: boolean;\n        languageId?: string;\n        branchIds?: number[];\n        dateFrom?: string;\n        dateTo?: string;\n        labelIds?: number[];\n        labelIncludeType?: LabelIncludeType;\n    }\n    interface CostsEstimationByTaskSchema {\n        unit?: Unit;\n        currency?: Currency;\n        format?: Format;\n        baseRates?: BaseRate;\n        individualRates?: IndividualRate[];\n        netRateSchemes?: NetRateSchemas;\n        calculateInternalMatches?: boolean;\n        includePreTranslatedStrings?: boolean;\n        taskId?: number;\n    }\n    interface GroupTopMembersSchema {\n        projectIds?: number[];\n        unit?: Unit;\n        languageId?: string;\n        format?: Format;\n        dateFrom?: string;\n        dateTo?: string;\n    }\n    interface RawDataSchema {\n        mode: ContributionMode;\n        unit?: Unit;\n        languageId?: string;\n        userId?: number;\n        dateFrom?: string;\n        dateTo?: string;\n    }\n    type GenerateReportRequest = PreTranslateEfficeincy | PreTranslateAccuracy | TranslateAccuracy | CostEstimationPostEnding | TranslationCostsPostEnding | TopMembers | ContributionRawData | SourceContentUpdates | ProjectMembers | EditorIssues | QaCheckIssues | SavingActivity | TranslationActivity;\n    type ReportSchema = Pick<GenerateReportRequest, 'schema'>;\n    interface PreTranslateEfficeincy {\n        name: 'pre-translate-efficiency';\n        schema: PreTranslateAccuracySchema | PreTranslateAccuracySchemaByTask;\n    }\n    interface PreTranslateAccuracy {\n        name: 'pre-translate-accuracy';\n        schema: PreTranslateAccuracySchema | PreTranslateAccuracySchemaByTask;\n    }\n    interface TranslateAccuracy {\n        name: 'translator-accuracy';\n        schema: TranslateAccuracySchema;\n    }\n    interface CostEstimationPostEnding {\n        name: 'costs-estimation-pe';\n        schema: CostEstimationPostEndingSchema | CostEstimationPostEndingSchemaByTask;\n    }\n    interface TranslationCostsPostEnding {\n        name: 'translation-costs-pe';\n        schema: TranslationCostsPostEndingSchema | TranslationCostsPostEndingSchemaByTask;\n    }\n    interface TopMembers {\n        name: 'top-members';\n        schema: TopMembersSchema;\n    }\n    interface ContributionRawData {\n        name: 'contribution-raw-data';\n        schema: ContributionRawDataSchema | ContributionRawDataSchemaByTask;\n    }\n    interface SourceContentUpdates {\n        name: 'source-content-updates';\n        schema: SourceContentUpdatesSchema;\n    }\n    interface ProjectMembers {\n        name: 'project-members';\n        schema: MembersSchema;\n    }\n    interface EditorIssues {\n        name: 'editor-issues';\n        schema: EditorIssuesSchema;\n    }\n    interface QaCheckIssues {\n        name: 'qa-check-issues';\n        schema: ProjectQaCheckIssuesSchema;\n    }\n    interface SavingActivity {\n        name: 'saving-activity';\n        schema: SavingActivitySchema;\n    }\n    interface TranslationActivity {\n        name: 'translation-activity';\n        schema: ProjectConsumptionSchema;\n    }\n    interface ReportStatusAttributes<S> {\n        format: Format;\n        reportName: string;\n        schema: S;\n    }\n    interface PreTranslateAccuracySchema {\n        unit?: Unit;\n        format?: Format;\n        postEditingCategories?: string[];\n        languageId?: string;\n        dateFrom?: string;\n        dateTo?: string;\n    }\n    interface PreTranslateAccuracySchemaByTask {\n        unit?: Unit;\n        format?: Format;\n        postEditingCategories?: string[];\n        taskId?: number;\n    }\n    interface TranslateAccuracySchema {\n        unit?: Unit;\n        format?: Format;\n        postEditingCategories?: string[];\n        languageId?: string;\n        userIds?: number[];\n        dateFrom?: string;\n        dateTo?: string;\n    }\n    interface CostEstimationPostEndingSchema {\n        unit?: Unit;\n        currency?: Currency;\n        format?: Format;\n        baseRates: BaseRate;\n        individualRates: IndividualRate[];\n        netRateSchemes: Omit<NetRateSchemas, 'mtMatch' | 'suggestionMatch'>;\n        calculateInternalMatches?: boolean;\n        includePreTranslatedStrings?: boolean;\n        languageId?: string;\n        fileIds?: number[];\n        directoryIds?: number[];\n        branchIds?: number[];\n        dateFrom?: string;\n        dateTo?: string;\n        labelIds?: number[];\n        labelIncludeType?: LabelIncludeType;\n        workflowStepId?: number;\n    }\n    interface CostEstimationPostEndingSchemaByTask {\n        unit?: Unit;\n        currency?: Currency;\n        format?: Format;\n        baseRates?: BaseRate;\n        individualRates?: IndividualRate[];\n        netRateSchemes?: Omit<NetRateSchemas, 'mtMatch' | 'suggestionMatch'>;\n        calculateInternalMatches?: boolean;\n        includePreTranslatedStrings?: boolean;\n        taskId?: number;\n    }\n    interface TranslationCostsPostEndingSchemaByTask {\n        unit?: Unit;\n        currency?: Currency;\n        format?: Format;\n        baseRates: BaseRate;\n        individualRates: IndividualRate[];\n        netRateSchemes: NetRateSchemas;\n        taskId?: number;\n        excludeApprovalsForEditedTranslations?: boolean;\n        preTranslatedStringsCategorizationAdjustment?: boolean;\n    }\n    interface TranslationCostsPostEndingSchema {\n        unit?: Unit;\n        currency?: Currency;\n        format?: Format;\n        baseRates: BaseRate;\n        individualRates: IndividualRate[];\n        netRateSchemes: NetRateSchemas;\n        excludeApprovalsForEditedTranslations?: boolean;\n        preTranslatedStringsCategorizationAdjustment?: boolean;\n        groupBy?: GroupBy;\n        dateFrom?: string;\n        dateTo?: string;\n        languageId?: string;\n        userIds?: number[];\n        fileIds?: number[];\n        directoryIds?: number[];\n        branchIds?: number[];\n        labelIds?: number;\n        labelIncludeType?: LabelIncludeType;\n        workflowStepId?: number;\n    }\n    interface TopMembersSchema {\n        unit?: Unit;\n        languageId?: string;\n        format?: Format;\n        dateFrom?: string;\n        dateTo?: string;\n    }\n    interface ContributionRawDataSchema {\n        mode: ContributionMode;\n        unit?: Unit;\n        languageId?: string;\n        userId?: string;\n        columns?: Column[];\n        fileIds?: number[];\n        directoryIds?: number[];\n        branchIds?: number[];\n        tmIds?: number[];\n        mtIds?: number[];\n        aiPromptIds?: number[];\n        dateFrom?: string;\n        dateTo?: string;\n    }\n    interface ContributionRawDataSchemaByTask {\n        mode: ContributionMode;\n        unit?: Unit;\n        taskId: number;\n        columns?: Column[];\n        tmIds?: number[];\n        mtIds?: number[];\n        aiPromptIds?: number[];\n        dateFrom?: string;\n        dateTo?: string;\n    }\n    interface PreTranslateEfficiencySchema {\n        unit?: Unit;\n        format?: Format;\n        postEditingCategories?: string[];\n        languageId?: string;\n        dateFrom?: string;\n        dateTo?: string;\n    }\n    interface ListOrganizationReportSettingsParams extends PaginationOptions {\n        projectId?: number;\n        groupId?: number;\n    }\n    interface ReportSettings {\n        id: number;\n        name: string;\n        currency: Currency;\n        unit: Unit;\n        config: ReportSettinsConfig;\n        isPublic: boolean;\n        isGlobal: boolean;\n        createdAt: string;\n        updatedAt: string;\n    }\n    interface AddReportSettingsRequest {\n        name: string;\n        currency: Currency;\n        unit: Unit;\n        config: ReportSettinsConfig;\n        isPublic?: boolean;\n        isGlobal?: boolean;\n    }\n    type UserReportSettings = Omit<ReportSettings, 'isPublic' | 'isGlobal'>;\n    type AddUserReportSettingsRequest = Omit<AddReportSettingsRequest, 'isPublic' | 'isGlobal'>;\n    type OrganizationReportSettings = Omit<ReportSettings, 'isGlobal'> & {\n        projectId: number;\n        groupId: number;\n    };\n    type AddOrganizationReportSettingsRequest = Omit<AddReportSettingsRequest, 'isGlobal'> & {\n        projectId?: number;\n        groupId?: number;\n    };\n    interface ReportSettinsConfig {\n        baseRates: BaseRate;\n        netRateSchemes: NetRateSchemas[];\n        individualRates: IndividualRate[];\n    }\n    type Unit = 'strings' | 'words' | 'chars' | 'chars_with_spaces';\n    type Currency = 'USD' | 'EUR' | 'JPY' | 'GBP' | 'AUD' | 'CAD' | 'CHF' | 'CNY' | 'SEK' | 'NZD' | 'MXN' | 'SGD' | 'HKD' | 'NOK' | 'KRW' | 'TRY' | 'RUB' | 'INR' | 'BRL' | 'ZAR' | 'GEL' | 'UAH';\n    type Format = 'xlsx' | 'csv' | 'json';\n    interface BaseRate {\n        fullTranslation: number;\n        proofread: number;\n    }\n    interface IndividualRate extends BaseRate {\n        languageIds: string[];\n        userIds: number[];\n        fullTranslation: number;\n        proofread: number;\n    }\n    interface NetRateSchemas {\n        tmMatch: {\n            matchType: Mode;\n            price: number;\n        }[];\n        mtMatch: {\n            matchType: Mode;\n            price: number;\n        }[];\n        suggestionMatch: {\n            matchType: Mode;\n            price: number;\n        }[];\n        aiMatch?: {\n            matchType: Mode;\n            price: number;\n        }[];\n    }\n    type Mode = 'no_match' | 'tm_match' | 'approval' | '99-95' | '94-90' | '89-80' | 'perfect' | '100';\n    type ContributionMode = 'translations' | 'approvals' | 'votes';\n    type GroupBy = 'user' | 'language';\n    type LabelIncludeType = 'strings_with_label' | 'strings_without_label';\n    type Column = 'userId' | 'languageId' | 'stringId' | 'translationId' | 'fileId' | 'filePath' | 'pluralForm' | 'sourceStringTextHash' | 'mtEngine' | 'mtId' | 'tmName' | 'tmId' | 'aiPromptName' | 'aiPromptId' | 'preTranslated' | 'tmMatch' | 'mtMatch' | 'aiMatch' | 'suggestionMatch' | 'sourceUnits' | 'targetUnits' | 'createdAt' | 'updatedAt' | 'mark';\n    interface SourceContentUpdatesSchema {\n        unit?: Unit;\n        format?: Format;\n        dateFrom?: string;\n        dateTo?: string;\n        languageId?: string;\n        userIds?: number[];\n        fileIds?: number[];\n        directoryIds?: number[];\n        branchIds?: number[];\n        labelIds?: number[];\n        labelIncludeType?: LabelIncludeType;\n    }\n    interface MembersSchema {\n        format?: Format;\n        dateFrom?: string;\n        dateTo?: string;\n    }\n    interface EditorIssuesSchema {\n        dateFrom?: string;\n        dateTo?: string;\n        format?: Format;\n        languageId?: string;\n        userId?: number;\n    }\n    interface ProjectQaCheckIssuesSchema {\n        format?: Format;\n        dateFrom?: string;\n        dateTo?: string;\n        languageId?: string;\n    }\n    interface SavingActivitySchema {\n        unit?: Unit;\n        languageId?: string;\n        format?: Format;\n        dateFrom?: string;\n        dateTo?: string;\n        userIds?: number[];\n        fileIds?: number[];\n        directoryIds?: number[];\n        branchIds?: number[];\n        labelIds?: number[];\n        labelIncludeType?: LabelIncludeType;\n    }\n    interface ProjectConsumptionSchema {\n        unit?: Unit;\n        languageId?: string;\n        format?: Format;\n        dateFrom?: string;\n        dateTo?: string;\n        userIds?: number[];\n        fileIds?: number[];\n        directoryIds?: number[];\n        branchIds?: number[];\n        labelIds?: number[];\n        labelIncludeType?: LabelIncludeType;\n    }\n    interface GroupTaskUsageSchema {\n        format: Format;\n        type: 'workload' | 'create-vs-resolve' | 'performance' | 'time' | 'cost';\n        projectIds?: number[];\n        assigneeId?: number;\n        creatorId?: number;\n        dateFrom?: string;\n        dateTo?: string;\n        wordsCountFrom?: number;\n        wordsCountTo?: number;\n        excludeApprovalsForEditedTranslations?: boolean;\n        currency?: Currency;\n        baseRates?: BaseRate;\n        individualRates?: IndividualRate[];\n        netRateSchemes?: NetRateSchemas;\n    }\n    interface GroupQaCheckIssuesSchema {\n        projectIds?: number[];\n        format?: Format;\n        dateFrom?: string;\n        dateTo?: string;\n        languageId?: string;\n    }\n    interface GroupTranslationActivitySchema {\n        projectIds?: number[];\n        unit?: Unit;\n        languageId?: string;\n        format?: Format;\n        dateFrom?: string;\n        dateTo?: string;\n        userIds?: number[];\n        fileIds?: number[];\n        directoryIds?: number[];\n        branchIds?: number[];\n        labelIds?: number[];\n        labelIncludeType?: LabelIncludeType;\n    }\n}\n```\n\n##### screenshots/index.d.ts\n\n```typescript\nimport { CrowdinApi, PaginationOptions, PatchRequest, ResponseList, ResponseObject } from '../core';\nexport declare class Screenshots extends CrowdinApi {\n    listScreenshots(projectId: number, options?: ScreenshotsModel.ListScreenshotParams): Promise<ResponseList<ScreenshotsModel.Screenshot>>;\n    listScreenshots(projectId: number, limit?: number, offset?: number): Promise<ResponseList<ScreenshotsModel.Screenshot>>;\n    addScreenshot(projectId: number, request: ScreenshotsModel.CreateScreenshotRequest): Promise<ResponseObject<ScreenshotsModel.Screenshot>>;\n    getScreenshot(projectId: number, screenshotId: number): Promise<ResponseObject<ScreenshotsModel.Screenshot>>;\n    updateScreenshot(projectId: number, screenshotId: number, request: ScreenshotsModel.UpdateScreenshotRequest): Promise<ResponseObject<ScreenshotsModel.Screenshot>>;\n    deleteScreenshot(projectId: number, screenshotId: number): Promise<void>;\n    editScreenshot(projectId: number, screenshotId: number, request: PatchRequest[]): Promise<ResponseObject<ScreenshotsModel.Screenshot>>;\n    listScreenshotTags(projectId: number, screenshotId: number, options?: PaginationOptions): Promise<ResponseList<ScreenshotsModel.Tag>>;\n    listScreenshotTags(projectId: number, screenshotId: number, limit?: number, offset?: number): Promise<ResponseList<ScreenshotsModel.Tag>>;\n    replaceTags(projectId: number, screenshotId: number, request: ScreenshotsModel.ReplaceTagRequest[] | ScreenshotsModel.AutoTagRequest): Promise<void>;\n    addTag(projectId: number, screenshotId: number, request: ScreenshotsModel.ReplaceTagRequest[]): Promise<ResponseObject<ScreenshotsModel.Tag>>;\n    clearTags(projectId: number, screenshotId: number): Promise<void>;\n    getTag(projectId: number, screenshotId: number, tagId: number): Promise<ResponseObject<ScreenshotsModel.Tag>>;\n    deleteTag(projectId: number, screenshotId: number, tagId: number): Promise<void>;\n    updateTag(projectId: number, screenshotId: number, tagId: number, request: PatchRequest[]): Promise<ResponseObject<ScreenshotsModel.Screenshot>>;\n}\nexport declare namespace ScreenshotsModel {\n    interface ListScreenshotParams extends PaginationOptions {\n        stringIds?: number[];\n        stringId?: number;\n        labelIds?: string;\n        excludeLabelIds?: string;\n        orderBy?: string;\n    }\n    interface Screenshot {\n        id: number;\n        userId: number;\n        url: string;\n        webUrl: string;\n        name: string;\n        size: Size;\n        tagsCount: number;\n        tags: Tag[];\n        labels: number[];\n        labelIds: number[];\n        createdAt: string;\n        updatedAt: string;\n    }\n    interface CreateScreenshotRequest {\n        storageId: number;\n        name: string;\n        autoTag?: boolean;\n        fileId?: number;\n        branchId?: number;\n        directoryId?: number;\n        labelIds?: number[];\n    }\n    interface UpdateScreenshotRequest {\n        storageId: number;\n        name: string;\n    }\n    interface Tag {\n        id: number;\n        screenshotId: number;\n        stringId: number;\n        position: Position;\n        createdAt: string;\n    }\n    interface ReplaceTagRequest {\n        stringId: number;\n        position?: Position;\n    }\n    interface AutoTagRequest {\n        autoTag: boolean;\n        fileId?: number;\n        branchId?: number;\n        directoryId?: number;\n    }\n    interface Size {\n        width: number;\n        height: number;\n    }\n    interface Position {\n        x: number;\n        y: number;\n        width: number;\n        height: number;\n    }\n}\n```\n\n##### securityLogs/index.d.ts\n\n```typescript\nimport { CrowdinApi, PaginationOptions, ResponseList, ResponseObject } from '../core';\nexport declare class SecurityLogs extends CrowdinApi {\n    listOrganizationSecurityLogs(options?: SecurityLogsModel.ListOrganizationSecurityLogsParams): Promise<ResponseList<SecurityLogsModel.SecurityLog>>;\n    getOrganizationSecurityLog(securityLogId: number): Promise<ResponseObject<SecurityLogsModel.SecurityLog>>;\n    listUserSecurityLogs(userId: number, options?: SecurityLogsModel.ListUserSecurityLogsParams): Promise<ResponseList<SecurityLogsModel.SecurityLog>>;\n    getUserSecurityLog(userId: number, securityLogId: number): Promise<ResponseObject<SecurityLogsModel.SecurityLog>>;\n}\nexport declare namespace SecurityLogsModel {\n    type Event = 'login' | 'password.set' | 'password.change' | 'email.change' | 'login.change' | 'personal_token.issued' | 'personal_token.revoked' | 'mfa.enabled' | 'mfa.disabled' | 'session.revoke' | 'session.revoke_all' | 'sso.connect' | 'sso.disconnect' | 'user.remove' | 'application.connected' | 'application.disconnected' | 'webauthn.created' | 'webauthn.deleted' | 'trusted_device.remove' | 'trusted_device.remove_all' | 'device_verification.enabled' | 'device_verification.disabled';\n    interface ListOrganizationSecurityLogsParams extends PaginationOptions {\n        event?: Event;\n        createdAfter?: string;\n        createdBefore?: string;\n        ipAddress?: string;\n        userId?: number;\n    }\n    type ListUserSecurityLogsParams = Omit<ListOrganizationSecurityLogsParams, 'userId'>;\n    interface SecurityLog {\n        id: number;\n        event: string;\n        info: string;\n        userId: number;\n        location: string;\n        ipAddress: string;\n        deviceName: string;\n        createdAt: string;\n    }\n}\n```\n\n##### sourceFiles/index.d.ts\n\n```typescript\nimport { CrowdinApi, DownloadLink, PaginationOptions, PatchRequest, ResponseList, ResponseObject, Status } from '../core';\nexport declare class SourceFiles extends CrowdinApi {\n    getClonedBranch(projectId: number, branchId: number, cloneId: string): Promise<ResponseObject<SourceFilesModel.Branch>>;\n    clonedBranch(projectId: number, branchId: number, request: SourceFilesModel.CloneBranchRequest): Promise<ResponseObject<Status<object>>>;\n    checkBranchClonedStatus(projectId: number, branchId: number, cloneId: string): Promise<ResponseObject<Status<object>>>;\n    listProjectBranches(projectId: number, options?: SourceFilesModel.ListProjectBranchesOptions): Promise<ResponseList<SourceFilesModel.Branch>>;\n    listProjectBranches(projectId: number, name?: string, limit?: number, offset?: number): Promise<ResponseList<SourceFilesModel.Branch>>;\n    createBranch(projectId: number, request: SourceFilesModel.CreateBranchRequest): Promise<ResponseObject<SourceFilesModel.Branch>>;\n    getBranch(projectId: number, branchId: number): Promise<ResponseObject<SourceFilesModel.Branch>>;\n    deleteBranch(projectId: number, branchId: number): Promise<void>;\n    editBranch(projectId: number, branchId: number, request: PatchRequest[]): Promise<ResponseObject<SourceFilesModel.Branch>>;\n    mergeBranch(projectId: number, branchId: number, request: SourceFilesModel.MergeBranchRequest): Promise<ResponseObject<Status<SourceFilesModel.MergeBranchAttributes>>>;\n    checkBranchMergeStatus(projectId: number, branchId: number, mergeId: string): Promise<ResponseObject<Status<SourceFilesModel.MergeBranchAttributes>>>;\n    getBranchMergeSummary(projectId: number, branchId: number, mergeId: string): Promise<ResponseObject<SourceFilesModel.MergeBranchSummary>>;\n    listProjectDirectories(projectId: number, options?: SourceFilesModel.ListProjectDirectoriesOptions): Promise<ResponseList<SourceFilesModel.Directory>>;\n    listProjectDirectories(projectId: number, branchId?: number, directoryId?: number, limit?: number, offset?: number, filter?: string, recursion?: string): Promise<ResponseList<SourceFilesModel.Directory>>;\n    createDirectory(projectId: number, request: SourceFilesModel.CreateDirectoryRequest): Promise<ResponseObject<SourceFilesModel.Directory>>;\n    getDirectory(projectId: number, directoryId: number): Promise<ResponseObject<SourceFilesModel.Directory>>;\n    deleteDirectory(projectId: number, directoryId: number): Promise<void>;\n    editDirectory(projectId: number, directoryId: number, request: PatchRequest[]): Promise<ResponseObject<SourceFilesModel.Directory>>;\n    listProjectFiles(projectId: number, options?: SourceFilesModel.ListProjectFilesOptions): Promise<ResponseList<SourceFilesModel.File>>;\n    listProjectFiles(projectId: number, branchId?: number, directoryId?: number, limit?: number, offset?: number, recursion?: any, filter?: string): Promise<ResponseList<SourceFilesModel.File>>;\n    createFile(projectId: number, request: SourceFilesModel.CreateFileRequest): Promise<ResponseObject<SourceFilesModel.File>>;\n    getFile(projectId: number, fileId: number): Promise<ResponseObject<SourceFilesModel.File>>;\n    updateOrRestoreFile(projectId: number, fileId: number, request: SourceFilesModel.ReplaceFileFromStorageRequest | SourceFilesModel.RestoreFile): Promise<ResponseObject<SourceFilesModel.File>>;\n    deleteFile(projectId: number, fileId: number): Promise<void>;\n    editFile(projectId: number, fileId: number, request: PatchRequest[]): Promise<ResponseObject<SourceFilesModel.File>>;\n    downloadFilePreview(projectId: number, fileId: number): Promise<ResponseObject<DownloadLink>>;\n    downloadFile(projectId: number, fileId: number): Promise<ResponseObject<DownloadLink>>;\n    listAssetReferences(projectId: number, fileId: number, options?: PaginationOptions): Promise<ResponseList<SourceFilesModel.AssetReference>>;\n    getAssetReference(projectId: number, fileId: number, referenceId: number): Promise<ResponseObject<SourceFilesModel.AssetReference>>;\n    addAssetReference(projectId: number, fileId: number, request: SourceFilesModel.AssetReferenceRequest): Promise<ResponseObject<SourceFilesModel.AssetReference>>;\n    deleteAssetReference(projectId: number, fileId: number, referenceId: number): Promise<void>;\n    listFileRevisions(projectId: number, fileId: number, options?: PaginationOptions): Promise<ResponseList<SourceFilesModel.FileRevision>>;\n    listFileRevisions(projectId: number, fileId: number, limit?: number, offset?: number): Promise<ResponseList<SourceFilesModel.FileRevision>>;\n    getFileRevision(projectId: number, fileId: number, revisionId: number): Promise<ResponseObject<SourceFilesModel.FileRevision>>;\n    listReviewedSourceFilesBuild(projectId: number, options?: SourceFilesModel.ListReviewedSourceFilesBuildOptions): Promise<ResponseList<SourceFilesModel.ReviewedSourceFilesBuild>>;\n    listReviewedSourceFilesBuild(projectId: number, branchId?: number, limit?: number, offset?: number): Promise<ResponseList<SourceFilesModel.ReviewedSourceFilesBuild>>;\n    buildReviewedSourceFiles(projectId: number, request?: SourceFilesModel.BuildReviewedSourceFilesRequest): Promise<ResponseObject<SourceFilesModel.ReviewedSourceFilesBuild>>;\n    checkReviewedSourceFilesBuildStatus(projectId: number, buildId: number): Promise<ResponseObject<SourceFilesModel.ReviewedSourceFilesBuild>>;\n    downloadReviewedSourceFiles(projectId: number, buildId: number): Promise<ResponseObject<DownloadLink>>;\n}\nexport declare namespace SourceFilesModel {\n    interface Branch {\n        id: number;\n        projectId: number;\n        name: string;\n        title: string;\n        exportPattern: string;\n        priority: Priority;\n        createdAt: string;\n        updatedAt: string;\n    }\n    interface CreateBranchRequest {\n        name: string;\n        title?: string;\n        exportPattern?: string;\n        priority?: Priority;\n    }\n    interface CloneBranchRequest {\n        name: string;\n        title?: string;\n    }\n    interface MergeBranchRequest {\n        deleteAfterMerge?: boolean;\n        sourceBranchId: number;\n        acceptSourceChanges?: boolean;\n        dryRun?: boolean;\n    }\n    interface MergeBranchAttributes {\n        sourceBranchId: number;\n        deleteAfterMerge: boolean;\n        acceptSourceChanges?: boolean;\n    }\n    interface MergeBranchSummary {\n        status: string;\n        sourceBranchId: number;\n        targetBranchId: number;\n        dryRun: boolean;\n        details: {\n            added: number;\n            deleted: number;\n            updated: number;\n            conflicted: number;\n        };\n    }\n    type Priority = 'low' | 'normal' | 'high';\n    interface ListProjectDirectoriesOptions extends PaginationOptions {\n        branchId?: number;\n        directoryId?: number;\n        filter?: string;\n        recursion?: string;\n        orderBy?: string;\n    }\n    interface Directory {\n        id: number;\n        projectId: number;\n        branchId: number;\n        directoryId: number;\n        name: string;\n        title: string;\n        exportPattern: string;\n        path: string;\n        priority: Priority;\n        createdAt: string;\n        updatedAt: string;\n    }\n    interface CreateDirectoryRequest {\n        name: string;\n        branchId?: number;\n        directoryId?: number;\n        title?: string;\n        exportPattern?: string;\n        priority?: Priority;\n    }\n    interface ListProjectFilesOptions extends PaginationOptions {\n        branchId?: number;\n        directoryId?: number;\n        recursion?: any;\n        filter?: string;\n        orderBy?: string;\n    }\n    interface File {\n        id: number;\n        projectId: number;\n        branchId: number;\n        directoryId: number;\n        name: string;\n        title: string;\n        context: string;\n        type: string;\n        path: string;\n        status: string;\n        revisionId: number;\n        priority: Priority;\n        importOptions: ImportOptions;\n        exportOptions: GeneralExportOptions | PropertyExportOptions;\n        excludedTargetLanguages: string[];\n        parserVersion: number;\n        createdAt: string;\n        updatedAt: string;\n        fields: Record<string, any>;\n    }\n    interface CreateFileRequest {\n        storageId: number;\n        name: string;\n        branchId?: number;\n        directoryId?: number;\n        title?: string;\n        context?: string;\n        type?: FileType;\n        parserVersion?: number;\n        importOptions?: ImportOptions;\n        exportOptions?: ExportOptions;\n        excludedTargetLanguages?: string[];\n        attachLabelIds?: number[];\n        fields?: Record<string, any>;\n    }\n    interface ReplaceFileFromStorageRequest {\n        storageId: number;\n        name?: string;\n        updateOption?: UpdateOption;\n        importOptions?: ImportOptions;\n        exportOptions?: ExportOptions;\n        attachLabelIds?: number[];\n        detachLabelIds?: number[];\n        replaceModifiedContext?: boolean;\n    }\n    type ExportOptions = GeneralExportOptions | PropertyExportOptions | JavaScriptExportOptions | MdExportOptions;\n    type ImportOptions = SpreadsheetImportOptions | XmlImportOptions | WebXmlImportOptions | DocxFileImportOptions | HtmlFileImportOptions | HtmlFrontMatterFileImportOptions | MdxFileImportOptions | MdFileImportOptions | StringCatalogFileImportOptions | AdocFileImportOptions | OtherImportOptions;\n    interface RestoreFile {\n        revisionId: number;\n    }\n    interface FileRevision {\n        id: number;\n        projectId: number;\n        fileId: number;\n        restoreToRevision: number;\n        info: FileRevisionInfo;\n        date: string;\n    }\n    interface FileRevisionInfo {\n        added: FileRevisionInfoAttribute;\n        deleted: FileRevisionInfoAttribute;\n        updated: FileRevisionInfoAttribute;\n    }\n    interface FileRevisionInfoAttribute {\n        strings: number;\n        words: number;\n    }\n    type FileType = 'auto' | 'android' | 'macosx' | 'resx' | 'properties' | 'gettext' | 'yaml' | 'php' | 'json' | 'xml' | 'ini' | 'rc' | 'resw' | 'resjson' | 'qtts' | 'joomla' | 'chrome' | 'dtd' | 'dklang' | 'flex' | 'nsh' | 'wxl' | 'xliff' | 'xliff_two' | 'html' | 'haml' | 'txt' | 'csv' | 'md' | 'flsnp' | 'fm_html' | 'fm_md' | 'mediawiki' | 'docx' | 'xlsx' | 'sbv' | 'properties_play' | 'properties_xml' | 'maxthon' | 'go_json' | 'dita' | 'mif' | 'idml' | 'stringsdict' | 'plist' | 'vtt' | 'vdf' | 'srt' | 'stf' | 'toml' | 'contentful_rt' | 'svg' | 'js' | 'coffee' | 'nestjs_i18n' | 'webxml';\n    interface SpreadsheetImportOptions {\n        firstLineContainsHeader?: boolean;\n        contentSegmentation?: boolean;\n        srxStorageId?: number;\n        importTranslations?: boolean;\n        scheme?: Scheme;\n    }\n    interface Scheme {\n        none: number;\n        identifier: number;\n        sourcePhrase: number;\n        sourceOrTranslation: number;\n        translation: number;\n        context: number;\n        maxLength: number;\n        labels: number;\n        [key: string]: number;\n    }\n    interface XmlImportOptions {\n        translateContent?: boolean;\n        translateAttributes?: boolean;\n        inlineTags?: string[];\n        contentSegmentation?: boolean;\n        translatableElements?: string[];\n        srxStorageId?: number;\n    }\n    interface WebXmlImportOptions {\n        inlineTags?: string[];\n        contentSegmentation?: boolean;\n        srxStorageId?: number;\n    }\n    interface DocxFileImportOptions {\n        cleanTagsAggressively?: boolean;\n        translateHiddenText?: boolean;\n        translateHyperlinkUrls?: boolean;\n        translateHiddenRowsAndColumns?: boolean;\n        importNotes?: boolean;\n        importHiddenSlides?: boolean;\n        contentSegmentation?: boolean;\n        srxStorageId?: number;\n    }\n    interface HtmlFileImportOptions {\n        excludedElements?: string[];\n        inlineTags?: string[];\n        contentSegmentation?: boolean;\n        srxStorageId?: number;\n    }\n    interface HtmlFrontMatterFileImportOptions extends HtmlFileImportOptions {\n        excludedFrontMatterElements?: string[];\n    }\n    interface MdxFileImportOptions {\n        excludedFrontMatterElements?: string[];\n        excludeCodeBlocks?: boolean;\n        contentSegmentation?: boolean;\n        srxStorageId?: number;\n    }\n    interface MdFileImportOptions {\n        excludedFrontMatterElements?: string[];\n        excludeCodeBlocks?: boolean;\n        inlineTags?: string[];\n        contentSegmentation?: boolean;\n        srxStorageId?: number;\n    }\n    interface StringCatalogFileImportOptions {\n        importKeyAsSource?: boolean;\n    }\n    interface AdocFileImportOptions {\n        excludeIncludeDirectives?: boolean;\n    }\n    interface OtherImportOptions {\n        contentSegmentation: boolean;\n        srxStorageId: number;\n    }\n    interface GeneralExportOptions {\n        exportPattern?: string;\n    }\n    interface PropertyExportOptions {\n        escapeQuotes?: EscapeQuotes;\n        exportPattern?: string;\n        escapeSpecialCharacters?: 0 | 1;\n    }\n    interface JavaScriptExportOptions {\n        exportPattern?: string;\n        exportQuotes?: ExportQuotes;\n    }\n    interface MdExportOptions {\n        exportPattern?: string;\n        strongMarker?: 'asterisk' | 'underscore';\n        emphasisMarker?: 'asterisk' | 'underscore';\n        unorderedListBullet?: 'asterisks' | 'plus' | 'plus';\n        tableColumnWidth?: 'consolidate' | 'evenly_distribute_cells';\n    }\n    enum EscapeQuotes {\n        ZERO = 0,\n        ONE = 1,\n        TWO = 2,\n        THREE = 3\n    }\n    enum ExportQuotes {\n        SINGLE = \"single\",\n        DOUBLE = \"double\"\n    }\n    type UpdateOption = 'clear_translations_and_approvals' | 'keep_translations' | 'keep_translations_and_approvals';\n    interface ReviewedSourceFilesBuild {\n        id: number;\n        projectId: number;\n        status: string;\n        progress: number;\n        attributes: ReviewedSourceFilesBuildAttributes;\n    }\n    interface ReviewedSourceFilesBuildAttributes {\n        branchId: number;\n        targetLanguageId: string;\n    }\n    interface BuildReviewedSourceFilesRequest {\n        branchId?: number;\n    }\n    interface ListProjectBranchesOptions extends PaginationOptions {\n        name?: string;\n        orderBy?: string;\n    }\n    interface ListReviewedSourceFilesBuildOptions extends PaginationOptions {\n        branchId?: number;\n    }\n    interface User {\n        id: number;\n        username: string;\n        fullName: string;\n        avatarUrl: string;\n    }\n    interface AssetReference {\n        id: number;\n        name: string;\n        user: User;\n        createdAt: string;\n        mimeType: string;\n    }\n    interface AssetReferenceRequest {\n        storageId: number;\n        name: string;\n    }\n}\n```\n\n##### sourceStrings/index.d.ts\n\n```typescript\nimport { BooleanInt, CrowdinApi, PaginationOptions, PatchRequest, ResponseList, ResponseObject, Status } from '../core';\nimport { SourceFilesModel } from '../sourceFiles';\nexport declare class SourceStrings extends CrowdinApi {\n    uploadStringsStatus(projectId: number, uploadId: string): Promise<ResponseObject<Status<SourceStringsModel.UploadStringsStatus>>>;\n    uploadStrings(projectId: number, request: SourceStringsModel.UploadStringsRequest): Promise<ResponseObject<Status<SourceStringsModel.UploadStringsStatus>>>;\n    listProjectStrings(projectId: number, options?: SourceStringsModel.ListProjectStringsOptions): Promise<ResponseList<SourceStringsModel.String>>;\n    listProjectStrings(projectId: number, fileId?: number, limit?: number, offset?: number, filter?: string, denormalizePlaceholders?: BooleanInt, labelIds?: string, scope?: SourceStringsModel.Scope, croql?: string, branchId?: number, directoryId?: number): Promise<ResponseList<SourceStringsModel.String>>;\n    addString(projectId: number, request: SourceStringsModel.CreateStringRequest | SourceStringsModel.CreateStringStringsBasedRequest): Promise<ResponseObject<SourceStringsModel.String>>;\n    stringBatchOperations(projectId: number, request: PatchRequest[]): Promise<ResponseList<SourceStringsModel.String>>;\n    getString(projectId: number, stringId: number, query?: {\n        denormalizePlaceholders: BooleanInt;\n    }): Promise<ResponseObject<SourceStringsModel.String>>;\n    deleteString(projectId: number, stringId: number): Promise<void>;\n    editString(projectId: number, stringId: number, request: PatchRequest[]): Promise<ResponseObject<SourceStringsModel.String>>;\n}\nexport declare namespace SourceStringsModel {\n    type UploadStringsType = 'auto' | 'android' | 'macosx' | 'arb' | 'csv' | 'json' | 'xliff' | 'xliff_two' | 'xlsx';\n    interface UploadStringsStatus {\n        branchId: number;\n        storageId: number;\n        fileType: UploadStringsType;\n        parserVersion: number;\n        labelIds: number[];\n        importOptions: {\n            firstLineContainsHeader: boolean;\n            importTranslations: boolean;\n            scheme: SourceFilesModel.Scheme;\n        };\n        updateStrings: boolean;\n        cleanupMode: boolean;\n        updateOption: UpdateOption;\n    }\n    interface UploadStringsRequest {\n        branchId: number;\n        storageId: number;\n        type?: UploadStringsType;\n        parserVersion?: number;\n        labelIds?: number[];\n        updateStrings?: boolean;\n        cleanupMode?: boolean;\n        importOptions?: {\n            firstLineContainsHeader: boolean;\n            importTranslations: boolean;\n            scheme: SourceFilesModel.Scheme;\n        };\n        updateOption?: UpdateOption;\n    }\n    interface ListProjectStringsOptions extends PaginationOptions {\n        orderBy?: string;\n        denormalizePlaceholders?: BooleanInt;\n        labelIds?: string;\n        fileId?: number;\n        branchId?: number;\n        directoryId?: number;\n        taskId?: number;\n        croql?: string;\n        filter?: string;\n        scope?: SourceStringsModel.Scope;\n    }\n    interface String {\n        id: number;\n        projectId: number;\n        branchId: number;\n        identifier: string;\n        text: string | PluralText;\n        type: Type;\n        context: string;\n        maxLength: number;\n        isHidden: boolean;\n        isDuplicate: boolean;\n        masterStringId: boolean;\n        hasPlurals: boolean;\n        isIcu: boolean;\n        labelIds: number[];\n        webUrl: string;\n        createdAt: string;\n        updatedAt: string;\n        fileId: number;\n        directoryId: number;\n        revision: number;\n        fields: Record<string, any>;\n    }\n    interface CreateStringRequest {\n        text: string | PluralText;\n        identifier?: string;\n        fileId: number;\n        context?: string;\n        isHidden?: boolean;\n        maxLength?: number;\n        labelIds?: number[];\n        fields?: Record<string, any>;\n    }\n    interface CreateStringStringsBasedRequest {\n        text: string | PluralText;\n        identifier: string;\n        branchId: number;\n        context?: string;\n        isHidden?: boolean;\n        maxLength?: number;\n        labelIds?: number[];\n        fields?: Record<string, any>;\n    }\n    interface PluralText {\n        zero?: string;\n        one?: string;\n        two?: string;\n        few?: string;\n        many?: string;\n        other?: string;\n    }\n    enum Type {\n        TEXT = 0,\n        ASSET = 1,\n        ICU = 2\n    }\n    type Scope = 'identifier' | 'text' | 'context';\n    type UpdateOption = 'clear_translations_and_approvals' | 'keep_translations' | 'keep_translations_and_approvals';\n}\n```\n\n##### stringComments/index.d.ts\n\n```typescript\nimport { CrowdinApi, PaginationOptions, PatchRequest, ResponseList, ResponseObject } from '../core';\nexport declare class StringComments extends CrowdinApi {\n    listStringComments(projectId: number, options?: StringCommentsModel.ListStringCommentsOptions): Promise<ResponseList<StringCommentsModel.StringComment>>;\n    listStringComments(projectId: number, stringId?: number, type?: StringCommentsModel.Type, targetLanguageId?: string, issueType?: StringCommentsModel.IssueType, issueStatus?: StringCommentsModel.IssueStatus): Promise<ResponseList<StringCommentsModel.StringComment>>;\n    addStringComment(projectId: number, request: StringCommentsModel.AddStringCommentRequest): Promise<ResponseObject<StringCommentsModel.StringComment>>;\n    getStringComment(projectId: number, stringCommentId: number): Promise<ResponseObject<StringCommentsModel.StringComment>>;\n    deleteStringComment(projectId: number, stringCommentId: number): Promise<void>;\n    editStringComment(projectId: number, stringCommentId: number, request: PatchRequest[]): Promise<ResponseObject<StringCommentsModel.StringComment>>;\n    stringCommentBatchOperations(projectId: number, request: PatchRequest[]): Promise<ResponseList<StringCommentsModel.StringComment>>;\n}\nexport declare namespace StringCommentsModel {\n    interface ListStringCommentsOptions extends PaginationOptions {\n        stringId?: number;\n        type?: Type;\n        targetLanguageId?: string;\n        issueType?: IssueType;\n        issueStatus?: IssueStatus;\n        orderBy?: string;\n    }\n    interface StringComment {\n        id: number;\n        isShared?: boolean;\n        text: string;\n        userId: number;\n        stringId: number;\n        user: User;\n        string: StringModel;\n        projectId: number;\n        languageId: string;\n        type: Type;\n        issueType: IssueType;\n        issueStatus: IssueStatus;\n        resolverId: number;\n        senderOrganization: {\n            id: number;\n            domain: string;\n        };\n        resolverOrganization: {\n            id: number;\n            domain: string;\n        };\n        resolver: User;\n        resolvedAt: string;\n        createdAt: string;\n    }\n    interface User {\n        id: number;\n        username: string;\n        fullName: string;\n        avatarUrl: string;\n    }\n    interface StringModel {\n        id: number;\n        text: string;\n        type: string;\n        hasPlurals: boolean;\n        isIcu: boolean;\n        context: string;\n        fileId: number;\n    }\n    interface AddStringCommentRequest {\n        stringId: number;\n        text: string;\n        targetLanguageId: string;\n        type: Type;\n        isShared?: boolean;\n        issueType?: IssueType;\n    }\n    type Type = 'comment' | 'issue';\n    type IssueType = 'general_question' | 'translation_mistake' | 'context_request' | 'source_mistake';\n    type IssueStatus = 'unresolved' | 'resolved';\n}\n```\n\n##### stringCorrections/index.d.ts\n\n```typescript\nimport { BooleanInt, CrowdinApi, PaginationOptions, ResponseList, ResponseObject } from '../core';\nexport declare class StringCorrections extends CrowdinApi {\n    listStringCorrections(projectId: number, options: StringCorrectionsModel.ListStringCorrectionsParams): Promise<ResponseList<StringCorrectionsModel.StringCorrection>>;\n    addStringCorrection(projectId: number, request: StringCorrectionsModel.AddStringCorrectionRequest): Promise<ResponseObject<StringCorrectionsModel.StringCorrection>>;\n    deleteStringCorrections(projectId: number, stringId: number): Promise<void>;\n    getStringCorrection(projectId: number, correctionId: number, params?: {\n        denormalizePlaceholders?: BooleanInt;\n    }): Promise<ResponseObject<StringCorrectionsModel.StringCorrection>>;\n    restoreStringCorrection(projectId: number, correctionId: number): Promise<ResponseObject<StringCorrectionsModel.StringCorrection>>;\n    deleteStringCorrection(projectId: number, correctionId: number): Promise<void>;\n}\nexport declare namespace StringCorrectionsModel {\n    interface ListStringCorrectionsParams extends PaginationOptions {\n        stringId: number;\n        orderBy?: string;\n        denormalizePlaceholders?: BooleanInt;\n    }\n    interface StringCorrection {\n        id: number;\n        text: string;\n        pluralCategoryName: PluralCategoryName;\n        user: {\n            id: number;\n            username: string;\n            fullName: string;\n            avatarUrl: string;\n        };\n        createdAt: string;\n    }\n    type PluralCategoryName = 'zero' | 'one' | 'two' | 'few' | 'many' | 'other';\n    interface AddStringCorrectionRequest {\n        stringId: number;\n        text: string;\n        pluralCategoryName?: PluralCategoryName;\n    }\n}\n```\n\n##### stringTranslations/index.d.ts\n\n```typescript\nimport { BooleanInt, CrowdinApi, PaginationOptions, PatchRequest, ResponseList, ResponseObject } from '../core';\nexport declare class StringTranslations extends CrowdinApi {\n    listTranslationApprovals(projectId: number, options?: StringTranslationsModel.ListTranslationApprovalsOptions): Promise<ResponseList<StringTranslationsModel.Approval>>;\n    listTranslationApprovals(projectId: number, stringId?: number, languageId?: string, translationId?: number, limit?: number, offset?: number, fileId?: number, labelIds?: string, excludeLabelIds?: string): Promise<ResponseList<StringTranslationsModel.Approval>>;\n    addApproval(projectId: number, request: StringTranslationsModel.AddApprovalRequest): Promise<ResponseObject<StringTranslationsModel.Approval>>;\n    removeStringApprovals(projectId: number, stringId: number): Promise<void>;\n    approvalInfo(projectId: number, approvalId: number): Promise<ResponseObject<StringTranslationsModel.Approval>>;\n    approvalBatchOperations(projectId: number, request: PatchRequest[]): Promise<ResponseList<StringTranslationsModel.Approval>>;\n    removeApproval(projectId: number, approvalId: number): Promise<void>;\n    listLanguageTranslations(projectId: number, languageId: string, options?: StringTranslationsModel.ListLanguageTranslationsOptions): Promise<ResponseList<StringTranslationsModel.PlainLanguageTranslation | StringTranslationsModel.PluralLanguageTranslation | StringTranslationsModel.IcuLanguageTranslation>>;\n    listLanguageTranslations(projectId: number, languageId: string, stringIds?: string, fileId?: number, limit?: number, offset?: number, labelIds?: string, denormalizePlaceholders?: BooleanInt, croql?: string): Promise<ResponseList<StringTranslationsModel.PlainLanguageTranslation | StringTranslationsModel.PluralLanguageTranslation | StringTranslationsModel.IcuLanguageTranslation>>;\n    translationAlignment(projectId: number, request: StringTranslationsModel.TranslationAlignmentRequest): Promise<ResponseObject<StringTranslationsModel.TranslationAlignmentResponse>>;\n    listStringTranslations(projectId: number, stringId: number, languageId: string, options?: StringTranslationsModel.ListStringTranslationsOptions): Promise<ResponseList<StringTranslationsModel.StringTranslation>>;\n    listStringTranslations(projectId: number, stringId: number, languageId: string, limit?: number, offset?: number, denormalizePlaceholders?: BooleanInt): Promise<ResponseList<StringTranslationsModel.StringTranslation>>;\n    addTranslation(projectId: number, request: StringTranslationsModel.AddStringTranslationRequest): Promise<ResponseObject<StringTranslationsModel.StringTranslation>>;\n    deleteAllTranslations(projectId: number, stringId: number, languageId?: string): Promise<void>;\n    translationInfo(projectId: number, translationId: number): Promise<ResponseObject<StringTranslationsModel.StringTranslation>>;\n    restoreTranslation(projectId: number, translationId: number): Promise<ResponseObject<StringTranslationsModel.StringTranslation>>;\n    translationBatchOperations(projectId: number, request: PatchRequest[]): Promise<ResponseList<StringTranslationsModel.StringTranslation>>;\n    deleteTranslation(projectId: number, translationId: number): Promise<void>;\n    listTranslationVotes(projectId: number, options?: StringTranslationsModel.ListTranslationVotesOptions): Promise<ResponseList<StringTranslationsModel.Vote>>;\n    listTranslationVotes(projectId: number, stringId?: number, languageId?: string, translationId?: number, labelIds?: string, excludeLabelIds?: string, limit?: number, offset?: number): Promise<ResponseList<StringTranslationsModel.Vote>>;\n    addVote(projectId: number, request: StringTranslationsModel.AddVoteRequest): Promise<ResponseObject<StringTranslationsModel.Vote>>;\n    voteInfo(projectId: number, voteId: number): Promise<ResponseObject<StringTranslationsModel.Vote>>;\n    cancelVote(projectId: number, voteId: number): Promise<void>;\n}\nexport declare namespace StringTranslationsModel {\n    interface ListTranslationApprovalsOptions extends PaginationOptions {\n        stringId?: number;\n        languageId?: string;\n        translationId?: number;\n        fileId?: number;\n        labelIds?: string;\n        excludeLabelIds?: string;\n        orderBy?: string;\n    }\n    interface Approval {\n        id: number;\n        user: User;\n        translationId: number;\n        stringId: number;\n        languageId: string;\n        createdAt: string;\n    }\n    interface AddApprovalRequest {\n        translationId: number;\n    }\n    interface StringTranslation {\n        id: number;\n        text: string;\n        pluralCategoryName: PluralCategoryName;\n        user: User;\n        rating: number;\n        provider: string;\n        isPreTranslated: boolean;\n        createdAt: string;\n    }\n    interface ListLanguageTranslationsOptions extends PaginationOptions {\n        stringIds?: string;\n        fileId?: number;\n        labelIds?: string;\n        denormalizePlaceholders?: BooleanInt;\n        croql?: string;\n        approvedOnly?: BooleanInt;\n        passedWorkflow?: BooleanInt;\n        orderBy?: string;\n        branchId?: number;\n        minApprovalCount?: number;\n        directoryId?: number;\n    }\n    interface PlainLanguageTranslation {\n        stringId: number;\n        contentType: string;\n        translationId: number;\n        text: string;\n        user: User;\n        createdAt: string;\n    }\n    interface PluralLanguageTranslation {\n        stringId: number;\n        contentType: string;\n        plurals: Plural[];\n    }\n    interface IcuLanguageTranslation {\n        stringId: number;\n        contentType: string;\n        translationId: number;\n        text: string;\n        user: User;\n        createdAt: string;\n    }\n    interface Plural {\n        translationId: number;\n        text: string;\n        pluralForm: string;\n        user: User;\n        createdAt: string;\n    }\n    interface TranslationAlignmentRequest {\n        sourceLanguageId: string;\n        targetLanguageId: string;\n        text: string;\n    }\n    interface TranslationAlignmentResponse {\n        words: {\n            text: string;\n            alignments: {\n                sourceWord: string;\n                sourceLemma: string;\n                targetWord: string;\n                targetLemma: string;\n                match: number;\n                probability: number;\n            }[];\n        }[];\n    }\n    interface AddStringTranslationRequest {\n        stringId: number;\n        languageId: string;\n        text: string;\n        pluralCategoryName?: PluralCategoryName;\n        addToTm?: boolean;\n    }\n    interface ListTranslationVotesOptions extends PaginationOptions {\n        stringId?: number;\n        languageId?: string;\n        translationId?: number;\n        fileId?: number;\n        labelIds?: string;\n        excludeLabelIds?: string;\n    }\n    interface Vote {\n        id: number;\n        user: User;\n        translationId: number;\n        votedAt: string;\n        mark: Mark;\n    }\n    interface AddVoteRequest {\n        mark: Mark;\n        translationId: number;\n    }\n    interface User {\n        id: number;\n        username: string;\n        fullName: string;\n        avatarUrl: string;\n    }\n    type Mark = 'up' | 'down';\n    interface ListStringTranslationsOptions extends PaginationOptions {\n        denormalizePlaceholders?: BooleanInt;\n        orderBy?: string;\n    }\n    type PluralCategoryName = 'zero' | 'one' | 'two' | 'few' | 'many' | 'other';\n}\n```\n\n##### tasks/index.d.ts\n\n```typescript\nimport { BooleanInt, CrowdinApi, DownloadLink, PaginationOptions, PatchRequest, ResponseList, ResponseObject } from '../core';\nimport { LanguagesModel } from '../languages';\nexport declare class Tasks extends CrowdinApi {\n    listTasks(projectId: number, options?: TasksModel.ListTasksOptions): Promise<ResponseList<TasksModel.Task>>;\n    listTasks(projectId: number, limit?: number, offset?: number, status?: TasksModel.Status): Promise<ResponseList<TasksModel.Task>>;\n    addTask(projectId: number, request: TasksModel.CreateTaskRequest): Promise<ResponseObject<TasksModel.Task>>;\n    exportTaskStrings(projectId: number, taskId: number): Promise<ResponseObject<DownloadLink>>;\n    getTask(projectId: number, taskId: number): Promise<ResponseObject<TasksModel.Task>>;\n    deleteTask(projectId: number, taskId: number): Promise<void>;\n    editTask(projectId: number, taskId: number, request: PatchRequest[]): Promise<ResponseObject<TasksModel.Task>>;\n    listTasksComments(projectId: number, taskId: number, options?: PaginationOptions): Promise<ResponseList<TasksModel.TaskComment>>;\n    addTaskComment(projectId: number, taskId: number, request: TasksModel.CreateTaskCommentRequest): Promise<ResponseObject<TasksModel.TaskComment>>;\n    getTaskComment(projectId: number, taskId: number, commentId: number): Promise<ResponseObject<TasksModel.TaskComment>>;\n    deleteTaskComment(projectId: number, taskId: number, commentId: number): Promise<void>;\n    editTaskComment(projectId: number, taskId: number, commentId: number, request: PatchRequest[]): Promise<ResponseObject<TasksModel.TaskComment>>;\n    listUserTasks(options?: TasksModel.ListUserTasksOptions): Promise<ResponseList<TasksModel.UserTask>>;\n    listUserTasks(limit?: number, offset?: number, status?: TasksModel.Status, isArchived?: BooleanInt): Promise<ResponseList<TasksModel.UserTask>>;\n    editTaskArchivedStatus(projectId: number, taskId: number, request: PatchRequest[]): Promise<ResponseObject<TasksModel.UserTask>>;\n    listTaskSettingsTemplates(projectId: number, options?: PaginationOptions): Promise<ResponseList<TasksModel.TaskSettingsTemplate>>;\n    addTaskSettingsTemplate(projectId: number, request: TasksModel.AddTaskSettingsTemplate): Promise<ResponseObject<TasksModel.TaskSettingsTemplate>>;\n    getTaskSettingsTemplate(projectId: number, taskSettingsId: number): Promise<ResponseObject<TasksModel.TaskSettingsTemplate>>;\n    deleteTaskSettingsTemplate(projectId: number, taskSettingsId: number): Promise<void>;\n    editTaskSettingsTemplate(projectId: number, taskSettingsId: number, request: PatchRequest[]): Promise<ResponseObject<TasksModel.TaskSettingsTemplate>>;\n}\nexport declare namespace TasksModel {\n    interface Task {\n        id: number;\n        projectId: number;\n        creatorId: number;\n        type: Type | TypeVendor;\n        status: Status;\n        title: string;\n        assignees: Assignee[];\n        assignedTeams: AssignedTeam[];\n        progress: Progress;\n        translateProgress: Progress;\n        sourceLanguageId: string;\n        targetLanguageId: string;\n        description: string;\n        translationUrl: string;\n        webUrl: string;\n        wordsCount: number;\n        commentsCount: number;\n        deadline: string;\n        startedAt: string;\n        resolvedAt: string;\n        timeRange: string;\n        workflowStepId: number;\n        buyUrl: string;\n        createdAt: string;\n        updatedAt: string;\n        sourceLanguage: LanguagesModel.Language;\n        targetLanguages: LanguagesModel.Language[];\n        labelIds: number[];\n        excludeLabelIds: number[];\n        precedingTaskId: number;\n        filesCount: number;\n        fileIds: number[];\n        branchIds: number[];\n        vendor: string;\n        fields: Record<string, any>;\n    }\n    interface ListUserTasksOptions extends PaginationOptions {\n        status?: Status;\n        isArchived?: BooleanInt;\n        orderBy?: string;\n    }\n    interface UserTask extends Task {\n        isArchived: boolean;\n    }\n    type CreateTaskRequest = CreateTaskEnterpriseByBranchIds | CreateTaskEnterpriseByFileIds | CreateTaskEnterpriseByStringIds | CreateTaskEnterpriseVendorByBranchIds | CreateTaskEnterpriseVendorByFileIds | CreateTaskEnterpriseVendorByStringIds | CreateTaskEnterprisePendingTask | CreateTaskByFileIds | CreateTaskByStringIds | CreateTaskByBranchIds | CreateTaskByFileIdsLanguageService | CreateTaskByStringIdsLanguageService | CreateTaskByBranchIdsLanguageService | CreateTaskVendorOhtByFileIds | CreateTaskVendorOhtByStringIds | CreateTaskVendorOhtByBranchIds | CreateTaskVendorGengoByFileIds | CreateTaskVendorGengoByStringIds | CreateTaskVendorGengoByBranchIds | CreateTaskVendorManualByFileIds | CreateTaskVendorManualByStringIds | CreateTaskVendorManualByBranchIds | CreateTaskPendingTask | CreateTaskPendingTaskLanguageService | CreateTaskPendingTaskVendorManual;\n    interface CreateTaskEnterpriseByBranchIds {\n        type: Type;\n        workflowStepId: number;\n        title: string;\n        languageId: string;\n        branchIds: number[];\n        labelIds?: number[];\n        excludeLabelIds?: number[];\n        status?: RequestStatus;\n        description?: string;\n        splitContent?: boolean;\n        skipAssignedStrings?: boolean;\n        assignees?: CreateTaskAssignee[];\n        assignedTeams?: AssignedTeam[];\n        includePreTranslatedStringsOnly?: boolean;\n        deadline?: string;\n        startedAt?: string;\n        dateFrom?: string;\n        dateTo?: string;\n        fields?: Record<string, any>;\n    }\n    interface CreateTaskEnterpriseByStringIds {\n        type: Type;\n        workflowStepId: number;\n        title: string;\n        languageId: string;\n        stringIds: number[];\n        status?: RequestStatus;\n        description?: string;\n        splitContent?: boolean;\n        skipAssignedStrings?: boolean;\n        assignees?: CreateTaskAssignee[];\n        assignedTeams?: AssignedTeam[];\n        includePreTranslatedStringsOnly?: boolean;\n        deadline?: string;\n        startedAt?: string;\n        dateFrom?: string;\n        dateTo?: string;\n        fields?: Record<string, any>;\n    }\n    type CreateTaskEnterpriseVendorByStringIds = Omit<CreateTaskEnterpriseByStringIds, 'type' | 'status' | 'splitContent' | 'assignees' | 'assignedTeams'>;\n    type CreateTaskEnterpriseVendorByBranchIds = Omit<CreateTaskEnterpriseByBranchIds, 'type' | 'status' | 'splitContent' | 'assignees' | 'assignedTeams'>;\n    type CreateTaskEnterpriseByFileIds = Omit<CreateTaskEnterpriseByBranchIds, 'branchIds'> & {\n        fileIds: number[];\n    };\n    type CreateTaskEnterpriseVendorByFileIds = Omit<CreateTaskEnterpriseByFileIds, 'type' | 'status' | 'splitContent' | 'assignees' | 'assignedTeams'>;\n    interface CreateTaskEnterprisePendingTask {\n        precedingTaskId: number;\n        type: Type.PROOFREAD;\n        title: string;\n        description?: string;\n        assignees?: CreateTaskAssignee[];\n        assignedTeams?: AssignedTeam[];\n        deadline?: string;\n    }\n    interface CreateTaskByFileIds {\n        title: string;\n        languageId: string;\n        type: Type;\n        fileIds: number[];\n        labelIds?: number[];\n        excludeLabelIds?: number[];\n        status?: RequestStatus;\n        description?: string;\n        splitContent?: boolean;\n        skipAssignedStrings?: boolean;\n        includePreTranslatedStringsOnly?: boolean;\n        assignees?: CreateTaskAssignee[];\n        deadline?: string;\n        startedAt?: string;\n        dateFrom?: string;\n        dateTo?: string;\n    }\n    type CreateTaskByStringIds = Omit<CreateTaskByFileIds, 'fileIds' | 'labelIds' | 'excludeLabelIds'> & {\n        stringIds: number;\n    };\n    type CreateTaskByBranchIds = Omit<CreateTaskByFileIds, 'fileIds'> & {\n        branchIds: number;\n    };\n    interface CreateTaskByFileIdsLanguageService {\n        title: string;\n        languageId: string;\n        type: TypeVendor;\n        vendor: 'crowdin_language_service';\n        fileIds: number[];\n        labelIds?: number[];\n        excludeLabelIds?: number[];\n        status?: RequestStatus;\n        description?: string;\n        includePreTranslatedStringsOnly?: boolean;\n        assignees?: CreateTaskAssignee[];\n        dateFrom?: string;\n        dateTo?: string;\n    }\n    type CreateTaskByStringIdsLanguageService = Omit<CreateTaskByFileIdsLanguageService, 'fileIds' | 'labelIds' | 'excludeLabelIds'> & {\n        stringIds: number[];\n    };\n    type CreateTaskByBranchIdsLanguageService = Omit<CreateTaskByFileIdsLanguageService, 'fileIds'> & {\n        branchIds: number[];\n    };\n    interface CreateTaskVendorOhtByFileIds {\n        title: string;\n        languageId: string;\n        type: TypeVendor;\n        vendor: 'oht';\n        fileIds: number[];\n        labelIds?: number[];\n        excludeLabelIds?: number[];\n        status?: RequestStatus;\n        description?: string;\n        expertise?: Expertise;\n        editService?: boolean;\n        includePreTranslatedStringsOnly?: boolean;\n        dateFrom?: string;\n        dateTo?: string;\n    }\n    type CreateTaskVendorOhtByStringIds = Omit<CreateTaskVendorOhtByFileIds, 'fileIds' | 'labelIds' | 'excludeLabelIds'> & {\n        stringIds: number[];\n    };\n    type CreateTaskVendorOhtByBranchIds = Omit<CreateTaskVendorOhtByFileIds, 'fileIds'> & {\n        branchIds: number[];\n    };\n    interface CreateTaskVendorGengoByFileIds {\n        title: string;\n        languageId: string;\n        type: TypeVendor.TRANSLATE_BY_VENDOR;\n        vendor: 'gengo';\n        fileIds: number[];\n        labelIds?: number[];\n        excludeLabelIds?: number[];\n        status?: RequestStatus;\n        description?: string;\n        expertise?: 'standard' | 'pro';\n        tone?: Tone;\n        purpose?: Purpose;\n        customerMessage?: string;\n        usePreferred?: boolean;\n        editService?: boolean;\n        dateFrom?: string;\n        dateTo?: string;\n    }\n    type CreateTaskVendorGengoByStringIds = Omit<CreateTaskVendorGengoByFileIds, 'fileIds' | 'labelIds' | 'excludeLabelIds'> & {\n        stringIds: number[];\n    };\n    type CreateTaskVendorGengoByBranchIds = Omit<CreateTaskVendorGengoByFileIds, 'fileIds'> & {\n        branchIds: number[];\n    };\n    interface CreateTaskVendorManualByFileIds {\n        title: string;\n        languageId: string;\n        type: TypeVendor;\n        vendor: 'alconost' | 'babbleon' | 'tomedes' | 'e2f' | 'write_path_admin' | 'inlingo' | 'acclaro' | 'translate_by_humans' | 'lingo24' | 'assertio_language_services' | 'gte_localize' | 'kettu_solutions' | 'languageline_solutions';\n        fileIds: number[];\n        labelIds?: number[];\n        excludeLabelIds?: number[];\n        status?: RequestStatus;\n        description?: string;\n        skipAssignedStrings?: boolean;\n        includePreTranslatedStringsOnly?: boolean;\n        assignees?: CreateTaskAssignee[];\n        deadline?: string;\n        startedAt?: string;\n        dateFrom?: string;\n        dateTo?: string;\n    }\n    type CreateTaskVendorManualByStringIds = Omit<CreateTaskVendorManualByFileIds, 'fileIds' | 'labelIds' | 'excludeLabelIds'> & {\n        stringIds: number[];\n    };\n    type CreateTaskVendorManualByBranchIds = Omit<CreateTaskVendorManualByFileIds, 'fileIds'> & {\n        branchIds: number[];\n    };\n    interface CreateTaskPendingTask {\n        precedingTaskId: number;\n        type: Type.PROOFREAD;\n        title: string;\n        description?: string;\n        assignees?: CreateTaskAssignee[];\n        deadline?: string;\n    }\n    interface CreateTaskPendingTaskLanguageService {\n        precedingTaskId: number;\n        type: TypeVendor.PROOFREAD_BY_VENDOR;\n        vendor: 'crowdin_language_service';\n        title: string;\n        description?: string;\n        deadline?: string;\n    }\n    interface CreateTaskPendingTaskVendorManual {\n        precedingTaskId: number;\n        type: TypeVendor.PROOFREAD_BY_VENDOR;\n        vendor: CreateTaskVendorManualByFileIds['vendor'];\n        title: string;\n        description?: string;\n        deadline?: string;\n    }\n    interface CreateTaskAssignee {\n        id: number;\n        wordsCount?: number;\n    }\n    type Status = 'todo' | 'in_progress' | 'done' | 'closed';\n    type RequestStatus = Extract<Status, 'todo' | 'in_progress'>;\n    enum Type {\n        TRANSLATE = 0,\n        PROOFREAD = 1\n    }\n    enum TypeVendor {\n        TRANSLATE_BY_VENDOR = 2,\n        PROOFREAD_BY_VENDOR = 3\n    }\n    interface Assignee {\n        id: number;\n        username: string;\n        fullName: string;\n        avatarUrl: string;\n        wordsCount: number;\n        wordsLeft: number;\n    }\n    interface AssignedTeam {\n        id: number;\n        wordsCount: number;\n    }\n    interface Progress {\n        total: number;\n        done: number;\n        percent: number;\n    }\n    type Expertise = 'standard' | 'mobile-applications' | 'software-it' | 'gaming-video-games' | 'technical-engineering' | 'marketing-consumer-media' | 'business-finance' | 'legal-certificate' | 'medical' | 'ad-words-banners' | 'automotive-aerospace' | 'scientific' | 'scientific-academic' | 'tourism' | 'training-employee-handbooks' | 'forex-crypto';\n    enum TranslatedExpertise {\n        ECONOMY = \"P\",\n        PROFESSIONAL = \"T\",\n        PREMIUM = \"R\"\n    }\n    type Tone = '' | 'Informal' | 'Friendly' | 'Business' | 'Formal' | 'other';\n    type Purpose = 'standard' | 'Personal use' | 'Business' | 'Online content' | 'App/Web localization' | 'Media content' | 'Semi-technical' | 'other';\n    type Subject = 'general' | 'accounting_finance' | 'aerospace_defence' | 'architecture' | 'art' | 'automotive' | 'certificates_diplomas_licences_cv_etc' | 'chemical' | 'civil_engineering_construction' | 'corporate_social_responsibility' | 'cosmetics' | 'culinary' | 'electronics_electrical_engineering' | 'energy_power_generation_oil_gas' | 'environment' | 'fashion' | 'games_viseogames_casino' | 'general_business_commerce' | 'history_archaeology' | 'information_technology' | 'insurance' | 'internet_e-commerce' | 'legal_documents_contracts' | 'literary_translations' | 'marketing_advertising_material_public_relations' | 'matematics_and_physics' | 'mechanical_manufacturing' | 'media_journalism_publishing' | 'medical_pharmaceutical' | 'music' | 'private_correspondence_letters' | 'religion' | 'science' | 'shipping_sailing_maritime' | 'social_science' | 'telecommunications' | 'travel_tourism';\n    interface ListTasksOptions extends PaginationOptions {\n        status?: TasksModel.Status;\n        assigneeId?: number;\n        orderBy?: string;\n    }\n    interface TaskSettingsTemplate {\n        id: number;\n        name: string;\n        config: TaskSettingsTemplateConfig;\n        createdAt: string;\n        updatedAt: string;\n    }\n    interface AddTaskSettingsTemplate {\n        name: string;\n        config: TaskSettingsTemplateConfig;\n    }\n    interface TaskSettingsTemplateConfig {\n        languages: {\n            languageId?: string;\n            userIds?: number[];\n            teamIds?: number[];\n        }[];\n    }\n    interface TaskComment {\n        id: number;\n        userId: number;\n        taskId: number;\n        text: string;\n        timeSpent: number;\n        createdAt: string;\n        updatedAt: string;\n    }\n    interface CreateTaskCommentRequest {\n        text?: string;\n        timeSpent?: number;\n    }\n}\n```\n\n##### teams/index.d.ts\n\n```typescript\nimport { CrowdinApi, Pagination, PaginationOptions, PatchRequest, ProjectRole, ProjectRoles, ResponseList, ResponseObject } from '../core';\nimport { ProjectsGroupsModel } from '../projectsGroups';\nexport declare class Teams extends CrowdinApi {\n    listGroupTeams(groupId: number, options?: TeamsModel.ListGroupTeamsOptions): Promise<ResponseList<TeamsModel.TeamGroup>>;\n    updateGroupTeams(groupId: number, request: PatchRequest[]): Promise<ResponseList<TeamsModel.TeamGroup>>;\n    getGroupTeam(groupId: number, teamId: number): Promise<ResponseObject<TeamsModel.TeamGroup>>;\n    listTeamProjectPermissions(teamId: number, options?: PaginationOptions): Promise<ResponseList<TeamsModel.ProjectPermissions>>;\n    editTeamProjectPermissions(teamId: number, request: PatchRequest[]): Promise<ResponseList<TeamsModel.ProjectPermissions>>;\n    addTeamToProject(projectId: number, request: TeamsModel.AddTeamToProjectRequest): Promise<TeamsModel.ProjectTeamResources>;\n    listTeams(options?: TeamsModel.ListTeamsOptions): Promise<ResponseList<TeamsModel.Team>>;\n    listTeams(limit?: number, offset?: number): Promise<ResponseList<TeamsModel.Team>>;\n    addTeam(request: TeamsModel.AddTeamRequest): Promise<ResponseObject<TeamsModel.Team>>;\n    getTeam(teamId: number): Promise<ResponseObject<TeamsModel.Team>>;\n    deleteTeam(teamId: number): Promise<void>;\n    editTeam(teamId: number, request: PatchRequest[]): Promise<ResponseObject<TeamsModel.Team>>;\n    teamMembersList(teamId: number, options?: PaginationOptions): Promise<ResponseList<TeamsModel.TeamMember>>;\n    teamMembersList(teamId: number, limit?: number, offset?: number): Promise<ResponseList<TeamsModel.TeamMember>>;\n    addTeamMembers(teamId: number, request: TeamsModel.AddTeamMembersRequest): Promise<TeamsModel.AddTeamMembersResponse>;\n    deleteAllTeamMembers(teamId: number): Promise<void>;\n    deleteTeamMember(teamId: number, memberId: number): Promise<void>;\n}\nexport declare namespace TeamsModel {\n    interface ListGroupTeamsOptions extends PaginationOptions {\n        orderBy?: string;\n    }\n    interface ProjectPermissions {\n        id: number;\n        roles: ProjectRole[];\n        project: ProjectsGroupsModel.Project | ProjectsGroupsModel.ProjectSettings;\n    }\n    interface AddTeamToProjectRequest {\n        teamId: number;\n        managerAccess?: boolean;\n        developerAccess?: boolean;\n        roles?: ProjectRole[];\n        accessToAllWorkflowSteps?: boolean;\n        permissions?: Permissions;\n    }\n    interface ListTeamsOptions extends PaginationOptions {\n        search?: string;\n        projectIds?: string;\n        projectRoles?: ProjectRoles[];\n        languageIds?: string;\n        groupIds?: string;\n        orderBy?: string;\n    }\n    interface ProjectTeamResources {\n        skipped: ProjectTeamResource;\n        added: ProjectTeamResource;\n    }\n    interface ProjectTeamResource {\n        id: number;\n        hasManagerAccess: boolean;\n        hasDeveloperAccess: boolean;\n        hasAccessToAllWorkflowSteps: boolean;\n        permissions: Permissions;\n        roles: ProjectRole[];\n    }\n    interface Permissions {\n        [lang: string]: {\n            workflowStepIds: number[] | 'all';\n        };\n    }\n    interface Team {\n        id: number;\n        name: string;\n        totalMembers: number;\n        webUrl: string;\n        createdAt: string;\n        updatedAt: string;\n    }\n    interface TeamGroup {\n        id: number;\n        team: Team;\n    }\n    interface AddTeamRequest {\n        name: string;\n    }\n    interface TeamMember {\n        id: number;\n        username: string;\n        firstName: string;\n        lastName: string;\n        avatarUrl: string;\n        addedAt: string;\n    }\n    interface AddTeamMembersRequest {\n        userIds: number[];\n    }\n    interface AddTeamMembersResponse {\n        skipped: ResponseObject<TeamMember>[];\n        added: ResponseObject<TeamMember>[];\n        pagination: Pagination;\n    }\n}\n```\n\n##### translationMemory/index.d.ts\n\n```typescript\nimport { CrowdinApi, DownloadLink, PaginationOptions, PatchRequest, ResponseList, ResponseObject, Status } from '../core';\nexport declare class TranslationMemory extends CrowdinApi {\n    listTm(options?: TranslationMemoryModel.ListTMsOptions): Promise<ResponseList<TranslationMemoryModel.TranslationMemory>>;\n    listTm(groupId?: number, limit?: number, offset?: number): Promise<ResponseList<TranslationMemoryModel.TranslationMemory>>;\n    addTm(request: TranslationMemoryModel.AddTranslationMemoryRequest): Promise<ResponseObject<TranslationMemoryModel.TranslationMemory>>;\n    getTm(tmId: number): Promise<ResponseObject<TranslationMemoryModel.TranslationMemory>>;\n    deleteTm(tmId: number): Promise<void>;\n    editTm(tmId: number, request: PatchRequest[]): Promise<ResponseObject<TranslationMemoryModel.TranslationMemory>>;\n    listTmSegments(tmId: number, options?: TranslationMemoryModel.ListSegmentsOptions): Promise<ResponseList<TranslationMemoryModel.TMSegment>>;\n    addTmSegment(tmId: number, request: TranslationMemoryModel.AddTMSegment): Promise<ResponseObject<TranslationMemoryModel.TMSegment>>;\n    clearTm(tmId: number): Promise<void>;\n    exportTm(tmId: number, request?: TranslationMemoryModel.ExportTranslationMemoryRequest): Promise<ResponseObject<Status<TranslationMemoryModel.ExportTranslationMemoryAttribute>>>;\n    checkExportStatus(tmId: number, exportId: string): Promise<ResponseObject<Status<TranslationMemoryModel.ExportTranslationMemoryAttribute>>>;\n    downloadTm(tmId: number, exportId: string): Promise<ResponseObject<DownloadLink>>;\n    concordanceSearch(projectId: number, request: TranslationMemoryModel.ConcordanceSearchRequest): Promise<ResponseList<TranslationMemoryModel.ConcordanceSearchResponse>>;\n    importTm(tmId: number, request: TranslationMemoryModel.ImportTranslationMemoryRequest): Promise<ResponseObject<Status<TranslationMemoryModel.ImportTranslationMemoryAttribute>>>;\n    checkImportStatus(tmId: number, importId: string): Promise<ResponseObject<Status<TranslationMemoryModel.ImportTranslationMemoryAttribute>>>;\n    getTmSegment(tmId: number, segmentId: number): Promise<ResponseObject<TranslationMemoryModel.TMSegment>>;\n    deleteTmSegment(tmId: number, segmentId: number): Promise<void>;\n    editTmSegment(tmId: number, segmentId: number, request: PatchRequest[]): Promise<ResponseObject<TranslationMemoryModel.TMSegment>>;\n    deleteTmSegmentRecord(tmId: number, segmentId: number, recordId: number): Promise<void>;\n    editTmSegmentRecord(tmId: number, segmentId: number, recordId: number, request: PatchRequest[]): Promise<ResponseObject<TranslationMemoryModel.TMSegment>>;\n    addTmSegmentRecords(tmId: number, segmentId: number, request: TranslationMemoryModel.AddTMSegment): Promise<ResponseObject<TranslationMemoryModel.TMSegment>>;\n}\nexport declare namespace TranslationMemoryModel {\n    interface TranslationMemory {\n        id: number;\n        groupId: number;\n        userId: number;\n        name: string;\n        languageId: string;\n        languageIds: string[];\n        segmentsCount: number;\n        defaultProjectIds: number[];\n        projectIds: number[];\n        createdAt: string;\n        webUrl: string;\n    }\n    interface AddTranslationMemoryRequest {\n        name: string;\n        languageId: string;\n        groupId?: number;\n    }\n    interface ConcordanceSearchRequest {\n        sourceLanguageId: string;\n        targetLanguageId: string;\n        autoSubstitution: boolean;\n        minRelevant: number;\n        expressions: string[];\n        expression?: string;\n    }\n    interface ConcordanceSearchResponse {\n        tm: TranslationMemory;\n        recordId: number;\n        source: string;\n        target: string;\n        relevant: number;\n        substituted: string;\n        updatedAt: string;\n    }\n    interface ExportTranslationMemoryRequest {\n        sourceLanguageId?: number;\n        targetLanguageId?: number;\n        format?: Format;\n    }\n    interface ImportTranslationMemoryRequest {\n        storageId: number;\n        firstLineContainsHeader?: boolean;\n        scheme?: Scheme;\n    }\n    interface ExportTranslationMemoryAttribute {\n        sourceLanguageId: string;\n        targetLanguageId: string;\n        format: string;\n    }\n    interface ImportTranslationMemoryAttribute {\n        tmId: number;\n        storageId: number;\n        firstLineContainsHeader: number;\n        scheme: Scheme;\n    }\n    type Format = 'tmx' | 'csv' | 'xlsx';\n    interface Scheme {\n        [key: string]: number;\n    }\n    interface ListTMsOptions extends PaginationOptions {\n        groupId?: number;\n        userId?: number;\n        orderBy?: string;\n    }\n    interface ListSegmentsOptions extends PaginationOptions {\n        croql?: string;\n        orderBy?: string;\n    }\n    interface TMSegment {\n        id: number;\n        records: TMSegmentRecord[];\n    }\n    interface TMSegmentRecord {\n        id: number;\n        languageId: string;\n        text: string;\n        usageCount: number;\n        createdBy: number;\n        updatedBy: number;\n        createdAt: string;\n        updatedAt: string;\n    }\n    interface AddTMSegment {\n        records: AddTMSegmentRecord[];\n    }\n    interface AddTMSegmentRecord {\n        languageId: string;\n        text: string;\n    }\n}\n```\n\n##### translationStatus/index.d.ts\n\n```typescript\nimport { CrowdinApi, PaginationOptions, ResponseList } from '../core';\nimport { LanguagesModel } from '../languages';\nexport declare class TranslationStatus extends CrowdinApi {\n    getBranchProgress(projectId: number, branchId: number, options?: PaginationOptions): Promise<ResponseList<TranslationStatusModel.LanguageProgress>>;\n    getBranchProgress(projectId: number, branchId: number, limit?: number, offset?: number): Promise<ResponseList<TranslationStatusModel.LanguageProgress>>;\n    getDirectoryProgress(projectId: number, directoryId: number, options?: PaginationOptions): Promise<ResponseList<TranslationStatusModel.LanguageProgress>>;\n    getDirectoryProgress(projectId: number, directoryId: number, limit?: number, offset?: number): Promise<ResponseList<TranslationStatusModel.LanguageProgress>>;\n    getFileProgress(projectId: number, fileId: number, options?: PaginationOptions): Promise<ResponseList<TranslationStatusModel.LanguageProgress>>;\n    getFileProgress(projectId: number, fileId: number, limit?: number, offset?: number): Promise<ResponseList<TranslationStatusModel.LanguageProgress>>;\n    getLanguageProgress(projectId: number, languageId: string, options?: PaginationOptions): Promise<ResponseList<TranslationStatusModel.FileProgress>>;\n    getLanguageProgress(projectId: number, languageId: string, limit?: number, offset?: number): Promise<ResponseList<TranslationStatusModel.FileProgress>>;\n    getProjectProgress(projectId: number, options?: PaginationOptions): Promise<ResponseList<TranslationStatusModel.LanguageProgress>>;\n    getProjectProgress(projectId: number, limit?: number, offset?: number, languageIds?: string): Promise<ResponseList<TranslationStatusModel.LanguageProgress>>;\n    listQaCheckIssues(projectId: number, options?: TranslationStatusModel.ListQaCheckIssuesOptions): Promise<ResponseList<TranslationStatusModel.QaCheck>>;\n    listQaCheckIssues(projectId: number, limit?: number, offset?: number, category?: TranslationStatusModel.Category, validation?: TranslationStatusModel.Validation, languageIds?: string): Promise<ResponseList<TranslationStatusModel.QaCheck>>;\n}\nexport declare namespace TranslationStatusModel {\n    interface LanguageProgress {\n        words: Words;\n        phrases: Words;\n        translationProgress: number;\n        approvalProgress: number;\n        eTag: string;\n        languageId: string;\n        language: LanguagesModel.Language;\n    }\n    interface FileProgress {\n        words: Words;\n        phrases: Words;\n        translationProgress: number;\n        approvalProgress: number;\n        branchId: number;\n        fileId: number;\n        eTag: string;\n    }\n    interface Words {\n        total: number;\n        translated: number;\n        approved: number;\n        preTranslateAppliedTo: number;\n    }\n    type Category = 'empty' | 'variables' | 'tags' | 'punctuation' | 'symbol_register' | 'spaces' | 'size' | 'special_symbols' | 'wrong_translation' | 'spellcheck' | 'icu';\n    type Validation = 'empty_string_check' | 'empty_suggestion_check' | 'max_length_check' | 'tags_check' | 'mismatch_ids_check' | 'cdata_check' | 'specials_symbols_check' | 'leading_newlines_check' | 'trailing_newlines_check' | 'leading_spaces_check' | 'trailing_spaces_check' | 'multiple_spaces_check' | 'custom_blocked_variables_check' | 'highest_priority_custom_variables_check' | 'highest_priority_variables_check' | 'c_variables_check' | 'python_variables_check' | 'rails_variables_check' | 'java_variables_check' | 'dot_net_variables_check' | 'twig_variables_check' | 'php_variables_check' | 'freemarker_variables_check' | 'lowest_priority_variable_check' | 'lowest_priority_custom_variables_check' | 'punctuation_check' | 'spaces_before_punctuation_check' | 'spaces_after_punctuation_check' | 'non_breaking_spaces_check' | 'capitalize_check' | 'multiple_uppercase_check' | 'parentheses_check' | 'entities_check' | 'escaped_quotes_check' | 'wrong_translation_issue_check' | 'spellcheck' | 'icu_check';\n    interface ListQaCheckIssuesOptions extends PaginationOptions {\n        category?: Category | Category[];\n        validation?: Validation | Validation[];\n        languageIds?: string;\n    }\n    interface QaCheck {\n        stringId: number;\n        languageId: string;\n        category: Category;\n        categoryDescription: string;\n        validation: Validation;\n        validationDescription: string;\n        pluralId: number;\n        text: string;\n    }\n    interface GetProjectProgressOptions extends PaginationOptions {\n        languageIds?: string;\n    }\n}\n```\n\n##### translations/index.d.ts\n\n```typescript\nimport { CrowdinApi, DownloadLink, PaginationOptions, PatchRequest, ResponseList, ResponseObject, Status } from '../core';\nimport { ProjectsGroupsModel } from '../projectsGroups';\nexport declare class Translations extends CrowdinApi {\n    listPreTranslations(projectId: number, options?: PaginationOptions): Promise<ResponseList<Status<TranslationsModel.PreTranslationStatusAttributes>>>;\n    preTranslationStatus(projectId: number, preTranslationId: string): Promise<ResponseObject<Status<TranslationsModel.PreTranslationStatusAttributes>>>;\n    applyPreTranslation(projectId: number, request: TranslationsModel.PreTranslateRequest | TranslationsModel.PreTranslateStringsRequest): Promise<ResponseObject<Status<TranslationsModel.PreTranslationStatusAttributes>>>;\n    editPreTranslation(projectId: number, preTranslationId: string, request: PatchRequest[]): Promise<ResponseObject<Status<TranslationsModel.PreTranslationStatusAttributes>>>;\n    getPreTranslationReport(projectId: number, preTranslationId: string): Promise<ResponseObject<TranslationsModel.PreTranslationReport>>;\n    buildProjectDirectoryTranslation(projectId: number, directoryId: number, request?: TranslationsModel.BuildProjectDirectoryTranslationRequest): Promise<ResponseObject<TranslationsModel.BuildProjectDirectoryTranslationResponse>>;\n    buildProjectFileTranslation(projectId: number, fileId: number, request: TranslationsModel.BuildProjectFileTranslationRequest, eTag?: string): Promise<ResponseObject<TranslationsModel.BuildProjectFileTranslationResponse>>;\n    listProjectBuilds(projectId: number, options?: TranslationsModel.ListProjectBuildsOptions): Promise<ResponseList<TranslationsModel.Build>>;\n    listProjectBuilds(projectId: number, branchId?: number, limit?: number, offset?: number): Promise<ResponseList<TranslationsModel.Build>>;\n    buildProject(projectId: number, request?: TranslationsModel.BuildRequest | TranslationsModel.PseudoBuildRequest): Promise<ResponseObject<TranslationsModel.Build>>;\n    uploadTranslation(projectId: number, languageId: string, request: TranslationsModel.UploadTranslationRequest): Promise<ResponseObject<TranslationsModel.UploadTranslationResponse>>;\n    uploadTranslationStrings(projectId: number, languageId: string, request: TranslationsModel.UploadTranslationStringsRequest): Promise<ResponseObject<TranslationsModel.UploadTranslationStringsResponse>>;\n    downloadTranslations(projectId: number, buildId: number): Promise<ResponseObject<DownloadLink>>;\n    checkBuildStatus(projectId: number, buildId: number): Promise<ResponseObject<TranslationsModel.Build>>;\n    cancelBuild(projectId: number, buildId: number): Promise<void>;\n    exportProjectTranslation(projectId: number, request: TranslationsModel.ExportProjectTranslationRequest): Promise<ResponseObject<DownloadLink>>;\n}\nexport declare namespace TranslationsModel {\n    interface PreTranslateRequest {\n        languageIds: string[];\n        fileIds: number[];\n        method?: Method;\n        engineId?: number;\n        aiPromptId?: number;\n        autoApproveOption?: AutoApproveOption;\n        duplicateTranslations?: boolean;\n        skipApprovedTranslations?: boolean;\n        translateUntranslatedOnly?: boolean;\n        translateWithPerfectMatchOnly?: boolean;\n        fallbackLanguages?: {\n            languageId?: string[];\n        };\n        labelIds?: number[];\n        excludeLabelIds?: number[];\n    }\n    interface PreTranslateStringsRequest {\n        languageIds: string[];\n        branchIds?: number[];\n        method?: Method;\n        engineId?: number;\n        aiPromptId?: number;\n        autoApproveOption?: AutoApproveOption;\n        duplicateTranslations?: boolean;\n        skipApprovedTranslations?: boolean;\n        translateUntranslatedOnly?: boolean;\n        translateWithPerfectMatchOnly?: boolean;\n        fallbackLanguages?: {\n            languageId: string[];\n        };\n        labelIds?: number[];\n        excludeLabelIds?: number[];\n    }\n    interface BuildProjectDirectoryTranslationRequest {\n        targetLanguageIds?: string[];\n        skipUntranslatedStrings?: boolean;\n        skipUntranslatedFiles?: boolean;\n        preserveFolderHierarchy?: boolean;\n        exportStringsThatPassedWorkflow?: boolean;\n        exportWithMinApprovalsCount?: number;\n        exportApprovedOnly?: boolean;\n    }\n    interface BuildProjectDirectoryTranslationResponse {\n        id: number;\n        projectId: number;\n        status: BuildStatus;\n        progress: number;\n        createdAt: string;\n        updatedAt: string;\n        finishedAt: string;\n    }\n    type BuildStatus = 'created' | 'inProgress' | 'canceled' | 'failed' | 'finished';\n    interface BuildProjectFileTranslationRequest {\n        targetLanguageId: string;\n        exportAsXliff?: boolean;\n        skipUntranslatedStrings?: boolean;\n        skipUntranslatedFiles?: boolean;\n        exportApprovedOnly?: boolean;\n        exportWithMinApprovalsCount?: number;\n        exportStringsThatPassedWorkflow?: boolean;\n    }\n    interface BuildProjectFileTranslationResponse extends DownloadLink {\n        etag: string;\n    }\n    interface PreTranslationStatusAttributes {\n        languageIds: string[];\n        fileIds: number[];\n        branchIds: number[];\n        method: Method;\n        autoApproveOption: AutoApproveOption;\n        duplicateTranslations: boolean;\n        skipApprovedTranslations: boolean;\n        translateUntranslatedOnly: boolean;\n        translateWithPerfectMatchOnly: boolean;\n    }\n    type Method = 'tm' | 'mt' | 'ai';\n    type AutoApproveOption = 'all' | 'exceptAutoSubstituted' | 'perfectMatchOnly' | 'none';\n    type CharTransformation = 'asian' | 'european' | 'arabic' | 'cyrillic';\n    interface Build {\n        id: number;\n        projectId: number;\n        status: BuildStatus;\n        progress: number;\n        attributes: Attribute;\n        createdAt: string;\n        updatedAt: string;\n        finishedAt: string;\n    }\n    interface Attribute {\n        branchId: number;\n        directoryId: number;\n        targetLanguageIds: string[];\n        skipUntranslatedStrings: boolean;\n        skipUntranslatedFiles: boolean;\n        exportApprovedOnly: boolean;\n        exportWithMinApprovalsCount: number;\n        exportStringsThatPassedWorkflow: boolean;\n    }\n    interface BuildRequest {\n        branchId?: number;\n        targetLanguageIds?: string[];\n        skipUntranslatedStrings?: boolean;\n        skipUntranslatedFiles?: boolean;\n        exportApprovedOnly?: boolean;\n        exportWithMinApprovalsCount?: number;\n        exportStringsThatPassedWorkflow?: boolean;\n    }\n    interface PseudoBuildRequest {\n        pseudo: boolean;\n        branchId?: number;\n        prefix?: string;\n        suffix?: string;\n        lengthTransformation?: number;\n        charTransformation?: CharTransformation;\n    }\n    interface UploadTranslationRequest {\n        storageId: number;\n        fileId?: number;\n        importEqSuggestions?: boolean;\n        autoApproveImported?: boolean;\n        translateHidden?: boolean;\n        addToTm?: boolean;\n    }\n    interface UploadTranslationStringsRequest {\n        storageId: number;\n        branchId?: number;\n        importEqSuggestions?: boolean;\n        autoApproveImported?: boolean;\n        translateHidden?: boolean;\n        addToTm?: boolean;\n    }\n    interface UploadTranslationResponse {\n        projectId: number;\n        storageId: number;\n        languageId: string;\n        fileId: number;\n    }\n    interface UploadTranslationStringsResponse {\n        projectId: number;\n        storageId: number;\n        languageId: string;\n        branchId: number;\n    }\n    interface ExportProjectTranslationRequest {\n        targetLanguageId: string;\n        format?: string;\n        labelIds?: number[];\n        branchIds?: number[];\n        directoryIds?: number[];\n        fileIds?: number[];\n        skipUntranslatedStrings?: boolean;\n        skipUntranslatedFiles?: boolean;\n        exportApprovedOnly?: boolean;\n        exportWithMinApprovalsCount?: number;\n        exportStringsThatPassedWorkflow?: boolean;\n    }\n    interface ListProjectBuildsOptions extends PaginationOptions {\n        branchId?: number;\n    }\n    interface PreTranslationReport {\n        languages: TargetLanguage[];\n        preTranslateType: Method;\n    }\n    interface TargetLanguage {\n        id: string;\n        files: TargetLanguageFile[];\n        skipped: SkippedInfo;\n        skippedQaCheckCategories: ProjectsGroupsModel.CheckCategories;\n    }\n    interface TargetLanguageFile {\n        id: string;\n        statistics: TargetLanguageFileStatistics;\n    }\n    interface TargetLanguageFileStatistics {\n        phrases: number;\n        words: number;\n    }\n    interface SkippedInfo {\n        [key: string]: any;\n    }\n}\n```\n\n##### uploadStorage/index.d.ts\n\n```typescript\nimport { CrowdinApi, PaginationOptions, ResponseList, ResponseObject } from '../core';\nexport declare class UploadStorage extends CrowdinApi {\n    listStorages(options?: PaginationOptions): Promise<ResponseList<UploadStorageModel.Storage>>;\n    listStorages(limit?: number, offset?: number): Promise<ResponseList<UploadStorageModel.Storage>>;\n    addStorage(fileName: string, request: any, contentType?: string): Promise<ResponseObject<UploadStorageModel.Storage>>;\n    getStorage(storageId: number): Promise<ResponseObject<UploadStorageModel.Storage>>;\n    deleteStorage(storageId: number): Promise<void>;\n}\nexport declare namespace UploadStorageModel {\n    interface Storage {\n        id: number;\n        fileName: string;\n    }\n}\n```\n\n##### users/index.d.ts\n\n```typescript\nimport { CrowdinApi, Pagination, PaginationOptions, PatchRequest, ProjectRole, ProjectRoles, ResponseList, ResponseObject } from '../core';\nimport { ProjectsGroupsModel } from '../projectsGroups';\nimport { TeamsModel } from '../teams';\nexport declare class Users extends CrowdinApi {\n    listGroupManagers(groupId: number, options?: UsersModel.ListGroupManagersOptions): Promise<ResponseList<UsersModel.GroupManager>>;\n    updateGroupManagers(groupId: number, request: PatchRequest[]): Promise<ResponseList<UsersModel.GroupManager>>;\n    getGroupManager(groupId: number, userId: number): Promise<ResponseObject<UsersModel.GroupManager>>;\n    listProjectMembers(projectId: number, options?: UsersModel.ListProjectMembersOptions): Promise<ResponseList<UsersModel.ProjectMember | UsersModel.EnterpriseProjectMember>>;\n    listProjectMembers(projectId: number, search?: string, role?: UsersModel.Role, languageId?: string, limit?: number, offset?: number): Promise<ResponseList<UsersModel.ProjectMember | UsersModel.EnterpriseProjectMember>>;\n    addProjectMember(projectId: number, request: UsersModel.AddProjectMemberRequest): Promise<UsersModel.AddProjectMemberResponse>;\n    getProjectMemberPermissions(projectId: number, memberId: number): Promise<ResponseObject<UsersModel.ProjectMember | UsersModel.EnterpriseProjectMember>>;\n    replaceProjectMemberPermissions(projectId: number, memberId: number, request?: UsersModel.ReplaceProjectMemberRequest): Promise<ResponseObject<UsersModel.ProjectMember | UsersModel.EnterpriseProjectMember>>;\n    deleteMemberFromProject(projectId: number, memberId: number): Promise<void>;\n    listUsers(options?: UsersModel.ListUsersOptions): Promise<ResponseList<UsersModel.User>>;\n    listUsers(status?: UsersModel.Status, search?: string, twoFactor?: UsersModel.TwoFactor, limit?: number, offset?: number): Promise<ResponseList<UsersModel.User>>;\n    inviteUser(request: UsersModel.InviteUserRequest): Promise<ResponseObject<UsersModel.User>>;\n    getUserInfo(userId: number): Promise<ResponseObject<UsersModel.User>>;\n    deleteUser(userId: number): Promise<void>;\n    editUser(userId: number, request: PatchRequest[]): Promise<ResponseObject<UsersModel.User>>;\n    getAuthenticatedUser(): Promise<ResponseObject<UsersModel.User>>;\n    editAuthenticatedUser(request: PatchRequest[]): Promise<ResponseObject<UsersModel.User>>;\n    listUserProjectPermissions(userId: number, options?: PaginationOptions): Promise<ResponseList<UsersModel.ProjectPermissions>>;\n    editUserProjectPermissions(userId: number, request: PatchRequest[]): Promise<ResponseList<UsersModel.ProjectPermissions>>;\n    listUserProjectContributions(userId: number, options?: PaginationOptions): Promise<ResponseList<UsersModel.ProjectPermissions>>;\n}\nexport declare namespace UsersModel {\n    interface ListGroupManagersOptions extends PaginationOptions {\n        teamIds?: number[];\n        orderBy?: string;\n    }\n    interface ListProjectMembersOptions extends PaginationOptions {\n        search?: string;\n        role?: Role;\n        languageId?: string;\n        workflowStepId?: number;\n        orderBy?: string;\n    }\n    interface ListUsersOptions extends PaginationOptions {\n        status?: Status;\n        search?: string;\n        twoFactor?: TwoFactor;\n        orderBy?: string;\n        organizationRoles?: OrganizationRoles[];\n        teamId?: number;\n        projectIds?: string;\n        projectRoles?: ProjectRoles[];\n        languageIds?: string;\n        groupIds?: string;\n        lastSeenFrom?: string;\n        lastSeenTo?: string;\n    }\n    interface InviteUserRequest {\n        email: string;\n        firstName?: string;\n        lastName?: string;\n        timezone?: string;\n        adminAccess?: boolean;\n    }\n    interface User {\n        id: number;\n        username: string;\n        email: string;\n        firstName: string;\n        lastName: string;\n        status: Status;\n        avatarUrl: string;\n        fields: Record<string, any>;\n        createdAt: string;\n        lastSeen: string;\n        twoFactor: TwoFactor;\n        isAdmin: boolean;\n        timezone: string;\n        emailVerified: string;\n    }\n    type Status = 'active' | 'pending' | 'blocked';\n    type TwoFactor = 'enabled' | 'disabled';\n    type OrganizationRoles = 'admin' | 'manager' | 'vendor' | 'client';\n    interface GroupManager {\n        id: number;\n        user: User;\n        teams: TeamsModel.Team[];\n    }\n    interface ProjectMember {\n        id: number;\n        username: string;\n        fullName: string;\n        role: Role;\n        permissions: Permissions;\n        avatarUrl: string;\n        joinedAt: string;\n        timezone: string;\n        roles: ProjectRole[];\n    }\n    interface EnterpriseProjectMember {\n        id: number;\n        username: string;\n        firstName: string;\n        lastName: string;\n        isManager: boolean;\n        isDeveloperr: boolean;\n        managerOfGroup: Group;\n        accessToAllWorkflowSteps: boolean;\n        permissions: Permissions;\n        givenAccessAt: string;\n        roles: ProjectRole[];\n    }\n    interface Group {\n        id: number;\n        name: string;\n    }\n    type Role = 'all' | 'owner' | 'manager' | 'proofreader' | 'translator' | 'blocked';\n    type LanguageRole = 'proofreader' | 'translator' | 'denied';\n    interface AddProjectMemberRequest {\n        userIds?: number[];\n        usernames?: string[];\n        emails?: string[];\n        managerAccess?: boolean;\n        roles?: ProjectRole[];\n        developerAccess?: boolean;\n        accessToAllWorkflowSteps?: boolean;\n        permissions?: Permissions;\n    }\n    interface AddProjectMemberResponse {\n        skipped: ResponseObject<ProjectMember | EnterpriseProjectMember>[];\n        added: ResponseObject<ProjectMember | EnterpriseProjectMember>[];\n        pagination: Pagination;\n    }\n    interface ReplaceProjectMemberRequest {\n        managerAccess?: boolean;\n        developerAccess?: boolean;\n        roles?: ProjectRole[];\n        accessToAllWorkflowSteps?: boolean;\n        permissions?: Permissions;\n    }\n    interface ProjectPermissions {\n        id: number;\n        roles: ProjectRole[];\n        project: ProjectsGroupsModel.Project | ProjectsGroupsModel.ProjectSettings;\n        teams: TeamsModel.Team[];\n    }\n    interface Contributions {\n        id: number;\n        translated: Contribution;\n        approved: Contribution;\n        voted: Contribution;\n        commented: Contribution;\n        project: ProjectsGroupsModel.Project | ProjectsGroupsModel.ProjectSettings;\n    }\n    interface Contribution {\n        strings: number;\n        words?: number;\n    }\n    interface Permissions {\n        [lang: string]: string | {\n            workflowStepIds: number[] | 'all';\n        };\n    }\n}\n```\n\n##### vendors/index.d.ts\n\n```typescript\nimport { CrowdinApi, PaginationOptions, ResponseList } from '../core';\nexport declare class Vendors extends CrowdinApi {\n    listVendors(options?: PaginationOptions): Promise<ResponseList<VendorsModel.Vendor>>;\n    listVendors(limit?: number, offset?: number): Promise<ResponseList<VendorsModel.Vendor>>;\n}\nexport declare namespace VendorsModel {\n    interface Vendor {\n        id: number;\n        name: string;\n        description: string;\n        status: 'pending' | 'confirmed' | 'rejected';\n        webUrl: string;\n    }\n}\n```\n\n##### webhooks/index.d.ts\n\n```typescript\nimport { CrowdinApi, PaginationOptions, PatchRequest, ResponseList, ResponseObject } from '../core';\nexport declare class Webhooks extends CrowdinApi {\n    listWebhooks(projectId: number, options?: PaginationOptions): Promise<ResponseList<WebhooksModel.Webhook>>;\n    listWebhooks(projectId: number, limit?: number, offset?: number): Promise<ResponseList<WebhooksModel.Webhook>>;\n    addWebhook(projectId: number, request: WebhooksModel.AddWebhookRequest): Promise<ResponseObject<WebhooksModel.Webhook>>;\n    getWebhook(projectId: number, webhookId: number): Promise<ResponseObject<WebhooksModel.Webhook>>;\n    deleteWebhook(projectId: number, webhookId: number): Promise<void>;\n    editWebhook(projectId: number, webhookId: number, request: PatchRequest[]): Promise<ResponseObject<WebhooksModel.Webhook>>;\n}\nexport declare namespace WebhooksModel {\n    interface Webhook {\n        id: number;\n        projectId: number;\n        name: string;\n        url: string;\n        events: Event[];\n        headers: Record<string, string>;\n        payload: Record<string, any>;\n        isActive: boolean;\n        batchingEnabled: boolean;\n        requestType: RequestType;\n        contentType: ContentType;\n        createdAt: string;\n        updatedAt: string;\n    }\n    interface AddWebhookRequest {\n        name: string;\n        url: string;\n        events: Event[];\n        requestType: RequestType;\n        isActive?: boolean;\n        batchingEnabled?: boolean;\n        contentType?: ContentType;\n        headers?: Record<string, string>;\n        payload?: Record<string, any>;\n    }\n    type ContentType = 'multipart/form-data' | 'application/json' | 'application/x-www-form-urlencoded';\n    type Event = 'file.added' | 'file.updated' | 'file.reverted' | 'file.deleted' | 'file.translated' | 'file.approved' | 'project.translated' | 'project.approved' | 'project.built' | 'translation.updated' | 'string.added' | 'string.updated' | 'string.deleted' | 'stringComment.created' | 'stringComment.updated' | 'stringComment.deleted' | 'stringComment.restored' | 'suggestion.added' | 'suggestion.updated' | 'suggestion.deleted' | 'suggestion.approved' | 'suggestion.disapproved' | 'task.added' | 'task.statusChanged' | 'task.deleted';\n    type RequestType = 'POST' | 'GET';\n}\n```\n\n##### workflows/index.d.ts\n\n```typescript\nimport { CrowdinApi, PaginationOptions, PatchRequest, ResponseList, ResponseObject } from '../core';\nimport { SourceStringsModel } from '../sourceStrings';\nexport declare class Workflows extends CrowdinApi {\n    listWorkflowSteps(projectId: number, options?: PaginationOptions): Promise<ResponseList<WorkflowModel.WorkflowStep>>;\n    listWorkflowSteps(projectId: number, limit?: number, offset?: number): Promise<ResponseList<WorkflowModel.WorkflowStep>>;\n    getWorkflowStep(projectId: number, stepId: number): Promise<ResponseObject<WorkflowModel.WorkflowStep>>;\n    listStringsOnTheWorkflowStep(projectId: number, stepId: number, options?: WorkflowModel.ListStringsOntheWorkflowStepOptions): Promise<ResponseList<SourceStringsModel.String>>;\n    listWorkflowTemplates(options?: WorkflowModel.ListWorkflowTemplatesOptions): Promise<ResponseList<WorkflowModel.Workflow>>;\n    listWorkflowTemplates(groupId?: number, limit?: number, offset?: number): Promise<ResponseList<WorkflowModel.Workflow>>;\n    getWorkflowTemplateInfo(templateId: number): Promise<ResponseObject<WorkflowModel.Workflow>>;\n    updateWorkflowStepStringStatus(projectId: number, stepId: number, languageId: string, request: PatchRequest[]): Promise<ResponseList<WorkflowModel.WorkflowStepStringStatus>>;\n    getWorkflowStepStringStatus(projectId: number, stepId: number, languageId: string, options?: PaginationOptions): Promise<ResponseList<WorkflowModel.WorkflowStepStringStatus>>;\n}\nexport declare namespace WorkflowModel {\n    interface WorkflowStep {\n        id: number;\n        title: string;\n        type: string;\n        languages: string[];\n        config: {\n            assignees: {\n                [language: string]: number[];\n            };\n        };\n    }\n    interface ListWorkflowTemplatesOptions extends PaginationOptions {\n        groupId?: number;\n    }\n    interface ListStringsOntheWorkflowStepOptions extends PaginationOptions {\n        languageIds?: string;\n        orderBy?: string;\n        status?: 'todo' | 'done' | 'pending' | 'incomplete' | 'need_review';\n    }\n    interface Workflow {\n        id: number;\n        title: string;\n        description: string;\n        groupId: number;\n        isDefault: boolean;\n        webUrl: string;\n        steps: {\n            id: number;\n            languages: string[];\n            assignees: number[];\n            vendorId: number;\n            config: {\n                minRelevant: number;\n                autoSubstitution: boolean;\n            };\n            mtId: number;\n        }[];\n    }\n    interface WorkflowStepStringStatus {\n        stringId: number;\n        languageId: string;\n        stepId: number;\n        status: string;\n        output: string;\n    }\n}\n```\n\n<!-- CROWDIN_API_CLIENT_TYPES_END -->\n\n### App Metadata Storage\n\n#### Overview\n\nApp Metadata Storage is a built-in key-value storage system provided by the Crowdin Apps SDK. It allows your app to persist data across sessions without needing external databases or storage services.\n\n**Available Methods:**\n- `crowdinApp.saveMetadata(key, data, crowdinId)` - Save or update metadata (recommended)\n- `crowdinApp.getMetadata(key)` - Retrieve metadata\n- `crowdinApp.deleteMetadata(key)` - Delete metadata\n\n**Alternative approach:**\n- `crowdinModule.metadataStore.saveMetadata(key, data, crowdinId)`\n- `crowdinModule.metadataStore.getMetadata(key)`\n- `crowdinModule.metadataStore.deleteMetadata(key)`\n\n#### Official Documentation\n\n**üìö Complete Documentation:** Refer to Crowdin Apps SDK documentation for metadata storage\n\n**‚ö†Ô∏è CRITICAL**: Metadata is stored at the organization level. Always include `organizationId` in your keys to properly scope data.\n\n#### Common Examples\n\n**Save Metadata:**\n```typescript\napp.post('/api/save-data', async (req: Request, res: Response) => {\n    try {\n        const jwt = req.query.jwt as string;\n        const { data } = req.body;\n\n        if (!jwt) {\n            return res.status(400).json({ success: false, error: 'JWT token is required' });\n        }\n        \n        if (!crowdinApp.establishCrowdinConnection) {\n            return res.status(500).json({ success: false, error: 'Crowdin connection method not available' });\n        }\n\n        const connection = await crowdinApp.establishCrowdinConnection(jwt, undefined);\n\n        if (!connection.client) {\n            return res.status(500).json({ success: false, error: 'Crowdin API client not available' });\n        }\n\n        const userId = connection.context.jwtPayload.context.user_id;\n        const organizationId = connection.context.jwtPayload.context.organization_id;\n        \n        // Create a namespaced key\n        const key = `org_${organizationId}_user_${userId}_preferences`;\n        \n        // Save data to metadata storage\n        await crowdinApp.saveMetadata(key, data, connection.context.crowdinId);\n        res.json({ success: true, message: 'Data saved successfully' });\n    } catch (error) {\n        console.error('Save error:', error);\n        res.status(500).json({ success: false, error: 'Failed to save data' });\n    }\n});\n```\n\n**Get Metadata:**\n```typescript\napp.get('/api/get-data', async (req: Request, res: Response) => {\n    try {\n        const jwt = req.query.jwt as string;\n        \n        if (!jwt) {\n            return res.status(400).json({ success: false, error: 'JWT token is required' });\n        }\n        \n        if (!crowdinApp.establishCrowdinConnection) {\n            return res.status(500).json({ success: false, error: 'Crowdin connection method not available' });\n        }\n\n        const connection = await crowdinApp.establishCrowdinConnection(jwt, undefined);\n\n        if (!connection.client) {\n            return res.status(500).json({ success: false, error: 'Crowdin API client not available' });\n        }\n\n        const userId = connection.context.jwtPayload.context.user_id;\n        const organizationId = connection.context.jwtPayload.context.organization_id;\n        \n        const key = `org_${organizationId}_user_${userId}_preferences`;\n        \n        // Retrieve data from metadata storage\n        const data = await crowdinApp.getMetadata(key);\n            \n        // Handle case when no data exists\n        if (!data) {\n            return res.json({ \n                success: true, \n                data: null, \n                message: 'No data found' \n            });\n        }\n        \n        res.json({ success: true, data });\n    } catch (error) {\n        console.error('Get error:', error);\n        res.status(500).json({ success: false, error: 'Failed to retrieve data' });\n    }\n});\n```\n\n**Delete Metadata:**\n```typescript\napp.delete('/api/delete-data', async (req: Request, res: Response) => {\n    try {\n        const jwt = req.query.jwt as string;\n        \n        if (!jwt) {\n            return res.status(400).json({ success: false, error: 'JWT token is required' });\n        }\n        \n        if (!crowdinApp.establishCrowdinConnection) {\n            return res.status(500).json({ success: false, error: 'Crowdin connection method not available' });\n        }\n\n        const connection = await crowdinApp.establishCrowdinConnection(jwt, undefined);\n\n        if (!connection.client) {\n            return res.status(500).json({ success: false, error: 'Crowdin API client not available' });\n        }\n\n        const userId = connection.context.jwtPayload.context.user_id;\n        const organizationId = connection.context.jwtPayload.context.organization_id;\n        \n        const key = `org_${organizationId}_user_${userId}_preferences`;\n        \n        // Delete data from metadata storage\n        await crowdinApp.deleteMetadata(key);\n        res.json({ success: true, message: 'Data deleted successfully' });\n    } catch (error) {\n        console.error('Delete error:', error);\n        res.status(500).json({ success: false, error: 'Failed to delete data' });\n    }\n});\n```\n\n**Get All Metadata:**\n```typescript\napp.get('/api/all-metadata', async (req: Request, res: Response) => {\n    try {\n        const jwt = req.query.jwt as string;\n        \n        if (!jwt) {\n            return res.status(400).json({ success: false, error: 'JWT token is required' });\n        }\n        \n        if (!crowdinApp.establishCrowdinConnection) {\n            return res.status(500).json({ success: false, error: 'Crowdin connection method not available' });\n        }\n\n        const connection = await crowdinApp.establishCrowdinConnection(jwt, undefined);\n\n        if (!connection.client) {\n            return res.status(500).json({ success: false, error: 'Crowdin API client not available' });\n        }\n\n        // Retrieve all metadata records from storage\n        const allMetadata = await crowdinApp.storage.getAllMetadata();\n        \n        // allMetadata structure:\n        // [\n        //   {\n        //     id: \"org_123_user_456_preferences\",  // key\n        //     data: \"{\"theme\":\"dark\",\"lang\":\"en\"}\", // JSON stringified value\n        //     crowdin_id: \"domain\"     // crowdin identifier (from connection.context.crowdinId during save)\n        //   },\n        //   ...\n        // ]\n        \n        // Parse and format data\n        const formattedData = allMetadata.map(record => ({\n            key: record.id,\n            value: JSON.parse(record.data || '{}'),\n            crowdinId: record.crowdin_id\n        }));\n        \n        res.json({ success: true, metadata: formattedData, count: formattedData.length });\n    } catch (error) {\n        console.error('Error retrieving all metadata:', error);\n        res.status(500).json({ success: false, error: 'Failed to retrieve metadata' });\n    }\n});\n```\n\n**Store Complex Objects:**\n```typescript\n// Save complex user preferences\nconst preferences = {\n    theme: 'dark',\n    language: 'en',\n    notifications: {\n        email: true,\n        push: false,\n        digest: 'weekly'\n    },\n    lastUpdated: new Date().toISOString(),\n    settings: {\n        autoSave: true,\n        confirmActions: true\n    }\n};\n\nconst key = `org_${organizationId}_user_${userId}_preferences`;\nawait crowdinApp.saveMetadata(key, preferences, connection.context.crowdinId);\n\n// Retrieve and update\nconst currentPrefs = await crowdinApp.getMetadata(key) || {};\nconst updatedPrefs = {\n    ...currentPrefs,\n    theme: 'light',\n    lastUpdated: new Date().toISOString()\n};\nawait crowdinApp.saveMetadata(key, updatedPrefs, connection.context.crowdinId);\n```\n\n#### Best Practices\n\n1. **Always use namespaced keys**\n   ```typescript\n   // ‚úÖ CORRECT - includes organization and entity identifiers\n   const key = `org_${organizationId}_user_${userId}_preferences`;\n   const key = `org_${organizationId}_project_${projectId}_cache`;\n   \n   // ‚ùå WRONG - no organization scope, may cause conflicts\n   const key = `user_preferences`;\n   const key = `${userId}_data`;\n   ```\n\n2. **Handle missing data gracefully**\n   ```typescript\n   // ‚úÖ CORRECT - provide defaults for missing data\n   const data = await crowdinApp.getMetadata(key) || { \n       theme: 'auto', \n       language: 'en' \n   };\n   \n   // ‚úÖ CORRECT - check for null/undefined\n   const data = await crowdinApp.getMetadata(key);\n   if (!data) {\n       return defaultSettings;\n   }\n   \n   // ‚ùå WRONG - may cause errors if data is null\n   const theme = data.theme; // Error if data is null\n   ```\n\n3. **Always use the correct identifier for the third parameter**\n   ```typescript\n   // ‚úÖ CORRECT - when connection object is available\n   await crowdinApp.saveMetadata(key, data, connection.context.crowdinId);\n   \n   // ‚úÖ CORRECT - when using webhookContext (no connection object, crowdinApp not available)\n   await crowdinModule.metadataStore.saveMetadata(key, data, `${webhookContext.domain || webhookContext.organizationId}`);\n   \n   // ‚ùå WRONG - don't use organizationId directly\n   await crowdinApp.saveMetadata(key, data, String(organizationId));\n   ```\n\n4. **Use descriptive key patterns**\n   ```typescript\n   // ‚úÖ CORRECT - clear, hierarchical structure\n   `org_${orgId}_user_${userId}_preferences`\n   `org_${orgId}_project_${projectId}_settings`\n   `org_${orgId}_cache_${cacheType}_${identifier}`\n   \n   // ‚ùå WRONG - unclear, hard to maintain\n   `data_${id}`\n   `temp_storage`\n   ```\n\n5. **Handle errors properly**\n   ```typescript\n   // ‚úÖ CORRECT - comprehensive error handling\n   try {\n       await crowdinApp.saveMetadata(key, data, connection.context.crowdinId);\n       return { success: true };\n   } catch (error: any) {\n       console.error('Metadata save failed:', error);\n       return { \n           success: false, \n           error: 'Failed to save data'\n       };\n   }\n   ```\n\n7. **Store only JSON-serializable data**\n   ```typescript\n   // ‚úÖ CORRECT - simple JSON-serializable objects\n   const data = {\n       name: 'John',\n       age: 30,\n       preferences: ['option1', 'option2'],\n       metadata: { key: 'value' }\n   };\n   \n   // ‚ùå WRONG - functions, dates, circular references\n   const data = {\n       name: 'John',\n       callback: () => {},           // Functions don't serialize\n       created: new Date(),           // Dates become strings\n       circular: data                 // Circular reference\n   };\n   \n   // ‚úÖ CORRECT - convert dates to ISO strings\n   const data = {\n       name: 'John',\n       created: new Date().toISOString()\n   };\n   ```\n\n8. **NEVER use KVStore for configurations - use metadata storage instead**\n   ```typescript\n   // ‚úÖ CORRECT - use metadata storage for ALL configuration storage\n   const config = {\n       apiKey: userApiKey,\n       apiEndpoint: 'https://api.example.com',\n       languageMapping: { 'en': 'en-US' }\n   };\n   await crowdinApp.saveMetadata(\n       `config_org_${organizationId}`, \n       config, \n       connection.context.crowdinId\n   );\n   \n   // ‚úÖ CORRECT - read configuration from metadata storage\n   const config = await crowdinApp.getMetadata(`config_org_${organizationId}`) || {};\n   \n   // ‚ùå WRONG - using KVStore for configuration storage\n   const config = {\n       apiKey: userApiKey,\n       apiEndpoint: 'https://api.example.com',\n       languageMapping: { 'en': 'en-US' }\n   };\n   await env.KVStore.put(\n       `config_org_${organizationId}`, \n       JSON.stringify(config)\n   );\n   \n   // ‚ùå WRONG - reading configuration from KVStore\n   const configData = await env.KVStore.get(`config_org_${organizationId}`);\n   const config = JSON.parse(configData || '{}');\n   ```\n\n9. **Use crowdinApp.saveMetadata or crowdinModule.metadataStore.saveMetadata - both implement upsert**\n   ```typescript\n   // ‚úÖ CORRECT - implements upsert (insert or update)\n   await crowdinApp.saveMetadata(\n       key, \n       data, \n       connection.context.crowdinId\n   );\n   \n   // ‚úÖ CORRECT - also implements upsert (insert or update)\n   await crowdinModule.metadataStore.saveMetadata(\n       key, \n       data, \n       connection.context.crowdinId\n   );\n   \n   // ‚ùå WRONG - only insert, NOT upsert (will fail if key already exists)\n   await crowdinApp.storage.saveMetadata(\n       key, \n       data, \n       connection.context.crowdinId\n   );\n   ```\n\n### Cron Scheduling\n\n#### Overview\n\nCron Scheduling allows your app to execute background tasks at specified time intervals.\n\n#### Official Documentation\n\n**üìö Complete Documentation:** Refer to Crowdin Apps SDK documentation for cron scheduling\n\n**‚ö†Ô∏è CRITICAL**: Only specific cron intervals are supported. Using unsupported intervals will result in an error.\n\n#### Supported Intervals\n\nThe following cron expressions are supported:\n\n| Cron Expression | Description | Frequency |\n|----------------|-------------|-----------|\n| `0 * * * *` | Every hour | Runs at minute 0 of every hour |\n| `0 */3 * * *` | Every 3 hours | Runs at minute 0 every 3 hours |\n| `0 */6 * * *` | Every 6 hours | Runs at minute 0 every 6 hours |\n| `0 */12 * * *` | Every 12 hours | Runs at minute 0 every 12 hours |\n| `0 0 * * *` | Daily | Runs at midnight (00:00) every day |\n| `0 0 * * SUN` | Weekly | Runs at midnight (00:00) every Sunday |\n| `0 0 1 * *` | Monthly | Runs at midnight (00:00) on the 1st of each month |\n\n#### Common Examples\n\n**Simple Hourly Task:**\n```typescript\n// In worker/app.ts, after initializing crowdinApp\nconst crowdinApp = crowdinModule.addCrowdinEndpoints(app, configuration) as CrowdinAppUtilities;\n\n// Register cron job - runs every hour\ncrowdinApp.cron.schedule('0 * * * *', async () => {\n    try {\n        console.log('Hourly task started at', new Date().toISOString());\n        \n        // Perform your scheduled task\n        // Example: Check status, update cache, etc.\n        \n        console.log('Task completed');\n    } catch (error) {\n        console.error('Cron job error:', error);\n    }\n});\n```\n\n**Multiple Tasks for Same Schedule:**\n```typescript\n// In worker/app.ts, after initializing crowdinApp\nconst crowdinApp = crowdinModule.addCrowdinEndpoints(app, configuration) as CrowdinAppUtilities;\n\n// Both tasks will run daily at midnight\ncrowdinApp.cron.schedule('0 0 * * *', async () => {\n    try {\n        console.log('Daily cleanup started');\n        // Cleanup old data\n    } catch (error) {\n        console.error('Cleanup error:', error);\n    }\n});\n\ncrowdinApp.cron.schedule('0 0 * * *', async () => {\n    try {\n        console.log('Daily report started');\n        // Generate reports\n    } catch (error) {\n        console.error('Report error:', error);\n    }\n});\n```\n\n**Using Crowdin API Client in Cron Jobs:**\n```typescript\n// In worker/app.ts, after initializing crowdinApp\nconst crowdinApp = crowdinModule.addCrowdinEndpoints(app, configuration) as CrowdinAppUtilities;\n\n// Register cron job that processes data for multiple organizations\ncrowdinApp.cron.schedule('0 0 * * *', async () => {\n    try {\n        console.log('Daily sync started');\n        \n        // Get all metadata records\n        const allMetadata = await crowdinApp.storage.getAllMetadata();\n        \n        if (!allMetadata || allMetadata.length === 0) {\n            console.log('No metadata found, skipping sync');\n            return;\n        }\n        \n        // Filter metadata by pattern using regex (e.g., find all organization configs)\n        const configPattern = /^org_(\\d+)_config$/;\n        const orgConfigs = allMetadata.filter(record => \n            configPattern.test(record.id)\n        );\n        \n        console.log(`Found ${orgConfigs.length} organization configs to process`);\n        \n        // Process each organization separately\n        for (const configRecord of orgConfigs) {\n            try {\n                const match = configRecord.id.match(configPattern);\n                const organizationId = match?.[1];\n                const crowdinId = configRecord.crowdin_id; // domain or organizationId\n                const configData = JSON.parse(configRecord.data || '{}');\n                \n                console.log(`Processing organization ${organizationId}`);\n                \n                // Create individual Crowdin API client for this organization\n                const encryptedData = crowdinApp.encryptCrowdinConnection({\n                    crowdinId,\n                    extra: {}, // Always pass empty object\n                });\n                \n                const { client } = await crowdinApp.dencryptCrowdinConnection(encryptedData, true);\n                \n                // Use client to make API calls for this specific organization\n                const projects = await client.projectsGroupsApi.withFetchAll().listProjects();\n                console.log(`Organization ${organizationId}: Found ${projects.data.length} projects`);\n                \n                // Process organization-specific configuration\n                if (configData.autoSync) {\n                    console.log(`Organization ${organizationId}: Auto-sync enabled, processing...`);\n                    // Perform sync operations\n                }\n                \n            } catch (error) {\n                console.error(`Error processing organization ${organizationId}:`, error);\n                // Continue with next organization\n            }\n        }\n        \n        console.log('Daily sync completed');\n    } catch (error) {\n        console.error('Cron job error:', error);\n    }\n});\n```\n\n#### Best Practices\n\n1. **Use appropriate intervals for your task**\n   ```typescript\n   // ‚úÖ CORRECT - frequent checks for time-sensitive tasks\n   crowdinApp.cron.schedule('0 * * * *', async () => {\n       // Hourly notification checks\n   });\n   \n   // ‚úÖ CORRECT - less frequent for resource-intensive tasks\n   crowdinApp.cron.schedule('0 0 * * *', async () => {\n       // Daily cleanup or report generation\n   });\n   \n   // ‚ùå WRONG - using unsupported interval\n   crowdinApp.cron.schedule('*/5 * * * *', async () => {\n       // Every 5 minutes - NOT SUPPORTED\n   });\n   ```\n\n2. **Handle errors gracefully**\n   ```typescript\n   // ‚úÖ CORRECT - catch and log errors\n   crowdinApp.cron.schedule('0 * * * *', async () => {\n       try {\n           await performTask();\n       } catch (error) {\n           console.error('Cron job failed:', error);\n           // Log error but don't throw - let job complete\n       }\n   });\n   \n   // ‚ùå WRONG - unhandled errors\n   crowdinApp.cron.schedule('0 * * * *', async () => {\n       await performTask(); // May crash if it throws\n   });\n   ```\n\n3. **Keep cron jobs lightweight**\n   ```typescript\n   // ‚úÖ CORRECT - efficient processing\n   crowdinApp.cron.schedule('0 0 * * *', async () => {\n       const startTime = Date.now();\n       console.log('Task started');\n       \n       // Perform lightweight operations\n       await quickCleanup();\n       \n       console.log(`Completed in ${Date.now() - startTime}ms`);\n   });\n   \n   // ‚ùå WRONG - heavy processing that may timeout\n   crowdinApp.cron.schedule('0 * * * *', async () => {\n       // Processing millions of records - may timeout\n       const allData = await fetchAllData();\n       await processAll(allData);\n   });\n   ```\n\n4. **Always await async operations**\n   ```typescript\n   // ‚úÖ CORRECT - await all async operations\n   crowdinApp.cron.schedule('0 * * * *', async () => {\n       await saveData();\n       await processQueue();\n       console.log('All tasks completed');\n   });\n   \n   // ‚úÖ CORRECT - setTimeout with proper promise wrapper\n   crowdinApp.cron.schedule('0 * * * *', async () => {\n       await new Promise((resolve) => {\n           setTimeout(async () => {\n               await processData();\n               resolve();\n           }, 1000);\n       });\n   });\n   \n   // ‚ùå WRONG - promise without await (will not complete)\n   crowdinApp.cron.schedule('0 * * * *', async () => {\n       saveData(); // This will NOT complete before cron job ends\n       console.log('Done'); // Logs immediately, but saveData is not finished\n   });\n   \n   // ‚ùå WRONG - setTimeout without proper promise wrapper\n   crowdinApp.cron.schedule('0 * * * *', async () => {\n       setTimeout(async () => {\n           await processData(); // This will NOT execute\n       }, 1000);\n   });\n   ```\n\n5. **Log execution for debugging**\n   ```typescript\n   // ‚úÖ CORRECT - comprehensive logging\n   crowdinApp.cron.schedule('0 */6 * * *', async () => {\n       const startTime = Date.now();\n       console.log(`Cron job started at ${new Date().toISOString()}`);\n       \n       try {\n           await performTask();\n           console.log(`Completed in ${Date.now() - startTime}ms`);\n       } catch (error) {\n           console.error(`Failed after ${Date.now() - startTime}ms:`, error);\n       }\n   });\n   ```\n\n### Webhooks\n\n#### Overview\n\nWebhooks allow your app to subscribe to events that occur in Crowdin projects or organizations. When a subscribed event happens, Crowdin automatically sends the event data to your app's callback function.\n\n#### Official Documentation\n\n**üìö Complete Documentation:** [Crowdin Webhooks](https://crowdin.github.io/app-project-module/tools/webhook/)\n\n**üìö Available Events:** [Webhook Events List](https://support.crowdin.com/developer/webhooks/)\n\n**‚ö†Ô∏è CRITICAL**: Only use event names from the official events list. Invalid event names will be ignored.\n\n#### Configuration\n\nConfigure webhooks in your app configuration in `worker/app.ts`:\n\n```typescript\nconst configuration: ClientConfig = {\n    // ... other configuration ...\n    \n    // Webhook subscriptions\n    webhooks: [\n        {\n            // List of events to subscribe to\n            events: ['file.added', 'file.updated', 'file.deleted'],\n            \n            // Callback function that handles events\n            callback({ client, events, webhookContext }) {\n                console.log('Received events:', events);\n                console.log('Organization:', webhookContext.organizationId);\n                console.log('User:', webhookContext.userId);\n                \n                // Process events here\n                events.forEach(event => {\n                    console.log('Event:', event.event, 'Project:', event.file.project.id);\n                });\n            },\n            \n            deferResponse: true\n        },\n        {\n            // You can have multiple webhook subscriptions\n            events: ['suggestion.updated', 'string.added'],\n            callback({ client, events, webhookContext }) {\n                // Handle translation events\n            },\n            \n            deferResponse: true\n        }\n    ]\n};\n```\n\n#### Common Examples\n\n**File Events:**\n```typescript\nwebhooks: [\n    {\n        events: ['file.added', 'file.updated', 'file.deleted', 'file.reverted'],\n        async callback({ client, events, webhookContext }) {\n            for (const event of events) {\n                console.log(`File ${event.event} in project ${event.file.project.id}`);\n                console.log('File details:', event.file);\n                \n                // Example: Get project details when file is added\n                if (event.event === 'file.added') {\n                    const project = await client.projectsGroupsApi.getProject(event.file.project.id);\n                    console.log('Project name:', project.data.name);\n                }\n            }\n        },\n        deferResponse: true\n    }\n]\n```\n\n#### Callback Parameters\n\nThe callback function receives an object with three properties:\n\n```typescript\ninterface WebhookCallback {\n    /**\n     * Crowdin API client - use to make API calls\n     * Same client as connection.client in endpoints\n     */\n    client: CrowdinApi;\n    \n    /**\n     * Array of webhook event objects\n     * Multiple events may be batched together\n     */\n    events: WebhookEvent[];\n    \n    /**\n     * Context information about the webhook\n     */\n    webhookContext: {\n        /** Crowdin domain (e.g., \"crowdin.com\") */\n        domain: string;\n        \n        /** Organization ID where event occurred */\n        organizationId: number;\n        \n        /** User ID who installed the application */\n        userId: number;\n        \n        /** Agent ID (if authenticationType is \"crowdin_agent\") */\n        agentId?: number;\n    };\n}\n```\n\n#### Common Event Types\n\n**Project Events:**\n- `project.created` - New project added\n- `project.deleted` - Project deleted\n- `project.translated` - Project fully translated\n- `project.approved` - Project reviewed\n- `project.built` - Project built\n\n**Group Events:**\n- `group.created` - New group added\n- `group.deleted` - Group deleted\n\n**File Events:**\n- `file.added` - New file added to project\n- `file.updated` - File updated\n- `file.deleted` - File deleted from project\n- `file.reverted` - File reverted to previous version\n- `file.translated` - File fully translated\n- `file.approved` - File reviewed\n\n**String Events:**\n- `string.added` - New source string added\n- `string.updated` - Source string updated\n- `string.deleted` - Source string deleted\n\n**Translation Events:**\n- `suggestion.added` - String translation added\n- `suggestion.updated` - String translation updated\n- `suggestion.deleted` - String translation deleted\n- `suggestion.approved` - String translation approved\n- `suggestion.disapproved` - String translation disapproved\n\n**Comment Events:**\n- `stringComment.created` - String comment added\n- `stringComment.updated` - String comment updated\n- `stringComment.deleted` - String comment deleted\n- `stringComment.restored` - String comment restored\n\n**Task Events:**\n- `task.added` - New task added\n- `task.statusChanged` - Task status changed\n- `task.updated` - Task updated\n- `task.deleted` - Task deleted\n\n#### Best Practices\n\n1. **Always set deferResponse to true**\n   ```typescript\n   // ‚úÖ CORRECT - deferResponse is set to true\n   webhooks: [\n       {\n           events: ['file.added'],\n           callback({ client, events, webhookContext }) {\n               console.log('Processing events');\n           },\n           deferResponse: true  // REQUIRED!\n       }\n   ]\n   \n   // ‚ùå WRONG - missing deferResponse\n   webhooks: [\n       {\n           events: ['file.added'],\n           callback({ client, events, webhookContext }) {\n               console.log('Processing events');\n           }\n           // Missing deferResponse: true - this will cause issues!\n       }\n   ]\n   ```\n\n2. **Handle multiple events in batch**\n   ```typescript\n   // ‚úÖ CORRECT - process all events\n   callback({ client, events, webhookContext }) {\n       events.forEach(event => {\n           console.log('Processing event:', event.event);\n       });\n   }\n   \n   // ‚ùå WRONG - only processes first event\n   callback({ client, events, webhookContext }) {\n       const event = events[0];\n       console.log('Processing event:', event.event);\n   }\n   ```\n\n3. **Handle errors gracefully**\n   ```typescript\n   // ‚úÖ CORRECT - catches and logs errors\n   async callback({ client, events, webhookContext }) {\n       for (const event of events) {\n           try {\n               await processEvent(event);\n           } catch (error) {\n               console.error('Failed to process event:', event.event, error);\n               // Continue processing other events\n           }\n       }\n   }\n   ```\n\n4. **Check event type before processing**\n   ```typescript\n   // ‚úÖ CORRECT - checks event type\n   callback({ client, events, webhookContext }) {\n       events.forEach(event => {\n           if (event.event === 'file.added') {\n               console.log('New file:', event.file?.name);\n           } else if (event.event === 'file.updated') {\n               console.log('Updated file:', event.file?.name);\n           }\n       });\n   }\n   ```\n\n5. **Use webhookContext for scoping**\n   ```typescript\n   // ‚úÖ CORRECT - uses context for organization-specific logic\n   async callback({ client, events, webhookContext }) {\n       const orgId = webhookContext.organizationId;\n       const userId = webhookContext.userId;\n       \n       // Store event in metadata\n       const key = `org_${orgId}_events_${Date.now()}`;\n       // await crowdinModule.metadataStore.saveMetadata(key, events, `${webhookContext.domain || webhookContext.organizationId}`);\n   }\n   ```\n\n6. **Don't perform long-running operations**\n   ```typescript\n   // ‚úÖ CORRECT - quick processing, delegate heavy work\n   async callback({ client, events, webhookContext }) {\n       // Quick logging\n       console.log('Received', events.length, 'events');\n       \n       // Store for later processing\n       const key = `org_${webhookContext.organizationId}_queue`;\n       // await crowdinModule.metadataStore.saveMetadata(key, events, `${webhookContext.domain || webhookContext.organizationId}`);\n   }\n   \n   // ‚ö†Ô∏è PROBLEMATIC - long-running operation blocks webhook\n   async callback({ client, events, webhookContext }) {\n       // This might timeout\n       for (const event of events) {\n           await processLargeFile(event.file?.id);\n           await sendMultipleNotifications(event);\n           await updateExternalDatabase(event);\n       }\n   }\n   ```\n\n#### Event Object Structure\n\nEach event type has its own interface with specific fields. Use these interfaces to understand which data is available for each event:\n\n```typescript\n// ============================================================================\n// SHARED MODELS - Reusable data structures\n// ============================================================================\n\ninterface ProjectModel {\n    id: number;\n    name: string;\n    identifier: string;\n    sourceLanguageId: string;\n    targetLanguageIds: string[];\n}\n\ninterface UserModel {\n    id: number;\n    username: string;\n}\n\ninterface LanguageModel {\n    id: string;\n    name: string;\n}\n\ninterface FileModelBase {\n    id: number;\n    name: string;\n    title: string;\n    type: string;\n    path: string;\n    branchId: number | null;\n    directoryId: number | null;\n}\n\ninterface FileModel extends FileModelBase {\n    project: ProjectModel;\n}\n\ninterface GroupModel {\n    id: number;\n    name: string;\n    parentId: number | null;\n}\n\ninterface StringModelBase {\n    id: number;\n    identifier: string;\n    text: string;\n    context: string | null;\n    isHidden: boolean;\n}\n\ninterface StringModel extends StringModelBase {\n    file: FileModelBase;\n    project: ProjectModel;\n}\n\ninterface TranslationModelBase {\n    id: number;\n    text: string;\n}\n\ninterface TranslationModel extends TranslationModelBase {\n    user: UserModel;\n    targetLanguage: LanguageModel;\n    string: StringModel;\n}\n\ninterface TaskModel {\n    id: number;\n    type: 0 | 1; // 0 - Translate, 1 - Proofread\n    title: string;\n    status: 'todo' | 'in_progress' | 'done' | 'closed' | 'pending' | 'review';\n    sourceLanguage: LanguageModel;\n    targetLanguage: LanguageModel;\n    project: ProjectModel;\n    taskCreator: UserModel;\n}\n\ninterface CommentModelBase {\n    id: number;\n    text: string;\n    type: 'issue' | 'comment';\n    issueType: 'general_question' | 'translation_mistake' |  'context_request' |  'source_mistake';\n    issueStatus: 'resolved' | 'unresolved';\n}\n\ninterface CommentModel extends CommentModelBase {\n    string: StringModel;\n    targetLanguage: LanguageModel;\n    user: UserModel;\n    commentResolver: UserModel | null;\n}\n\ninterface BuildModel {\n    id: number;\n    downloadUrl: string;\n    project: ProjectModel;\n}\n\n// ============================================================================\n// BASE EVENT INTERFACES\n// ============================================================================\n\ninterface BaseEventWithUser {\n    user: UserModel;\n}\n\ninterface BaseProjectEvent {\n    project: ProjectModel;\n}\n\ninterface BaseGroupEvent {\n    group: GroupModel;\n}\n\ninterface BaseFileEvent {\n    file: FileModel;\n}\n\ninterface BaseStringEvent {\n    string: StringModel;\n}\n\ninterface BaseTranslationEvent {\n    translation: TranslationModel;\n}\n\ninterface BaseTaskEvent {\n    task: TaskModel;\n}\n\ninterface BaseCommentEvent {\n    comment: CommentModel;\n}\n\n// ============================================================================\n// PROJECT EVENTS\n// ============================================================================\n\ninterface ProjectCreatedEvent extends BaseProjectEvent, BaseEventWithUser {\n    event: 'project.created';\n}\n\ninterface ProjectDeletedEvent extends BaseProjectEvent, BaseEventWithUser {\n    event: 'project.deleted';\n}\n\ninterface ProjectTranslatedEvent extends BaseProjectEvent {\n    event: 'project.translated';\n    targetLanguage: LanguageModel;\n}\n\ninterface ProjectApprovedEvent extends BaseProjectEvent {\n    event: 'project.approved';\n    targetLanguage: LanguageModel;\n}\n\ninterface ProjectBuiltEvent {\n    event: 'project.built';\n    build: BuildModel;\n}\n\n// ============================================================================\n// GROUP EVENTS\n// ============================================================================\n\ninterface GroupCreatedEvent extends BaseGroupEvent, BaseEventWithUser {\n    event: 'group.created';\n}\n\ninterface GroupDeletedEvent extends BaseGroupEvent, BaseEventWithUser {\n    event: 'group.deleted';\n}\n\n// ============================================================================\n// FILE EVENTS\n// ============================================================================\n\ninterface FileAddedEvent extends BaseFileEvent, BaseEventWithUser {\n    event: 'file.added';\n}\n\ninterface FileUpdatedEvent extends BaseFileEvent, BaseEventWithUser {\n    event: 'file.updated';\n}\n\ninterface FileDeletedEvent extends BaseFileEvent, BaseEventWithUser {\n    event: 'file.deleted';\n}\n\ninterface FileRevertedEvent extends BaseFileEvent, BaseEventWithUser {\n    event: 'file.reverted';\n}\n\ninterface FileTranslatedEvent extends BaseFileEvent {\n    event: 'file.translated';\n    targetLanguage: LanguageModel;\n}\n\ninterface FileApprovedEvent extends BaseFileEvent {\n    event: 'file.approved';\n    targetLanguage: LanguageModel;\n}\n\n// ============================================================================\n// STRING EVENTS\n// ============================================================================\n\ninterface StringAddedEvent extends BaseStringEvent, BaseEventWithUser {\n    event: 'string.added';\n}\n\ninterface StringUpdatedEvent extends BaseStringEvent, BaseEventWithUser {\n    event: 'string.updated';\n}\n\ninterface StringDeletedEvent extends BaseStringEvent, BaseEventWithUser {\n    event: 'string.deleted';\n}\n\n// ============================================================================\n// TRANSLATION/SUGGESTION EVENTS\n// ============================================================================\n\ninterface SuggestionAddedEvent extends BaseTranslationEvent {\n    event: 'suggestion.added';\n}\n\ninterface SuggestionUpdatedEvent extends BaseTranslationEvent {\n    event: 'suggestion.updated';\n}\n\ninterface SuggestionDeletedEvent extends BaseTranslationEvent {\n    event: 'suggestion.deleted';\n}\n\ninterface SuggestionApprovedEvent extends BaseTranslationEvent {\n    event: 'suggestion.approved';\n}\n\ninterface SuggestionDisapprovedEvent extends BaseTranslationEvent {\n    event: 'suggestion.disapproved';\n}\n\ninterface TranslationUpdatedEvent {\n    event: 'translation.updated';\n    newTranslation: TranslationModel;\n}\n\n// ============================================================================\n// COMMENT EVENTS\n// ============================================================================\n\ninterface StringCommentCreatedEvent extends BaseCommentEvent {\n    event: 'stringComment.created';\n}\n\ninterface StringCommentUpdatedEvent extends BaseCommentEvent {\n    event: 'stringComment.updated';\n}\n\ninterface StringCommentDeletedEvent extends BaseCommentEvent {\n    event: 'stringComment.deleted';\n}\n\ninterface StringCommentRestoredEvent extends BaseCommentEvent {\n    event: 'stringComment.restored';\n}\n\n// ============================================================================\n// TASK EVENTS\n// ============================================================================\n\ninterface TaskAddedEvent extends BaseTaskEvent {\n    event: 'task.added';\n}\n\ninterface TaskStatusChangedEvent extends BaseTaskEvent {\n    event: 'task.statusChanged';\n}\n\ninterface TaskUpdatedEvent extends BaseTaskEvent {\n    event: 'task.updated';\n}\n\ninterface TaskDeletedEvent extends BaseTaskEvent {\n    event: 'task.deleted';\n}\n\n// ============================================================================\n// UNION TYPE - All possible webhook events\n// ============================================================================\n\ntype WebhookEvent = \n    // Project events\n    | ProjectCreatedEvent\n    | ProjectDeletedEvent\n    | ProjectTranslatedEvent\n    | ProjectApprovedEvent\n    | ProjectBuiltEvent\n    // Group events\n    | GroupCreatedEvent\n    | GroupDeletedEvent\n    // File events\n    | FileAddedEvent\n    | FileUpdatedEvent\n    | FileDeletedEvent\n    | FileRevertedEvent\n    | FileTranslatedEvent\n    | FileApprovedEvent\n    // String events\n    | StringAddedEvent\n    | StringUpdatedEvent\n    | StringDeletedEvent\n    // Translation/Suggestion events\n    | SuggestionAddedEvent\n    | SuggestionUpdatedEvent\n    | SuggestionDeletedEvent\n    | SuggestionApprovedEvent\n    | SuggestionDisapprovedEvent\n    | TranslationUpdatedEvent\n    // Comment events\n    | StringCommentCreatedEvent\n    | StringCommentUpdatedEvent\n    | StringCommentDeletedEvent\n    | StringCommentRestoredEvent\n    // Task events\n    | TaskAddedEvent\n    | TaskStatusChangedEvent\n    | TaskUpdatedEvent\n    | TaskDeletedEvent;\n```\n\n## Frontend Development\n\n### Crowdin Apps JS API\n\n#### Official Documentation\n\nThe `AP` object provides the Crowdin Apps JS API for interacting with the Crowdin application context.\n\n**üìö Complete API Reference:** https://support.crowdin.com/developer/crowdin-apps-js/\n\n**‚ö†Ô∏è CRITICAL**: Only use methods and types from the Crowdin Apps JS API definitions below.\n\n**Do NOT invent methods or properties that are not listed here.**\n\n#### Common Examples\n\n**Get Context (Promise-based):**\n```typescript\n// Promisified helper\nconst getContext = (): Promise<any> => {\n    return new Promise(resolve => window.AP.getContext(resolve));\n};\n\n// Usage\nconst context = await getContext();\nconsole.log('Project ID:', context.project_id);\n```\n\n**Get JWT Token (Promise-based):**\n```typescript\n// Promisified helper\nconst getJwtToken = (): Promise<string> => {\n    return new Promise(resolve => window.AP.getJwtToken(resolve));\n};\n\n// Usage with fetch\nconst token = await getJwtToken();\nconst response = await fetch(`/api/endpoint?jwt=${token}`);\nconst data = await response.json();\n```\n\n#### Best Practices\n\n1. **Handle errors gracefully**\n   ```typescript\n   try {\n       const context = await getContext();\n       if (!context.organization_id) {\n           throw new Error('Organization ID not found');\n       }\n       // Your code\n   } catch (error) {\n       console.error('Failed to get context:', error);\n   }\n   ```\n\n#### Complete Type Definitions\n\n##### Global AP Object Structure\n\n```typescript\ndeclare namespace AP {\n    // Global Actions\n    function getContext(callback: (context: Context) => void): void;\n    function getJwtToken(callback: (token: string) => void): void;\n    function getTheme(): 'light' | 'dark';\n    function redirect(path: string): void;\n    \n    // Editor Module\n    namespace editor {\n        // String Operations\n        function getString(callback: (string: StringInfo) => void): void;\n        function getSelectedStrings(callback: (strings: StringInfo[] | null) => void): void;\n        function getTranslations(callback: (translations: Translation[]) => void): void;\n        function getTopTranslation(callback: (translation: Translation | null) => void): void;\n        \n        // Translation Manipulation\n        function setTranslation(text: string): void;\n        function appendTranslation(text: string): void;\n        function clearTranslation(): void;\n        function setFocus(): void;\n        \n        // Messages\n        function noticeMessage(message: string): void;\n        function successMessage(message: string): void;\n        function errorMessage(message: string): void;\n        function setApplicationNotification(count: number): void;\n        function clearApplicationNotification(): void;\n        \n        // Filters\n        function getCustomFilter(callback: (filter: CustomFilter) => void): void;\n        function setCustomFilter(customFilter: CustomFilter): void;\n        function resetCustomFilter(): void;\n        function getFilter(callback: (filter: number) => void): void;\n        function setFilter(filterNumber: number): void;\n        function getFiltersList(callback: (filters: FilterInfo[]) => void): void;\n        \n        // CroQL Filters\n        function getCroqlFilter(callback: (filter: string) => void): void;\n        function setCroqlFilter(query: string): void;\n        function resetCroqlFilter(): void;\n        \n        // Pagination\n        function getPage(callback: (page: number) => void): void;\n        function setPage(pageNumber: number): void;\n        \n        // Language Operations\n        function getProjectTargetLanguages(callback: (languages: Language[]) => void): void;\n        function setTargetLanguage(languageIdOrIds: string | string[], callback?: () => void): void;\n        \n        // Search\n        function search(text: string, options?: SearchOptions): void;\n        \n        // Workflow Step Status Filter\n        function setWorkflowStepStatusFilter(status: WorkflowStepStatus): void;\n        function getWorkflowStepStatusFilter(callback: (status: WorkflowStepStatus) => void): void;\n        \n        // Editor Mode\n        function getMode(callback: (mode: EditorMode) => void): void;\n        function setMode(mode: EditorMode): void;\n        \n        // Context Menu\n        function registerContextMenuAction(action: ContextMenuAction, callback: (action: ContextMenuActionWithId) => void): void;\n        \n        // File Operations\n        function changeFiles(ids: number[]): void;\n        function isMultipleFilesSelected(callback: (isMultiple: boolean) => void): void;\n        function getSelectedFiles(callback: (files: FileData[]) => void): void;\n    }\n    \n    // Events Module\n    namespace events {\n        function once(event: EditorEvent, callback: (data: any) => void): void;\n        function on(event: EditorEvent, callback: (data: any) => void): void;\n        function off(event: EditorEvent, callback?: (data: any) => void): void;\n        function ofAll(event: EditorEvent): void;\n        function onAny(callback: (event: string, data: any) => void): void;\n        function offAny(callback?: (event: string, data: any) => void): void;\n    }\n}\n```\n\n##### Type Definitions\n\n```typescript\n// Context Information\ninterface Context {\n    project_id: number;\n    organization_id: number;\n    editor?: EditorContext;\n}\n\ninterface EditorContext {\n    mode: 'translate' | 'proofread' | 'review' | 'multilingual';\n    theme: 'light' | 'dark';\n    source_language_id: string;\n    target_language_id: string;\n    file: number;\n    fileData?: FileData;\n    workflow_step?: WorkflowStep;\n}\n\ninterface FileData {\n    id: string;\n    is_plain_text: boolean;\n    type: string;\n    status: string;\n    parent_id: string;\n    node_type: string;\n    created: string;\n    extension: string;\n    priority: string;\n    name: string;\n    upload_ready: number;\n    export_ready: number;\n    export_xliff_ready: number;\n    can_change: number;\n    plural_support: number;\n    excluded_languages: string[];\n    html_preview: boolean;\n    identifier_required: number;\n    total: number;\n    translated: number;\n    approved: number;\n    preTranslated: number;\n    translated_percent: number;\n    approved_percent: number;\n    progress: FileProgress;\n}\n\ninterface FileProgress {\n    total: number;\n    translated: number;\n    approved: number;\n    translated_percent: number;\n    approved_percent: number;\n    pre_translated: number;\n    file_id: number;\n    language_id: number;\n    translation_link: string;\n}\n\n// String Information\ninterface StringInfo {\n    id: number;\n    identifier: string;\n    text: string;\n    context: string;\n    max_length: number;\n    file: FileInfo;\n}\n\ninterface FileInfo {\n    id: number;\n    name: string;\n}\n\n// Translation Information\ninterface Translation {\n    id: number;\n    string_id: number;\n    text: string;\n    target_language_id: string;\n    votes_rating: number;\n    approved: boolean;\n    author: User;\n    created_at: string;\n}\n\ninterface User {\n    id: string;\n    login: string;\n    name: string;\n    avatar_url: string;\n}\n\n// Filter Information\ninterface CustomFilter {\n    added_from: string;\n    added_to: string;\n    updated_from: string;\n    updated_to: string;\n    changed_from: string;\n    changed_to: string;\n    verbal_expression: string;\n    verbal_expression_scope: string;\n    translations: string;\n    duplicates: string;\n    tm_and_mt: string;\n    pre_translation: string;\n    approvals: string;\n    comments: string;\n    screenshots: string;\n    visibility: string;\n    qa_issues: string;\n    labels: number[];\n    label_match_rule: string;\n    exclude_labels: number[];\n    exclude_label_match_rule: string;\n    string_type: string;\n    votes: string;\n    approvals_count_select: string;\n    translated_by_user: string;\n    not_translated_by_user: string;\n    approved_by_user: string;\n    not_approved_by_user: string;\n    approved_by_step: number;\n    approved_step: number;\n    sort_method: number;\n    sort_ascending: number;\n    em: number;\n    croql_expression: string;\n    ai_query: string;\n}\n\ninterface FilterInfo {\n    name: string;\n    value: number;\n}\n\n// Language Information\ninterface Language {\n    id: string;\n    name: string;\n    internal_code: string;\n    code: string;\n    preferred: boolean;\n}\n\n// Workflow Information\ninterface WorkflowStep {\n    id: number;\n    title: string;\n    type: string;\n}\n\n// Search Options (for AP.editor.search)\ninterface SearchOptions {\n    searchStrict: boolean;\n    searchFullMatch: boolean;\n    caseSensitive: boolean;\n    search_option: number; // 1 - Strings, 2 - Context, 3 - Translations, 4 - Identifier (Key), 0 - Everything\n}\n\n// Workflow step statuses (for AP.editor.setWorkflowStepStatusFilter)\ntype WorkflowStepStatus =\n    | 'ALL'\n    | 'TODO'\n    | 'DONE'\n    | 'INCOMPLETE';\n\n// Editor mode (for AP.editor.setMode)\ntype EditorMode =\n    | 'translate'\n    | 'proofread'\n    | 'review'\n    | 'multilingual';\n\n// Context Menu Action (for AP.editor.registerContextMenuAction)\ninterface ContextMenuAction {\n    type: 'textarea-context-menu' | 'source-string-context-menu' | 'source-string-selected-text-context-menu';\n    name: string;\n    children?: ContextMenuChild[];\n}\n\ninterface ContextMenuChild {\n    name: string;\n}\n\ninterface ContextMenuActionWithId extends ContextMenuAction {\n    eventSubscriptionId: string;\n    children?: ContextMenuChildWithId[];\n}\n\ninterface ContextMenuChildWithId extends ContextMenuChild {\n    eventSubscriptionId: string;\n}\n\n// Editor Events\ntype EditorEvent = \n    | 'string.change'\n    | 'string.selected'\n    | 'textarea.edited'\n    | 'translation.added'\n    | 'translation.deleted'\n    | 'translation.restored'\n    | 'translation.vote'\n    | 'translation.approve'\n    | 'translation.disapprove'\n    | 'language.change'\n    | 'file.change'\n    | 'theme.changed'\n    | 'asset.source.preview'\n    | 'asset.suggestion.preview';\n```\n\n##### Event Data Structures\n\n```typescript\n// Event: string.change\ninterface StringChangeEvent {\n    id: number;\n    text: string;\n    context: string;\n    max_length: number;\n    file: FileInfo;\n}\n\n// Event: string.selected\ninterface StringSelectedEvent {\n    string: StringInfo;\n    translations: Record<string, Translation[]>;\n}\n\n// Event: textarea.edited\ninterface TextareaEditedEvent {\n    id: number;\n    text: string;\n    context: string;\n    max_length: number;\n    file: FileInfo;\n    oldText: string;\n    newText: string;\n}\n\n// Event: translation.added\ninterface TranslationAddedEvent extends Translation {}\n\n// Event: translation.deleted\ninterface TranslationDeletedEvent {\n    id: number;\n    string_id: number;\n}\n\n// Event: translation.restored\ninterface TranslationRestoredEvent extends Translation {}\n\n// Event: translation.vote\ninterface TranslationVoteEvent extends Translation {}\n\n// Event: translation.approve\ninterface TranslationApproveEvent extends Translation {\n    approver: User;\n    approved_at: string;\n}\n\n// Event: translation.disapprove\ninterface TranslationDisapproveEvent extends Translation {}\n\n// Event: language.change\ninterface LanguageChangeEvent {\n    project_id: number;\n    organization_id: number;\n    editor: EditorContext;\n}\n\n// Event: file.change\ninterface FileChangeEvent {\n    project_id: number;\n    organization_id: number;\n    editor: EditorContext;\n}\n\n// Event: theme.changed\ntype ThemeChangedEvent = 'light' | 'dark';\n\n// Event: asset.source.preview\ninterface AssetSourcePreviewEvent {\n    project_id: number;\n    organization_id: number;\n    editor: EditorContext;\n}\n\n// Event: asset.suggestion.preview\ninterface AssetSuggestionPreviewEvent {\n    project_id: number;\n    organization_id: number;\n    editor: EditorContext;\n    suggestion: any;\n}\n```\n\n## Development Workflow\n\n### 1. Configure Your App Identity\n\n**‚ö†Ô∏è Important**: You MUST update the configuration in `worker/app.ts` before deployment:\n\n```typescript\nconst configuration: ClientConfig = {\n    name: \"Your App Name\",           // Change this to your app's display name\n    identifier: \"your-app-id\",       // Change to unique identifier (lowercase, hyphens)\n    description: \"Your app description\", // Change to describe your app's purpose\n    // ... rest of configuration\n}\n```\n\n**Note**: The `identifier` must be unique across all Crowdin apps. Use format like: `company-editor-tool`\n\n### 2. Key Files to Modify\n\n- `worker/app.ts` - Add new API endpoints here\n- `src/pages/HomePage.tsx` - Main page component (customize for your app logic)\n- `src/components/app-sidebar.tsx` - Sidebar navigation (customize menu items)\n- `src/components/layout/AppLayout.tsx` - Application layout (customize layout structure)\n- `src/index.css` - Customize global styles and Tailwind theme\n- `tailwind.config.js` - Add custom colors and extend theme"
    }
  },
  {
    "name": "crowdin-ai-provider",
    "language": "typescript",
    "frameworks": [
      "@dnd-kit",
      "@hookform/resolvers",
      "autoprefixer",
      "class-variance-authority",
      "cloudflare",
      "clsx",
      "cmdk",
      "date-fns",
      "express",
      "framer-motion",
      "immer",
      "input-otp",
      "next",
      "postcss",
      "react",
      "recharts",
      "sonner",
      "tailwind",
      "tw-animate-css",
      "typescript",
      "vaul",
      "vite",
      "wrangler",
      "zod",
      "zustand"
    ],
    "description": {
      "selection": "# Template Selection\n\nCrowdin app with AI Provider module.\n\nUse when:\n- Integrating custom AI models (OpenAI, Azure OpenAI, Anthropic, Google Gemini, etc.)\n- Providing AI-powered translation suggestions and content generation\n- Building custom AI features for Crowdin projects\n- Connecting enterprise or proprietary AI services to Crowdin\n- Need dynamic model discovery from AI provider API\n- Implementing AI models with vision, function calling, or JSON mode capabilities\n- Require organization-level AI provider configuration\n- Need to support multiple AI models with different capabilities\n\nAvoid when:\n- Building machine translation integrations (use Custom MT instead)\n- Transforming files during import/export (use File Processing instead)\n- Building editor extensions (use Editor Right Panel instead)\n- Building organization-wide tools (use Organization Menu instead)\n- Building user profile tools (use Profile Resources Menu instead)\n- Building project-specific tools (use Project Tools instead)\n\nBuilt with:\n- Crowdin Apps JS API\n- Crowdin Apps SDK (@crowdin/app-project-module)\n- React\n- ShadCN UI\n- Tailwind\n- Lucide Icons\n- ESLint\n- Vite\n- TypeScript\n- Express.js\n- Cloudflare Workers",
      "usage": "# Usage\n\n## Overview\nCrowdin app with AI Provider module for integrating custom AI models into Crowdin AI features.\n- Backend: TypeScript with Express.js and Crowdin Apps SDK\n- Frontend: React + TypeScript + ShadCN UI + Crowdin Apps JS API\n\n## Tech Stack\n- Crowdin Apps JS API\n- Crowdin Apps SDK (@crowdin/app-project-module)\n- React\n- ShadCN UI\n- Tailwind\n- Lucide Icons\n- ESLint\n- Vite\n- TypeScript\n- Express.js\n- Cloudflare Workers\n\n## Development Restrictions\n- **Tailwind Colors**: Hardcode custom colors in `tailwind.config.js`, NOT in `index.css`\n- **Components**: Use existing ShadCN components instead of writing custom ones\n- **Icons**: Import from `lucide-react` directly\n- **Error Handling**: ErrorBoundary components are pre-implemented\n- **Authentication**: Always use JWT tokens from Crowdin for API requests\n- **AI Provider Configuration**: Don't modify the aiProvider module configuration structure\n- **Scopes**: Ensure your app has appropriate API scopes\n- **Storage Keys**: Always include organizationId in metadata keys to isolate data per organization\n- **Streaming Support**: Add streaming implementation if you need real-time response delivery (set supportsStreaming: true and implement sendEvent callback)\n- **Rate Limits**: Use RateLimitError for 429 status codes from AI provider\n- **Critical Errors**: Throw errors for critical configuration issues (missing API keys, invalid credentials) that prevent the AI service from working\n\n## Styling\n- Responsive, accessible\n- Prefer ShadCN components; Tailwind for layout/spacing/typography\n- Use framer-motion sparingly for micro-interactions\n\n## Project Structure\n\n### Backend Structure\n- `worker/app.ts` - Express app factory with AI Provider module configuration\n- `worker/index.ts` - Cloudflare Worker entry point (HTTP handler, cron scheduler, middleware)\n- `worker/types/` - Backend TypeScript type definitions\n  - `cloudflare-env.d.ts` - Cloudflare environment types (KV storage, secrets)\n\n### Frontend Structure\n- `index.html` - HTML entry point with Crowdin Apps JS API script\n- `src/main.tsx` - React entry point with ErrorBoundary wrapper\n- `src/index.css` - Global styles and Tailwind CSS customizations\n- `src/components/` - React components\n  - `app-sidebar.tsx` - Application sidebar navigation\n  - `ErrorBoundary.tsx` - React error boundary with backend error reporting\n  - `ErrorFallback.tsx` - Fallback UI component for error states\n  - `RouteErrorBoundary.tsx` - Error boundary for routing errors\n  - `layout/` - Layout components\n    - `AppLayout.tsx` - Main application layout wrapper\n  - `ui/` - ShadCN UI components (button, card, sonner, etc.)\n- `src/pages/` - Page components\n  - `HomePage.tsx` - Home page component (main entry point for your app logic)\n- `src/hooks/` - Custom React hooks\n  - `use-mobile.tsx` - Hook for detecting mobile breakpoints\n- `src/lib/` - Utility modules\n  - `utils.ts` - Tailwind utility functions (`cn` for class merging)\n  - `errorReporter.ts` - Client-side error reporting to backend\n  - `apiClient.ts` - Generic API call wrapper with JWT token handling\n- `src/types/` - TypeScript type definitions\n  - `global.d.ts` - Global type declarations\n  - `vite-env.d.ts` - Vite environment types\n\n## Backend Development\n\n### App Configuration\n\nConfigure your app identity in `worker/app.ts`:\n\n```typescript\nconst configuration: ClientConfig = {\n    name: \"Your App Name\",                    // Display name shown in Crowdin UI\n    identifier: \"your-unique-app-identifier\", // Unique ID (lowercase, hyphens)\n    description: \"Your app description\",      // Brief description of functionality\n    // ... rest of configuration\n}\n```\n\n**Guidelines:**\n- **identifier**: Must be unique across all Crowdin apps. Format: `company-ai-provider`\n- **name**: User-friendly display name (e.g., \"Company AI Provider\")\n- **description**: Brief explanation of what your AI Provider does\n\n#### Required Scopes\n\nAdd scopes to configuration in `worker/app.ts` based on your app's functionality.\n\n**‚ö†Ô∏è IMPORTANT**: Only use scopes from the list below. Do not invent or use non-existent scopes!\n\n```typescript\nconst configuration: ClientConfig = {\n    // ... other configuration ...\n    scopes: [\n        // Choose from the following valid scopes:\n        \n        // General scopes\n        crowdinModule.Scope.NOTIFICATIONS,               // 'notification' - Notifications management\n        \n        // Project-level scopes\n        crowdinModule.Scope.PROJECTS,                    // 'project' - Project management\n        crowdinModule.Scope.TASKS,                       // 'project.task' - Project tasks\n        crowdinModule.Scope.REPORTS,                     // 'project.report' - Project reports\n        crowdinModule.Scope.TRANSLATION_STATUS,          // 'project.status' - Translation status\n        crowdinModule.Scope.SOURCE_FILES_AND_STRINGS,    // 'project.source' - Source files and strings\n        crowdinModule.Scope.WEBHOOKS,                    // 'project.webhook' - Project webhooks\n        crowdinModule.Scope.TRANSLATIONS,                // 'project.translation' - Translations\n        crowdinModule.Scope.SCREENSHOTS,                 // 'project.screenshot' - Screenshots\n        \n        // Organization-level scopes\n        crowdinModule.Scope.USERS,                       // 'user' - User management\n        crowdinModule.Scope.TEAMS,                       // 'team' - Team management\n        crowdinModule.Scope.GROUPS,                      // 'group' - Group management\n        crowdinModule.Scope.ORGANIZATION_WEBHOOKS,       // 'webhook' - Organization webhooks\n        crowdinModule.Scope.VENDORS,                     // 'vendor' - Vendor management\n        crowdinModule.Scope.FIELDS,                      // 'field' - Custom fields\n        crowdinModule.Scope.SECURITY_LOGS,               // 'security-log' - Security logs\n        crowdinModule.Scope.APPLICATIONS,                // 'application' - Applications management\n        \n        // Resources\n        crowdinModule.Scope.TRANSLATION_MEMORIES,        // 'tm' - Translation memories\n        crowdinModule.Scope.MACHINE_TRANSLATION_ENGINES, // 'mt' - Machine translation engines\n        crowdinModule.Scope.GLOSSARIES,                  // 'glossary' - Glossaries\n        \n        // AI-related scopes\n        crowdinModule.Scope.AI,                          // 'ai' - AI features\n        crowdinModule.Scope.AI_PROVIDERS,                // 'ai.provider' - AI providers\n        crowdinModule.Scope.AI_PROMPTS,                  // 'ai.prompt' - AI prompts\n        crowdinModule.Scope.AI_PROXIES,                  // 'ai.proxy' - AI proxies\n    ]\n}\n```\n\n### AI Provider Module Configuration\n\nConfigure the AI Provider module in `worker/app.ts`:\n\n```typescript\nimport type { Client } from '@crowdin/crowdin-api-client';\nimport type { CrowdinContextInfo, CrowdinClientRequest, ClientConfig } from '@crowdin/app-project-module/out/types';\nimport type { \n    ChatCompletionMessage, \n    SupportedModels, \n    ChatCompletionResponseMessage,\n    ChatCompletionTool,\n    ChatCompletionChunkMessage,\n    AiToolChoice\n} from '@crowdin/app-project-module/out/modules/ai-provider/types';\nimport type { ExtendedResult } from '@crowdin/app-project-module/out/modules/integration/types';\n\nconst configuration: ClientConfig = {\n    // ... other configuration ...\n\n    aiProvider: {\n        // Settings UI module configuration\n        settingsUiModule: {\n            fileName: 'index.html',\n            uiPath: '/'\n        },\n\n        // Get list of available AI models (required)\n        getModelsList: async ({ client, context }: { client: Client; context: CrowdinContextInfo }): Promise<SupportedModels[]> => {\n            // Fetch models from API\n            // Return array of models with capabilities\n            return [\n                {\n                    id: 'gpt-4o',\n                    supportsJsonMode: true,\n                    supportsFunctionCalling: true,\n                    supportsStreaming: true,\n                    supportsVision: true,\n                    contextWindowLimit: 128000,\n                    outputLimit: 16384,\n                }\n            ];\n        },\n        \n        // Handle chat completion requests (required)\n        chatCompletions: async ({\n                messages,\n                model,\n                action,\n                responseFormat,\n                client,\n                context,\n                req,\n                isStream,\n                sendEvent,\n                tools,\n                toolChoice,\n            }: {\n                messages: ChatCompletionMessage[];\n                model: string;\n                action: string;\n                responseFormat: string;\n                client: Client;\n                context: CrowdinContextInfo;\n                req: CrowdinClientRequest;\n                isStream: boolean;\n                sendEvent: (chunk: ChatCompletionChunkMessage) => Promise<void>;\n                tools?: ChatCompletionTool[];\n                toolChoice?: string | AiToolChoice;\n            }): Promise<ChatCompletionResponseMessage[] | ExtendedResult<ChatCompletionResponseMessage[]> | void> => {\n            // Your AI integration logic here\n            const response = await fetch('https://api.openai.com/v1/chat/completions', {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                    'Authorization': `Bearer ${apiKey}`,\n                },\n                body: JSON.stringify({ model, messages }),\n            });\n            \n            const data = await response.json();\n            \n            return [{\n                role: 'assistant',\n                content: data.choices[0].message.content,\n            }];\n        },\n    }\n}\n```\n\n#### Common Examples\n\n**Dynamic Model Discovery from OpenAI API:**\n```typescript\nimport type { Client } from '@crowdin/crowdin-api-client';\nimport type { CrowdinContextInfo } from '@crowdin/app-project-module/out/types';\nimport type { SupportedModels } from '@crowdin/app-project-module/out/modules/ai-provider/types';\n\nconst configuration = {\n    // ... other configuration ...\n\n    getModelsList: async ({ client, context }: { client: Client; context: CrowdinContextInfo }): Promise<SupportedModels[]> => {\n        const organizationId = context.jwtPayload.context.organization_id;\n        const configKey = `ai_provider_config_org_${organizationId}`;\n        const config = await crowdinModule.metadataStore.getMetadata(configKey) || {};\n\n        if (!config.apiKey) {\n            return []; // No API key - return empty list\n        }\n\n        const apiEndpoint = config.apiEndpoint || 'https://api.openai.com/v1';\n\n        try {\n            const response = await fetch(`${apiEndpoint}/models`, {\n                method: 'GET',\n                headers: {\n                    'Authorization': `Bearer ${config.apiKey}`,\n                },\n            });\n\n            if (!response.ok) {\n                return []; // Fallback to empty list on error\n            }\n\n            const data = await response.json();\n\n            // Map models with capabilities\n            return data.data.map(model => ({\n                id: model.id,\n                supportsJsonMode: true,\n                supportsFunctionCalling: true,\n                supportsStreaming: true,\n                supportsVision: true,\n                contextWindowLimit: 128000,\n                outputLimit: 16384,\n            }));\n        } catch (error) {\n            console.error('Error fetching models:', error);\n            throw error;\n        }\n    }\n}\n```\n\n**Chat Completions with OpenAI:**\n```typescript\nimport type { Client } from '@crowdin/crowdin-api-client';\nimport type { CrowdinContextInfo, CrowdinClientRequest } from '@crowdin/app-project-module/out/types';\nimport type { \n    ChatCompletionMessage, \n    ChatCompletionResponseMessage,\n    ChatCompletionTool,\n    ChatCompletionChunkMessage,\n    AiToolChoice\n} from '@crowdin/app-project-module/out/modules/ai-provider/types';\nimport type { ExtendedResult } from '@crowdin/app-project-module/out/modules/integration/types';\n\nconst configuration: ClientConfig = {\n    // ... other configuration ...\n\n    chatCompletions: async ({\n        messages,\n        model,\n        action,\n        responseFormat,\n        client,\n        context,\n        req,\n        isStream,\n        sendEvent,\n        tools,\n        toolChoice,\n    }: {\n        messages: ChatCompletionMessage[];\n        model: string;\n        action: string;\n        responseFormat: string;\n        client: Client;\n        context: CrowdinContextInfo;\n        req: CrowdinClientRequest;\n        isStream: boolean;\n        sendEvent: (chunk: ChatCompletionChunkMessage) => Promise<void>;\n        tools?: ChatCompletionTool[];\n        toolChoice?: string | AiToolChoice;\n    }): Promise<ChatCompletionResponseMessage[] | ExtendedResult<ChatCompletionResponseMessage[]> | void> => {\n        const organizationId = context.jwtPayload.context.organization_id;\n        const configKey = `ai_provider_config_org_${organizationId}`;\n        const config = await crowdinModule.metadataStore.getMetadata(configKey) || {};\n\n        if (!config.apiKey) {\n            throw new Error('OpenAI API key is not configured.');\n        }\n\n        const apiEndpoint = config.apiEndpoint || 'https://api.openai.com/v1';\n\n        // Prepare request body\n        const requestBody: any = {\n            model,\n            messages,\n            stream: isStream,\n        };\n\n        // Add optional parameters\n        if (responseFormat) {\n            requestBody.response_format = { type: responseFormat };\n        }\n        if (tools && tools.length > 0) {\n            requestBody.tools = tools;\n        }\n        if (toolChoice) {\n            requestBody.tool_choice = toolChoice;\n        }\n\n        // Note: Streaming support\n        // If you need real-time response delivery, implement streaming:\n        // 1. Set supportsStreaming: true in model capabilities\n        // 2. Check if (isStream && sendEvent) here\n        // 3. Parse SSE stream and call sendEvent({ content: chunk }) for each chunk\n        // 4. Return early without returning a value\n\n        try {\n            const response = await fetch(`${apiEndpoint}/chat/completions`, {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                    'Authorization': `Bearer ${config.apiKey}`,\n                },\n                body: JSON.stringify(requestBody),\n            });\n\n            if (!response.ok) {\n                const errorText = await response.text();\n                if (response.status === 429) {\n                    throw new RateLimitError({\n                        message: 'OpenAI API rate limit reached. Please try again later.',\n                        error: new Error(errorText)\n                    });\n                }\n                throw new Error(`OpenAI API error: ${response.status} - ${errorText}`);\n            }\n\n            const data = await response.json();\n            const message = data.choices?.[0]?.message;\n\n            if (!message) {\n                throw new Error('No message in OpenAI response');\n            }\n\n            return [{\n                role: 'assistant',\n                content: message.content || '',\n                tool_calls: message.tool_calls,\n            }];\n        } catch (error) {\n            console.error('Error in chat completion:', error);\n            throw error;\n        }\n    }\n}\n```\n\n#### Best Practices\n\n1. **Handle rate limits with RateLimitError**\n   ```typescript\n   // ‚úÖ CORRECT - uses RateLimitError for 429 status\n   chatCompletions: async ({\n        messages,\n        model,\n        action,\n        responseFormat,\n        client,\n        context,\n        req,\n        isStream,\n        sendEvent,\n        tools,\n        toolChoice,\n    }: {\n        messages: ChatCompletionMessage[];\n        model: string;\n        action: string;\n        responseFormat: string;\n        client: Client;\n        context: CrowdinContextInfo;\n        req: CrowdinClientRequest;\n        isStream: boolean;\n        sendEvent: (chunk: ChatCompletionChunkMessage) => Promise<void>;\n        tools?: ChatCompletionTool[];\n        toolChoice?: string | AiToolChoice;\n    }): Promise<ChatCompletionResponseMessage[] | ExtendedResult<ChatCompletionResponseMessage[]> | void> => {\n       const response = await fetch(`${apiEndpoint}/chat/completions`, {...});\n       \n       if (!response.ok) {\n           if (response.status === 429) {\n               const errorText = await response.text();\n               throw new RateLimitError({\n                   message: 'OpenAI API rate limit reached. Please try again later.',\n                   error: new Error(errorText)\n               });\n           }\n           throw new Error(`API error: ${response.status}`);\n       }\n       \n       // Process response...\n   }\n   \n   // ‚ùå WRONG - generic error for rate limits\n   chatCompletions: async ({\n        messages,\n        model,\n        action,\n        responseFormat,\n        client,\n        context,\n        req,\n        isStream,\n        sendEvent,\n        tools,\n        toolChoice,\n    }: {\n        messages: ChatCompletionMessage[];\n        model: string;\n        action: string;\n        responseFormat: string;\n        client: Client;\n        context: CrowdinContextInfo;\n        req: CrowdinClientRequest;\n        isStream: boolean;\n        sendEvent: (chunk: ChatCompletionChunkMessage) => Promise<void>;\n        tools?: ChatCompletionTool[];\n        toolChoice?: string | AiToolChoice;\n    }): Promise<ChatCompletionResponseMessage[] | ExtendedResult<ChatCompletionResponseMessage[]> | void> => {\n       const response = await fetch(`${apiEndpoint}/chat/completions`, {...});\n       \n       if (!response.ok) {\n           // BAD: Doesn't distinguish rate limit errors\n           throw new Error(`API error: ${response.status}`);\n       }\n   }\n   ```\n\n2. **Always return proper response format**\n   ```typescript\n   // ‚úÖ CORRECT - returns array of ChatCompletionResponseMessage\n   chatCompletions: async ({\n        messages,\n        model,\n        action,\n        responseFormat,\n        client,\n        context,\n        req,\n        isStream,\n        sendEvent,\n        tools,\n        toolChoice,\n    }: {\n        messages: ChatCompletionMessage[];\n        model: string;\n        action: string;\n        responseFormat: string;\n        client: Client;\n        context: CrowdinContextInfo;\n        req: CrowdinClientRequest;\n        isStream: boolean;\n        sendEvent: (chunk: ChatCompletionChunkMessage) => Promise<void>;\n        tools?: ChatCompletionTool[];\n        toolChoice?: string | AiToolChoice;\n    }): Promise<ChatCompletionResponseMessage[] | ExtendedResult<ChatCompletionResponseMessage[]> | void> => {\n       const data = await response.json();\n       const message = data.choices?.[0]?.message;\n       \n       return [{\n           role: 'assistant',\n           content: message.content || '',\n           tool_calls: message.tool_calls,\n       }];\n   }\n   \n   // ‚ùå WRONG - returns raw string instead of proper message object\n   chatCompletions: async ({\n        messages,\n        model,\n        action,\n        responseFormat,\n        client,\n        context,\n        req,\n        isStream,\n        sendEvent,\n        tools,\n        toolChoice,\n    }: {\n        messages: ChatCompletionMessage[];\n        model: string;\n        action: string;\n        responseFormat: string;\n        client: Client;\n        context: CrowdinContextInfo;\n        req: CrowdinClientRequest;\n        isStream: boolean;\n        sendEvent: (chunk: ChatCompletionChunkMessage) => Promise<void>;\n        tools?: ChatCompletionTool[];\n        toolChoice?: string | AiToolChoice;\n    }): Promise<ChatCompletionResponseMessage[] | ExtendedResult<ChatCompletionResponseMessage[]> | void> => {\n       const data = await response.json();\n       \n       // BAD: Wrong return format\n       return data.choices[0].message.content;\n   }\n   ```\n\n3. **Throw errors for critical configuration issues**\n   ```typescript\n   // ‚úÖ CORRECT - checks API key at the start\n   chatCompletions: async ({\n        messages,\n        model,\n        action,\n        responseFormat,\n        client,\n        context,\n        req,\n        isStream,\n        sendEvent,\n        tools,\n        toolChoice,\n    }: {\n        messages: ChatCompletionMessage[];\n        model: string;\n        action: string;\n        responseFormat: string;\n        client: Client;\n        context: CrowdinContextInfo;\n        req: CrowdinClientRequest;\n        isStream: boolean;\n        sendEvent: (chunk: ChatCompletionChunkMessage) => Promise<void>;\n        tools?: ChatCompletionTool[];\n        toolChoice?: string | AiToolChoice;\n    }): Promise<ChatCompletionResponseMessage[] | ExtendedResult<ChatCompletionResponseMessage[]> | void> => {\n       const organizationId = context.jwtPayload.context.organization_id;\n       const configKey = `ai_provider_config_org_${organizationId}`;\n       const config = await crowdinModule.metadataStore.getMetadata(configKey) || {};\n       \n       // Check for critical configuration\n       if (!config.apiKey) {\n           throw new Error('OpenAI API key is not configured. Please configure it in the app settings.');\n       }\n       \n       // Proceed with API call\n       const response = await fetch(`${apiEndpoint}/chat/completions`, {...});\n       // ... process response\n   }\n   \n   // ‚ùå WRONG - doesn't check configuration, fails silently\n   chatCompletions: async ({\n        messages,\n        model,\n        action,\n        responseFormat,\n        client,\n        context,\n        req,\n        isStream,\n        sendEvent,\n        tools,\n        toolChoice,\n    }: {\n        messages: ChatCompletionMessage[];\n        model: string;\n        action: string;\n        responseFormat: string;\n        client: Client;\n        context: CrowdinContextInfo;\n        req: CrowdinClientRequest;\n        isStream: boolean;\n        sendEvent: (chunk: ChatCompletionChunkMessage) => Promise<void>;\n        tools?: ChatCompletionTool[];\n        toolChoice?: string | AiToolChoice;\n    }): Promise<ChatCompletionResponseMessage[] | ExtendedResult<ChatCompletionResponseMessage[]> | void> => {\n       const config = await crowdinModule.metadataStore.getMetadata(configKey) || {};\n       \n       // BAD: Uses config without checking if apiKey exists\n       const response = await fetch(`${apiEndpoint}/chat/completions`, {\n           headers: {\n               'Authorization': `Bearer ${config.apiKey}`, // May be undefined!\n           }\n       });\n   }\n   ```\n\n4. **Use MODEL_CAPABILITIES for known models**\n   ```typescript\n   // ‚úÖ CORRECT - provides capabilities for known models, defaults for others\n   const MODEL_CAPABILITIES: Record<string, Partial<SupportedModels>> = {\n       'gpt-4o': {\n           supportsJsonMode: true,\n           supportsFunctionCalling: true,\n           supportsStreaming: false,\n           supportsVision: true,\n           contextWindowLimit: 128000,\n           outputLimit: 16384,\n       },\n       // ... other known models\n   };\n   \n   getModelsList: async ({ client, context }: { client: Client; context: CrowdinContextInfo }): Promise<SupportedModels[]> => {\n       const data = await response.json();\n       \n       return data.data.map(model => {\n           // Use predefined capabilities or defaults\n           const capabilities = MODEL_CAPABILITIES[model.id] || {\n               supportsJsonMode: false,\n               supportsFunctionCalling: false,\n               supportsStreaming: false,\n               supportsVision: false,\n               contextWindowLimit: 4096,\n               outputLimit: 4096,\n           };\n           \n           return { id: model.id, ...capabilities };\n       });\n   }\n   \n   // ‚ùå WRONG - hardcodes models, doesn't fetch from API\n   getModelsList: async ({ client, context }: { client: Client; context: CrowdinContextInfo }): Promise<SupportedModels[]> => {\n       // BAD: Static list, won't include new models from OpenAI\n       return [\n           { id: 'gpt-4o', supportsJsonMode: true, ... },\n           { id: 'gpt-4', supportsJsonMode: true, ... },\n       ];\n   }\n   ```\n\n5. **Use context information for organization-specific settings**\n   ```typescript\n   // ‚úÖ CORRECT - loads organization-specific configuration\n   chatCompletions: async ({\n        messages,\n        model,\n        action,\n        responseFormat,\n        client,\n        context,\n        req,\n        isStream,\n        sendEvent,\n        tools,\n        toolChoice,\n    }: {\n        messages: ChatCompletionMessage[];\n        model: string;\n        action: string;\n        responseFormat: string;\n        client: Client;\n        context: CrowdinContextInfo;\n        req: CrowdinClientRequest;\n        isStream: boolean;\n        sendEvent: (chunk: ChatCompletionChunkMessage) => Promise<void>;\n        tools?: ChatCompletionTool[];\n        toolChoice?: string | AiToolChoice;\n    }): Promise<ChatCompletionResponseMessage[] | ExtendedResult<ChatCompletionResponseMessage[]> | void> => {\n       const orgId = context.jwtPayload.context.organization_id;\n       \n       // Load organization-specific AI provider settings\n       const configKey = `ai_provider_config_org_${orgId}`;\n       const config = await crowdinModule.metadataStore.getMetadata(configKey) || {};\n       \n       // Use organization's custom endpoint or default\n       const apiEndpoint = config.apiEndpoint || 'https://api.openai.com/v1';\n       \n       // Make request with organization's API key\n       const response = await fetch(`${apiEndpoint}/chat/completions`, {\n           headers: {\n               'Authorization': `Bearer ${config.apiKey}`,\n           },\n           // ...\n       });\n   }\n   \n   // ‚ùå WRONG - uses hardcoded configuration\n   chatCompletions: async ({\n        messages,\n        model,\n        action,\n        responseFormat,\n        client,\n        context,\n        req,\n        isStream,\n        sendEvent,\n        tools,\n        toolChoice,\n    }: {\n        messages: ChatCompletionMessage[];\n        model: string;\n        action: string;\n        responseFormat: string;\n        client: Client;\n        context: CrowdinContextInfo;\n        req: CrowdinClientRequest;\n        isStream: boolean;\n        sendEvent: (chunk: ChatCompletionChunkMessage) => Promise<void>;\n        tools?: ChatCompletionTool[];\n        toolChoice?: string | AiToolChoice;\n    }): Promise<ChatCompletionResponseMessage[] | ExtendedResult<ChatCompletionResponseMessage[]> | void> => {\n       // BAD: Hardcoded API key and endpoint\n       const response = await fetch('https://api.openai.com/v1/chat/completions', {\n           headers: {\n               'Authorization': 'Bearer sk-hardcoded-key',\n           },\n       });\n   }\n   ```\n\n#### Complete Type Definitions\n\n**‚ö†Ô∏è CRITICAL**: Only use types from `@crowdin/app-project-module`.\n\n**Do NOT invent methods or properties that are not listed here.**\n\n##### out/types.d.ts\n\n```typescript\nexport interface CrowdinContextInfo {\n    jwtPayload: JwtPayload;\n    crowdinId: string;\n    clientId: string;\n    appIdentifier: string;\n}\n\ninterface JwtPayload {\n    aud: string;\n    sub: string;\n    domain?: string;\n    module?: string;\n    context: JwtPayloadContext;\n    iat: number;\n    exp: number;\n    code?: string;\n}\n\nexport interface JwtPayloadContext {\n    project_id: number;\n    project_identifier?: string;\n    organization_id: number;\n    organization_domain?: string;\n    user_id: number;\n    user_login?: string;\n}\n\n// ... other types (CrowdinClientRequest, Environments, ModuleKey, UiModule, etc.)\n// See @crowdin/app-project-module/out/types.d.ts for complete type definitions\n```\n\n<!-- AI_PROVIDER_TYPES_START -->\n##### out/modules/ai-provider/types.d.ts\n\n```typescript\nimport { CrowdinClientRequest, CrowdinContextInfo, Environments, ModuleKey, UiModule } from '../../types';\nimport Crowdin from '@crowdin/crowdin-api-client';\nimport { ExtendedResult } from '../integration/types';\n\nexport interface AiProviderModule extends Environments, ModuleKey {\n    name?: string;\n    description?: string;\n    settingsUiModule?: UiModule;\n    chatCompletions: ({\n        messages,\n        model,\n        action,\n        responseFormat,\n        client,\n        context,\n        req,\n        isStream,\n        sendEvent,\n        tools,\n        toolChoice,\n    }: {\n        messages: ChatCompletionMessage[];\n        model: string;\n        action: string;\n        responseFormat: string;\n        client: Crowdin;\n        context: CrowdinContextInfo;\n        req: CrowdinClientRequest;\n        isStream: boolean;\n        sendEvent: (chunk: ChatCompletionChunkMessage) => Promise<void>;\n        tools?: ChatCompletionTool[];\n        toolChoice?: string | AiToolChoice;\n    }) => Promise<ChatCompletionResponseMessage[] | ExtendedResult<ChatCompletionResponseMessage[]> | void>;\n    getModelsList: ({\n        client,\n        context,\n    }: {\n        client: Crowdin;\n        context: CrowdinContextInfo;\n    }) => Promise<SupportedModels[]>;\n}\n\nexport interface SupportedModels {\n    id: string;\n    supportsJsonMode?: boolean;\n    supportsFunctionCalling?: boolean;\n    supportsStreaming?: boolean;\n    supportsVision?: boolean;\n    contextWindowLimit?: number;\n    outputLimit?: number;\n}\n\nexport interface ChatCompletionTool {\n    type: 'function';\n    function: ChatCompletionToolFunctionDeclaration;\n}\n\nexport interface ChatCompletionToolFunctionDeclaration {\n    name: string;\n    description?: string;\n    parameters?: object;\n}\n\nexport interface AiToolChoice {\n    type: 'function';\n    function: {\n        name: string;\n    };\n}\n\nexport type ChatCompletionMessage =\n    | ChatCompletionSystemMessage\n    | ChatCompletionUserMessage\n    | ChatCompletionAssistantMessage\n    | ChatCompletionToolMessage;\n\nexport interface ChatCompletionSystemMessage {\n    role: 'system';\n    content: string | ChatCompletionContentPartText[];\n}\n\nexport interface ChatCompletionUserMessage {\n    role?: 'user';\n    content: string | ChatCompletionContentPart[];\n}\n\nexport type ChatCompletionResponseMessage = ChatCompletionAssistantMessage;\n\nexport interface ChatCompletionAssistantMessage {\n    role?: 'assistant';\n    content?: string | ChatCompletionContentPartText[] | null;\n    tool_calls?: ChatCompletionMessageToolCall[] | null;\n}\n\nexport interface ChatCompletionChunkMessage {\n    role?: ROLES;\n    content?: string | null;\n    tool_calls?: ChatCompletionDeltaMessageToolCall[];\n}\n\nexport interface ChatCompletionToolMessage {\n    content: string | ChatCompletionContentPartText[];\n    role: 'tool';\n    tool_call_id: string;\n}\n\nexport type ROLES = 'user' | 'assistant' | 'system' | 'tool';\n\nexport type ChatCompletionContentPart = ChatCompletionContentPartText | ChatCompletionContentPartImage;\n\nexport type ChatCompletionContentPartText = {\n    type: 'text';\n    text: string;\n};\n\nexport type ChatCompletionContentPartImage = {\n    type: 'image_url';\n    image_url: {\n        url: string;\n    };\n};\n\nexport interface ChatCompletionMessageToolCall {\n    id: string;\n    type: 'function';\n    function: {\n        arguments?: string;\n        name: string;\n    };\n}\n\nexport interface ChatCompletionDeltaMessageToolCall {\n    index: number;\n    id?: string;\n    type?: 'function';\n    function?: {\n        arguments?: string;\n        name?: string;\n    };\n}\n\nexport interface InputMessage {\n    role?: ROLES;\n    content: string | InputContentPart[];\n}\n\nexport type InputContentPart = ChatCompletionContentPartText | InputChatCompletionContentPartImage;\n\nexport type InputChatCompletionContentPartImage = {\n    type: 'image';\n    mimeType: string;\n    url: string;\n};\n```\n<!-- AI_PROVIDER_TYPES_END -->\n\n### API Endpoints Best Practices\n\n#### Common Examples\n\n**Standard Endpoint:**\n```typescript\napp.post('/api/process-data', async (req: Request, res: Response) => {\n    try {\n        const jwt = req.query.jwt as string;\n        const { data } = req.body;\n        \n        if (!jwt) {\n            return res.status(400).json({ success: false, error: 'JWT token is required' });\n        }\n        if (!data) {\n            return res.status(400).json({ success: false, error: 'Data is required' });\n        }\n\n        const connection = await crowdinApp.establishCrowdinConnection(jwt, undefined);\n        \n        // Your async logic here\n        const result = await processData(data);\n        \n        res.json({ \n            success: true, \n            result\n        });\n    } catch (error) {\n        console.error('Error:', error);\n        res.status(500).json({ success: false, error: 'Operation failed' });\n    }\n});\n```\n\n#### Best Practices\n\n1. **Always await async operations**\n   ```typescript\n   // ‚úÖ CORRECT - all operations are awaited\n   app.post('/api/save-config', async (req: Request, res: Response) => {\n       const jwt = req.query.jwt as string;\n       const connection = await crowdinApp.establishCrowdinConnection(jwt, undefined);\n       \n       await crowdinApp.saveMetadata(key, data, connection.context.crowdinId);\n       \n       res.json({ success: true });\n   });\n   \n   // ‚ùå WRONG - missing await, operation will NOT complete\n   app.post('/api/save-config', async (req: Request, res: Response) => {\n       const jwt = req.query.jwt as string;\n       const connection = await crowdinApp.establishCrowdinConnection(jwt, undefined);\n       \n       // This will NOT save! Response is sent before operation completes\n       crowdinApp.saveMetadata(key, data, connection.context.crowdinId);\n       \n       res.json({ success: true });\n   });\n   ```\n\n2. **Always return response after all operations complete**\n   ```typescript\n   // ‚úÖ CORRECT - response sent after all operations\n   app.post('/api/update', async (req: Request, res: Response) => {\n       const connection = await crowdinApp.establishCrowdinConnection(jwt, undefined);\n       \n       await operation1();\n       await operation2();\n       await operation3();\n       \n       res.json({ success: true }); // All operations completed\n   });\n   \n   // ‚ùå WRONG - response sent too early\n   app.post('/api/update', async (req: Request, res: Response) => {\n       const connection = await crowdinApp.establishCrowdinConnection(jwt, undefined);\n       \n       res.json({ success: true }); // Sent immediately\n       \n       await operation1(); // These will NOT execute\n       await operation2();\n       await operation3();\n   });\n   ```\n\n3. **Use Promise.all for independent parallel operations**\n   ```typescript\n   // ‚úÖ CORRECT - parallel operations (faster)\n   const [result1, result2, result3] = await Promise.all([\n       connection.client.projectsGroupsApi.getProject(id1),\n       connection.client.projectsGroupsApi.getProject(id2),\n       connection.client.projectsGroupsApi.getProject(id3)\n   ]);\n   \n   // ‚ùå WRONG - sequential operations (slower)\n   const result1 = await connection.client.projectsGroupsApi.getProject(id1);\n   const result2 = await connection.client.projectsGroupsApi.getProject(id2);\n   const result3 = await connection.client.projectsGroupsApi.getProject(id3);\n   ```\n\n4. **Wrap all async code in try-catch**\n   ```typescript\n   // ‚úÖ CORRECT - comprehensive error handling\n   app.get('/api/data', async (req: Request, res: Response) => {\n       try {\n           const connection = await crowdinApp.establishCrowdinConnection(jwt, undefined);\n           const data = await fetchData();\n           res.json({ success: true, data });\n       } catch (error) {\n           console.error('Error:', error);\n           res.status(500).json({ success: false, error: 'Operation failed' });\n       }\n   });\n   \n   // ‚ùå WRONG - no error handling\n   app.get('/api/data', async (req: Request, res: Response) => {\n       const connection = await crowdinApp.establishCrowdinConnection(jwt, undefined);\n       const data = await fetchData(); // May throw unhandled error\n       res.json({ success: true, data });\n   });\n   ```\n\n5. **Never use setTimeout without proper promise wrapper**\n   ```typescript\n   // ‚úÖ CORRECT - setTimeout with promise wrapper\n   app.get('/api/delayed', async (req: Request, res: Response) => {\n       await new Promise((resolve) => {\n           setTimeout(async () => {\n               await saveData();\n               resolve(undefined);\n           }, 1000);\n       });\n       \n       res.json({ success: true });\n   });\n   \n   // ‚ùå WRONG - setTimeout without await (will NOT execute)\n   app.get('/api/delayed', async (req: Request, res: Response) => {\n       setTimeout(async () => {\n           await saveData(); // This will NOT execute\n       }, 1000);\n       \n       res.json({ success: true }); // Sent immediately\n   });\n   ```\n\n6. **Always check for required parameters early**\n   ```typescript\n   // ‚úÖ CORRECT - validate parameters first\n   app.post('/api/process', async (req: Request, res: Response) => {\n       const jwt = req.query.jwt as string;\n       const { projectId, data } = req.body;\n       \n       // Validate early\n       if (!jwt) {\n           return res.status(400).json({ error: 'JWT token is required' });\n       }\n       if (!projectId) {\n           return res.status(400).json({ error: 'Project ID is required' });\n       }\n       if (!data) {\n           return res.status(400).json({ error: 'Data is required' });\n       }\n       \n       // Continue with processing\n       const connection = await crowdinApp.establishCrowdinConnection(jwt, undefined);\n       // ... rest of the logic\n   });\n   ```\n\n### Crowdin API Client\n\n#### Official Documentation\n\nThe `connection.client` object is an instance of `@crowdin/crowdin-api-client`.\n\n**üìö Complete API Reference:** https://crowdin.github.io/crowdin-api-client-js/modules.html\n\n**‚ö†Ô∏è CRITICAL**: Only use methods documented in the official API reference. Do NOT invent or assume methods exist.\n\n#### Common Examples\n\n**Standard Endpoint Template:**\n```typescript\napp.get('/api/your-endpoint', async (req: Request, res: Response) => {\n    try {\n        const jwt = req.query.jwt as string;\n        if (!jwt) {\n            return res.status(400).json({ success: false, error: 'JWT token is required' });\n        }\n\n        if (!crowdinApp.establishCrowdinConnection) {\n            return res.status(500).json({ success: false, error: 'Crowdin connection method not available' });\n        }\n\n        const connection = await crowdinApp.establishCrowdinConnection(jwt, undefined);\n\n        if (!connection.client) {\n            return res.status(500).json({ success: false, error: 'Crowdin API client not available' });\n        }\n\n        const userId = connection.context.jwtPayload.context.user_id;\n        const organizationId = connection.context.jwtPayload.context.organization_id;\n\n        // Your logic here using connection.client API\n        \n        res.status(200).json({ success: true, data: result });\n    } catch (error) {\n        console.error('Error:', error);\n        res.status(500).json({ success: false, error: 'Operation failed' });\n    }\n});\n```\n\n**Get Project Details:**\n```typescript\nconst response = await connection.client.projectsGroupsApi.getProject(projectId);\n\n// Access project properties\nconst project = response.data;\nconst projectName = project.name;                    // string\nconst sourceLanguageId = project.sourceLanguageId;   // string\nconst targetLanguageIds = project.targetLanguageIds; // string[]\nconst description = project.description;             // string | null\n```\n\n**List All Projects (with pagination):**\n```typescript\nconst response = await connection.client.projectsGroupsApi.withFetchAll().listProjects();\n\n// Iterate through all projects\nresponse.data.forEach((projectItem: ResponseObject<ProjectsGroupsModel.Project>) => {\n  const projectId = projectItem.data.id;\n  const projectName = projectItem.data.name;\n  const groupId = projectItem.data.groupId; // number | null\n});\n```\n\n**Get Supported Languages:**\n```typescript\nconst response = await connection.client.languagesApi.withFetchAll().listSupportedLanguages();\n\n// Filter languages\nconst targetLanguageIds = ['uk', 'pl', 'de'];\nconst projectLanguages = response.data.filter(\n  (lang: ResponseObject<LanguagesModel.Language>) => targetLanguageIds.includes(lang.data.id)\n);\n\n// Map to simpler structure\nconst languages = projectLanguages.map((lang: ResponseObject<LanguagesModel.Language>) => ({\n  id: lang.data.id,           // string: \"uk\"\n  name: lang.data.name,       // string: \"Ukrainian\"\n  locale: lang.data.locale,   // string: \"uk-UA\"\n  osxLocale: lang.data.osxLocale // string\n}));\n```\n\n**List Source Files:**\n```typescript\nconst response = await connection.client.sourceFilesApi.withFetchAll().listProjectFiles(projectId);\n\nresponse.data.forEach((fileItem: ResponseObject<SourceFilesModel.File>) => {\n  const file = fileItem.data;\n  const fileId = file.id;             // number\n  const fileName = file.name;         // string\n  const branchId = file.branchId;     // number | null\n  const directoryId = file.directoryId; // number | null\n});\n```\n\n#### Best Practices\n\n1. **Always access data via `.data` property**\n   ```typescript\n   // ‚úÖ CORRECT\n   const project = response.data;\n   const projectName = response.data.name;\n   \n   // ‚ùå WRONG - will be undefined\n   const projectName = response.name;\n   ```\n\n2. **Use withFetchAll() for complete data**\n   ```typescript\n   // ‚úÖ CORRECT - gets all items\n   const response = await connection.client.languagesApi.withFetchAll().listSupportedLanguages();\n   \n   // ‚ö†Ô∏è PARTIAL - only first page (25 items)\n   const response = await connection.client.languagesApi.listSupportedLanguages();\n   ```\n\n3. **Handle nullable properties**\n   ```typescript\n   const description = response.data.description || 'No description';\n   const groupId = response.data.groupId ?? null;\n   ```\n\n4. **Handle errors properly**\n   ```typescript\n   try {\n     const response = await connection.client.projectsGroupsApi.getProject(projectId);\n     const project = response.data;\n     // Use project data\n   } catch (error: any) {\n     console.error('Crowdin API Error:', error);\n\n     // API errors have specific structure\n     if (error.code === 404) {\n       return res.status(404).json({ error: 'Project not found' });\n     }\n     \n     return res.status(500).json({\n       error: 'API request failed',\n       details: error.message\n     });\n   }\n   ```\n\n5. **Use TypeScript types**\n   ```typescript\n   import type { ResponseObject, ProjectsGroupsModel } from '@crowdin/crowdin-api-client';\n   \n   // Use in your code\n   const response: ResponseObject<ProjectsGroupsModel.Project> = await connection.client.projectsGroupsApi.getProject(projectId);\n   const project: ProjectsGroupsModel.Project = response.data;\n   ```\n\n6. **Always sort data explicitly when order matters**\n   ```typescript\n   // ‚úÖ CORRECT - sort projects by creation date (newest first)\n   const response = await connection.client.projectsGroupsApi.withFetchAll().listProjects();\n   const sortedByDate = response.data.sort(\n     (a: ResponseObject<ProjectsGroupsModel.Project>, b: ResponseObject<ProjectsGroupsModel.Project>) => {\n       const dateA = new Date(a.data.createdAt).getTime();\n       const dateB = new Date(b.data.createdAt).getTime();\n       return dateB - dateA; // Descending order (newest first)\n     }\n   );\n   \n   // ‚ùå WRONG - assuming data is already sorted by date\n   const response = await connection.client.projectsGroupsApi.withFetchAll().listProjects();\n   // Directly using response.data without sorting - order is not guaranteed!\n   ```\n\n7. **Never use CroQL - fetch all data and filter manually**\n   ```typescript\n   // ‚úÖ CORRECT - fetch all strings and filter manually\n   const allStrings = await connection.client.sourceStringsApi.withFetchAll().listProjectStrings(projectId);\n   \n   // Filter for specific criteria\n   const filteredStrings = allStrings.data.filter(\n     (item: ResponseObject<SourceStringsModel.String>) => {\n       const str = item.data;\n       return str.text.includes('welcome') && !str.isHidden;\n     }\n   );\n   \n   // ‚ùå WRONG - using CroQL queries\n   const response = await connection.client.sourceStringsApi.listProjectStrings(projectId, {\n     croql: 'text contains \"welcome\" AND isHidden = false'\n   });\n   // CroQL should be avoided - fetch all data and filter in your code instead\n   ```\n\n#### Complete Type Definitions\n\n**‚ö†Ô∏è CRITICAL**: Only use methods and types from `@crowdin/crowdin-api-client` definitions below.\n\n**Do NOT invent methods or properties that are not listed here.**\n\n<!-- CROWDIN_API_CLIENT_TYPES_START -->\n\n##### ai/index.d.ts\n\n```typescript\nimport { CrowdinApi, DownloadLink, PaginationOptions, PatchRequest, PlainObject, ResponseList, ResponseObject, Status } from '../core';\nexport declare class Ai extends CrowdinApi {\n    listAiOrganizationCustomPlaceholders(options?: PaginationOptions): Promise<ResponseList<AiModel.CustomPlaceholder>>;\n    addAiOrganizationCustomPlaceholder(request: AiModel.AddCustomPlaceholderRequest): Promise<ResponseObject<AiModel.CustomPlaceholder>>;\n    getAiOrganizationCustomPlaceholder(aiCustomPlaceholderId: number): Promise<ResponseObject<AiModel.CustomPlaceholder>>;\n    deleteAiOrganizationCustomPlaceholder(aiCustomPlaceholderId: number): Promise<void>;\n    editAiOrganizationCustomPlaceholder(aiCustomPlaceholderId: number, request: PatchRequest[]): Promise<ResponseObject<AiModel.CustomPlaceholder>>;\n    generateAiOrganizationPromptFineTuningDataset(aiPromptId: number, request: AiModel.GenerateFineTuningDataset): Promise<ResponseObject<Status<AiModel.FineTuningDataset>>>;\n    getAiOrganizationPromptFineTuningDatasetStatus(aiPromptId: number, jobIdentifier: string): Promise<ResponseObject<Status<AiModel.FineTuningDataset>>>;\n    listAiOrganizationPromptFineTuningEvents(aiPromptId: number, jobIdentifier: string, options?: PaginationOptions): Promise<ResponseList<AiModel.PromptFineTuningEvent>>;\n    listAiOrganizationPromptFineTuningJobs(options?: AiModel.ListPromptFineTuningJobsOptions): Promise<ResponseList<Status<AiModel.FineTuningJob>>>;\n    createAiOrganizationPromptFineTuningJob(aiPromptId: number, request: AiModel.GenerateFineTuningJob): Promise<ResponseObject<Status<AiModel.FineTuningJob>>>;\n    getAiOrganizationPromptFineTuningJobStatus(aiPromptId: number, jobIdentifier: string): Promise<ResponseObject<Status<AiModel.FineTuningJob>>>;\n    downloadAiOrganizationPromptFineTuningDataset(aiPromptId: number, jobIdentifier: string): Promise<ResponseObject<DownloadLink>>;\n    cloneAiOrganizationPrompt(aiPromptId: number, request?: {\n        name?: string;\n    }): Promise<ResponseObject<AiModel.AiPromptResponse>>;\n    listAiOrganizationPrompts(options?: AiModel.ListAiPromptsOptions): Promise<ResponseList<AiModel.AiPromptResponse>>;\n    addAiOrganizationPrompt(request: AiModel.AddAiPromptRequest): Promise<ResponseObject<AiModel.AiPromptResponse>>;\n    generateAiOrganizationPromptCompletion(aiPromptId: number, request: AiModel.GenerateAiPromptCompletionRequest): Promise<ResponseObject<Status<AiModel.AiPromptCompletionAttribute>>>;\n    getAiOrganizationPromptCompletionStatus(aiPromptId: number, completionId: string): Promise<ResponseObject<Status<AiModel.AiPromptCompletionAttribute>>>;\n    cancelAiOrganizationPromptCompletion(aiPromptId: number, completionId: string): Promise<void>;\n    downloadAiOrganizationPromptCompletion(aiPromptId: number, completionId: string): Promise<ResponseObject<DownloadLink>>;\n    getAiOrganizationPrompt(aiPromptId: number): Promise<ResponseObject<AiModel.AiPromptResponse>>;\n    deleteAiOrganizationPrompt(aiPromptId: number): Promise<void>;\n    editAiOrganizationPrompt(aiPromptId: number, request: PatchRequest[]): Promise<ResponseObject<AiModel.AiPromptResponse>>;\n    listAiOrganizationProviders(options?: PaginationOptions): Promise<ResponseList<AiModel.AiProviderResponse>>;\n    addAiOrganizationProvider(request: AiModel.AddAiProviderRequest): Promise<ResponseObject<AiModel.AiProviderResponse>>;\n    getAiOrganizationProvider(aiProviderId: number): Promise<ResponseObject<AiModel.AiProviderResponse>>;\n    deleteAiOrganizationProvider(aiProviderId: number): Promise<void>;\n    editAiOrganizationProvider(aiProviderId: number, request: PatchRequest[]): Promise<ResponseObject<AiModel.AiProviderResponse>>;\n    listAiOrganizationProviderModels(aiProviderId: number, options?: PaginationOptions): Promise<ResponseList<AiModel.AiProviderModelResponse>>;\n    listAiOrganizationAllProviderModels(options?: PaginationOptions): Promise<ResponseList<AiModel.AiProviderModelResponse>>;\n    createAiOrganizationProxyChatCompletion(aiProviderId: number, request?: AiModel.OtherChatCompletionRequest | AiModel.GoogleGeminiChatCompletionRequest): Promise<ResponseObject<AiModel.AiProviderProxyResponseData>>;\n    generateAiOrganizationReport(request: AiModel.AiReport): Promise<ResponseObject<Status<AiModel.AiReport>>>;\n    checkAiOrganizationReportStatus(aiReportId: string): Promise<ResponseObject<Status<AiModel.AiReport>>>;\n    downloadAiOrganizationReport(aiReportId: string): Promise<ResponseObject<DownloadLink>>;\n    getAiOrganizationSettings(): Promise<ResponseObject<AiModel.AiSettings>>;\n    editAiOrganizationSettings(request: PatchRequest[]): Promise<ResponseObject<AiModel.AiSettings>>;\n    listAiUserCustomPlaceholders(userId: number, options?: PaginationOptions): Promise<ResponseList<AiModel.CustomPlaceholder>>;\n    addAiUserCustomPlaceholder(userId: number, request: AiModel.AddCustomPlaceholderRequest): Promise<ResponseObject<AiModel.CustomPlaceholder>>;\n    getAiUserCustomPlaceholder(userId: number, aiCustomPlaceholderId: number): Promise<ResponseObject<AiModel.CustomPlaceholder>>;\n    deleteAiUserCustomPlaceholder(userId: number, aiCustomPlaceholderId: number): Promise<void>;\n    editAiUserCustomPlaceholder(userId: number, aiCustomPlaceholderId: number, request: PatchRequest[]): Promise<ResponseObject<AiModel.CustomPlaceholder>>;\n    generateAiUserPromptFineTuningDataset(userId: number, aiPromptId: number, request: AiModel.GenerateFineTuningDataset): Promise<ResponseObject<Status<AiModel.FineTuningDataset>>>;\n    getAiUserPromptFineTuningDatasetStatus(userId: number, aiPromptId: number, jobIdentifier: string): Promise<ResponseObject<Status<AiModel.FineTuningDataset>>>;\n    listAiUserPromptFineTuningEvents(userId: number, aiPromptId: number, jobIdentifier: string, options?: PaginationOptions): Promise<ResponseList<AiModel.PromptFineTuningEvent>>;\n    listAiUserPromptFineTuningJobs(userId: number, options?: AiModel.ListPromptFineTuningJobsOptions): Promise<ResponseList<Status<AiModel.FineTuningJob>>>;\n    createAiUserPromptFineTuningJob(userId: number, aiPromptId: number, request: AiModel.GenerateFineTuningJob): Promise<ResponseObject<Status<AiModel.FineTuningJob>>>;\n    getAiUserPromptFineTuningJobStatus(userId: number, aiPromptId: number, jobIdentifier: string): Promise<ResponseObject<Status<AiModel.FineTuningJob>>>;\n    downloadAiUserPromptFineTuningDataset(userId: number, aiPromptId: number, jobIdentifier: string): Promise<ResponseObject<DownloadLink>>;\n    cloneAiUserPrompt(userId: number, aiPromptId: number, request?: {\n        name?: string;\n    }): Promise<ResponseObject<AiModel.AiPromptResponse>>;\n    listAiUserPrompts(userId: number, options?: AiModel.ListAiPromptsOptions): Promise<ResponseList<AiModel.AiPromptResponse>>;\n    addAiUserPrompt(userId: number, request: AiModel.AddAiPromptRequest): Promise<ResponseObject<AiModel.AiPromptResponse>>;\n    generateAiUserPromptCompletion(userId: number, aiPromptId: number, request: AiModel.GenerateAiPromptCompletionRequest): Promise<ResponseObject<Status<AiModel.AiPromptCompletionAttribute>>>;\n    getAiUserPromptCompletionStatus(userId: number, aiPromptId: number, completionId: string): Promise<ResponseObject<Status<AiModel.AiPromptCompletionAttribute>>>;\n    cancelAiUserPromptCompletion(userId: number, aiPromptId: number, completionId: string): Promise<void>;\n    downloadAiUserPromptCompletion(userId: number, aiPromptId: number, completionId: string): Promise<ResponseObject<DownloadLink>>;\n    getAiUserPrompt(userId: number, aiPromptId: number): Promise<ResponseObject<AiModel.AiPromptResponse>>;\n    deleteAiUserPrompt(userId: number, aiPromptId: number): Promise<void>;\n    editAiUserPrompt(userId: number, aiPromptId: number, request: PatchRequest[]): Promise<ResponseObject<AiModel.AiPromptResponse>>;\n    listAiUserProviders(userId: number, options?: PaginationOptions): Promise<ResponseList<AiModel.AiProviderResponse>>;\n    addAiUserProvider(userId: number, request: AiModel.AddAiProviderRequest): Promise<ResponseObject<AiModel.AiProviderResponse>>;\n    getAiUserProvider(userId: number, aiProviderId: number): Promise<ResponseObject<AiModel.AiProviderResponse>>;\n    deleteAiUserProvider(userId: number, aiProviderId: number): Promise<void>;\n    editAiUserProvider(userId: number, aiProviderId: number, request: PatchRequest[]): Promise<ResponseObject<AiModel.AiProviderResponse>>;\n    listAiUserProviderModels(userId: number, aiProviderId: number, options?: PaginationOptions): Promise<ResponseList<AiModel.AiProviderModelResponse>>;\n    listAiUserAllProviderModels(userId: number, options?: PaginationOptions): Promise<ResponseList<AiModel.AiProviderModelResponse>>;\n    createAiUserProxyChatCompletion(userId: number, aiProviderId: number, request?: AiModel.OtherChatCompletionRequest | AiModel.GoogleGeminiChatCompletionRequest): Promise<ResponseObject<AiModel.AiProviderProxyResponseData>>;\n    generateAiUserReport(userId: number, request: AiModel.AiReport): Promise<ResponseObject<Status<AiModel.AiReport>>>;\n    checkAiUserReportStatus(userId: number, aiReportId: string): Promise<ResponseObject<Status<AiModel.AiReport>>>;\n    downloadAiUserReport(userId: number, aiReportId: string): Promise<ResponseObject<DownloadLink>>;\n    getAiUsertSettings(userId: number): Promise<ResponseObject<AiModel.AiSettings>>;\n    editAiUserSettings(userId: number, request: PatchRequest[]): Promise<ResponseObject<AiModel.AiSettings>>;\n}\nexport declare namespace AiModel {\n    interface CustomPlaceholder {\n        id: number;\n        description: string;\n        placeholder: string;\n        value: string;\n        createdAt: string;\n        updatedAt: string;\n    }\n    interface AddCustomPlaceholderRequest {\n        description: string;\n        placeholder: string;\n        value: string;\n    }\n    interface FineTuningDataset {\n        projectIds: number[];\n        tmIds: number[];\n        purpose: 'training' | 'validation';\n        dateFrom: string;\n        dateTo: string;\n        maxFileSize: number;\n        minExamplesCount: number;\n        maxExamplesCount: number;\n    }\n    interface GenerateFineTuningDataset {\n        projectIds?: number[];\n        tmIds?: number[];\n        purpose?: 'training' | 'validation';\n        dateFrom?: string;\n        dateTo?: string;\n        maxFileSize?: number;\n        minExamplesCount?: number;\n        maxExamplesCount?: number;\n    }\n    interface GenerateFineTuningJob {\n        dryRun?: boolean;\n        hyperparameters?: {\n            batchSize: number;\n            learningRateMultiplier: number;\n            nEpochs: number;\n        };\n        trainingOptions: Omit<GenerateFineTuningDataset, 'purpose'>;\n        validationOptions?: Omit<GenerateFineTuningDataset, 'purpose'>;\n    }\n    interface FineTuningJob {\n        dryRun: boolean;\n        aiPromptId: number;\n        hyperparameters: {\n            batchSize: number;\n            learningRateMultiplier: number;\n            nEpochs: number;\n        };\n        trainingOptions: Omit<GenerateFineTuningDataset, 'purpose'>;\n        validationOptions: Omit<GenerateFineTuningDataset, 'purpose'>;\n        baseModel: string;\n        fineTunedModel: string;\n        trainedTokensCount: number;\n        trainingDatasetUrl: string;\n        validationDatasetUrl: string;\n        metadata: PlainObject;\n    }\n    interface PromptFineTuningEvent {\n        id: string;\n        type: string;\n        message: string;\n        data: {\n            step: number;\n            totalSteps: number;\n            trainingLoss: number;\n            validationLoss: number;\n            fullValidationLoss: number;\n        };\n        createdAt: string;\n    }\n    interface ListPromptFineTuningJobsOptions extends PaginationOptions {\n        statuses: string;\n        orderBy: string;\n    }\n    interface ListAiPromptsOptions extends PaginationOptions {\n        projectId?: number;\n        action?: Action;\n    }\n    interface AiPromptResponse {\n        id: number;\n        name: string;\n        action: Action;\n        aiProviderId: number;\n        aiModelId: string;\n        isEnabled: boolean;\n        enabledProjectIds: number[];\n        config: AiModel.AiPromptConfigBasicPreTranslate | AiModel.AiPromptConfigBasicAssistAction | AiModel.AiPromptConfigBasicAligmentAction | AiModel.AiPromptConfigAdvanced | AiModel.AiPromptConfigExternal;\n        promptPreview: string;\n        isFineTuningAvailable: boolean;\n        createdAt: string;\n        updatedAt: string;\n    }\n    interface AiPromptConfigBasicOtherLanguageTranslations {\n        isEnabled?: boolean;\n        languageIds?: string[];\n    }\n    interface AiPromptConfigBasicPreTranslate {\n        mode: 'basic';\n        companyDescription?: string;\n        projectDescription?: string;\n        audienceDescription?: string;\n        customPlaceholders?: string[];\n        otherLanguageTranslations?: AiModel.AiPromptConfigBasicOtherLanguageTranslations;\n        glossaryTerms?: boolean;\n        tmSuggestions?: boolean;\n        fileContent?: boolean;\n        fileContext?: boolean;\n        screenshots?: boolean;\n        publicProjectDescription?: boolean;\n        siblingsStrings?: boolean;\n    }\n    interface AiPromptConfigBasicAssistAction {\n        mode: 'basic';\n        companyDescription?: string;\n        projectDescription?: string;\n        audienceDescription?: string;\n        otherLanguageTranslations?: AiModel.AiPromptConfigBasicOtherLanguageTranslations;\n        glossaryTerms?: boolean;\n        tmSuggestions?: boolean;\n        fileContext?: boolean;\n        screenshots?: boolean;\n        publicProjectDescription?: boolean;\n        siblingsStrings?: boolean;\n        filteredStrings?: boolean;\n    }\n    interface AiPromptConfigBasicAligmentAction {\n        mode: 'basic';\n        customPlaceholders?: string[];\n        publicProjectDescription?: boolean;\n    }\n    interface AiPromptConfigAdvanced {\n        mode: 'advanced';\n        screenshots?: boolean;\n        prompt: string;\n        otherLanguageTranslations?: AiModel.AiPromptConfigBasicOtherLanguageTranslations;\n    }\n    interface AiPromptConfigExternal {\n        mode: 'external';\n        identifier: string;\n        key: string;\n        options?: any;\n    }\n    interface AddAiPromptRequest {\n        name: string;\n        action: Action;\n        aiProviderId?: number;\n        aiModelId?: string;\n        isEnabled?: boolean;\n        enabledProjectIds?: number[];\n        config: AiModel.AiPromptConfigBasicPreTranslate | AiModel.AiPromptConfigBasicAssistAction | AiModel.AiPromptConfigBasicAligmentAction | AiModel.AiPromptConfigAdvanced | AiPromptConfigExternal;\n    }\n    interface GenerateAiPromptCompletionRequest {\n        resources: AiModel.AiPromptResourceWithPreTranslate | AiModel.AiPromptResourceWithAssist | AiModel.AiPromptResourceWithAlignment | AiModel.AiPromptResourceWithCustom;\n        tools?: {\n            tool: {\n                type: 'function';\n                function: {\n                    description?: string;\n                    name: string;\n                    parameters?: PlainObject;\n                };\n            };\n        }[];\n        tool_choice?: string | PlainObject;\n    }\n    interface AiPromptCompletionAttribute {\n        aiPromptId: number;\n    }\n    interface AiPromptResourceWithPreTranslate {\n        projectId: number;\n        sourceLanguageId?: string;\n        targetLanguageId?: string;\n        stringIds?: number[];\n        overridePromptValues?: OverridePromptValues;\n    }\n    interface AiPromptResourceWithAlignment {\n        projectId: number;\n        sourceLanguageId?: string;\n        targetLanguageId?: string;\n        stringIds?: number[];\n        overridePromptValues?: OverridePromptValues;\n    }\n    interface AiPromptResourceWithAssist {\n        projectId: number;\n        sourceLanguageId?: string;\n        targetLanguageId?: string;\n        stringIds?: number[];\n        filteredStringsIds?: number[];\n        overridePromptValues?: OverridePromptValues;\n    }\n    interface AiPromptResourceWithCustom {\n        projectId: number;\n        sourceLanguageId?: string;\n        targetLanguageId?: string;\n        stringIds?: number[];\n        overridePromptValues?: OverridePromptValues;\n        customInstruction?: string;\n    }\n    interface OverridePromptValues {\n        [key: string]: any;\n    }\n    interface AiProviderResponse {\n        id: number;\n        name: string;\n        type: ProviderType;\n        credentials: AiModel.AiProviderCredentialsBasic | AiModel.AiProviderCredentialsAzureOpenAi | AiProviderCredentialsGoogleGemini | AiProviderCredentialsCustom;\n        config: AiModel.AiProviderConfig;\n        isEnabled: boolean;\n        useSystemCredentials: boolean;\n        createdAt: string;\n        updatedAt: string;\n        promptsCount: string;\n    }\n    interface AiProviderCredentialsBasic {\n        apiKey: string;\n    }\n    interface AiProviderCredentialsAzureOpenAi extends AiProviderCredentialsBasic {\n        resourceName: string;\n        deploymentName: string;\n        apiVersion: string;\n    }\n    interface AiProviderCredentialsGoogleGemini {\n        project: string;\n        region: string;\n        serviceAccountKey: string;\n    }\n    interface AiProviderCredentialsWatsonx {\n        apiKey: string;\n        projectId: string;\n        region: string;\n    }\n    interface AiProviderCredentialsCustom {\n        identifier: string;\n        key: string;\n    }\n    interface AiProviderConfig {\n        actionRules?: AiModel.AiProviderConfigActionRule[];\n    }\n    interface AiProviderConfigActionRule {\n        action?: 'pre_translate' | 'assist';\n        availableAiModelIds?: string[];\n    }\n    interface AddAiProviderRequest {\n        name: string;\n        type: ProviderType;\n        credentials?: AiModel.AiProviderCredentialsBasic | AiModel.AiProviderCredentialsAzureOpenAi | AiProviderCredentialsGoogleGemini | AiProviderCredentialsWatsonx | AiProviderCredentialsCustom;\n        config?: AiModel.AiProviderConfig;\n        isEnabled?: boolean;\n        useSystemCredentials?: boolean;\n    }\n    interface AiProviderModelResponse {\n        id: string;\n    }\n    interface AiProviderProxyResponseData {\n        data: object;\n    }\n    interface OtherChatCompletionRequest {\n        stream?: boolean;\n        [key: string]: any;\n    }\n    interface GoogleGeminiChatCompletionRequest extends OtherChatCompletionRequest {\n        model: string;\n    }\n    type AiReport = AiReportTokenUsage;\n    interface AiReportTokenUsage {\n        type: 'tokens-usage-raw-data';\n        schema: AiReportGeneralSchema;\n    }\n    interface AiReportGeneralSchema {\n        dateFrom: string;\n        dateTo: string;\n        format?: 'json' | 'csv';\n        projectIds?: number[];\n        promptIds?: number[];\n        userIds?: number[];\n    }\n    interface AiSettings {\n        assistActionAiPromptId: number;\n        showSuggestion: boolean;\n        shortcuts: {\n            name: string;\n            prompt: string;\n            enabled: boolean;\n        }[];\n    }\n    type Action = 'pre_translate' | 'assist';\n    type ProviderType = 'open_ai' | 'azure_open_ai' | 'google_gemini' | 'mistral_ai' | 'anthropic' | 'custom_ai' | 'x_ai' | 'deepseek' | 'watsonx';\n}\n```\n\n##### applications/index.d.ts\n\n```typescript\nimport { CrowdinApi, ResponseObject, PatchRequest, Pagination, ResponseList } from '../core';\nexport declare class Applications extends CrowdinApi {\n    listApplicationInstallations(options?: Pagination): Promise<ResponseList<ApplicationsModel.Application>>;\n    installApplication(request: ApplicationsModel.InstallApplication): Promise<ResponseObject<ApplicationsModel.Application>>;\n    getApplicationInstallation(applicationId: string): Promise<ResponseObject<ApplicationsModel.Application>>;\n    deleteApplicationInstallation(applicationId: string, force?: boolean): Promise<ResponseObject<ApplicationsModel.Application>>;\n    editApplicationInstallation(applicationId: string, request: PatchRequest[]): Promise<ResponseObject<ApplicationsModel.Application>>;\n    getApplicationData(applicationId: string, path: string): Promise<ResponseObject<any>>;\n    updateOrRestoreApplicationData(applicationId: string, path: string, request: any): Promise<ResponseObject<any>>;\n    addApplicationData(applicationId: string, path: string, request: any): Promise<ResponseObject<any>>;\n    deleteApplicationData(applicationId: string, path: string): Promise<void>;\n    editApplicationData(applicationId: string, path: string, request: any): Promise<ResponseObject<any>>;\n}\nexport declare namespace ApplicationsModel {\n    interface Application {\n        identifier: string;\n        name: string;\n        description: string;\n        logo: string;\n        baseUrl: string;\n        manifestUrl: string;\n        createdAt: string;\n        modules: ApplicationModule[];\n        scopes: string[];\n        permissions: ApplicationPermissions;\n        defaultPermissions: any;\n        limitReached: boolean;\n    }\n    interface InstallApplication {\n        url: string;\n        permissions?: ApplicationPermissions;\n        modules?: ApplicationModule[];\n    }\n    interface ApplicationPermissions {\n        user: {\n            value: 'all' | 'owner' | 'managers' | 'guests' | 'restricted';\n            ids: number[];\n        };\n        project: {\n            value: 'own' | 'restricted';\n            ids: number[];\n        };\n    }\n    interface ApplicationModule {\n        key: string;\n        type?: string;\n        data?: any;\n        authenticationType?: string;\n        permissions: Omit<ApplicationPermissions, 'project'>;\n    }\n}\n```\n\n##### bundles/index.d.ts\n\n```typescript\nimport { CrowdinApi, DownloadLink, PaginationOptions, PatchRequest, ResponseList, ResponseObject, Status } from '../core';\nimport { SourceFilesModel } from '../sourceFiles';\nexport declare class Bundles extends CrowdinApi {\n    listBundles(projectId: number, options?: PaginationOptions): Promise<ResponseList<BundlesModel.Bundle>>;\n    addBundle(projectId: number, request: BundlesModel.CreateBundleRequest): Promise<ResponseObject<BundlesModel.Bundle>>;\n    getBundle(projectId: number, bundleId: number): Promise<ResponseObject<BundlesModel.Bundle>>;\n    deleteBundle(projectId: number, bundleId: number): Promise<void>;\n    editBundle(projectId: number, bundleId: number, request: PatchRequest[]): Promise<ResponseObject<BundlesModel.Bundle>>;\n    downloadBundle(projectId: number, bundleId: number, exportId: string): Promise<ResponseObject<DownloadLink>>;\n    exportBundle(projectId: number, bundleId: number): Promise<ResponseObject<Status<BundlesModel.ExportAttributes>>>;\n    checkBundleExportStatus(projectId: number, bundleId: number, exportId: string): Promise<ResponseObject<Status<BundlesModel.ExportAttributes>>>;\n    listBundleFiles(projectId: number, bundleId: number, options?: PaginationOptions): Promise<ResponseList<SourceFilesModel.File>>;\n    listBundleBranches(projectId: number, bundleId: number, options?: PaginationOptions): Promise<ResponseList<SourceFilesModel.Branch>>;\n}\nexport declare namespace BundlesModel {\n    interface Bundle {\n        id: number;\n        name: string;\n        format: string;\n        sourcePatterns: string[];\n        ignorePatterns: string[];\n        exportPattern: string;\n        isMultilingual: boolean;\n        includeProjectSourceLanguage: boolean;\n        labelIds: number[];\n        excludeLabelIds: number[];\n        createdAt: string;\n        webUrl: string;\n        updatedAt: string;\n    }\n    interface CreateBundleRequest {\n        name: string;\n        format: string;\n        sourcePatterns: string[];\n        ignorePatterns?: string[];\n        exportPattern: string;\n        isMultilingual?: boolean;\n        includeProjectSourceLanguage?: boolean;\n        includeInContextPseudoLanguage?: boolean;\n        labelIds?: number[];\n        excludeLabelIds?: number[];\n    }\n    interface ExportAttributes {\n        bundleId: number;\n    }\n}\n```\n\n##### clients/index.d.ts\n\n```typescript\nimport { CrowdinApi, PaginationOptions, ResponseList } from '../core';\nexport declare class Clients extends CrowdinApi {\n    listClients(options?: PaginationOptions): Promise<ResponseList<ClientsModel.Client>>;\n}\nexport declare namespace ClientsModel {\n    interface Client {\n        id: number;\n        name: string;\n        description: string;\n        status: 'pending' | 'confirmed' | 'rejected';\n        webUrl: string;\n    }\n}\n```\n\n##### core/http-client-error.d.ts\n\n```typescript\nimport { AxiosError } from 'axios';\nimport { FetchClientJsonPayloadError } from './internal/fetch/fetchClientError';\nexport type HttpClientError = AxiosError | FetchClientJsonPayloadError | Error;\nexport declare const toHttpClientError: (error?: unknown) => HttpClientError;\n```\n\n##### core/index.d.ts\n\n```typescript\nimport { HttpClientError } from './http-client-error';\nimport { RetryConfig, RetryService } from './internal/retry';\nexport interface HttpClient {\n    get<T>(url: string, config?: {\n        headers: Record<string, string>;\n    }): Promise<T>;\n    delete<T>(url: string, config?: {\n        headers: Record<string, string>;\n    }): Promise<T>;\n    head<T>(url: string, config?: {\n        headers: Record<string, string>;\n    }): Promise<T>;\n    post<T>(url: string, data?: unknown, config?: {\n        headers: Record<string, string>;\n    }): Promise<T>;\n    put<T>(url: string, data?: unknown, config?: {\n        headers: Record<string, string>;\n    }): Promise<T>;\n    patch<T>(url: string, data?: unknown, config?: {\n        headers: Record<string, string>;\n    }): Promise<T>;\n}\nexport type HttpClientType = 'axios' | 'fetch';\nexport interface Credentials {\n    token: string;\n    organization?: string;\n    baseUrl?: string;\n}\nexport interface ClientConfig {\n    httpClientType?: HttpClientType;\n    httpClient?: HttpClient;\n    userAgent?: string;\n    integrationUserAgent?: string;\n    retryConfig?: RetryConfig;\n    httpRequestTimeout?: number;\n}\nexport interface ResponseList<T> {\n    data: ResponseObject<T>[];\n    pagination: Pagination;\n}\nexport interface ResponseObject<T> {\n    data: T;\n}\nexport interface Pagination {\n    offset: number;\n    limit: number;\n}\nexport type PaginationOptions = Partial<Pagination>;\nexport interface PatchRequest {\n    value?: any;\n    op: PatchOperation;\n    path: string;\n}\nexport type PatchOperation = 'add' | 'remove' | 'replace' | 'move' | 'copy' | 'test';\nexport type ProjectRoles = 'manager' | 'developer' | 'translator' | 'proofreader' | 'language_coordinator' | 'member';\nexport interface DownloadLink {\n    url: string;\n    expireIn: string;\n}\nexport declare enum BooleanInt {\n    TRUE = 1,\n    FALSE = 0\n}\nexport interface Status<T> {\n    identifier: string;\n    status: string;\n    progress: number;\n    attributes: T;\n    createdAt: string;\n    updatedAt: string;\n    startedAt: string;\n    finishedAt: string;\n    eta: string;\n}\nexport interface Attribute {\n    [key: string]: string;\n}\nexport type PlainObject = Record<string, any>;\nexport declare class CrowdinError extends Error {\n    apiError: any;\n    code: number;\n    constructor(message: string, code: number, apiError: any);\n}\nexport declare class CrowdinValidationError extends CrowdinError {\n    validationCodes: {\n        key: string;\n        codes: string[];\n    }[];\n    constructor(message: string, validationCodes: {\n        key: string;\n        codes: string[];\n    }[], apiError: any);\n}\nexport declare function handleHttpClientError(error: HttpClientError): never;\nexport declare abstract class CrowdinApi {\n    private static readonly CROWDIN_URL_SUFFIX;\n    private static readonly AXIOS_INSTANCE;\n    private static readonly FETCH_INSTANCE;\n    readonly token: string;\n    readonly organization?: string;\n    readonly url: string;\n    readonly config: ClientConfig | undefined;\n    readonly retryService: RetryService;\n    protected fetchAllFlag: boolean;\n    protected maxLimit: number | undefined;\n    constructor(credentials: Credentials, config?: ClientConfig);\n    graphql<T>(req: {\n        query: string;\n        operationName?: string;\n        variables?: any;\n    }, config?: {\n        url?: string;\n    }): Promise<ResponseObject<T>>;\n    protected addQueryParam(url: string, name: string, value?: string | number): string;\n    protected defaultConfig(): {\n        headers: Record<string, string>;\n    };\n    get httpClient(): HttpClient;\n    withFetchAll(maxLimit?: number): this;\n    protected getList<T = any>(url: string, limit?: number, offset?: number, config?: {\n        headers: Record<string, string>;\n    }): Promise<ResponseList<T>>;\n    protected fetchAll<T>(url: string, config: {\n        headers: Record<string, string>;\n    }, maxAmount?: number): Promise<ResponseList<T>>;\n    protected encodeUrlParam(param: string | number | boolean): string;\n    protected get<T>(url: string, config?: {\n        headers: Record<string, string>;\n    }): Promise<T>;\n    protected delete<T>(url: string, config?: {\n        headers: Record<string, string>;\n    }): Promise<T>;\n    protected head<T>(url: string, config?: {\n        headers: Record<string, string>;\n    }): Promise<T>;\n    protected post<T>(url: string, data?: unknown, config?: {\n        headers: Record<string, string>;\n    }): Promise<T>;\n    protected put<T>(url: string, data?: unknown, config?: {\n        headers: Record<string, string>;\n    }): Promise<T>;\n    protected patch<T>(url: string, data?: unknown, config?: {\n        headers: Record<string, string>;\n    }): Promise<T>;\n}\nexport declare function isOptionalString(parameter: string | unknown, parameterInArgs: boolean): parameter is string | undefined;\nexport declare function isOptionalNumber(parameter: number | unknown, parameterInArgs: boolean): parameter is number | undefined;\nexport interface ProjectRole {\n    name: string;\n    permissions: ProjectRolePermissions;\n}\nexport interface ProjectRolePermissions {\n    allLanguages: boolean;\n    languagesAccess: {\n        [lang: string]: {\n            allContent: boolean;\n            workflowStepIds: number[];\n        };\n    };\n}\n```\n\n##### dictionaries/index.d.ts\n\n```typescript\nimport { CrowdinApi, PatchRequest, ResponseList, ResponseObject } from '../core';\nexport declare class Dictionaries extends CrowdinApi {\n    listDictionaries(projectId: number, options?: DictionariesModel.ListDictionariesOptions): Promise<ResponseList<DictionariesModel.Dictionary>>;\n    listDictionaries(projectId: number, languageIds?: string): Promise<ResponseList<DictionariesModel.Dictionary>>;\n    editDictionary(projectId: number, languageId: string, request: PatchRequest[]): Promise<ResponseObject<DictionariesModel.Dictionary>>;\n}\nexport declare namespace DictionariesModel {\n    interface Dictionary {\n        languageId: string;\n        words: string[];\n    }\n    interface ListDictionariesOptions {\n        languageIds?: string;\n    }\n}\n```\n\n##### distributions/index.d.ts\n\n```typescript\nimport { CrowdinApi, PaginationOptions, PatchRequest, ResponseList, ResponseObject } from '../core';\nexport declare class Distributions extends CrowdinApi {\n    listDistributions(projectId: number, options?: PaginationOptions): Promise<ResponseList<DistributionsModel.Distribution>>;\n    listDistributions(projectId: number, limit?: number, offset?: number): Promise<ResponseList<DistributionsModel.Distribution>>;\n    createDistribution(projectId: number, request: DistributionsModel.CreateDistributionRequest | DistributionsModel.CreateDistributionStringsBasedRequest): Promise<ResponseObject<DistributionsModel.Distribution>>;\n    getDistribution(projectId: number, hash: string): Promise<ResponseObject<DistributionsModel.Distribution>>;\n    deleteDistribution(projectId: number, hash: string): Promise<void>;\n    editDistribution(projectId: number, hash: string, request: PatchRequest[]): Promise<ResponseObject<DistributionsModel.Distribution>>;\n    getDistributionRelease(projectId: number, hash: string): Promise<ResponseObject<DistributionsModel.DistributionRelease | DistributionsModel.DistributionStringsBasedRelease>>;\n    createDistributionRelease(projectId: number, hash: string): Promise<ResponseObject<DistributionsModel.DistributionRelease | DistributionsModel.DistributionStringsBasedRelease>>;\n}\nexport declare namespace DistributionsModel {\n    interface Distribution {\n        hash: string;\n        manifestUrl: string;\n        name: string;\n        bundleIds: number[];\n        createdAt: string;\n        updatedAt: string;\n        exportMode: ExportMode;\n        fileIds: number[];\n    }\n    interface CreateDistributionRequest {\n        exportMode?: ExportMode;\n        name: string;\n        fileIds?: number[];\n        bundleIds?: number[];\n    }\n    interface CreateDistributionStringsBasedRequest {\n        name: string;\n        bundleIds: number[];\n    }\n    interface DistributionRelease {\n        status: string;\n        progress: number;\n        currentLanguageId: string;\n        currentFileId: number;\n        date: string;\n    }\n    interface DistributionStringsBasedRelease {\n        status: string;\n        progress: number;\n        currentLanguageId: string;\n        currentBranchId: number;\n        date: string;\n    }\n    type ExportMode = 'default' | 'bundle';\n}\n```\n\n##### fields/index.d.ts\n\n```typescript\nimport { CrowdinApi, PaginationOptions, PatchRequest, ResponseList, ResponseObject } from '../core';\nexport declare class Fields extends CrowdinApi {\n    listFields(options?: FieldsModel.ListFieldsParams): Promise<ResponseList<FieldsModel.Field>>;\n    addField(request: FieldsModel.AddFieldRequest): Promise<ResponseObject<FieldsModel.Field>>;\n    getField(fieldId: number): Promise<ResponseObject<FieldsModel.Field>>;\n    deleteField(fieldId: number): Promise<void>;\n    editField(fieldId: number, request: PatchRequest[]): Promise<ResponseObject<FieldsModel.Field>>;\n}\nexport declare namespace FieldsModel {\n    type Entity = 'project' | 'user' | 'task' | 'file' | 'translation' | 'string';\n    type Type = 'checkbox' | 'radiobuttons' | 'date' | 'datetime' | 'number' | 'labels' | 'select' | 'multiselect' | 'text' | 'textarea' | 'url';\n    type Place = 'projectCreateModal' | 'projectHeader' | 'projectDetails' | 'projectCrowdsourceDetails' | 'projectSettings' | 'projectTaskEditCreate' | 'projectTaskDetails' | 'projectTaskBoardCard' | 'fileDetails' | 'fileSettings' | 'userEditModal' | 'userDetails' | 'userPopover' | 'stringEditModal' | 'stringDetails' | 'translationUnderContent';\n    interface Location {\n        place: Place;\n    }\n    interface Option {\n        label: string;\n        value: string;\n    }\n    interface OtherFieldConfig {\n        locations: Location[];\n    }\n    interface ListFieldConfig extends OtherFieldConfig {\n        options: Option[];\n    }\n    interface NumberFieldConfig extends OtherFieldConfig {\n        min: number;\n        max: number;\n        units: string;\n    }\n    type Config = ListFieldConfig | NumberFieldConfig | OtherFieldConfig;\n    interface ListFieldsParams extends PaginationOptions {\n        search?: string;\n        entity?: Entity;\n        type?: Type;\n    }\n    interface Field {\n        id: number;\n        name: string;\n        slug: string;\n        type: Type;\n        description: string;\n        entities: Entity[];\n        config: Config;\n        createdAt: string;\n        updatedAt: string;\n    }\n    interface AddFieldRequest {\n        name: string;\n        slug: string;\n        type: Type;\n        description?: string;\n        entities: Entity[];\n        config?: Config;\n    }\n}\n```\n\n##### glossaries/index.d.ts\n\n```typescript\nimport { CrowdinApi, DownloadLink, PaginationOptions, PatchRequest, ResponseList, ResponseObject, Status } from '../core';\nexport declare class Glossaries extends CrowdinApi {\n    listGlossaries(options?: GlossariesModel.ListGlossariesOptions): Promise<ResponseList<GlossariesModel.Glossary>>;\n    listGlossaries(groupId?: number, limit?: number, offset?: number): Promise<ResponseList<GlossariesModel.Glossary>>;\n    addGlossary(request: GlossariesModel.CreateGlossaryRequest): Promise<ResponseObject<GlossariesModel.Glossary>>;\n    getGlossary(glossaryId: number): Promise<ResponseObject<GlossariesModel.Glossary>>;\n    deleteGlossary(glossaryId: number): Promise<void>;\n    editGlossary(glossaryId: number, request: PatchRequest[]): Promise<ResponseObject<GlossariesModel.Glossary>>;\n    exportGlossary(glossaryId: number, request: GlossariesModel.ExportGlossaryRequest): Promise<ResponseObject<Status<GlossariesModel.GlossaryExportStatusAttribute>>>;\n    checkGlossaryExportStatus(glossaryId: number, exportId: string): Promise<ResponseObject<Status<GlossariesModel.GlossaryExportStatusAttribute>>>;\n    downloadGlossary(glossaryId: number, exportId: string): Promise<ResponseObject<DownloadLink>>;\n    importGlossaryFile(glossaryId: number, request: GlossariesModel.GlossaryFile): Promise<ResponseObject<Status<GlossariesModel.GlossaryImportStatusAttribute>>>;\n    checkGlossaryImportStatus(glossaryId: number, importId: string): Promise<ResponseObject<Status<GlossariesModel.GlossaryImportStatusAttribute>>>;\n    listTerms(glossaryId: number, options?: GlossariesModel.ListTermsOptions): Promise<ResponseList<GlossariesModel.Term>>;\n    listTerms(glossaryId: number, userId?: number, limit?: number, offset?: number, languageId?: string, translationOfTermId?: number, conceptId?: number): Promise<ResponseList<GlossariesModel.Term>>;\n    addTerm(glossaryId: number, request: GlossariesModel.CreateTermRequest): Promise<ResponseObject<GlossariesModel.Term>>;\n    clearGlossary(glossaryId: number, options?: GlossariesModel.ClearGlossaryOptions): Promise<ResponseObject<GlossariesModel.Term>>;\n    clearGlossary(glossaryId: number, languageId?: number, translationOfTermId?: number, conceptId?: number): Promise<ResponseObject<GlossariesModel.Term>>;\n    getTerm(glossaryId: number, termId: number): Promise<ResponseObject<GlossariesModel.Term>>;\n    deleteTerm(glossaryId: number, termId: number): Promise<void>;\n    editTerm(glossaryId: number, termId: number, request: PatchRequest[]): Promise<ResponseObject<GlossariesModel.Term>>;\n    listConcepts(glossaryId: number, options?: {\n        orderBy?: string;\n    } & PaginationOptions): Promise<ResponseList<GlossariesModel.Concept>>;\n    getConcept(glossaryId: number, conceptId: number): Promise<ResponseObject<GlossariesModel.Concept>>;\n    updateConcept(glossaryId: number, conceptId: number, request: GlossariesModel.UpdateConceptRequest): Promise<ResponseObject<GlossariesModel.Concept>>;\n    deleteConcept(glossaryId: number, conceptId: number): Promise<void>;\n    concordanceSearch(projectId: number, request: GlossariesModel.ConcordanceSearchRequest): Promise<ResponseList<GlossariesModel.ConcordanceSearchResponse>>;\n}\nexport declare namespace GlossariesModel {\n    interface Glossary {\n        id: number;\n        name: string;\n        groupId: number;\n        userId: number;\n        terms: number;\n        languageId: string;\n        languageIds: string[];\n        defaultProjectIds: number[];\n        projectIds: number[];\n        webUrl: string;\n        createdAt: string;\n    }\n    interface CreateGlossaryRequest {\n        name: string;\n        languageId: string;\n        groupId?: number;\n    }\n    type ExportField = 'term' | 'description' | 'partOfSpeech' | 'type' | 'status' | 'gender' | 'note' | 'url' | 'conceptDefinition' | 'conceptSubject' | 'conceptNote' | 'conceptUrl' | 'conceptFigure';\n    interface ExportGlossaryRequest {\n        format?: GlossaryFormat;\n        exportFields?: ExportField[];\n    }\n    interface GlossaryExportStatusAttribute {\n        format: string;\n        exportFields: ExportField[];\n    }\n    interface GlossaryImportStatusAttribute {\n        storageId: number;\n        scheme: unknown;\n        firstLineContainsHeader: boolean;\n    }\n    interface GlossaryFile {\n        storageId: number;\n        scheme?: GlossaryFileScheme;\n        firstLineContainsHeader?: boolean;\n    }\n    interface ListTermsOptions extends PaginationOptions {\n        userId?: number;\n        languageId?: string;\n        conceptId?: number;\n        orderBy?: string;\n        croql?: string;\n        translationOfTermId?: number;\n    }\n    interface Term {\n        id: number;\n        userId: number;\n        glossaryId: number;\n        languageId: string;\n        text: string;\n        description: string;\n        partOfSpeech: PartOfSpeech;\n        status: Status;\n        type: Type;\n        gender: Gender;\n        note: string;\n        url: string;\n        conceptId: number;\n        lemma: string;\n        createdAt: string;\n        updatedAt: string;\n    }\n    interface CreateTermRequest {\n        languageId: string;\n        text: string;\n        description?: string;\n        partOfSpeech?: PartOfSpeech;\n        status?: Status;\n        type?: Type;\n        gender?: Gender;\n        note?: string;\n        url?: string;\n        conceptId?: number;\n        translationOfTermId?: number;\n    }\n    interface ConcordanceSearchRequest extends PaginationOptions {\n        sourceLanguageId: string;\n        targetLanguageId: string;\n        expressions: string[];\n        expression?: string;\n    }\n    interface ConcordanceSearchResponse {\n        glossary: Glossary;\n        concept: Concept;\n        sourceTerms: Term[];\n        targetTerms: Term[];\n    }\n    type Status = 'preferred' | 'admitted' | 'not recommended' | 'obsolete';\n    type Type = 'full form' | 'acronym' | 'abbreviation' | 'short form' | 'phrase' | 'variant';\n    type Gender = 'masculine' | 'feminine' | 'neuter' | 'other';\n    type GlossaryFormat = 'tbx' | 'tbx_v3' | 'csv' | 'xlsx';\n    interface GlossaryFileScheme {\n        [key: string]: number;\n    }\n    type PartOfSpeech = 'adjective' | 'adposition' | 'adverb' | 'auxiliary' | 'coordinating conjunction' | 'determiner' | 'interjection' | 'noun' | 'numeral' | 'particle' | 'pronoun' | 'proper noun' | 'subordinating conjunction' | 'verb' | 'other';\n    interface ListGlossariesOptions extends PaginationOptions {\n        groupId?: number;\n        userId?: number;\n        orderBy?: string;\n    }\n    interface ClearGlossaryOptions {\n        languageId?: number;\n        translationOfTermId?: number;\n        conceptId?: number;\n    }\n    interface Concept {\n        id: number;\n        userId: number;\n        glossaryId: number;\n        subject: string;\n        definition: string;\n        translatable: boolean;\n        note: string;\n        url: string;\n        figure: string;\n        languagesDetails: LanguageDetails[];\n        createdAt: string;\n        updatedAt: string;\n    }\n    interface LanguageDetails {\n        languageId: string;\n        userId: number;\n        definition: string;\n        note: string;\n        createdAt: string;\n        updatedAt: string;\n    }\n    interface UpdateConceptRequest {\n        subject?: string;\n        definition?: string;\n        translatable?: boolean;\n        note?: string;\n        url?: string;\n        figure?: string;\n        languagesDetails?: {\n            languageId: string;\n            definition: string;\n            note?: string;\n        }[];\n    }\n}\n```\n\n##### index.d.ts\n\n```typescript\nimport { Ai } from './ai';\nimport { Applications } from './applications';\nimport { Bundles } from './bundles';\nimport { Clients } from './clients';\nimport { ClientConfig, Credentials, CrowdinApi } from './core';\nimport { Dictionaries } from './dictionaries';\nimport { Distributions } from './distributions';\nimport { Fields } from './fields';\nimport { Glossaries } from './glossaries';\nimport { Issues } from './issues';\nimport { Labels } from './labels';\nimport { Languages } from './languages';\nimport { MachineTranslation } from './machineTranslation';\nimport { Notifications } from './notifications';\nimport { OrganizationWebhooks } from './organizationWebhooks';\nimport { ProjectsGroups } from './projectsGroups';\nimport { Reports } from './reports';\nimport { Screenshots } from './screenshots';\nimport { SecurityLogs } from './securityLogs';\nimport { SourceFiles } from './sourceFiles';\nimport { SourceStrings } from './sourceStrings';\nimport { StringComments } from './stringComments';\nimport { StringCorrections } from './stringCorrections';\nimport { StringTranslations } from './stringTranslations';\nimport { Tasks } from './tasks';\nimport { Teams } from './teams';\nimport { TranslationMemory } from './translationMemory';\nimport { TranslationStatus } from './translationStatus';\nimport { Translations } from './translations';\nimport { UploadStorage } from './uploadStorage';\nimport { Users } from './users';\nimport { Vendors } from './vendors';\nimport { Webhooks } from './webhooks';\nimport { Workflows } from './workflows';\nexport * from './ai';\nexport * from './applications';\nexport * from './bundles';\nexport * from './clients';\nexport * from './core';\nexport * from './dictionaries';\nexport * from './distributions';\nexport * from './fields';\nexport * from './glossaries';\nexport * from './issues';\nexport * from './labels';\nexport * from './languages';\nexport * from './machineTranslation';\nexport * from './notifications';\nexport * from './organizationWebhooks';\nexport * from './projectsGroups';\nexport * from './reports';\nexport * from './screenshots';\nexport * from './securityLogs';\nexport * from './sourceFiles';\nexport * from './sourceStrings';\nexport * from './stringComments';\nexport * from './stringCorrections';\nexport * from './stringTranslations';\nexport * from './tasks';\nexport * from './teams';\nexport * from './translationMemory';\nexport * from './translationStatus';\nexport * from './translations';\nexport * from './uploadStorage';\nexport * from './users';\nexport * from './vendors';\nexport * from './webhooks';\nexport * from './workflows';\nexport default class Client extends CrowdinApi {\n    readonly aiApi: Ai;\n    readonly applicationsApi: Applications;\n    readonly sourceFilesApi: SourceFiles;\n    readonly glossariesApi: Glossaries;\n    readonly languagesApi: Languages;\n    readonly translationsApi: Translations;\n    readonly translationStatusApi: TranslationStatus;\n    readonly projectsGroupsApi: ProjectsGroups;\n    readonly reportsApi: Reports;\n    readonly screenshotsApi: Screenshots;\n    readonly sourceStringsApi: SourceStrings;\n    readonly uploadStorageApi: UploadStorage;\n    readonly tasksApi: Tasks;\n    readonly translationMemoryApi: TranslationMemory;\n    readonly webhooksApi: Webhooks;\n    readonly organizationWebhooksApi: OrganizationWebhooks;\n    readonly machineTranslationApi: MachineTranslation;\n    readonly stringTranslationsApi: StringTranslations;\n    readonly workflowsApi: Workflows;\n    readonly usersApi: Users;\n    readonly vendorsApi: Vendors;\n    readonly issuesApi: Issues;\n    readonly teamsApi: Teams;\n    readonly distributionsApi: Distributions;\n    readonly dictionariesApi: Dictionaries;\n    readonly labelsApi: Labels;\n    readonly stringCommentsApi: StringComments;\n    readonly bundlesApi: Bundles;\n    readonly notificationsApi: Notifications;\n    readonly clientsApi: Clients;\n    readonly securityLogsApi: SecurityLogs;\n    readonly fieldsApi: Fields;\n    readonly stringCorrectionsApi: StringCorrections;\n    constructor(credentials: Credentials, config?: ClientConfig);\n}\nexport { Client };\n```\n\n##### issues/index.d.ts\n\n```typescript\nimport { CrowdinApi, PaginationOptions, PatchRequest, ResponseList, ResponseObject } from '../core';\nexport declare class Issues extends CrowdinApi {\n    listReportedIssues(projectId: number, options?: IssuesModel.ListReportedIssuesOptions): Promise<ResponseList<IssuesModel.Issue>>;\n    listReportedIssues(projectId: number, limit?: number, offset?: number, type?: IssuesModel.Type, status?: IssuesModel.Status): Promise<ResponseList<IssuesModel.Issue>>;\n    editIssue(projectId: number, issueId: number, request: PatchRequest[]): Promise<ResponseObject<IssuesModel.Issue>>;\n}\nexport declare namespace IssuesModel {\n    type Type = 'all' | 'general_question' | 'translation_mistake' | 'context_request' | 'source_mistake';\n    type Status = 'all' | 'resolved' | 'unresolved';\n    interface Issue {\n        id: number;\n        text: string;\n        userId: number;\n        stringId: number;\n        user: User;\n        string: string;\n        languageId: string;\n        type: Type;\n        status: Status;\n        createdAt: string;\n    }\n    interface User {\n        id: number;\n        username: string;\n        fullName: string;\n        avatarUrl: string;\n    }\n    interface String {\n        id: number;\n        text: string;\n        type: string;\n        hasPlurals: boolean;\n        isIcu: boolean;\n        context: string;\n        fileId: number;\n    }\n    interface ListReportedIssuesOptions extends PaginationOptions {\n        type?: IssuesModel.Type;\n        status?: IssuesModel.Status;\n    }\n}\n```\n\n##### labels/index.d.ts\n\n```typescript\nimport { CrowdinApi, PaginationOptions, PatchRequest, ResponseList, ResponseObject } from '../core';\nimport { ScreenshotsModel } from '../screenshots';\nimport { SourceStringsModel } from '../sourceStrings';\nexport declare class Labels extends CrowdinApi {\n    listLabels(projectId: number, options?: LabelsModel.ListLabelsParams): Promise<ResponseList<LabelsModel.Label>>;\n    listLabels(projectId: number, limit?: number, offset?: number): Promise<ResponseList<LabelsModel.Label>>;\n    addLabel(projectId: number, request: LabelsModel.AddLabelRequest): Promise<ResponseObject<LabelsModel.Label>>;\n    getLabel(projectId: number, labelId: number): Promise<ResponseObject<LabelsModel.Label>>;\n    deleteLabel(projectId: number, labelId: number): Promise<void>;\n    editLabel(projectId: number, labelId: number, request: PatchRequest[]): Promise<ResponseObject<LabelsModel.Label>>;\n    assignLabelToScreenshots(projectId: number, labelId: number, request: LabelsModel.AssignLabelToScreenshotsRequet): Promise<ResponseList<ScreenshotsModel.Screenshot>>;\n    unassignLabelFromScreenshots(projectId: number, labelId: number, screenshotIds: string): Promise<ResponseList<ScreenshotsModel.Screenshot>>;\n    assignLabelToString(projectId: number, labelId: number, request: LabelsModel.AssignLabelToStringsRequet): Promise<ResponseList<SourceStringsModel.String>>;\n    unassignLabelFromString(projectId: number, labelId: number, stringIds: string): Promise<ResponseList<SourceStringsModel.String>>;\n}\nexport declare namespace LabelsModel {\n    interface ListLabelsParams extends PaginationOptions {\n        orderBy?: string;\n    }\n    interface Label {\n        id: number;\n        title: string;\n        isSystem?: boolean;\n    }\n    interface AddLabelRequest {\n        title: string;\n    }\n    interface AssignLabelToStringsRequet {\n        stringIds: number[];\n    }\n    interface AssignLabelToScreenshotsRequet {\n        screenshotIds: number[];\n    }\n}\n```\n\n##### languages/index.d.ts\n\n```typescript\nimport { CrowdinApi, PaginationOptions, PatchRequest, ResponseList, ResponseObject } from '../core';\nexport declare class Languages extends CrowdinApi {\n    listSupportedLanguages(options?: PaginationOptions): Promise<ResponseList<LanguagesModel.Language>>;\n    listSupportedLanguages(limit?: number, offset?: number): Promise<ResponseList<LanguagesModel.Language>>;\n    addCustomLanguage(request: LanguagesModel.AddLanguageRequest): Promise<ResponseObject<LanguagesModel.Language>>;\n    getLanguage(languageId: string): Promise<ResponseObject<LanguagesModel.Language>>;\n    deleteCustomLanguage(languageId: string): Promise<void>;\n    editCustomLanguage(languageId: string, request: PatchRequest[]): Promise<ResponseObject<LanguagesModel.Language>>;\n}\nexport declare namespace LanguagesModel {\n    interface Language {\n        id: string;\n        name: string;\n        editorCode: string;\n        twoLettersCode: string;\n        threeLettersCode: string;\n        locale: string;\n        androidCode: string;\n        osxCode: string;\n        osxLocale: string;\n        pluralCategoryNames: string[];\n        pluralRules: string;\n        pluralExamples: string[];\n        textDirection: TextDirection;\n        dialectOf: string;\n    }\n    interface AddLanguageRequest {\n        name: string;\n        code: string;\n        localeCode: string;\n        textDirection: TextDirection;\n        pluralCategoryNames: string[];\n        threeLettersCode: string;\n        twoLettersCode?: string;\n        dialectOf?: string;\n    }\n    type TextDirection = 'ltr' | 'rtl';\n}\n```\n\n##### machineTranslation/index.d.ts\n\n```typescript\nimport { CrowdinApi, PaginationOptions, PatchRequest, ResponseList, ResponseObject } from '../core';\nexport declare class MachineTranslation extends CrowdinApi {\n    listMts(options?: MachineTranslationModel.ListMTsOptions): Promise<ResponseList<MachineTranslationModel.MachineTranslation>>;\n    listMts(groupId?: number, limit?: number, offset?: number): Promise<ResponseList<MachineTranslationModel.MachineTranslation>>;\n    createMt(request: MachineTranslationModel.CreateMachineTranslationRequest): Promise<ResponseObject<MachineTranslationModel.MachineTranslation>>;\n    getMt(mtId: number): Promise<ResponseObject<MachineTranslationModel.MachineTranslation>>;\n    deleteMt(mtId: number): Promise<void>;\n    updateMt(mtId: number, request: PatchRequest[]): Promise<ResponseObject<MachineTranslationModel.MachineTranslation>>;\n    translate(mtId: number, request: MachineTranslationModel.TranslateRequest): Promise<ResponseObject<MachineTranslationModel.TranslateResponse>>;\n}\nexport declare namespace MachineTranslationModel {\n    interface MachineTranslation {\n        id: number;\n        groupId: number;\n        name: string;\n        type: number;\n        credentials: Credentials;\n        projectIds: number[];\n        supportedLanguageIds: string[];\n        supportedLanguagePairs: Record<string, string[]>;\n        enabledLanguageIds: string[];\n        enabledProjectIds: number[];\n        isEnabled: boolean;\n    }\n    type Credentials = {\n        apiKey: string;\n    } | {\n        credentials: string;\n    } | {\n        model: string;\n        apiKey: string;\n    } | {\n        isSystemCredentials: boolean;\n        apiKey: string;\n    } | {\n        endpoint: string;\n        apiKey: string;\n    } | {\n        url: string;\n    } | {\n        accessKey: string;\n        secretKey: string;\n    };\n    interface CreateMachineTranslationRequest {\n        name: string;\n        type: string;\n        credentials: Credentials;\n        groupId?: number;\n        enabledLanguageIds?: string[];\n        enabledProjectIds?: number[];\n        isEnabled?: boolean;\n    }\n    interface TranslateRequest {\n        languageRecognitionProvider?: LanguageRecognitionProvider;\n        sourceLanguageId?: string;\n        targetLanguageId: string;\n        strings?: string[];\n    }\n    interface TranslateResponse {\n        sourceLanguageId: string;\n        targetLanguageId: string;\n        strings: string[];\n        translations: string[];\n    }\n    type LanguageRecognitionProvider = 'crowdin' | 'engine';\n    interface ListMTsOptions extends PaginationOptions {\n        groupId?: number;\n    }\n}\n```\n\n##### notifications/index.d.ts\n\n```typescript\nimport { CrowdinApi } from '../core';\nexport declare class Notifications extends CrowdinApi {\n    sendNotificationToAuthenticatedUser(request: NotificationsModel.Notification): Promise<void>;\n    sendNotificationToProjectMembers(projectId: number, request: NotificationsModel.NotificationByUsers | NotificationsModel.NotificationByRole): Promise<void>;\n    sendNotificationToOrganizationMembers(request: NotificationsModel.Notification | NotificationsModel.NotificationByUsers | NotificationsModel.NotificationByRole): Promise<void>;\n}\nexport declare namespace NotificationsModel {\n    interface Notification {\n        message: string;\n    }\n    interface NotificationByUsers extends Notification {\n        userIds: number[];\n    }\n    interface NotificationByRole extends Notification {\n        role: 'owner' | 'admin';\n    }\n}\n```\n\n##### organizationWebhooks/index.d.ts\n\n```typescript\nimport { CrowdinApi, PaginationOptions, PatchRequest, ResponseList, ResponseObject } from '../core';\nimport { WebhooksModel } from '../webhooks';\nexport declare class OrganizationWebhooks extends CrowdinApi {\n    listWebhooks(options?: PaginationOptions): Promise<ResponseList<OrganizationWebhooksModel.OrganizationWebhook>>;\n    addWebhook(request: OrganizationWebhooksModel.AddOrganizationWebhookRequest): Promise<ResponseObject<OrganizationWebhooksModel.OrganizationWebhook>>;\n    getWebhook(webhookId: number): Promise<ResponseObject<OrganizationWebhooksModel.OrganizationWebhook>>;\n    deleteWebhook(webhookId: number): Promise<void>;\n    editWebhook(webhookId: number, request: PatchRequest[]): Promise<ResponseObject<OrganizationWebhooksModel.OrganizationWebhook>>;\n}\nexport declare namespace OrganizationWebhooksModel {\n    type OrganizationWebhook = Omit<WebhooksModel.Webhook, 'projectId' | 'events'> & {\n        events: Event[];\n    };\n    type AddOrganizationWebhookRequest = Omit<WebhooksModel.AddWebhookRequest, 'events'> & {\n        events: Event[];\n    };\n    type Event = 'group.created' | 'group.deleted' | 'project.created' | 'project.deleted';\n}\n```\n\n##### projectsGroups/index.d.ts\n\n```typescript\nimport { BooleanInt, CrowdinApi, DownloadLink, PaginationOptions, PatchRequest, ResponseList, ResponseObject } from '../core';\nimport { LanguagesModel } from '../languages';\nexport declare class ProjectsGroups extends CrowdinApi {\n    listGroups(options?: ProjectsGroupsModel.ListGroupsOptions): Promise<ResponseList<ProjectsGroupsModel.Group>>;\n    listGroups(parentId?: number, offset?: number, userId?: number, limit?: number): Promise<ResponseList<ProjectsGroupsModel.Group>>;\n    addGroup(request: ProjectsGroupsModel.AddGroupRequest): Promise<ResponseObject<ProjectsGroupsModel.Group>>;\n    getGroup(groupId: number): Promise<ResponseObject<ProjectsGroupsModel.Group>>;\n    deleteGroup(groupId: number): Promise<void>;\n    editGroup(groupId: number, request: PatchRequest[]): Promise<ResponseObject<ProjectsGroupsModel.Group>>;\n    listProjects(options?: ProjectsGroupsModel.ListProjectsOptions): Promise<ResponseList<ProjectsGroupsModel.Project | ProjectsGroupsModel.ProjectSettings>>;\n    listProjects(groupId?: number, hasManagerAccess?: BooleanInt, limit?: number, offset?: number): Promise<ResponseList<ProjectsGroupsModel.Project | ProjectsGroupsModel.ProjectSettings>>;\n    addProject(request: ProjectsGroupsModel.CreateProjectEnterpriseRequest | ProjectsGroupsModel.CreateProjectRequest): Promise<ResponseObject<ProjectsGroupsModel.Project | ProjectsGroupsModel.ProjectSettings>>;\n    getProject(projectId: number): Promise<ResponseObject<ProjectsGroupsModel.Project | ProjectsGroupsModel.ProjectSettings>>;\n    deleteProject(projectId: number): Promise<void>;\n    editProject(projectId: number, request: PatchRequest[]): Promise<ResponseObject<ProjectsGroupsModel.Project | ProjectsGroupsModel.ProjectSettings>>;\n    downloadProjectFileFormatSettingsCustomSegmentation(projectId: number, fileFormatSettingsId: number): Promise<ResponseObject<DownloadLink>>;\n    resetProjectFileFormatSettingsCustomSegmentation(projectId: number, fileFormatSettingsId: number): Promise<ResponseObject<DownloadLink>>;\n    listProjectFileFormatSettings(projectId: number, options?: PaginationOptions): Promise<ResponseList<ProjectsGroupsModel.ProjectFileFormatSettings>>;\n    addProjectFileFormatSettings(projectId: number, request: ProjectsGroupsModel.AddProjectFileFormatSettingsRequest): Promise<ResponseObject<ProjectsGroupsModel.ProjectFileFormatSettings>>;\n    getProjectFileFormatSettings(projectId: number, fileFormatSettingsId: number): Promise<ResponseObject<ProjectsGroupsModel.ProjectFileFormatSettings>>;\n    deleteProjectFileFormatSettings(projectId: number, fileFormatSettingsId: number): Promise<void>;\n    editProjectFileFormatSettings(projectId: number, fileFormatSettingsId: number, request: PatchRequest[]): Promise<ResponseObject<ProjectsGroupsModel.ProjectFileFormatSettings>>;\n    listProjectStringsExporterSettings(projectId: number, options?: PaginationOptions): Promise<ResponseList<ProjectsGroupsModel.ProjectStringsExporterSettings>>;\n    addProjectStringsExporterSettings(projectId: number, request: ProjectsGroupsModel.AddProjectStringsExporterSettingsRequest): Promise<ResponseObject<ProjectsGroupsModel.ProjectStringsExporterSettings>>;\n    getProjectStringsExporterSettings(projectId: number, systemStringsExporterSettingsId: number): Promise<ResponseObject<ProjectsGroupsModel.ProjectStringsExporterSettings>>;\n    deleteProjectStringsExporterSettings(projectId: number, systemStringsExporterSettingsId: number): Promise<void>;\n    editProjectStringsExporterSettings(projectId: number, systemStringsExporterSettingsId: number, request: ProjectsGroupsModel.AddProjectStringsExporterSettingsRequest): Promise<ResponseObject<ProjectsGroupsModel.ProjectStringsExporterSettings>>;\n}\nexport declare namespace ProjectsGroupsModel {\n    interface Group {\n        id: number;\n        name: string;\n        description: string;\n        parentId: number;\n        organizationId: number;\n        userId: number;\n        subgroupsCount: number;\n        projectsCount: number;\n        webUrl: string;\n        createdAt: string;\n        updatedAt: string;\n    }\n    interface AddGroupRequest {\n        name: string;\n        parentId?: number;\n        description?: string;\n    }\n    interface Project {\n        id: number;\n        type: Type;\n        userId: number;\n        sourceLanguageId: string;\n        targetLanguageIds: string[];\n        languageAccessPolicy: LanguageAccessPolicy;\n        name: string;\n        identifier: string;\n        description: string;\n        visibility: string;\n        logo: string;\n        publicDownloads: boolean;\n        createdAt: string;\n        updatedAt: string;\n        lastActivity: string;\n        sourceLanguage: LanguagesModel.Language;\n        targetLanguages: LanguagesModel.Language[];\n        webUrl: string;\n        savingsReportSettingsTemplateId: number;\n        fields: Record<string, any>;\n        cname: string;\n        groupId: number;\n        background: string;\n        isExternal: boolean;\n        externalType: string;\n        externalProjectId: number;\n        externalOrganizationId: number;\n        workflowId: number;\n        hasCrowdsourcing: boolean;\n        publicUrl: string;\n    }\n    interface CreateProjectRequest {\n        name: string;\n        identifier: string;\n        sourceLanguageId: string;\n        targetLanguageIds?: string[];\n        visibility?: JoinPolicy;\n        languageAccessPolicy?: LanguageAccessPolicy;\n        cname?: string;\n        description?: string;\n        tagDetection?: TagDetection;\n        isMtAllowed?: boolean;\n        taskBasedAccessControl?: boolean;\n        autoSubstitution?: boolean;\n        autoTranslateDialects?: boolean;\n        publicDownloads?: boolean;\n        hiddenStringsProofreadersAccess?: boolean;\n        useGlobalTm?: boolean;\n        showTmSuggestionsDialects?: boolean;\n        tmApprovedSuggestionsOnly?: boolean;\n        skipUntranslatedStrings?: boolean;\n        exportApprovedOnly?: boolean;\n        qaCheckIsActive?: boolean;\n        qaCheckCategories?: CheckCategories;\n        qaChecksIgnorableCategories?: CheckCategories;\n        languageMapping?: LanguageMapping;\n        glossaryAccess?: boolean;\n        glossaryAccessOption?: GlossaryAccessOption;\n        normalizePlaceholder?: boolean;\n        notificationSettings?: NotificationSettings;\n        tmPreTranslate?: ProjectSettings['tmPreTranslate'];\n        mtPreTranslate?: ProjectSettings['mtPreTranslate'];\n        aiPreTranslate?: ProjectSettings['aiPreTranslate'];\n        assistActionAiPromptId?: number;\n        editorSuggestionAiPromptId?: number;\n        savingsReportSettingsTemplateId?: number;\n        defaultTmId?: number;\n        defaultGlossaryId?: number;\n        inContext?: boolean;\n        inContextProcessHiddenStrings?: boolean;\n        inContextPseudoLanguageId?: string;\n        saveMetaInfoInSource?: boolean;\n        type?: BooleanInt;\n        skipUntranslatedFiles?: boolean;\n        tmContextType?: TmContextType;\n    }\n    interface CreateProjectEnterpriseRequest {\n        name: string;\n        sourceLanguageId: string;\n        templateId?: number;\n        steps?: WorkflowTemplateStepConfig[];\n        groupId?: number;\n        targetLanguageIds?: string[];\n        vendorId?: number;\n        mtEngineId?: number;\n        description?: string;\n        translateDuplicates?: TranslateDuplicates;\n        tagsDetection?: TagDetection;\n        isMtAllowed?: boolean;\n        taskBasedAccessControl?: boolean;\n        taskReviewerIds?: number[];\n        autoSubstitution?: boolean;\n        showTmSuggestionsDialects?: boolean;\n        tmApprovedSuggestionsOnly?: boolean;\n        autoTranslateDialects?: boolean;\n        publicDownloads?: boolean;\n        hiddenStringsProofreadersAccess?: boolean;\n        delayedWorkflowStart?: boolean;\n        skipUntranslatedStrings?: boolean;\n        exportWithMinApprovalsCount?: number;\n        exportStringsThatPassedWorkflow?: number;\n        normalizePlaceholder?: boolean;\n        qaCheckIsActive?: boolean;\n        qaApprovalsCount?: number;\n        qaCheckCategories?: CheckCategories;\n        qaChecksIgnorableCategories?: CheckCategories;\n        customQaCheckIds?: number[];\n        languageMapping?: LanguageMapping;\n        glossaryAccess?: boolean;\n        glossaryAccessOption?: GlossaryAccessOption;\n        notificationSettings?: NotificationSettings;\n        savingsReportSettingsTemplateId?: number;\n        fields?: Record<string, any>;\n        assistActionAiPromptId?: number;\n        editorSuggestionAiPromptId?: number;\n        alignmentActionAiPromptId?: number;\n        defaultTmId?: number;\n        defaultGlossaryId?: number;\n        inContext?: boolean;\n        inContextProcessHiddenStrings?: boolean;\n        inContextPseudoLanguageId?: string;\n        saveMetaInfoInSource?: boolean;\n        type?: BooleanInt;\n        skipUntranslatedFiles?: boolean;\n        tmContextType?: TmContextType;\n    }\n    type GlossaryAccessOption = 'readOnly' | 'fullAccess' | 'manageDrafts';\n    interface ProjectSettings extends Project {\n        translateDuplicates: TranslateDuplicates;\n        tagsDetection: TagDetection;\n        glossaryAccess: boolean;\n        glossaryAccessOption: GlossaryAccessOption;\n        isMtAllowed: boolean;\n        taskBasedAccessControl: boolean;\n        hiddenStringsProofreadersAccess: boolean;\n        autoSubstitution: boolean;\n        exportTranslatedOnly: boolean;\n        skipUntranslatedStrings: boolean;\n        exportApprovedOnly: boolean;\n        autoTranslateDialects: boolean;\n        useGlobalTm: boolean;\n        showTmSuggestionsDialects: boolean;\n        tmApprovedSuggestionsOnly: boolean;\n        isSuspended: boolean;\n        qaCheckIsActive: boolean;\n        qaCheckCategories: CheckCategories;\n        qaChecksIgnorableCategories: CheckCategories;\n        languageMapping: LanguageMapping;\n        notificationSettings: NotificationSettings;\n        defaultTmId: number;\n        defaultGlossaryId: number;\n        assignedTms: {\n            [id: string]: {\n                priority: number;\n            };\n        };\n        assignedGlossaries: number[];\n        tmPenalties: {\n            autoSubstitution: number;\n            tmPriority: {\n                priority: number;\n                penalty: number;\n            };\n            multipleTranslations: number;\n            timeSinceLastUsage: {\n                months: number;\n                penalty: number;\n            };\n            timeSinceLastModified: {\n                months: number;\n                penalty: number;\n            };\n        };\n        normalizePlaceholder: boolean;\n        tmPreTranslate: {\n            enabled: boolean;\n            autoApproveOption: 'all' | 'perfectMatchOnly' | 'exceptAutoSubstituted' | 'perfectMatchApprovedOnly' | 'none';\n            minimumMatchRatio: 'perfect' | '100';\n        };\n        mtPreTranslate: {\n            enabled: boolean;\n            mts: {\n                mtId: number;\n                languageIds: string[];\n            }[];\n        };\n        aiPreTranslate: {\n            enabled: boolean;\n            aiPrompts: {\n                aiPromptId: number;\n                languageIds: string[];\n            }[];\n        };\n        assistActionAiPromptId: number;\n        editorSuggestionAiPromptId: number;\n        inContext: boolean;\n        inContextProcessHiddenStrings: string;\n        inContextPseudoLanguageId: string;\n        inContextPseudoLanguage: LanguagesModel.Language;\n        saveMetaInfoInSource: boolean;\n        skipUntranslatedFiles: boolean;\n        tmContextType: TmContextType;\n        clientOrganizationId: number;\n        taskReviewerIds: number[];\n        exportWithMinApprovalsCount: number;\n        exportStringsThatPassedWorkflow: boolean;\n        qaApprovalsCount: number;\n        customQaCheckIds: number[];\n        externalQaCheckIds: number[];\n        delayedWorkflowStart: boolean;\n        alignmentActionAiPromptId: number;\n    }\n    enum Type {\n        FILES_BASED = 0,\n        STRINGS_BASED = 1\n    }\n    enum TagDetection {\n        AUTO = 0,\n        COUNT_TAGS = 1,\n        SKIP_TAGS = 2\n    }\n    type JoinPolicy = 'open' | 'private';\n    type LanguageAccessPolicy = 'open' | 'moderate';\n    interface CheckCategories {\n        empty: boolean;\n        size: boolean;\n        tags: boolean;\n        spaces: boolean;\n        variables: boolean;\n        punctuation: boolean;\n        symbolRegister: boolean;\n        specialSymbols: boolean;\n        wrongTranslation: boolean;\n        spellcheck: boolean;\n        icu: boolean;\n        terms: boolean;\n        duplicate: boolean;\n        ftl: boolean;\n        android: boolean;\n    }\n    interface LanguageMapping {\n        [key: string]: LanguageMappingEntity;\n    }\n    interface LanguageMappingEntity {\n        name: string;\n        two_letters_code: string;\n        three_letters_code: string;\n        locale: string;\n        locale_with_underscore: string;\n        android_code: string;\n        osx_code: string;\n        osx_locale: string;\n    }\n    enum TranslateDuplicates {\n        SHOW = 0,\n        HIDE_REGULAR_DETECTION = 1,\n        SHOW_AUTO_TRANSLATE = 2,\n        SHOW_WITHIN_VERION_BRANCH_REGULAR_DETECTION = 3,\n        HIDE_STRICT_DETECTION = 4,\n        SHOW_WITHIN_VERION_BRANCH_STRICT_DETECTION = 5\n    }\n    interface NotificationSettings {\n        translatorNewStrings?: boolean;\n        managerNewStrings?: boolean;\n        managerLanguageCompleted?: boolean;\n    }\n    interface ListGroupsOptions extends PaginationOptions {\n        parentId?: number;\n        userId?: number;\n        orderBy?: string;\n    }\n    interface ListProjectsOptions extends PaginationOptions {\n        groupId?: number;\n        hasManagerAccess?: BooleanInt;\n        orderBy?: string;\n        type?: BooleanInt;\n    }\n    type Settings = PropertyFileFormatSettings | CommonFileFormatSettings | XmlFileFormatSettings | MdxV2FormatSettings | FmHtmlFormatSettings | HtmlFormatSettings | JsonFormatSettings | MdxV1FormatSettings | JavaScriptFileFormatSettings | DocxFileFormatSettings;\n    interface ProjectFileFormatSettings {\n        id: number;\n        name: string;\n        format: string;\n        extensions: string[];\n        settings: Settings;\n        createdAt: string;\n        updatedAt: string;\n    }\n    interface AddProjectFileFormatSettingsRequest {\n        format: string;\n        settings: Settings;\n    }\n    interface PropertyFileFormatSettings {\n        escapeQuotes?: 0 | 1 | 2 | 3;\n        escapeSpecialCharacters?: 0 | 1;\n        exportPattern?: string;\n    }\n    interface JavaScriptFileFormatSettings {\n        exportPattern?: 'string';\n        exportQuotes?: 'single' | 'double';\n    }\n    interface CommonFileFormatSettings {\n        contentSegmentation?: boolean;\n        srxStorageId?: number;\n        exportPattern?: string;\n    }\n    interface XmlFileFormatSettings extends CommonFileFormatSettings {\n        translateContent?: boolean;\n        translateAttributes?: boolean;\n        translatableElements?: string[];\n    }\n    interface JsonFormatSettings extends CommonFileFormatSettings {\n        type?: 'i18next_json' | 'nestjs_i18n';\n    }\n    interface MdxV2FormatSettings extends CommonFileFormatSettings {\n        excludeCodeBlocks?: boolean;\n        excludedFrontMatterElements?: string[];\n    }\n    interface MdxV1FormatSettings extends CommonFileFormatSettings {\n        excludeCodeBlocks?: boolean;\n        excludedFrontMatterElements?: string[];\n        type?: 'mdx_v1' | 'mdx_v2';\n    }\n    interface FmHtmlFormatSettings extends CommonFileFormatSettings {\n        excludedElements?: boolean;\n        excludedFrontMatterElements?: string[];\n    }\n    interface HtmlFormatSettings extends CommonFileFormatSettings {\n        excludedElements?: boolean;\n    }\n    interface DocxFileFormatSettings extends CommonFileFormatSettings {\n        cleanTagsAggressively?: boolean;\n        translateHiddenText?: boolean;\n        translateHyperlinkUrls?: boolean;\n        translateHiddenRowsAndColumns?: boolean;\n        importNotes?: boolean;\n        importHiddenSlides?: boolean;\n    }\n    type TmContextType = 'segmentContext' | 'auto' | 'prevAndNextSegment';\n    type WorkflowTemplateStepConfig = WorkflowTemplateStepConfigTranslateProofread | WorkflowTemplateStepConfigVendor | WorkflowTemplateStepConfigTMPreTranslate | WorkflowTemplateStepConfigMTPreTranslate;\n    interface WorkflowTemplateStepConfigTranslateProofread {\n        id: number;\n        languages?: string[];\n        assignees?: number[];\n        config?: {\n            assignees: {\n                [key: string]: number[];\n            };\n        };\n    }\n    interface WorkflowTemplateStepConfigVendor {\n        id: number;\n        languages?: string[];\n        vendorId?: number;\n    }\n    interface WorkflowTemplateStepConfigTMPreTranslate {\n        id: number;\n        languages?: string[];\n        config?: {\n            minRelevant?: number;\n            autoSubstitution?: boolean;\n        };\n    }\n    interface WorkflowTemplateStepConfigMTPreTranslate {\n        id: number;\n        languages?: string[];\n        mtId?: number;\n    }\n    type StringsExporterSettings = AndroidStringsExporterSettings | MacOSXStringsExporterSettings | XliffStringsExporterSettings;\n    interface ProjectStringsExporterSettings {\n        id: number;\n        format: string;\n        settings: StringsExporterSettings;\n        createdAt: string;\n        updatedAt: string;\n    }\n    interface AndroidStringsExporterSettings {\n        convertPlaceholders?: boolean;\n        convertLineBreaks?: boolean;\n        useCdataForStringsWithTags?: boolean;\n    }\n    interface MacOSXStringsExporterSettings {\n        convertPlaceholders?: boolean;\n        convertLineBreaks?: boolean;\n    }\n    interface XliffStringsExporterSettings {\n        languagePairMapping?: {\n            [key: string]: {\n                sourceLanguageId: string;\n            };\n        };\n        copySourceToEmptyTarget?: boolean;\n        exportTranslatorsComment?: boolean;\n    }\n    interface AddProjectStringsExporterSettingsRequest {\n        format: string;\n        settings: StringsExporterSettings;\n    }\n}\n```\n\n##### reports/index.d.ts\n\n```typescript\nimport { CrowdinApi, DownloadLink, PaginationOptions, PatchRequest, ResponseList, ResponseObject, Status } from '../core';\nexport declare class Reports extends CrowdinApi {\n    listOrganizationReportArchives(options?: ReportsModel.ListReportArchiveParams): Promise<ResponseList<ReportsModel.ReportArchive>>;\n    getOrganizationReportArchive(archiveId: number): Promise<ResponseObject<ReportsModel.ReportArchive>>;\n    deleteOrganizationReportArchive(archiveId: number): Promise<void>;\n    exportOrganizationReportArchive(archiveId: number, request?: {\n        format?: ReportsModel.Format;\n    }): Promise<ResponseObject<Status<ReportsModel.ReportArchiveStatusAttribute>>>;\n    checkOrganizationReportArchiveStatus(archiveId: number, exportId: string): Promise<ResponseObject<Status<ReportsModel.ReportArchiveStatusAttribute>>>;\n    downloadOrganizationReportArchive(archiveId: number, exportId: string): Promise<ResponseObject<DownloadLink>>;\n    listUserReportArchives(userId: number, options?: ReportsModel.ListReportArchiveParams): Promise<ResponseList<ReportsModel.ReportArchive>>;\n    getUserReportArchive(userId: number, archiveId: number): Promise<ResponseObject<ReportsModel.ReportArchive>>;\n    deleteUserReportArchive(userId: number, archiveId: number): Promise<void>;\n    exportUserReportArchive(userId: number, archiveId: number, request?: {\n        format?: ReportsModel.Format;\n    }): Promise<ResponseObject<Status<ReportsModel.ReportArchiveStatusAttribute>>>;\n    checkUserReportArchiveStatus(userId: number, archiveId: number, exportId: string): Promise<ResponseObject<Status<ReportsModel.ReportArchiveStatusAttribute>>>;\n    downloadUserReportArchive(userId: number, archiveId: number, exportId: string): Promise<ResponseObject<DownloadLink>>;\n    generateGroupReport(groupId: number, request: ReportsModel.GenerateGroupReportRequest): Promise<ResponseObject<Status<ReportsModel.ReportStatusAttributes<ReportsModel.GroupReportSchema>>>>;\n    checkGroupReportStatus(groupId: number, reportId: string): Promise<ResponseObject<Status<ReportsModel.ReportStatusAttributes<ReportsModel.GroupReportSchema>>>>;\n    downloadGroupReport(groupId: number, reportId: string): Promise<ResponseObject<DownloadLink>>;\n    listOrganizationReportSettingsTemplates(options?: ReportsModel.ListOrganizationReportSettingsParams): Promise<ResponseList<ReportsModel.OrganizationReportSettings>>;\n    addOrganizationReportSettingsTemplate(request: ReportsModel.AddOrganizationReportSettingsRequest): Promise<ResponseObject<ReportsModel.OrganizationReportSettings>>;\n    getOrganizationReportSettingsTemplate(reportSettingsTemplateId: number): Promise<ResponseObject<ReportsModel.OrganizationReportSettings>>;\n    editOrganizationReportSettingsTemplate(reportSettingsTemplateId: number, request: PatchRequest[]): Promise<ResponseObject<ReportsModel.OrganizationReportSettings>>;\n    deleteOrganizationReportSettingsTemplate(reportSettingsTemplateId: number): Promise<void>;\n    generateOrganizationReport(request: ReportsModel.GenerateOrganizationReportRequest): Promise<ResponseObject<Status<ReportsModel.ReportStatusAttributes<ReportsModel.OrganizationReportSchema>>>>;\n    checkOrganizationReportStatus(reportId: string): Promise<ResponseObject<Status<ReportsModel.ReportStatusAttributes<ReportsModel.OrganizationReportSchema>>>>;\n    downloadOrganizationReport(reportId: string): Promise<ResponseObject<DownloadLink>>;\n    generateReport(projectId: number, request: ReportsModel.GenerateReportRequest): Promise<ResponseObject<Status<ReportsModel.ReportStatusAttributes<ReportsModel.ReportSchema>>>>;\n    checkReportStatus(projectId: number, reportId: string): Promise<ResponseObject<Status<ReportsModel.ReportStatusAttributes<ReportsModel.ReportSchema>>>>;\n    downloadReport(projectId: number, reportId: string): Promise<ResponseObject<DownloadLink>>;\n    listReportSettingsTemplates(projectId: number, options?: PaginationOptions): Promise<ResponseList<ReportsModel.ReportSettings>>;\n    addReportSettingsTemplate(projectId: number, request: ReportsModel.AddReportSettingsRequest): Promise<ResponseObject<ReportsModel.ReportSettings>>;\n    getReportSettingsTemplate(projectId: number, reportSettingsTemplateId: number): Promise<ResponseObject<ReportsModel.ReportSettings>>;\n    editReportSettingsTemplate(projectId: number, reportSettingsTemplateId: number, request: PatchRequest[]): Promise<ResponseObject<ReportsModel.ReportSettings>>;\n    deleteReportSettingsTemplate(projectId: number, reportSettingsTemplateId: number): Promise<void>;\n    listUserReportSettingsTemplates(userId: number, options?: PaginationOptions): Promise<ResponseList<ReportsModel.UserReportSettings>>;\n    addUserReportSettingsTemplate(userId: number, request: ReportsModel.AddUserReportSettingsRequest): Promise<ResponseObject<ReportsModel.UserReportSettings>>;\n    getUserReportSettingsTemplate(userId: number, reportSettingsTemplateId: number): Promise<ResponseObject<ReportsModel.UserReportSettings>>;\n    editUserReportSettingsTemplate(userId: number, reportSettingsTemplateId: number, request: PatchRequest[]): Promise<ResponseObject<ReportsModel.UserReportSettings>>;\n    deleteUserReportSettingsTemplate(userId: number, reportSettingsTemplateId: number): Promise<void>;\n}\nexport declare namespace ReportsModel {\n    interface ReportArchive {\n        id: number;\n        scopeType: string;\n        scopeId: number;\n        userId: number;\n        name: string;\n        webUrl: string;\n        scheme: any;\n        createdAt: string;\n    }\n    interface ListReportArchiveParams extends PaginationOptions {\n        scopeType: string;\n        scopeId: number;\n    }\n    interface ReportArchiveStatusAttribute {\n        format: Format;\n        reportName: string;\n        schema: any;\n    }\n    type GroupReportSchema = GroupTranslationCostsPostEditingSchema | GroupTopMembersSchema | GroupTaskUsageSchema | GroupQaCheckIssuesSchema | GroupTranslationActivitySchema;\n    type OrganizationReportSchema = GroupTranslationCostsPostEditingSchema | GroupTopMembersSchema | GroupTaskUsageSchema | GroupQaCheckIssuesSchema | GroupTranslationActivitySchema;\n    interface GenerateGroupReportRequest {\n        name: string;\n        schema: GroupReportSchema;\n    }\n    interface GenerateOrganizationReportRequest {\n        name: string;\n        schema: OrganizationReportSchema;\n    }\n    interface GroupTranslationCostsPostEditingSchema {\n        projectIds?: number[];\n        unit?: Unit;\n        currency?: Currency;\n        format?: Format;\n        baseRates: BaseRate;\n        individualRates: IndividualRate[];\n        netRateSchemes: NetRateSchemas;\n        excludeApprovalsForEditedTranslations?: boolean;\n        preTranslatedStringsCategorizationAdjustment?: boolean;\n        groupBy?: GroupBy;\n        dateFrom?: string;\n        dateTo?: string;\n        userIds?: number[];\n    }\n    interface GroupTranslationCostsPerEditingByTaskSchema {\n        unit?: Unit;\n        currency?: Currency;\n        format?: Format;\n        baseRates: BaseRate;\n        individualRates: IndividualRate[];\n        netRateSchemes: NetRateSchemas;\n        taskId?: number;\n    }\n    interface CostsEstimationSchema {\n        projectIds?: number[];\n        unit?: Unit;\n        currency?: Currency;\n        format?: Format;\n        baseRates: BaseRate;\n        individualRates: IndividualRate[];\n        netRateSchemes: NetRateSchemas;\n        calculateInternalMatches?: boolean;\n        includePreTranslatedStrings?: boolean;\n        languageId?: string;\n        branchIds?: number[];\n        dateFrom?: string;\n        dateTo?: string;\n        labelIds?: number[];\n        labelIncludeType?: LabelIncludeType;\n    }\n    interface CostsEstimationByTaskSchema {\n        unit?: Unit;\n        currency?: Currency;\n        format?: Format;\n        baseRates?: BaseRate;\n        individualRates?: IndividualRate[];\n        netRateSchemes?: NetRateSchemas;\n        calculateInternalMatches?: boolean;\n        includePreTranslatedStrings?: boolean;\n        taskId?: number;\n    }\n    interface GroupTopMembersSchema {\n        projectIds?: number[];\n        unit?: Unit;\n        languageId?: string;\n        format?: Format;\n        dateFrom?: string;\n        dateTo?: string;\n    }\n    interface RawDataSchema {\n        mode: ContributionMode;\n        unit?: Unit;\n        languageId?: string;\n        userId?: number;\n        dateFrom?: string;\n        dateTo?: string;\n    }\n    type GenerateReportRequest = PreTranslateEfficeincy | PreTranslateAccuracy | TranslateAccuracy | CostEstimationPostEnding | TranslationCostsPostEnding | TopMembers | ContributionRawData | SourceContentUpdates | ProjectMembers | EditorIssues | QaCheckIssues | SavingActivity | TranslationActivity;\n    type ReportSchema = Pick<GenerateReportRequest, 'schema'>;\n    interface PreTranslateEfficeincy {\n        name: 'pre-translate-efficiency';\n        schema: PreTranslateAccuracySchema | PreTranslateAccuracySchemaByTask;\n    }\n    interface PreTranslateAccuracy {\n        name: 'pre-translate-accuracy';\n        schema: PreTranslateAccuracySchema | PreTranslateAccuracySchemaByTask;\n    }\n    interface TranslateAccuracy {\n        name: 'translator-accuracy';\n        schema: TranslateAccuracySchema;\n    }\n    interface CostEstimationPostEnding {\n        name: 'costs-estimation-pe';\n        schema: CostEstimationPostEndingSchema | CostEstimationPostEndingSchemaByTask;\n    }\n    interface TranslationCostsPostEnding {\n        name: 'translation-costs-pe';\n        schema: TranslationCostsPostEndingSchema | TranslationCostsPostEndingSchemaByTask;\n    }\n    interface TopMembers {\n        name: 'top-members';\n        schema: TopMembersSchema;\n    }\n    interface ContributionRawData {\n        name: 'contribution-raw-data';\n        schema: ContributionRawDataSchema | ContributionRawDataSchemaByTask;\n    }\n    interface SourceContentUpdates {\n        name: 'source-content-updates';\n        schema: SourceContentUpdatesSchema;\n    }\n    interface ProjectMembers {\n        name: 'project-members';\n        schema: MembersSchema;\n    }\n    interface EditorIssues {\n        name: 'editor-issues';\n        schema: EditorIssuesSchema;\n    }\n    interface QaCheckIssues {\n        name: 'qa-check-issues';\n        schema: ProjectQaCheckIssuesSchema;\n    }\n    interface SavingActivity {\n        name: 'saving-activity';\n        schema: SavingActivitySchema;\n    }\n    interface TranslationActivity {\n        name: 'translation-activity';\n        schema: ProjectConsumptionSchema;\n    }\n    interface ReportStatusAttributes<S> {\n        format: Format;\n        reportName: string;\n        schema: S;\n    }\n    interface PreTranslateAccuracySchema {\n        unit?: Unit;\n        format?: Format;\n        postEditingCategories?: string[];\n        languageId?: string;\n        dateFrom?: string;\n        dateTo?: string;\n    }\n    interface PreTranslateAccuracySchemaByTask {\n        unit?: Unit;\n        format?: Format;\n        postEditingCategories?: string[];\n        taskId?: number;\n    }\n    interface TranslateAccuracySchema {\n        unit?: Unit;\n        format?: Format;\n        postEditingCategories?: string[];\n        languageId?: string;\n        userIds?: number[];\n        dateFrom?: string;\n        dateTo?: string;\n    }\n    interface CostEstimationPostEndingSchema {\n        unit?: Unit;\n        currency?: Currency;\n        format?: Format;\n        baseRates: BaseRate;\n        individualRates: IndividualRate[];\n        netRateSchemes: Omit<NetRateSchemas, 'mtMatch' | 'suggestionMatch'>;\n        calculateInternalMatches?: boolean;\n        includePreTranslatedStrings?: boolean;\n        languageId?: string;\n        fileIds?: number[];\n        directoryIds?: number[];\n        branchIds?: number[];\n        dateFrom?: string;\n        dateTo?: string;\n        labelIds?: number[];\n        labelIncludeType?: LabelIncludeType;\n        workflowStepId?: number;\n    }\n    interface CostEstimationPostEndingSchemaByTask {\n        unit?: Unit;\n        currency?: Currency;\n        format?: Format;\n        baseRates?: BaseRate;\n        individualRates?: IndividualRate[];\n        netRateSchemes?: Omit<NetRateSchemas, 'mtMatch' | 'suggestionMatch'>;\n        calculateInternalMatches?: boolean;\n        includePreTranslatedStrings?: boolean;\n        taskId?: number;\n    }\n    interface TranslationCostsPostEndingSchemaByTask {\n        unit?: Unit;\n        currency?: Currency;\n        format?: Format;\n        baseRates: BaseRate;\n        individualRates: IndividualRate[];\n        netRateSchemes: NetRateSchemas;\n        taskId?: number;\n        excludeApprovalsForEditedTranslations?: boolean;\n        preTranslatedStringsCategorizationAdjustment?: boolean;\n    }\n    interface TranslationCostsPostEndingSchema {\n        unit?: Unit;\n        currency?: Currency;\n        format?: Format;\n        baseRates: BaseRate;\n        individualRates: IndividualRate[];\n        netRateSchemes: NetRateSchemas;\n        excludeApprovalsForEditedTranslations?: boolean;\n        preTranslatedStringsCategorizationAdjustment?: boolean;\n        groupBy?: GroupBy;\n        dateFrom?: string;\n        dateTo?: string;\n        languageId?: string;\n        userIds?: number[];\n        fileIds?: number[];\n        directoryIds?: number[];\n        branchIds?: number[];\n        labelIds?: number;\n        labelIncludeType?: LabelIncludeType;\n        workflowStepId?: number;\n    }\n    interface TopMembersSchema {\n        unit?: Unit;\n        languageId?: string;\n        format?: Format;\n        dateFrom?: string;\n        dateTo?: string;\n    }\n    interface ContributionRawDataSchema {\n        mode: ContributionMode;\n        unit?: Unit;\n        languageId?: string;\n        userId?: string;\n        columns?: Column[];\n        fileIds?: number[];\n        directoryIds?: number[];\n        branchIds?: number[];\n        tmIds?: number[];\n        mtIds?: number[];\n        aiPromptIds?: number[];\n        dateFrom?: string;\n        dateTo?: string;\n    }\n    interface ContributionRawDataSchemaByTask {\n        mode: ContributionMode;\n        unit?: Unit;\n        taskId: number;\n        columns?: Column[];\n        tmIds?: number[];\n        mtIds?: number[];\n        aiPromptIds?: number[];\n        dateFrom?: string;\n        dateTo?: string;\n    }\n    interface PreTranslateEfficiencySchema {\n        unit?: Unit;\n        format?: Format;\n        postEditingCategories?: string[];\n        languageId?: string;\n        dateFrom?: string;\n        dateTo?: string;\n    }\n    interface ListOrganizationReportSettingsParams extends PaginationOptions {\n        projectId?: number;\n        groupId?: number;\n    }\n    interface ReportSettings {\n        id: number;\n        name: string;\n        currency: Currency;\n        unit: Unit;\n        config: ReportSettinsConfig;\n        isPublic: boolean;\n        isGlobal: boolean;\n        createdAt: string;\n        updatedAt: string;\n    }\n    interface AddReportSettingsRequest {\n        name: string;\n        currency: Currency;\n        unit: Unit;\n        config: ReportSettinsConfig;\n        isPublic?: boolean;\n        isGlobal?: boolean;\n    }\n    type UserReportSettings = Omit<ReportSettings, 'isPublic' | 'isGlobal'>;\n    type AddUserReportSettingsRequest = Omit<AddReportSettingsRequest, 'isPublic' | 'isGlobal'>;\n    type OrganizationReportSettings = Omit<ReportSettings, 'isGlobal'> & {\n        projectId: number;\n        groupId: number;\n    };\n    type AddOrganizationReportSettingsRequest = Omit<AddReportSettingsRequest, 'isGlobal'> & {\n        projectId?: number;\n        groupId?: number;\n    };\n    interface ReportSettinsConfig {\n        baseRates: BaseRate;\n        netRateSchemes: NetRateSchemas[];\n        individualRates: IndividualRate[];\n    }\n    type Unit = 'strings' | 'words' | 'chars' | 'chars_with_spaces';\n    type Currency = 'USD' | 'EUR' | 'JPY' | 'GBP' | 'AUD' | 'CAD' | 'CHF' | 'CNY' | 'SEK' | 'NZD' | 'MXN' | 'SGD' | 'HKD' | 'NOK' | 'KRW' | 'TRY' | 'RUB' | 'INR' | 'BRL' | 'ZAR' | 'GEL' | 'UAH';\n    type Format = 'xlsx' | 'csv' | 'json';\n    interface BaseRate {\n        fullTranslation: number;\n        proofread: number;\n    }\n    interface IndividualRate extends BaseRate {\n        languageIds: string[];\n        userIds: number[];\n        fullTranslation: number;\n        proofread: number;\n    }\n    interface NetRateSchemas {\n        tmMatch: {\n            matchType: Mode;\n            price: number;\n        }[];\n        mtMatch: {\n            matchType: Mode;\n            price: number;\n        }[];\n        suggestionMatch: {\n            matchType: Mode;\n            price: number;\n        }[];\n        aiMatch?: {\n            matchType: Mode;\n            price: number;\n        }[];\n    }\n    type Mode = 'no_match' | 'tm_match' | 'approval' | '99-95' | '94-90' | '89-80' | 'perfect' | '100';\n    type ContributionMode = 'translations' | 'approvals' | 'votes';\n    type GroupBy = 'user' | 'language';\n    type LabelIncludeType = 'strings_with_label' | 'strings_without_label';\n    type Column = 'userId' | 'languageId' | 'stringId' | 'translationId' | 'fileId' | 'filePath' | 'pluralForm' | 'sourceStringTextHash' | 'mtEngine' | 'mtId' | 'tmName' | 'tmId' | 'aiPromptName' | 'aiPromptId' | 'preTranslated' | 'tmMatch' | 'mtMatch' | 'aiMatch' | 'suggestionMatch' | 'sourceUnits' | 'targetUnits' | 'createdAt' | 'updatedAt' | 'mark';\n    interface SourceContentUpdatesSchema {\n        unit?: Unit;\n        format?: Format;\n        dateFrom?: string;\n        dateTo?: string;\n        languageId?: string;\n        userIds?: number[];\n        fileIds?: number[];\n        directoryIds?: number[];\n        branchIds?: number[];\n        labelIds?: number[];\n        labelIncludeType?: LabelIncludeType;\n    }\n    interface MembersSchema {\n        format?: Format;\n        dateFrom?: string;\n        dateTo?: string;\n    }\n    interface EditorIssuesSchema {\n        dateFrom?: string;\n        dateTo?: string;\n        format?: Format;\n        languageId?: string;\n        userId?: number;\n    }\n    interface ProjectQaCheckIssuesSchema {\n        format?: Format;\n        dateFrom?: string;\n        dateTo?: string;\n        languageId?: string;\n    }\n    interface SavingActivitySchema {\n        unit?: Unit;\n        languageId?: string;\n        format?: Format;\n        dateFrom?: string;\n        dateTo?: string;\n        userIds?: number[];\n        fileIds?: number[];\n        directoryIds?: number[];\n        branchIds?: number[];\n        labelIds?: number[];\n        labelIncludeType?: LabelIncludeType;\n    }\n    interface ProjectConsumptionSchema {\n        unit?: Unit;\n        languageId?: string;\n        format?: Format;\n        dateFrom?: string;\n        dateTo?: string;\n        userIds?: number[];\n        fileIds?: number[];\n        directoryIds?: number[];\n        branchIds?: number[];\n        labelIds?: number[];\n        labelIncludeType?: LabelIncludeType;\n    }\n    interface GroupTaskUsageSchema {\n        format: Format;\n        type: 'workload' | 'create-vs-resolve' | 'performance' | 'time' | 'cost';\n        projectIds?: number[];\n        assigneeId?: number;\n        creatorId?: number;\n        dateFrom?: string;\n        dateTo?: string;\n        wordsCountFrom?: number;\n        wordsCountTo?: number;\n        excludeApprovalsForEditedTranslations?: boolean;\n        currency?: Currency;\n        baseRates?: BaseRate;\n        individualRates?: IndividualRate[];\n        netRateSchemes?: NetRateSchemas;\n    }\n    interface GroupQaCheckIssuesSchema {\n        projectIds?: number[];\n        format?: Format;\n        dateFrom?: string;\n        dateTo?: string;\n        languageId?: string;\n    }\n    interface GroupTranslationActivitySchema {\n        projectIds?: number[];\n        unit?: Unit;\n        languageId?: string;\n        format?: Format;\n        dateFrom?: string;\n        dateTo?: string;\n        userIds?: number[];\n        fileIds?: number[];\n        directoryIds?: number[];\n        branchIds?: number[];\n        labelIds?: number[];\n        labelIncludeType?: LabelIncludeType;\n    }\n}\n```\n\n##### screenshots/index.d.ts\n\n```typescript\nimport { CrowdinApi, PaginationOptions, PatchRequest, ResponseList, ResponseObject } from '../core';\nexport declare class Screenshots extends CrowdinApi {\n    listScreenshots(projectId: number, options?: ScreenshotsModel.ListScreenshotParams): Promise<ResponseList<ScreenshotsModel.Screenshot>>;\n    listScreenshots(projectId: number, limit?: number, offset?: number): Promise<ResponseList<ScreenshotsModel.Screenshot>>;\n    addScreenshot(projectId: number, request: ScreenshotsModel.CreateScreenshotRequest): Promise<ResponseObject<ScreenshotsModel.Screenshot>>;\n    getScreenshot(projectId: number, screenshotId: number): Promise<ResponseObject<ScreenshotsModel.Screenshot>>;\n    updateScreenshot(projectId: number, screenshotId: number, request: ScreenshotsModel.UpdateScreenshotRequest): Promise<ResponseObject<ScreenshotsModel.Screenshot>>;\n    deleteScreenshot(projectId: number, screenshotId: number): Promise<void>;\n    editScreenshot(projectId: number, screenshotId: number, request: PatchRequest[]): Promise<ResponseObject<ScreenshotsModel.Screenshot>>;\n    listScreenshotTags(projectId: number, screenshotId: number, options?: PaginationOptions): Promise<ResponseList<ScreenshotsModel.Tag>>;\n    listScreenshotTags(projectId: number, screenshotId: number, limit?: number, offset?: number): Promise<ResponseList<ScreenshotsModel.Tag>>;\n    replaceTags(projectId: number, screenshotId: number, request: ScreenshotsModel.ReplaceTagRequest[] | ScreenshotsModel.AutoTagRequest): Promise<void>;\n    addTag(projectId: number, screenshotId: number, request: ScreenshotsModel.ReplaceTagRequest[]): Promise<ResponseObject<ScreenshotsModel.Tag>>;\n    clearTags(projectId: number, screenshotId: number): Promise<void>;\n    getTag(projectId: number, screenshotId: number, tagId: number): Promise<ResponseObject<ScreenshotsModel.Tag>>;\n    deleteTag(projectId: number, screenshotId: number, tagId: number): Promise<void>;\n    updateTag(projectId: number, screenshotId: number, tagId: number, request: PatchRequest[]): Promise<ResponseObject<ScreenshotsModel.Screenshot>>;\n}\nexport declare namespace ScreenshotsModel {\n    interface ListScreenshotParams extends PaginationOptions {\n        stringIds?: number[];\n        stringId?: number;\n        labelIds?: string;\n        excludeLabelIds?: string;\n        orderBy?: string;\n    }\n    interface Screenshot {\n        id: number;\n        userId: number;\n        url: string;\n        webUrl: string;\n        name: string;\n        size: Size;\n        tagsCount: number;\n        tags: Tag[];\n        labels: number[];\n        labelIds: number[];\n        createdAt: string;\n        updatedAt: string;\n    }\n    interface CreateScreenshotRequest {\n        storageId: number;\n        name: string;\n        autoTag?: boolean;\n        fileId?: number;\n        branchId?: number;\n        directoryId?: number;\n        labelIds?: number[];\n    }\n    interface UpdateScreenshotRequest {\n        storageId: number;\n        name: string;\n    }\n    interface Tag {\n        id: number;\n        screenshotId: number;\n        stringId: number;\n        position: Position;\n        createdAt: string;\n    }\n    interface ReplaceTagRequest {\n        stringId: number;\n        position?: Position;\n    }\n    interface AutoTagRequest {\n        autoTag: boolean;\n        fileId?: number;\n        branchId?: number;\n        directoryId?: number;\n    }\n    interface Size {\n        width: number;\n        height: number;\n    }\n    interface Position {\n        x: number;\n        y: number;\n        width: number;\n        height: number;\n    }\n}\n```\n\n##### securityLogs/index.d.ts\n\n```typescript\nimport { CrowdinApi, PaginationOptions, ResponseList, ResponseObject } from '../core';\nexport declare class SecurityLogs extends CrowdinApi {\n    listOrganizationSecurityLogs(options?: SecurityLogsModel.ListOrganizationSecurityLogsParams): Promise<ResponseList<SecurityLogsModel.SecurityLog>>;\n    getOrganizationSecurityLog(securityLogId: number): Promise<ResponseObject<SecurityLogsModel.SecurityLog>>;\n    listUserSecurityLogs(userId: number, options?: SecurityLogsModel.ListUserSecurityLogsParams): Promise<ResponseList<SecurityLogsModel.SecurityLog>>;\n    getUserSecurityLog(userId: number, securityLogId: number): Promise<ResponseObject<SecurityLogsModel.SecurityLog>>;\n}\nexport declare namespace SecurityLogsModel {\n    type Event = 'login' | 'password.set' | 'password.change' | 'email.change' | 'login.change' | 'personal_token.issued' | 'personal_token.revoked' | 'mfa.enabled' | 'mfa.disabled' | 'session.revoke' | 'session.revoke_all' | 'sso.connect' | 'sso.disconnect' | 'user.remove' | 'application.connected' | 'application.disconnected' | 'webauthn.created' | 'webauthn.deleted' | 'trusted_device.remove' | 'trusted_device.remove_all' | 'device_verification.enabled' | 'device_verification.disabled';\n    interface ListOrganizationSecurityLogsParams extends PaginationOptions {\n        event?: Event;\n        createdAfter?: string;\n        createdBefore?: string;\n        ipAddress?: string;\n        userId?: number;\n    }\n    type ListUserSecurityLogsParams = Omit<ListOrganizationSecurityLogsParams, 'userId'>;\n    interface SecurityLog {\n        id: number;\n        event: string;\n        info: string;\n        userId: number;\n        location: string;\n        ipAddress: string;\n        deviceName: string;\n        createdAt: string;\n    }\n}\n```\n\n##### sourceFiles/index.d.ts\n\n```typescript\nimport { CrowdinApi, DownloadLink, PaginationOptions, PatchRequest, ResponseList, ResponseObject, Status } from '../core';\nexport declare class SourceFiles extends CrowdinApi {\n    getClonedBranch(projectId: number, branchId: number, cloneId: string): Promise<ResponseObject<SourceFilesModel.Branch>>;\n    clonedBranch(projectId: number, branchId: number, request: SourceFilesModel.CloneBranchRequest): Promise<ResponseObject<Status<object>>>;\n    checkBranchClonedStatus(projectId: number, branchId: number, cloneId: string): Promise<ResponseObject<Status<object>>>;\n    listProjectBranches(projectId: number, options?: SourceFilesModel.ListProjectBranchesOptions): Promise<ResponseList<SourceFilesModel.Branch>>;\n    listProjectBranches(projectId: number, name?: string, limit?: number, offset?: number): Promise<ResponseList<SourceFilesModel.Branch>>;\n    createBranch(projectId: number, request: SourceFilesModel.CreateBranchRequest): Promise<ResponseObject<SourceFilesModel.Branch>>;\n    getBranch(projectId: number, branchId: number): Promise<ResponseObject<SourceFilesModel.Branch>>;\n    deleteBranch(projectId: number, branchId: number): Promise<void>;\n    editBranch(projectId: number, branchId: number, request: PatchRequest[]): Promise<ResponseObject<SourceFilesModel.Branch>>;\n    mergeBranch(projectId: number, branchId: number, request: SourceFilesModel.MergeBranchRequest): Promise<ResponseObject<Status<SourceFilesModel.MergeBranchAttributes>>>;\n    checkBranchMergeStatus(projectId: number, branchId: number, mergeId: string): Promise<ResponseObject<Status<SourceFilesModel.MergeBranchAttributes>>>;\n    getBranchMergeSummary(projectId: number, branchId: number, mergeId: string): Promise<ResponseObject<SourceFilesModel.MergeBranchSummary>>;\n    listProjectDirectories(projectId: number, options?: SourceFilesModel.ListProjectDirectoriesOptions): Promise<ResponseList<SourceFilesModel.Directory>>;\n    listProjectDirectories(projectId: number, branchId?: number, directoryId?: number, limit?: number, offset?: number, filter?: string, recursion?: string): Promise<ResponseList<SourceFilesModel.Directory>>;\n    createDirectory(projectId: number, request: SourceFilesModel.CreateDirectoryRequest): Promise<ResponseObject<SourceFilesModel.Directory>>;\n    getDirectory(projectId: number, directoryId: number): Promise<ResponseObject<SourceFilesModel.Directory>>;\n    deleteDirectory(projectId: number, directoryId: number): Promise<void>;\n    editDirectory(projectId: number, directoryId: number, request: PatchRequest[]): Promise<ResponseObject<SourceFilesModel.Directory>>;\n    listProjectFiles(projectId: number, options?: SourceFilesModel.ListProjectFilesOptions): Promise<ResponseList<SourceFilesModel.File>>;\n    listProjectFiles(projectId: number, branchId?: number, directoryId?: number, limit?: number, offset?: number, recursion?: any, filter?: string): Promise<ResponseList<SourceFilesModel.File>>;\n    createFile(projectId: number, request: SourceFilesModel.CreateFileRequest): Promise<ResponseObject<SourceFilesModel.File>>;\n    getFile(projectId: number, fileId: number): Promise<ResponseObject<SourceFilesModel.File>>;\n    updateOrRestoreFile(projectId: number, fileId: number, request: SourceFilesModel.ReplaceFileFromStorageRequest | SourceFilesModel.RestoreFile): Promise<ResponseObject<SourceFilesModel.File>>;\n    deleteFile(projectId: number, fileId: number): Promise<void>;\n    editFile(projectId: number, fileId: number, request: PatchRequest[]): Promise<ResponseObject<SourceFilesModel.File>>;\n    downloadFilePreview(projectId: number, fileId: number): Promise<ResponseObject<DownloadLink>>;\n    downloadFile(projectId: number, fileId: number): Promise<ResponseObject<DownloadLink>>;\n    listAssetReferences(projectId: number, fileId: number, options?: PaginationOptions): Promise<ResponseList<SourceFilesModel.AssetReference>>;\n    getAssetReference(projectId: number, fileId: number, referenceId: number): Promise<ResponseObject<SourceFilesModel.AssetReference>>;\n    addAssetReference(projectId: number, fileId: number, request: SourceFilesModel.AssetReferenceRequest): Promise<ResponseObject<SourceFilesModel.AssetReference>>;\n    deleteAssetReference(projectId: number, fileId: number, referenceId: number): Promise<void>;\n    listFileRevisions(projectId: number, fileId: number, options?: PaginationOptions): Promise<ResponseList<SourceFilesModel.FileRevision>>;\n    listFileRevisions(projectId: number, fileId: number, limit?: number, offset?: number): Promise<ResponseList<SourceFilesModel.FileRevision>>;\n    getFileRevision(projectId: number, fileId: number, revisionId: number): Promise<ResponseObject<SourceFilesModel.FileRevision>>;\n    listReviewedSourceFilesBuild(projectId: number, options?: SourceFilesModel.ListReviewedSourceFilesBuildOptions): Promise<ResponseList<SourceFilesModel.ReviewedSourceFilesBuild>>;\n    listReviewedSourceFilesBuild(projectId: number, branchId?: number, limit?: number, offset?: number): Promise<ResponseList<SourceFilesModel.ReviewedSourceFilesBuild>>;\n    buildReviewedSourceFiles(projectId: number, request?: SourceFilesModel.BuildReviewedSourceFilesRequest): Promise<ResponseObject<SourceFilesModel.ReviewedSourceFilesBuild>>;\n    checkReviewedSourceFilesBuildStatus(projectId: number, buildId: number): Promise<ResponseObject<SourceFilesModel.ReviewedSourceFilesBuild>>;\n    downloadReviewedSourceFiles(projectId: number, buildId: number): Promise<ResponseObject<DownloadLink>>;\n}\nexport declare namespace SourceFilesModel {\n    interface Branch {\n        id: number;\n        projectId: number;\n        name: string;\n        title: string;\n        exportPattern: string;\n        priority: Priority;\n        createdAt: string;\n        updatedAt: string;\n    }\n    interface CreateBranchRequest {\n        name: string;\n        title?: string;\n        exportPattern?: string;\n        priority?: Priority;\n    }\n    interface CloneBranchRequest {\n        name: string;\n        title?: string;\n    }\n    interface MergeBranchRequest {\n        deleteAfterMerge?: boolean;\n        sourceBranchId: number;\n        acceptSourceChanges?: boolean;\n        dryRun?: boolean;\n    }\n    interface MergeBranchAttributes {\n        sourceBranchId: number;\n        deleteAfterMerge: boolean;\n        acceptSourceChanges?: boolean;\n    }\n    interface MergeBranchSummary {\n        status: string;\n        sourceBranchId: number;\n        targetBranchId: number;\n        dryRun: boolean;\n        details: {\n            added: number;\n            deleted: number;\n            updated: number;\n            conflicted: number;\n        };\n    }\n    type Priority = 'low' | 'normal' | 'high';\n    interface ListProjectDirectoriesOptions extends PaginationOptions {\n        branchId?: number;\n        directoryId?: number;\n        filter?: string;\n        recursion?: string;\n        orderBy?: string;\n    }\n    interface Directory {\n        id: number;\n        projectId: number;\n        branchId: number;\n        directoryId: number;\n        name: string;\n        title: string;\n        exportPattern: string;\n        path: string;\n        priority: Priority;\n        createdAt: string;\n        updatedAt: string;\n    }\n    interface CreateDirectoryRequest {\n        name: string;\n        branchId?: number;\n        directoryId?: number;\n        title?: string;\n        exportPattern?: string;\n        priority?: Priority;\n    }\n    interface ListProjectFilesOptions extends PaginationOptions {\n        branchId?: number;\n        directoryId?: number;\n        recursion?: any;\n        filter?: string;\n        orderBy?: string;\n    }\n    interface File {\n        id: number;\n        projectId: number;\n        branchId: number;\n        directoryId: number;\n        name: string;\n        title: string;\n        context: string;\n        type: string;\n        path: string;\n        status: string;\n        revisionId: number;\n        priority: Priority;\n        importOptions: ImportOptions;\n        exportOptions: GeneralExportOptions | PropertyExportOptions;\n        excludedTargetLanguages: string[];\n        parserVersion: number;\n        createdAt: string;\n        updatedAt: string;\n        fields: Record<string, any>;\n    }\n    interface CreateFileRequest {\n        storageId: number;\n        name: string;\n        branchId?: number;\n        directoryId?: number;\n        title?: string;\n        context?: string;\n        type?: FileType;\n        parserVersion?: number;\n        importOptions?: ImportOptions;\n        exportOptions?: ExportOptions;\n        excludedTargetLanguages?: string[];\n        attachLabelIds?: number[];\n        fields?: Record<string, any>;\n    }\n    interface ReplaceFileFromStorageRequest {\n        storageId: number;\n        name?: string;\n        updateOption?: UpdateOption;\n        importOptions?: ImportOptions;\n        exportOptions?: ExportOptions;\n        attachLabelIds?: number[];\n        detachLabelIds?: number[];\n        replaceModifiedContext?: boolean;\n    }\n    type ExportOptions = GeneralExportOptions | PropertyExportOptions | JavaScriptExportOptions | MdExportOptions;\n    type ImportOptions = SpreadsheetImportOptions | XmlImportOptions | WebXmlImportOptions | DocxFileImportOptions | HtmlFileImportOptions | HtmlFrontMatterFileImportOptions | MdxFileImportOptions | MdFileImportOptions | StringCatalogFileImportOptions | AdocFileImportOptions | OtherImportOptions;\n    interface RestoreFile {\n        revisionId: number;\n    }\n    interface FileRevision {\n        id: number;\n        projectId: number;\n        fileId: number;\n        restoreToRevision: number;\n        info: FileRevisionInfo;\n        date: string;\n    }\n    interface FileRevisionInfo {\n        added: FileRevisionInfoAttribute;\n        deleted: FileRevisionInfoAttribute;\n        updated: FileRevisionInfoAttribute;\n    }\n    interface FileRevisionInfoAttribute {\n        strings: number;\n        words: number;\n    }\n    type FileType = 'auto' | 'android' | 'macosx' | 'resx' | 'properties' | 'gettext' | 'yaml' | 'php' | 'json' | 'xml' | 'ini' | 'rc' | 'resw' | 'resjson' | 'qtts' | 'joomla' | 'chrome' | 'dtd' | 'dklang' | 'flex' | 'nsh' | 'wxl' | 'xliff' | 'xliff_two' | 'html' | 'haml' | 'txt' | 'csv' | 'md' | 'flsnp' | 'fm_html' | 'fm_md' | 'mediawiki' | 'docx' | 'xlsx' | 'sbv' | 'properties_play' | 'properties_xml' | 'maxthon' | 'go_json' | 'dita' | 'mif' | 'idml' | 'stringsdict' | 'plist' | 'vtt' | 'vdf' | 'srt' | 'stf' | 'toml' | 'contentful_rt' | 'svg' | 'js' | 'coffee' | 'nestjs_i18n' | 'webxml';\n    interface SpreadsheetImportOptions {\n        firstLineContainsHeader?: boolean;\n        contentSegmentation?: boolean;\n        srxStorageId?: number;\n        importTranslations?: boolean;\n        scheme?: Scheme;\n    }\n    interface Scheme {\n        none: number;\n        identifier: number;\n        sourcePhrase: number;\n        sourceOrTranslation: number;\n        translation: number;\n        context: number;\n        maxLength: number;\n        labels: number;\n        [key: string]: number;\n    }\n    interface XmlImportOptions {\n        translateContent?: boolean;\n        translateAttributes?: boolean;\n        inlineTags?: string[];\n        contentSegmentation?: boolean;\n        translatableElements?: string[];\n        srxStorageId?: number;\n    }\n    interface WebXmlImportOptions {\n        inlineTags?: string[];\n        contentSegmentation?: boolean;\n        srxStorageId?: number;\n    }\n    interface DocxFileImportOptions {\n        cleanTagsAggressively?: boolean;\n        translateHiddenText?: boolean;\n        translateHyperlinkUrls?: boolean;\n        translateHiddenRowsAndColumns?: boolean;\n        importNotes?: boolean;\n        importHiddenSlides?: boolean;\n        contentSegmentation?: boolean;\n        srxStorageId?: number;\n    }\n    interface HtmlFileImportOptions {\n        excludedElements?: string[];\n        inlineTags?: string[];\n        contentSegmentation?: boolean;\n        srxStorageId?: number;\n    }\n    interface HtmlFrontMatterFileImportOptions extends HtmlFileImportOptions {\n        excludedFrontMatterElements?: string[];\n    }\n    interface MdxFileImportOptions {\n        excludedFrontMatterElements?: string[];\n        excludeCodeBlocks?: boolean;\n        contentSegmentation?: boolean;\n        srxStorageId?: number;\n    }\n    interface MdFileImportOptions {\n        excludedFrontMatterElements?: string[];\n        excludeCodeBlocks?: boolean;\n        inlineTags?: string[];\n        contentSegmentation?: boolean;\n        srxStorageId?: number;\n    }\n    interface StringCatalogFileImportOptions {\n        importKeyAsSource?: boolean;\n    }\n    interface AdocFileImportOptions {\n        excludeIncludeDirectives?: boolean;\n    }\n    interface OtherImportOptions {\n        contentSegmentation: boolean;\n        srxStorageId: number;\n    }\n    interface GeneralExportOptions {\n        exportPattern?: string;\n    }\n    interface PropertyExportOptions {\n        escapeQuotes?: EscapeQuotes;\n        exportPattern?: string;\n        escapeSpecialCharacters?: 0 | 1;\n    }\n    interface JavaScriptExportOptions {\n        exportPattern?: string;\n        exportQuotes?: ExportQuotes;\n    }\n    interface MdExportOptions {\n        exportPattern?: string;\n        strongMarker?: 'asterisk' | 'underscore';\n        emphasisMarker?: 'asterisk' | 'underscore';\n        unorderedListBullet?: 'asterisks' | 'plus' | 'plus';\n        tableColumnWidth?: 'consolidate' | 'evenly_distribute_cells';\n    }\n    enum EscapeQuotes {\n        ZERO = 0,\n        ONE = 1,\n        TWO = 2,\n        THREE = 3\n    }\n    enum ExportQuotes {\n        SINGLE = \"single\",\n        DOUBLE = \"double\"\n    }\n    type UpdateOption = 'clear_translations_and_approvals' | 'keep_translations' | 'keep_translations_and_approvals';\n    interface ReviewedSourceFilesBuild {\n        id: number;\n        projectId: number;\n        status: string;\n        progress: number;\n        attributes: ReviewedSourceFilesBuildAttributes;\n    }\n    interface ReviewedSourceFilesBuildAttributes {\n        branchId: number;\n        targetLanguageId: string;\n    }\n    interface BuildReviewedSourceFilesRequest {\n        branchId?: number;\n    }\n    interface ListProjectBranchesOptions extends PaginationOptions {\n        name?: string;\n        orderBy?: string;\n    }\n    interface ListReviewedSourceFilesBuildOptions extends PaginationOptions {\n        branchId?: number;\n    }\n    interface User {\n        id: number;\n        username: string;\n        fullName: string;\n        avatarUrl: string;\n    }\n    interface AssetReference {\n        id: number;\n        name: string;\n        user: User;\n        createdAt: string;\n        mimeType: string;\n    }\n    interface AssetReferenceRequest {\n        storageId: number;\n        name: string;\n    }\n}\n```\n\n##### sourceStrings/index.d.ts\n\n```typescript\nimport { BooleanInt, CrowdinApi, PaginationOptions, PatchRequest, ResponseList, ResponseObject, Status } from '../core';\nimport { SourceFilesModel } from '../sourceFiles';\nexport declare class SourceStrings extends CrowdinApi {\n    uploadStringsStatus(projectId: number, uploadId: string): Promise<ResponseObject<Status<SourceStringsModel.UploadStringsStatus>>>;\n    uploadStrings(projectId: number, request: SourceStringsModel.UploadStringsRequest): Promise<ResponseObject<Status<SourceStringsModel.UploadStringsStatus>>>;\n    listProjectStrings(projectId: number, options?: SourceStringsModel.ListProjectStringsOptions): Promise<ResponseList<SourceStringsModel.String>>;\n    listProjectStrings(projectId: number, fileId?: number, limit?: number, offset?: number, filter?: string, denormalizePlaceholders?: BooleanInt, labelIds?: string, scope?: SourceStringsModel.Scope, croql?: string, branchId?: number, directoryId?: number): Promise<ResponseList<SourceStringsModel.String>>;\n    addString(projectId: number, request: SourceStringsModel.CreateStringRequest | SourceStringsModel.CreateStringStringsBasedRequest): Promise<ResponseObject<SourceStringsModel.String>>;\n    stringBatchOperations(projectId: number, request: PatchRequest[]): Promise<ResponseList<SourceStringsModel.String>>;\n    getString(projectId: number, stringId: number, query?: {\n        denormalizePlaceholders: BooleanInt;\n    }): Promise<ResponseObject<SourceStringsModel.String>>;\n    deleteString(projectId: number, stringId: number): Promise<void>;\n    editString(projectId: number, stringId: number, request: PatchRequest[]): Promise<ResponseObject<SourceStringsModel.String>>;\n}\nexport declare namespace SourceStringsModel {\n    type UploadStringsType = 'auto' | 'android' | 'macosx' | 'arb' | 'csv' | 'json' | 'xliff' | 'xliff_two' | 'xlsx';\n    interface UploadStringsStatus {\n        branchId: number;\n        storageId: number;\n        fileType: UploadStringsType;\n        parserVersion: number;\n        labelIds: number[];\n        importOptions: {\n            firstLineContainsHeader: boolean;\n            importTranslations: boolean;\n            scheme: SourceFilesModel.Scheme;\n        };\n        updateStrings: boolean;\n        cleanupMode: boolean;\n        updateOption: UpdateOption;\n    }\n    interface UploadStringsRequest {\n        branchId: number;\n        storageId: number;\n        type?: UploadStringsType;\n        parserVersion?: number;\n        labelIds?: number[];\n        updateStrings?: boolean;\n        cleanupMode?: boolean;\n        importOptions?: {\n            firstLineContainsHeader: boolean;\n            importTranslations: boolean;\n            scheme: SourceFilesModel.Scheme;\n        };\n        updateOption?: UpdateOption;\n    }\n    interface ListProjectStringsOptions extends PaginationOptions {\n        orderBy?: string;\n        denormalizePlaceholders?: BooleanInt;\n        labelIds?: string;\n        fileId?: number;\n        branchId?: number;\n        directoryId?: number;\n        taskId?: number;\n        croql?: string;\n        filter?: string;\n        scope?: SourceStringsModel.Scope;\n    }\n    interface String {\n        id: number;\n        projectId: number;\n        branchId: number;\n        identifier: string;\n        text: string | PluralText;\n        type: Type;\n        context: string;\n        maxLength: number;\n        isHidden: boolean;\n        isDuplicate: boolean;\n        masterStringId: boolean;\n        hasPlurals: boolean;\n        isIcu: boolean;\n        labelIds: number[];\n        webUrl: string;\n        createdAt: string;\n        updatedAt: string;\n        fileId: number;\n        directoryId: number;\n        revision: number;\n        fields: Record<string, any>;\n    }\n    interface CreateStringRequest {\n        text: string | PluralText;\n        identifier?: string;\n        fileId: number;\n        context?: string;\n        isHidden?: boolean;\n        maxLength?: number;\n        labelIds?: number[];\n        fields?: Record<string, any>;\n    }\n    interface CreateStringStringsBasedRequest {\n        text: string | PluralText;\n        identifier: string;\n        branchId: number;\n        context?: string;\n        isHidden?: boolean;\n        maxLength?: number;\n        labelIds?: number[];\n        fields?: Record<string, any>;\n    }\n    interface PluralText {\n        zero?: string;\n        one?: string;\n        two?: string;\n        few?: string;\n        many?: string;\n        other?: string;\n    }\n    enum Type {\n        TEXT = 0,\n        ASSET = 1,\n        ICU = 2\n    }\n    type Scope = 'identifier' | 'text' | 'context';\n    type UpdateOption = 'clear_translations_and_approvals' | 'keep_translations' | 'keep_translations_and_approvals';\n}\n```\n\n##### stringComments/index.d.ts\n\n```typescript\nimport { CrowdinApi, PaginationOptions, PatchRequest, ResponseList, ResponseObject } from '../core';\nexport declare class StringComments extends CrowdinApi {\n    listStringComments(projectId: number, options?: StringCommentsModel.ListStringCommentsOptions): Promise<ResponseList<StringCommentsModel.StringComment>>;\n    listStringComments(projectId: number, stringId?: number, type?: StringCommentsModel.Type, targetLanguageId?: string, issueType?: StringCommentsModel.IssueType, issueStatus?: StringCommentsModel.IssueStatus): Promise<ResponseList<StringCommentsModel.StringComment>>;\n    addStringComment(projectId: number, request: StringCommentsModel.AddStringCommentRequest): Promise<ResponseObject<StringCommentsModel.StringComment>>;\n    getStringComment(projectId: number, stringCommentId: number): Promise<ResponseObject<StringCommentsModel.StringComment>>;\n    deleteStringComment(projectId: number, stringCommentId: number): Promise<void>;\n    editStringComment(projectId: number, stringCommentId: number, request: PatchRequest[]): Promise<ResponseObject<StringCommentsModel.StringComment>>;\n    stringCommentBatchOperations(projectId: number, request: PatchRequest[]): Promise<ResponseList<StringCommentsModel.StringComment>>;\n}\nexport declare namespace StringCommentsModel {\n    interface ListStringCommentsOptions extends PaginationOptions {\n        stringId?: number;\n        type?: Type;\n        targetLanguageId?: string;\n        issueType?: IssueType;\n        issueStatus?: IssueStatus;\n        orderBy?: string;\n    }\n    interface StringComment {\n        id: number;\n        isShared?: boolean;\n        text: string;\n        userId: number;\n        stringId: number;\n        user: User;\n        string: StringModel;\n        projectId: number;\n        languageId: string;\n        type: Type;\n        issueType: IssueType;\n        issueStatus: IssueStatus;\n        resolverId: number;\n        senderOrganization: {\n            id: number;\n            domain: string;\n        };\n        resolverOrganization: {\n            id: number;\n            domain: string;\n        };\n        resolver: User;\n        resolvedAt: string;\n        createdAt: string;\n    }\n    interface User {\n        id: number;\n        username: string;\n        fullName: string;\n        avatarUrl: string;\n    }\n    interface StringModel {\n        id: number;\n        text: string;\n        type: string;\n        hasPlurals: boolean;\n        isIcu: boolean;\n        context: string;\n        fileId: number;\n    }\n    interface AddStringCommentRequest {\n        stringId: number;\n        text: string;\n        targetLanguageId: string;\n        type: Type;\n        isShared?: boolean;\n        issueType?: IssueType;\n    }\n    type Type = 'comment' | 'issue';\n    type IssueType = 'general_question' | 'translation_mistake' | 'context_request' | 'source_mistake';\n    type IssueStatus = 'unresolved' | 'resolved';\n}\n```\n\n##### stringCorrections/index.d.ts\n\n```typescript\nimport { BooleanInt, CrowdinApi, PaginationOptions, ResponseList, ResponseObject } from '../core';\nexport declare class StringCorrections extends CrowdinApi {\n    listStringCorrections(projectId: number, options: StringCorrectionsModel.ListStringCorrectionsParams): Promise<ResponseList<StringCorrectionsModel.StringCorrection>>;\n    addStringCorrection(projectId: number, request: StringCorrectionsModel.AddStringCorrectionRequest): Promise<ResponseObject<StringCorrectionsModel.StringCorrection>>;\n    deleteStringCorrections(projectId: number, stringId: number): Promise<void>;\n    getStringCorrection(projectId: number, correctionId: number, params?: {\n        denormalizePlaceholders?: BooleanInt;\n    }): Promise<ResponseObject<StringCorrectionsModel.StringCorrection>>;\n    restoreStringCorrection(projectId: number, correctionId: number): Promise<ResponseObject<StringCorrectionsModel.StringCorrection>>;\n    deleteStringCorrection(projectId: number, correctionId: number): Promise<void>;\n}\nexport declare namespace StringCorrectionsModel {\n    interface ListStringCorrectionsParams extends PaginationOptions {\n        stringId: number;\n        orderBy?: string;\n        denormalizePlaceholders?: BooleanInt;\n    }\n    interface StringCorrection {\n        id: number;\n        text: string;\n        pluralCategoryName: PluralCategoryName;\n        user: {\n            id: number;\n            username: string;\n            fullName: string;\n            avatarUrl: string;\n        };\n        createdAt: string;\n    }\n    type PluralCategoryName = 'zero' | 'one' | 'two' | 'few' | 'many' | 'other';\n    interface AddStringCorrectionRequest {\n        stringId: number;\n        text: string;\n        pluralCategoryName?: PluralCategoryName;\n    }\n}\n```\n\n##### stringTranslations/index.d.ts\n\n```typescript\nimport { BooleanInt, CrowdinApi, PaginationOptions, PatchRequest, ResponseList, ResponseObject } from '../core';\nexport declare class StringTranslations extends CrowdinApi {\n    listTranslationApprovals(projectId: number, options?: StringTranslationsModel.ListTranslationApprovalsOptions): Promise<ResponseList<StringTranslationsModel.Approval>>;\n    listTranslationApprovals(projectId: number, stringId?: number, languageId?: string, translationId?: number, limit?: number, offset?: number, fileId?: number, labelIds?: string, excludeLabelIds?: string): Promise<ResponseList<StringTranslationsModel.Approval>>;\n    addApproval(projectId: number, request: StringTranslationsModel.AddApprovalRequest): Promise<ResponseObject<StringTranslationsModel.Approval>>;\n    removeStringApprovals(projectId: number, stringId: number): Promise<void>;\n    approvalInfo(projectId: number, approvalId: number): Promise<ResponseObject<StringTranslationsModel.Approval>>;\n    approvalBatchOperations(projectId: number, request: PatchRequest[]): Promise<ResponseList<StringTranslationsModel.Approval>>;\n    removeApproval(projectId: number, approvalId: number): Promise<void>;\n    listLanguageTranslations(projectId: number, languageId: string, options?: StringTranslationsModel.ListLanguageTranslationsOptions): Promise<ResponseList<StringTranslationsModel.PlainLanguageTranslation | StringTranslationsModel.PluralLanguageTranslation | StringTranslationsModel.IcuLanguageTranslation>>;\n    listLanguageTranslations(projectId: number, languageId: string, stringIds?: string, fileId?: number, limit?: number, offset?: number, labelIds?: string, denormalizePlaceholders?: BooleanInt, croql?: string): Promise<ResponseList<StringTranslationsModel.PlainLanguageTranslation | StringTranslationsModel.PluralLanguageTranslation | StringTranslationsModel.IcuLanguageTranslation>>;\n    translationAlignment(projectId: number, request: StringTranslationsModel.TranslationAlignmentRequest): Promise<ResponseObject<StringTranslationsModel.TranslationAlignmentResponse>>;\n    listStringTranslations(projectId: number, stringId: number, languageId: string, options?: StringTranslationsModel.ListStringTranslationsOptions): Promise<ResponseList<StringTranslationsModel.StringTranslation>>;\n    listStringTranslations(projectId: number, stringId: number, languageId: string, limit?: number, offset?: number, denormalizePlaceholders?: BooleanInt): Promise<ResponseList<StringTranslationsModel.StringTranslation>>;\n    addTranslation(projectId: number, request: StringTranslationsModel.AddStringTranslationRequest): Promise<ResponseObject<StringTranslationsModel.StringTranslation>>;\n    deleteAllTranslations(projectId: number, stringId: number, languageId?: string): Promise<void>;\n    translationInfo(projectId: number, translationId: number): Promise<ResponseObject<StringTranslationsModel.StringTranslation>>;\n    restoreTranslation(projectId: number, translationId: number): Promise<ResponseObject<StringTranslationsModel.StringTranslation>>;\n    translationBatchOperations(projectId: number, request: PatchRequest[]): Promise<ResponseList<StringTranslationsModel.StringTranslation>>;\n    deleteTranslation(projectId: number, translationId: number): Promise<void>;\n    listTranslationVotes(projectId: number, options?: StringTranslationsModel.ListTranslationVotesOptions): Promise<ResponseList<StringTranslationsModel.Vote>>;\n    listTranslationVotes(projectId: number, stringId?: number, languageId?: string, translationId?: number, labelIds?: string, excludeLabelIds?: string, limit?: number, offset?: number): Promise<ResponseList<StringTranslationsModel.Vote>>;\n    addVote(projectId: number, request: StringTranslationsModel.AddVoteRequest): Promise<ResponseObject<StringTranslationsModel.Vote>>;\n    voteInfo(projectId: number, voteId: number): Promise<ResponseObject<StringTranslationsModel.Vote>>;\n    cancelVote(projectId: number, voteId: number): Promise<void>;\n}\nexport declare namespace StringTranslationsModel {\n    interface ListTranslationApprovalsOptions extends PaginationOptions {\n        stringId?: number;\n        languageId?: string;\n        translationId?: number;\n        fileId?: number;\n        labelIds?: string;\n        excludeLabelIds?: string;\n        orderBy?: string;\n    }\n    interface Approval {\n        id: number;\n        user: User;\n        translationId: number;\n        stringId: number;\n        languageId: string;\n        createdAt: string;\n    }\n    interface AddApprovalRequest {\n        translationId: number;\n    }\n    interface StringTranslation {\n        id: number;\n        text: string;\n        pluralCategoryName: PluralCategoryName;\n        user: User;\n        rating: number;\n        provider: string;\n        isPreTranslated: boolean;\n        createdAt: string;\n    }\n    interface ListLanguageTranslationsOptions extends PaginationOptions {\n        stringIds?: string;\n        fileId?: number;\n        labelIds?: string;\n        denormalizePlaceholders?: BooleanInt;\n        croql?: string;\n        approvedOnly?: BooleanInt;\n        passedWorkflow?: BooleanInt;\n        orderBy?: string;\n        branchId?: number;\n        minApprovalCount?: number;\n        directoryId?: number;\n    }\n    interface PlainLanguageTranslation {\n        stringId: number;\n        contentType: string;\n        translationId: number;\n        text: string;\n        user: User;\n        createdAt: string;\n    }\n    interface PluralLanguageTranslation {\n        stringId: number;\n        contentType: string;\n        plurals: Plural[];\n    }\n    interface IcuLanguageTranslation {\n        stringId: number;\n        contentType: string;\n        translationId: number;\n        text: string;\n        user: User;\n        createdAt: string;\n    }\n    interface Plural {\n        translationId: number;\n        text: string;\n        pluralForm: string;\n        user: User;\n        createdAt: string;\n    }\n    interface TranslationAlignmentRequest {\n        sourceLanguageId: string;\n        targetLanguageId: string;\n        text: string;\n    }\n    interface TranslationAlignmentResponse {\n        words: {\n            text: string;\n            alignments: {\n                sourceWord: string;\n                sourceLemma: string;\n                targetWord: string;\n                targetLemma: string;\n                match: number;\n                probability: number;\n            }[];\n        }[];\n    }\n    interface AddStringTranslationRequest {\n        stringId: number;\n        languageId: string;\n        text: string;\n        pluralCategoryName?: PluralCategoryName;\n        addToTm?: boolean;\n    }\n    interface ListTranslationVotesOptions extends PaginationOptions {\n        stringId?: number;\n        languageId?: string;\n        translationId?: number;\n        fileId?: number;\n        labelIds?: string;\n        excludeLabelIds?: string;\n    }\n    interface Vote {\n        id: number;\n        user: User;\n        translationId: number;\n        votedAt: string;\n        mark: Mark;\n    }\n    interface AddVoteRequest {\n        mark: Mark;\n        translationId: number;\n    }\n    interface User {\n        id: number;\n        username: string;\n        fullName: string;\n        avatarUrl: string;\n    }\n    type Mark = 'up' | 'down';\n    interface ListStringTranslationsOptions extends PaginationOptions {\n        denormalizePlaceholders?: BooleanInt;\n        orderBy?: string;\n    }\n    type PluralCategoryName = 'zero' | 'one' | 'two' | 'few' | 'many' | 'other';\n}\n```\n\n##### tasks/index.d.ts\n\n```typescript\nimport { BooleanInt, CrowdinApi, DownloadLink, PaginationOptions, PatchRequest, ResponseList, ResponseObject } from '../core';\nimport { LanguagesModel } from '../languages';\nexport declare class Tasks extends CrowdinApi {\n    listTasks(projectId: number, options?: TasksModel.ListTasksOptions): Promise<ResponseList<TasksModel.Task>>;\n    listTasks(projectId: number, limit?: number, offset?: number, status?: TasksModel.Status): Promise<ResponseList<TasksModel.Task>>;\n    addTask(projectId: number, request: TasksModel.CreateTaskRequest): Promise<ResponseObject<TasksModel.Task>>;\n    exportTaskStrings(projectId: number, taskId: number): Promise<ResponseObject<DownloadLink>>;\n    getTask(projectId: number, taskId: number): Promise<ResponseObject<TasksModel.Task>>;\n    deleteTask(projectId: number, taskId: number): Promise<void>;\n    editTask(projectId: number, taskId: number, request: PatchRequest[]): Promise<ResponseObject<TasksModel.Task>>;\n    listTasksComments(projectId: number, taskId: number, options?: PaginationOptions): Promise<ResponseList<TasksModel.TaskComment>>;\n    addTaskComment(projectId: number, taskId: number, request: TasksModel.CreateTaskCommentRequest): Promise<ResponseObject<TasksModel.TaskComment>>;\n    getTaskComment(projectId: number, taskId: number, commentId: number): Promise<ResponseObject<TasksModel.TaskComment>>;\n    deleteTaskComment(projectId: number, taskId: number, commentId: number): Promise<void>;\n    editTaskComment(projectId: number, taskId: number, commentId: number, request: PatchRequest[]): Promise<ResponseObject<TasksModel.TaskComment>>;\n    listUserTasks(options?: TasksModel.ListUserTasksOptions): Promise<ResponseList<TasksModel.UserTask>>;\n    listUserTasks(limit?: number, offset?: number, status?: TasksModel.Status, isArchived?: BooleanInt): Promise<ResponseList<TasksModel.UserTask>>;\n    editTaskArchivedStatus(projectId: number, taskId: number, request: PatchRequest[]): Promise<ResponseObject<TasksModel.UserTask>>;\n    listTaskSettingsTemplates(projectId: number, options?: PaginationOptions): Promise<ResponseList<TasksModel.TaskSettingsTemplate>>;\n    addTaskSettingsTemplate(projectId: number, request: TasksModel.AddTaskSettingsTemplate): Promise<ResponseObject<TasksModel.TaskSettingsTemplate>>;\n    getTaskSettingsTemplate(projectId: number, taskSettingsId: number): Promise<ResponseObject<TasksModel.TaskSettingsTemplate>>;\n    deleteTaskSettingsTemplate(projectId: number, taskSettingsId: number): Promise<void>;\n    editTaskSettingsTemplate(projectId: number, taskSettingsId: number, request: PatchRequest[]): Promise<ResponseObject<TasksModel.TaskSettingsTemplate>>;\n}\nexport declare namespace TasksModel {\n    interface Task {\n        id: number;\n        projectId: number;\n        creatorId: number;\n        type: Type | TypeVendor;\n        status: Status;\n        title: string;\n        assignees: Assignee[];\n        assignedTeams: AssignedTeam[];\n        progress: Progress;\n        translateProgress: Progress;\n        sourceLanguageId: string;\n        targetLanguageId: string;\n        description: string;\n        translationUrl: string;\n        webUrl: string;\n        wordsCount: number;\n        commentsCount: number;\n        deadline: string;\n        startedAt: string;\n        resolvedAt: string;\n        timeRange: string;\n        workflowStepId: number;\n        buyUrl: string;\n        createdAt: string;\n        updatedAt: string;\n        sourceLanguage: LanguagesModel.Language;\n        targetLanguages: LanguagesModel.Language[];\n        labelIds: number[];\n        excludeLabelIds: number[];\n        precedingTaskId: number;\n        filesCount: number;\n        fileIds: number[];\n        branchIds: number[];\n        vendor: string;\n        fields: Record<string, any>;\n    }\n    interface ListUserTasksOptions extends PaginationOptions {\n        status?: Status;\n        isArchived?: BooleanInt;\n        orderBy?: string;\n    }\n    interface UserTask extends Task {\n        isArchived: boolean;\n    }\n    type CreateTaskRequest = CreateTaskEnterpriseByBranchIds | CreateTaskEnterpriseByFileIds | CreateTaskEnterpriseByStringIds | CreateTaskEnterpriseVendorByBranchIds | CreateTaskEnterpriseVendorByFileIds | CreateTaskEnterpriseVendorByStringIds | CreateTaskEnterprisePendingTask | CreateTaskByFileIds | CreateTaskByStringIds | CreateTaskByBranchIds | CreateTaskByFileIdsLanguageService | CreateTaskByStringIdsLanguageService | CreateTaskByBranchIdsLanguageService | CreateTaskVendorOhtByFileIds | CreateTaskVendorOhtByStringIds | CreateTaskVendorOhtByBranchIds | CreateTaskVendorGengoByFileIds | CreateTaskVendorGengoByStringIds | CreateTaskVendorGengoByBranchIds | CreateTaskVendorManualByFileIds | CreateTaskVendorManualByStringIds | CreateTaskVendorManualByBranchIds | CreateTaskPendingTask | CreateTaskPendingTaskLanguageService | CreateTaskPendingTaskVendorManual;\n    interface CreateTaskEnterpriseByBranchIds {\n        type: Type;\n        workflowStepId: number;\n        title: string;\n        languageId: string;\n        branchIds: number[];\n        labelIds?: number[];\n        excludeLabelIds?: number[];\n        status?: RequestStatus;\n        description?: string;\n        splitContent?: boolean;\n        skipAssignedStrings?: boolean;\n        assignees?: CreateTaskAssignee[];\n        assignedTeams?: AssignedTeam[];\n        includePreTranslatedStringsOnly?: boolean;\n        deadline?: string;\n        startedAt?: string;\n        dateFrom?: string;\n        dateTo?: string;\n        fields?: Record<string, any>;\n    }\n    interface CreateTaskEnterpriseByStringIds {\n        type: Type;\n        workflowStepId: number;\n        title: string;\n        languageId: string;\n        stringIds: number[];\n        status?: RequestStatus;\n        description?: string;\n        splitContent?: boolean;\n        skipAssignedStrings?: boolean;\n        assignees?: CreateTaskAssignee[];\n        assignedTeams?: AssignedTeam[];\n        includePreTranslatedStringsOnly?: boolean;\n        deadline?: string;\n        startedAt?: string;\n        dateFrom?: string;\n        dateTo?: string;\n        fields?: Record<string, any>;\n    }\n    type CreateTaskEnterpriseVendorByStringIds = Omit<CreateTaskEnterpriseByStringIds, 'type' | 'status' | 'splitContent' | 'assignees' | 'assignedTeams'>;\n    type CreateTaskEnterpriseVendorByBranchIds = Omit<CreateTaskEnterpriseByBranchIds, 'type' | 'status' | 'splitContent' | 'assignees' | 'assignedTeams'>;\n    type CreateTaskEnterpriseByFileIds = Omit<CreateTaskEnterpriseByBranchIds, 'branchIds'> & {\n        fileIds: number[];\n    };\n    type CreateTaskEnterpriseVendorByFileIds = Omit<CreateTaskEnterpriseByFileIds, 'type' | 'status' | 'splitContent' | 'assignees' | 'assignedTeams'>;\n    interface CreateTaskEnterprisePendingTask {\n        precedingTaskId: number;\n        type: Type.PROOFREAD;\n        title: string;\n        description?: string;\n        assignees?: CreateTaskAssignee[];\n        assignedTeams?: AssignedTeam[];\n        deadline?: string;\n    }\n    interface CreateTaskByFileIds {\n        title: string;\n        languageId: string;\n        type: Type;\n        fileIds: number[];\n        labelIds?: number[];\n        excludeLabelIds?: number[];\n        status?: RequestStatus;\n        description?: string;\n        splitContent?: boolean;\n        skipAssignedStrings?: boolean;\n        includePreTranslatedStringsOnly?: boolean;\n        assignees?: CreateTaskAssignee[];\n        deadline?: string;\n        startedAt?: string;\n        dateFrom?: string;\n        dateTo?: string;\n    }\n    type CreateTaskByStringIds = Omit<CreateTaskByFileIds, 'fileIds' | 'labelIds' | 'excludeLabelIds'> & {\n        stringIds: number;\n    };\n    type CreateTaskByBranchIds = Omit<CreateTaskByFileIds, 'fileIds'> & {\n        branchIds: number;\n    };\n    interface CreateTaskByFileIdsLanguageService {\n        title: string;\n        languageId: string;\n        type: TypeVendor;\n        vendor: 'crowdin_language_service';\n        fileIds: number[];\n        labelIds?: number[];\n        excludeLabelIds?: number[];\n        status?: RequestStatus;\n        description?: string;\n        includePreTranslatedStringsOnly?: boolean;\n        assignees?: CreateTaskAssignee[];\n        dateFrom?: string;\n        dateTo?: string;\n    }\n    type CreateTaskByStringIdsLanguageService = Omit<CreateTaskByFileIdsLanguageService, 'fileIds' | 'labelIds' | 'excludeLabelIds'> & {\n        stringIds: number[];\n    };\n    type CreateTaskByBranchIdsLanguageService = Omit<CreateTaskByFileIdsLanguageService, 'fileIds'> & {\n        branchIds: number[];\n    };\n    interface CreateTaskVendorOhtByFileIds {\n        title: string;\n        languageId: string;\n        type: TypeVendor;\n        vendor: 'oht';\n        fileIds: number[];\n        labelIds?: number[];\n        excludeLabelIds?: number[];\n        status?: RequestStatus;\n        description?: string;\n        expertise?: Expertise;\n        editService?: boolean;\n        includePreTranslatedStringsOnly?: boolean;\n        dateFrom?: string;\n        dateTo?: string;\n    }\n    type CreateTaskVendorOhtByStringIds = Omit<CreateTaskVendorOhtByFileIds, 'fileIds' | 'labelIds' | 'excludeLabelIds'> & {\n        stringIds: number[];\n    };\n    type CreateTaskVendorOhtByBranchIds = Omit<CreateTaskVendorOhtByFileIds, 'fileIds'> & {\n        branchIds: number[];\n    };\n    interface CreateTaskVendorGengoByFileIds {\n        title: string;\n        languageId: string;\n        type: TypeVendor.TRANSLATE_BY_VENDOR;\n        vendor: 'gengo';\n        fileIds: number[];\n        labelIds?: number[];\n        excludeLabelIds?: number[];\n        status?: RequestStatus;\n        description?: string;\n        expertise?: 'standard' | 'pro';\n        tone?: Tone;\n        purpose?: Purpose;\n        customerMessage?: string;\n        usePreferred?: boolean;\n        editService?: boolean;\n        dateFrom?: string;\n        dateTo?: string;\n    }\n    type CreateTaskVendorGengoByStringIds = Omit<CreateTaskVendorGengoByFileIds, 'fileIds' | 'labelIds' | 'excludeLabelIds'> & {\n        stringIds: number[];\n    };\n    type CreateTaskVendorGengoByBranchIds = Omit<CreateTaskVendorGengoByFileIds, 'fileIds'> & {\n        branchIds: number[];\n    };\n    interface CreateTaskVendorManualByFileIds {\n        title: string;\n        languageId: string;\n        type: TypeVendor;\n        vendor: 'alconost' | 'babbleon' | 'tomedes' | 'e2f' | 'write_path_admin' | 'inlingo' | 'acclaro' | 'translate_by_humans' | 'lingo24' | 'assertio_language_services' | 'gte_localize' | 'kettu_solutions' | 'languageline_solutions';\n        fileIds: number[];\n        labelIds?: number[];\n        excludeLabelIds?: number[];\n        status?: RequestStatus;\n        description?: string;\n        skipAssignedStrings?: boolean;\n        includePreTranslatedStringsOnly?: boolean;\n        assignees?: CreateTaskAssignee[];\n        deadline?: string;\n        startedAt?: string;\n        dateFrom?: string;\n        dateTo?: string;\n    }\n    type CreateTaskVendorManualByStringIds = Omit<CreateTaskVendorManualByFileIds, 'fileIds' | 'labelIds' | 'excludeLabelIds'> & {\n        stringIds: number[];\n    };\n    type CreateTaskVendorManualByBranchIds = Omit<CreateTaskVendorManualByFileIds, 'fileIds'> & {\n        branchIds: number[];\n    };\n    interface CreateTaskPendingTask {\n        precedingTaskId: number;\n        type: Type.PROOFREAD;\n        title: string;\n        description?: string;\n        assignees?: CreateTaskAssignee[];\n        deadline?: string;\n    }\n    interface CreateTaskPendingTaskLanguageService {\n        precedingTaskId: number;\n        type: TypeVendor.PROOFREAD_BY_VENDOR;\n        vendor: 'crowdin_language_service';\n        title: string;\n        description?: string;\n        deadline?: string;\n    }\n    interface CreateTaskPendingTaskVendorManual {\n        precedingTaskId: number;\n        type: TypeVendor.PROOFREAD_BY_VENDOR;\n        vendor: CreateTaskVendorManualByFileIds['vendor'];\n        title: string;\n        description?: string;\n        deadline?: string;\n    }\n    interface CreateTaskAssignee {\n        id: number;\n        wordsCount?: number;\n    }\n    type Status = 'todo' | 'in_progress' | 'done' | 'closed';\n    type RequestStatus = Extract<Status, 'todo' | 'in_progress'>;\n    enum Type {\n        TRANSLATE = 0,\n        PROOFREAD = 1\n    }\n    enum TypeVendor {\n        TRANSLATE_BY_VENDOR = 2,\n        PROOFREAD_BY_VENDOR = 3\n    }\n    interface Assignee {\n        id: number;\n        username: string;\n        fullName: string;\n        avatarUrl: string;\n        wordsCount: number;\n        wordsLeft: number;\n    }\n    interface AssignedTeam {\n        id: number;\n        wordsCount: number;\n    }\n    interface Progress {\n        total: number;\n        done: number;\n        percent: number;\n    }\n    type Expertise = 'standard' | 'mobile-applications' | 'software-it' | 'gaming-video-games' | 'technical-engineering' | 'marketing-consumer-media' | 'business-finance' | 'legal-certificate' | 'medical' | 'ad-words-banners' | 'automotive-aerospace' | 'scientific' | 'scientific-academic' | 'tourism' | 'training-employee-handbooks' | 'forex-crypto';\n    enum TranslatedExpertise {\n        ECONOMY = \"P\",\n        PROFESSIONAL = \"T\",\n        PREMIUM = \"R\"\n    }\n    type Tone = '' | 'Informal' | 'Friendly' | 'Business' | 'Formal' | 'other';\n    type Purpose = 'standard' | 'Personal use' | 'Business' | 'Online content' | 'App/Web localization' | 'Media content' | 'Semi-technical' | 'other';\n    type Subject = 'general' | 'accounting_finance' | 'aerospace_defence' | 'architecture' | 'art' | 'automotive' | 'certificates_diplomas_licences_cv_etc' | 'chemical' | 'civil_engineering_construction' | 'corporate_social_responsibility' | 'cosmetics' | 'culinary' | 'electronics_electrical_engineering' | 'energy_power_generation_oil_gas' | 'environment' | 'fashion' | 'games_viseogames_casino' | 'general_business_commerce' | 'history_archaeology' | 'information_technology' | 'insurance' | 'internet_e-commerce' | 'legal_documents_contracts' | 'literary_translations' | 'marketing_advertising_material_public_relations' | 'matematics_and_physics' | 'mechanical_manufacturing' | 'media_journalism_publishing' | 'medical_pharmaceutical' | 'music' | 'private_correspondence_letters' | 'religion' | 'science' | 'shipping_sailing_maritime' | 'social_science' | 'telecommunications' | 'travel_tourism';\n    interface ListTasksOptions extends PaginationOptions {\n        status?: TasksModel.Status;\n        assigneeId?: number;\n        orderBy?: string;\n    }\n    interface TaskSettingsTemplate {\n        id: number;\n        name: string;\n        config: TaskSettingsTemplateConfig;\n        createdAt: string;\n        updatedAt: string;\n    }\n    interface AddTaskSettingsTemplate {\n        name: string;\n        config: TaskSettingsTemplateConfig;\n    }\n    interface TaskSettingsTemplateConfig {\n        languages: {\n            languageId?: string;\n            userIds?: number[];\n            teamIds?: number[];\n        }[];\n    }\n    interface TaskComment {\n        id: number;\n        userId: number;\n        taskId: number;\n        text: string;\n        timeSpent: number;\n        createdAt: string;\n        updatedAt: string;\n    }\n    interface CreateTaskCommentRequest {\n        text?: string;\n        timeSpent?: number;\n    }\n}\n```\n\n##### teams/index.d.ts\n\n```typescript\nimport { CrowdinApi, Pagination, PaginationOptions, PatchRequest, ProjectRole, ProjectRoles, ResponseList, ResponseObject } from '../core';\nimport { ProjectsGroupsModel } from '../projectsGroups';\nexport declare class Teams extends CrowdinApi {\n    listGroupTeams(groupId: number, options?: TeamsModel.ListGroupTeamsOptions): Promise<ResponseList<TeamsModel.TeamGroup>>;\n    updateGroupTeams(groupId: number, request: PatchRequest[]): Promise<ResponseList<TeamsModel.TeamGroup>>;\n    getGroupTeam(groupId: number, teamId: number): Promise<ResponseObject<TeamsModel.TeamGroup>>;\n    listTeamProjectPermissions(teamId: number, options?: PaginationOptions): Promise<ResponseList<TeamsModel.ProjectPermissions>>;\n    editTeamProjectPermissions(teamId: number, request: PatchRequest[]): Promise<ResponseList<TeamsModel.ProjectPermissions>>;\n    addTeamToProject(projectId: number, request: TeamsModel.AddTeamToProjectRequest): Promise<TeamsModel.ProjectTeamResources>;\n    listTeams(options?: TeamsModel.ListTeamsOptions): Promise<ResponseList<TeamsModel.Team>>;\n    listTeams(limit?: number, offset?: number): Promise<ResponseList<TeamsModel.Team>>;\n    addTeam(request: TeamsModel.AddTeamRequest): Promise<ResponseObject<TeamsModel.Team>>;\n    getTeam(teamId: number): Promise<ResponseObject<TeamsModel.Team>>;\n    deleteTeam(teamId: number): Promise<void>;\n    editTeam(teamId: number, request: PatchRequest[]): Promise<ResponseObject<TeamsModel.Team>>;\n    teamMembersList(teamId: number, options?: PaginationOptions): Promise<ResponseList<TeamsModel.TeamMember>>;\n    teamMembersList(teamId: number, limit?: number, offset?: number): Promise<ResponseList<TeamsModel.TeamMember>>;\n    addTeamMembers(teamId: number, request: TeamsModel.AddTeamMembersRequest): Promise<TeamsModel.AddTeamMembersResponse>;\n    deleteAllTeamMembers(teamId: number): Promise<void>;\n    deleteTeamMember(teamId: number, memberId: number): Promise<void>;\n}\nexport declare namespace TeamsModel {\n    interface ListGroupTeamsOptions extends PaginationOptions {\n        orderBy?: string;\n    }\n    interface ProjectPermissions {\n        id: number;\n        roles: ProjectRole[];\n        project: ProjectsGroupsModel.Project | ProjectsGroupsModel.ProjectSettings;\n    }\n    interface AddTeamToProjectRequest {\n        teamId: number;\n        managerAccess?: boolean;\n        developerAccess?: boolean;\n        roles?: ProjectRole[];\n        accessToAllWorkflowSteps?: boolean;\n        permissions?: Permissions;\n    }\n    interface ListTeamsOptions extends PaginationOptions {\n        search?: string;\n        projectIds?: string;\n        projectRoles?: ProjectRoles[];\n        languageIds?: string;\n        groupIds?: string;\n        orderBy?: string;\n    }\n    interface ProjectTeamResources {\n        skipped: ProjectTeamResource;\n        added: ProjectTeamResource;\n    }\n    interface ProjectTeamResource {\n        id: number;\n        hasManagerAccess: boolean;\n        hasDeveloperAccess: boolean;\n        hasAccessToAllWorkflowSteps: boolean;\n        permissions: Permissions;\n        roles: ProjectRole[];\n    }\n    interface Permissions {\n        [lang: string]: {\n            workflowStepIds: number[] | 'all';\n        };\n    }\n    interface Team {\n        id: number;\n        name: string;\n        totalMembers: number;\n        webUrl: string;\n        createdAt: string;\n        updatedAt: string;\n    }\n    interface TeamGroup {\n        id: number;\n        team: Team;\n    }\n    interface AddTeamRequest {\n        name: string;\n    }\n    interface TeamMember {\n        id: number;\n        username: string;\n        firstName: string;\n        lastName: string;\n        avatarUrl: string;\n        addedAt: string;\n    }\n    interface AddTeamMembersRequest {\n        userIds: number[];\n    }\n    interface AddTeamMembersResponse {\n        skipped: ResponseObject<TeamMember>[];\n        added: ResponseObject<TeamMember>[];\n        pagination: Pagination;\n    }\n}\n```\n\n##### translationMemory/index.d.ts\n\n```typescript\nimport { CrowdinApi, DownloadLink, PaginationOptions, PatchRequest, ResponseList, ResponseObject, Status } from '../core';\nexport declare class TranslationMemory extends CrowdinApi {\n    listTm(options?: TranslationMemoryModel.ListTMsOptions): Promise<ResponseList<TranslationMemoryModel.TranslationMemory>>;\n    listTm(groupId?: number, limit?: number, offset?: number): Promise<ResponseList<TranslationMemoryModel.TranslationMemory>>;\n    addTm(request: TranslationMemoryModel.AddTranslationMemoryRequest): Promise<ResponseObject<TranslationMemoryModel.TranslationMemory>>;\n    getTm(tmId: number): Promise<ResponseObject<TranslationMemoryModel.TranslationMemory>>;\n    deleteTm(tmId: number): Promise<void>;\n    editTm(tmId: number, request: PatchRequest[]): Promise<ResponseObject<TranslationMemoryModel.TranslationMemory>>;\n    listTmSegments(tmId: number, options?: TranslationMemoryModel.ListSegmentsOptions): Promise<ResponseList<TranslationMemoryModel.TMSegment>>;\n    addTmSegment(tmId: number, request: TranslationMemoryModel.AddTMSegment): Promise<ResponseObject<TranslationMemoryModel.TMSegment>>;\n    clearTm(tmId: number): Promise<void>;\n    exportTm(tmId: number, request?: TranslationMemoryModel.ExportTranslationMemoryRequest): Promise<ResponseObject<Status<TranslationMemoryModel.ExportTranslationMemoryAttribute>>>;\n    checkExportStatus(tmId: number, exportId: string): Promise<ResponseObject<Status<TranslationMemoryModel.ExportTranslationMemoryAttribute>>>;\n    downloadTm(tmId: number, exportId: string): Promise<ResponseObject<DownloadLink>>;\n    concordanceSearch(projectId: number, request: TranslationMemoryModel.ConcordanceSearchRequest): Promise<ResponseList<TranslationMemoryModel.ConcordanceSearchResponse>>;\n    importTm(tmId: number, request: TranslationMemoryModel.ImportTranslationMemoryRequest): Promise<ResponseObject<Status<TranslationMemoryModel.ImportTranslationMemoryAttribute>>>;\n    checkImportStatus(tmId: number, importId: string): Promise<ResponseObject<Status<TranslationMemoryModel.ImportTranslationMemoryAttribute>>>;\n    getTmSegment(tmId: number, segmentId: number): Promise<ResponseObject<TranslationMemoryModel.TMSegment>>;\n    deleteTmSegment(tmId: number, segmentId: number): Promise<void>;\n    editTmSegment(tmId: number, segmentId: number, request: PatchRequest[]): Promise<ResponseObject<TranslationMemoryModel.TMSegment>>;\n    deleteTmSegmentRecord(tmId: number, segmentId: number, recordId: number): Promise<void>;\n    editTmSegmentRecord(tmId: number, segmentId: number, recordId: number, request: PatchRequest[]): Promise<ResponseObject<TranslationMemoryModel.TMSegment>>;\n    addTmSegmentRecords(tmId: number, segmentId: number, request: TranslationMemoryModel.AddTMSegment): Promise<ResponseObject<TranslationMemoryModel.TMSegment>>;\n}\nexport declare namespace TranslationMemoryModel {\n    interface TranslationMemory {\n        id: number;\n        groupId: number;\n        userId: number;\n        name: string;\n        languageId: string;\n        languageIds: string[];\n        segmentsCount: number;\n        defaultProjectIds: number[];\n        projectIds: number[];\n        createdAt: string;\n        webUrl: string;\n    }\n    interface AddTranslationMemoryRequest {\n        name: string;\n        languageId: string;\n        groupId?: number;\n    }\n    interface ConcordanceSearchRequest {\n        sourceLanguageId: string;\n        targetLanguageId: string;\n        autoSubstitution: boolean;\n        minRelevant: number;\n        expressions: string[];\n        expression?: string;\n    }\n    interface ConcordanceSearchResponse {\n        tm: TranslationMemory;\n        recordId: number;\n        source: string;\n        target: string;\n        relevant: number;\n        substituted: string;\n        updatedAt: string;\n    }\n    interface ExportTranslationMemoryRequest {\n        sourceLanguageId?: number;\n        targetLanguageId?: number;\n        format?: Format;\n    }\n    interface ImportTranslationMemoryRequest {\n        storageId: number;\n        firstLineContainsHeader?: boolean;\n        scheme?: Scheme;\n    }\n    interface ExportTranslationMemoryAttribute {\n        sourceLanguageId: string;\n        targetLanguageId: string;\n        format: string;\n    }\n    interface ImportTranslationMemoryAttribute {\n        tmId: number;\n        storageId: number;\n        firstLineContainsHeader: number;\n        scheme: Scheme;\n    }\n    type Format = 'tmx' | 'csv' | 'xlsx';\n    interface Scheme {\n        [key: string]: number;\n    }\n    interface ListTMsOptions extends PaginationOptions {\n        groupId?: number;\n        userId?: number;\n        orderBy?: string;\n    }\n    interface ListSegmentsOptions extends PaginationOptions {\n        croql?: string;\n        orderBy?: string;\n    }\n    interface TMSegment {\n        id: number;\n        records: TMSegmentRecord[];\n    }\n    interface TMSegmentRecord {\n        id: number;\n        languageId: string;\n        text: string;\n        usageCount: number;\n        createdBy: number;\n        updatedBy: number;\n        createdAt: string;\n        updatedAt: string;\n    }\n    interface AddTMSegment {\n        records: AddTMSegmentRecord[];\n    }\n    interface AddTMSegmentRecord {\n        languageId: string;\n        text: string;\n    }\n}\n```\n\n##### translationStatus/index.d.ts\n\n```typescript\nimport { CrowdinApi, PaginationOptions, ResponseList } from '../core';\nimport { LanguagesModel } from '../languages';\nexport declare class TranslationStatus extends CrowdinApi {\n    getBranchProgress(projectId: number, branchId: number, options?: PaginationOptions): Promise<ResponseList<TranslationStatusModel.LanguageProgress>>;\n    getBranchProgress(projectId: number, branchId: number, limit?: number, offset?: number): Promise<ResponseList<TranslationStatusModel.LanguageProgress>>;\n    getDirectoryProgress(projectId: number, directoryId: number, options?: PaginationOptions): Promise<ResponseList<TranslationStatusModel.LanguageProgress>>;\n    getDirectoryProgress(projectId: number, directoryId: number, limit?: number, offset?: number): Promise<ResponseList<TranslationStatusModel.LanguageProgress>>;\n    getFileProgress(projectId: number, fileId: number, options?: PaginationOptions): Promise<ResponseList<TranslationStatusModel.LanguageProgress>>;\n    getFileProgress(projectId: number, fileId: number, limit?: number, offset?: number): Promise<ResponseList<TranslationStatusModel.LanguageProgress>>;\n    getLanguageProgress(projectId: number, languageId: string, options?: PaginationOptions): Promise<ResponseList<TranslationStatusModel.FileProgress>>;\n    getLanguageProgress(projectId: number, languageId: string, limit?: number, offset?: number): Promise<ResponseList<TranslationStatusModel.FileProgress>>;\n    getProjectProgress(projectId: number, options?: PaginationOptions): Promise<ResponseList<TranslationStatusModel.LanguageProgress>>;\n    getProjectProgress(projectId: number, limit?: number, offset?: number, languageIds?: string): Promise<ResponseList<TranslationStatusModel.LanguageProgress>>;\n    listQaCheckIssues(projectId: number, options?: TranslationStatusModel.ListQaCheckIssuesOptions): Promise<ResponseList<TranslationStatusModel.QaCheck>>;\n    listQaCheckIssues(projectId: number, limit?: number, offset?: number, category?: TranslationStatusModel.Category, validation?: TranslationStatusModel.Validation, languageIds?: string): Promise<ResponseList<TranslationStatusModel.QaCheck>>;\n}\nexport declare namespace TranslationStatusModel {\n    interface LanguageProgress {\n        words: Words;\n        phrases: Words;\n        translationProgress: number;\n        approvalProgress: number;\n        eTag: string;\n        languageId: string;\n        language: LanguagesModel.Language;\n    }\n    interface FileProgress {\n        words: Words;\n        phrases: Words;\n        translationProgress: number;\n        approvalProgress: number;\n        branchId: number;\n        fileId: number;\n        eTag: string;\n    }\n    interface Words {\n        total: number;\n        translated: number;\n        approved: number;\n        preTranslateAppliedTo: number;\n    }\n    type Category = 'empty' | 'variables' | 'tags' | 'punctuation' | 'symbol_register' | 'spaces' | 'size' | 'special_symbols' | 'wrong_translation' | 'spellcheck' | 'icu';\n    type Validation = 'empty_string_check' | 'empty_suggestion_check' | 'max_length_check' | 'tags_check' | 'mismatch_ids_check' | 'cdata_check' | 'specials_symbols_check' | 'leading_newlines_check' | 'trailing_newlines_check' | 'leading_spaces_check' | 'trailing_spaces_check' | 'multiple_spaces_check' | 'custom_blocked_variables_check' | 'highest_priority_custom_variables_check' | 'highest_priority_variables_check' | 'c_variables_check' | 'python_variables_check' | 'rails_variables_check' | 'java_variables_check' | 'dot_net_variables_check' | 'twig_variables_check' | 'php_variables_check' | 'freemarker_variables_check' | 'lowest_priority_variable_check' | 'lowest_priority_custom_variables_check' | 'punctuation_check' | 'spaces_before_punctuation_check' | 'spaces_after_punctuation_check' | 'non_breaking_spaces_check' | 'capitalize_check' | 'multiple_uppercase_check' | 'parentheses_check' | 'entities_check' | 'escaped_quotes_check' | 'wrong_translation_issue_check' | 'spellcheck' | 'icu_check';\n    interface ListQaCheckIssuesOptions extends PaginationOptions {\n        category?: Category | Category[];\n        validation?: Validation | Validation[];\n        languageIds?: string;\n    }\n    interface QaCheck {\n        stringId: number;\n        languageId: string;\n        category: Category;\n        categoryDescription: string;\n        validation: Validation;\n        validationDescription: string;\n        pluralId: number;\n        text: string;\n    }\n    interface GetProjectProgressOptions extends PaginationOptions {\n        languageIds?: string;\n    }\n}\n```\n\n##### translations/index.d.ts\n\n```typescript\nimport { CrowdinApi, DownloadLink, PaginationOptions, PatchRequest, ResponseList, ResponseObject, Status } from '../core';\nimport { ProjectsGroupsModel } from '../projectsGroups';\nexport declare class Translations extends CrowdinApi {\n    listPreTranslations(projectId: number, options?: PaginationOptions): Promise<ResponseList<Status<TranslationsModel.PreTranslationStatusAttributes>>>;\n    preTranslationStatus(projectId: number, preTranslationId: string): Promise<ResponseObject<Status<TranslationsModel.PreTranslationStatusAttributes>>>;\n    applyPreTranslation(projectId: number, request: TranslationsModel.PreTranslateRequest | TranslationsModel.PreTranslateStringsRequest): Promise<ResponseObject<Status<TranslationsModel.PreTranslationStatusAttributes>>>;\n    editPreTranslation(projectId: number, preTranslationId: string, request: PatchRequest[]): Promise<ResponseObject<Status<TranslationsModel.PreTranslationStatusAttributes>>>;\n    getPreTranslationReport(projectId: number, preTranslationId: string): Promise<ResponseObject<TranslationsModel.PreTranslationReport>>;\n    buildProjectDirectoryTranslation(projectId: number, directoryId: number, request?: TranslationsModel.BuildProjectDirectoryTranslationRequest): Promise<ResponseObject<TranslationsModel.BuildProjectDirectoryTranslationResponse>>;\n    buildProjectFileTranslation(projectId: number, fileId: number, request: TranslationsModel.BuildProjectFileTranslationRequest, eTag?: string): Promise<ResponseObject<TranslationsModel.BuildProjectFileTranslationResponse>>;\n    listProjectBuilds(projectId: number, options?: TranslationsModel.ListProjectBuildsOptions): Promise<ResponseList<TranslationsModel.Build>>;\n    listProjectBuilds(projectId: number, branchId?: number, limit?: number, offset?: number): Promise<ResponseList<TranslationsModel.Build>>;\n    buildProject(projectId: number, request?: TranslationsModel.BuildRequest | TranslationsModel.PseudoBuildRequest): Promise<ResponseObject<TranslationsModel.Build>>;\n    uploadTranslation(projectId: number, languageId: string, request: TranslationsModel.UploadTranslationRequest): Promise<ResponseObject<TranslationsModel.UploadTranslationResponse>>;\n    uploadTranslationStrings(projectId: number, languageId: string, request: TranslationsModel.UploadTranslationStringsRequest): Promise<ResponseObject<TranslationsModel.UploadTranslationStringsResponse>>;\n    downloadTranslations(projectId: number, buildId: number): Promise<ResponseObject<DownloadLink>>;\n    checkBuildStatus(projectId: number, buildId: number): Promise<ResponseObject<TranslationsModel.Build>>;\n    cancelBuild(projectId: number, buildId: number): Promise<void>;\n    exportProjectTranslation(projectId: number, request: TranslationsModel.ExportProjectTranslationRequest): Promise<ResponseObject<DownloadLink>>;\n}\nexport declare namespace TranslationsModel {\n    interface PreTranslateRequest {\n        languageIds: string[];\n        fileIds: number[];\n        method?: Method;\n        engineId?: number;\n        aiPromptId?: number;\n        autoApproveOption?: AutoApproveOption;\n        duplicateTranslations?: boolean;\n        skipApprovedTranslations?: boolean;\n        translateUntranslatedOnly?: boolean;\n        translateWithPerfectMatchOnly?: boolean;\n        fallbackLanguages?: {\n            languageId?: string[];\n        };\n        labelIds?: number[];\n        excludeLabelIds?: number[];\n    }\n    interface PreTranslateStringsRequest {\n        languageIds: string[];\n        branchIds?: number[];\n        method?: Method;\n        engineId?: number;\n        aiPromptId?: number;\n        autoApproveOption?: AutoApproveOption;\n        duplicateTranslations?: boolean;\n        skipApprovedTranslations?: boolean;\n        translateUntranslatedOnly?: boolean;\n        translateWithPerfectMatchOnly?: boolean;\n        fallbackLanguages?: {\n            languageId: string[];\n        };\n        labelIds?: number[];\n        excludeLabelIds?: number[];\n    }\n    interface BuildProjectDirectoryTranslationRequest {\n        targetLanguageIds?: string[];\n        skipUntranslatedStrings?: boolean;\n        skipUntranslatedFiles?: boolean;\n        preserveFolderHierarchy?: boolean;\n        exportStringsThatPassedWorkflow?: boolean;\n        exportWithMinApprovalsCount?: number;\n        exportApprovedOnly?: boolean;\n    }\n    interface BuildProjectDirectoryTranslationResponse {\n        id: number;\n        projectId: number;\n        status: BuildStatus;\n        progress: number;\n        createdAt: string;\n        updatedAt: string;\n        finishedAt: string;\n    }\n    type BuildStatus = 'created' | 'inProgress' | 'canceled' | 'failed' | 'finished';\n    interface BuildProjectFileTranslationRequest {\n        targetLanguageId: string;\n        exportAsXliff?: boolean;\n        skipUntranslatedStrings?: boolean;\n        skipUntranslatedFiles?: boolean;\n        exportApprovedOnly?: boolean;\n        exportWithMinApprovalsCount?: number;\n        exportStringsThatPassedWorkflow?: boolean;\n    }\n    interface BuildProjectFileTranslationResponse extends DownloadLink {\n        etag: string;\n    }\n    interface PreTranslationStatusAttributes {\n        languageIds: string[];\n        fileIds: number[];\n        branchIds: number[];\n        method: Method;\n        autoApproveOption: AutoApproveOption;\n        duplicateTranslations: boolean;\n        skipApprovedTranslations: boolean;\n        translateUntranslatedOnly: boolean;\n        translateWithPerfectMatchOnly: boolean;\n    }\n    type Method = 'tm' | 'mt' | 'ai';\n    type AutoApproveOption = 'all' | 'exceptAutoSubstituted' | 'perfectMatchOnly' | 'none';\n    type CharTransformation = 'asian' | 'european' | 'arabic' | 'cyrillic';\n    interface Build {\n        id: number;\n        projectId: number;\n        status: BuildStatus;\n        progress: number;\n        attributes: Attribute;\n        createdAt: string;\n        updatedAt: string;\n        finishedAt: string;\n    }\n    interface Attribute {\n        branchId: number;\n        directoryId: number;\n        targetLanguageIds: string[];\n        skipUntranslatedStrings: boolean;\n        skipUntranslatedFiles: boolean;\n        exportApprovedOnly: boolean;\n        exportWithMinApprovalsCount: number;\n        exportStringsThatPassedWorkflow: boolean;\n    }\n    interface BuildRequest {\n        branchId?: number;\n        targetLanguageIds?: string[];\n        skipUntranslatedStrings?: boolean;\n        skipUntranslatedFiles?: boolean;\n        exportApprovedOnly?: boolean;\n        exportWithMinApprovalsCount?: number;\n        exportStringsThatPassedWorkflow?: boolean;\n    }\n    interface PseudoBuildRequest {\n        pseudo: boolean;\n        branchId?: number;\n        prefix?: string;\n        suffix?: string;\n        lengthTransformation?: number;\n        charTransformation?: CharTransformation;\n    }\n    interface UploadTranslationRequest {\n        storageId: number;\n        fileId?: number;\n        importEqSuggestions?: boolean;\n        autoApproveImported?: boolean;\n        translateHidden?: boolean;\n        addToTm?: boolean;\n    }\n    interface UploadTranslationStringsRequest {\n        storageId: number;\n        branchId?: number;\n        importEqSuggestions?: boolean;\n        autoApproveImported?: boolean;\n        translateHidden?: boolean;\n        addToTm?: boolean;\n    }\n    interface UploadTranslationResponse {\n        projectId: number;\n        storageId: number;\n        languageId: string;\n        fileId: number;\n    }\n    interface UploadTranslationStringsResponse {\n        projectId: number;\n        storageId: number;\n        languageId: string;\n        branchId: number;\n    }\n    interface ExportProjectTranslationRequest {\n        targetLanguageId: string;\n        format?: string;\n        labelIds?: number[];\n        branchIds?: number[];\n        directoryIds?: number[];\n        fileIds?: number[];\n        skipUntranslatedStrings?: boolean;\n        skipUntranslatedFiles?: boolean;\n        exportApprovedOnly?: boolean;\n        exportWithMinApprovalsCount?: number;\n        exportStringsThatPassedWorkflow?: boolean;\n    }\n    interface ListProjectBuildsOptions extends PaginationOptions {\n        branchId?: number;\n    }\n    interface PreTranslationReport {\n        languages: TargetLanguage[];\n        preTranslateType: Method;\n    }\n    interface TargetLanguage {\n        id: string;\n        files: TargetLanguageFile[];\n        skipped: SkippedInfo;\n        skippedQaCheckCategories: ProjectsGroupsModel.CheckCategories;\n    }\n    interface TargetLanguageFile {\n        id: string;\n        statistics: TargetLanguageFileStatistics;\n    }\n    interface TargetLanguageFileStatistics {\n        phrases: number;\n        words: number;\n    }\n    interface SkippedInfo {\n        [key: string]: any;\n    }\n}\n```\n\n##### uploadStorage/index.d.ts\n\n```typescript\nimport { CrowdinApi, PaginationOptions, ResponseList, ResponseObject } from '../core';\nexport declare class UploadStorage extends CrowdinApi {\n    listStorages(options?: PaginationOptions): Promise<ResponseList<UploadStorageModel.Storage>>;\n    listStorages(limit?: number, offset?: number): Promise<ResponseList<UploadStorageModel.Storage>>;\n    addStorage(fileName: string, request: any, contentType?: string): Promise<ResponseObject<UploadStorageModel.Storage>>;\n    getStorage(storageId: number): Promise<ResponseObject<UploadStorageModel.Storage>>;\n    deleteStorage(storageId: number): Promise<void>;\n}\nexport declare namespace UploadStorageModel {\n    interface Storage {\n        id: number;\n        fileName: string;\n    }\n}\n```\n\n##### users/index.d.ts\n\n```typescript\nimport { CrowdinApi, Pagination, PaginationOptions, PatchRequest, ProjectRole, ProjectRoles, ResponseList, ResponseObject } from '../core';\nimport { ProjectsGroupsModel } from '../projectsGroups';\nimport { TeamsModel } from '../teams';\nexport declare class Users extends CrowdinApi {\n    listGroupManagers(groupId: number, options?: UsersModel.ListGroupManagersOptions): Promise<ResponseList<UsersModel.GroupManager>>;\n    updateGroupManagers(groupId: number, request: PatchRequest[]): Promise<ResponseList<UsersModel.GroupManager>>;\n    getGroupManager(groupId: number, userId: number): Promise<ResponseObject<UsersModel.GroupManager>>;\n    listProjectMembers(projectId: number, options?: UsersModel.ListProjectMembersOptions): Promise<ResponseList<UsersModel.ProjectMember | UsersModel.EnterpriseProjectMember>>;\n    listProjectMembers(projectId: number, search?: string, role?: UsersModel.Role, languageId?: string, limit?: number, offset?: number): Promise<ResponseList<UsersModel.ProjectMember | UsersModel.EnterpriseProjectMember>>;\n    addProjectMember(projectId: number, request: UsersModel.AddProjectMemberRequest): Promise<UsersModel.AddProjectMemberResponse>;\n    getProjectMemberPermissions(projectId: number, memberId: number): Promise<ResponseObject<UsersModel.ProjectMember | UsersModel.EnterpriseProjectMember>>;\n    replaceProjectMemberPermissions(projectId: number, memberId: number, request?: UsersModel.ReplaceProjectMemberRequest): Promise<ResponseObject<UsersModel.ProjectMember | UsersModel.EnterpriseProjectMember>>;\n    deleteMemberFromProject(projectId: number, memberId: number): Promise<void>;\n    listUsers(options?: UsersModel.ListUsersOptions): Promise<ResponseList<UsersModel.User>>;\n    listUsers(status?: UsersModel.Status, search?: string, twoFactor?: UsersModel.TwoFactor, limit?: number, offset?: number): Promise<ResponseList<UsersModel.User>>;\n    inviteUser(request: UsersModel.InviteUserRequest): Promise<ResponseObject<UsersModel.User>>;\n    getUserInfo(userId: number): Promise<ResponseObject<UsersModel.User>>;\n    deleteUser(userId: number): Promise<void>;\n    editUser(userId: number, request: PatchRequest[]): Promise<ResponseObject<UsersModel.User>>;\n    getAuthenticatedUser(): Promise<ResponseObject<UsersModel.User>>;\n    editAuthenticatedUser(request: PatchRequest[]): Promise<ResponseObject<UsersModel.User>>;\n    listUserProjectPermissions(userId: number, options?: PaginationOptions): Promise<ResponseList<UsersModel.ProjectPermissions>>;\n    editUserProjectPermissions(userId: number, request: PatchRequest[]): Promise<ResponseList<UsersModel.ProjectPermissions>>;\n    listUserProjectContributions(userId: number, options?: PaginationOptions): Promise<ResponseList<UsersModel.ProjectPermissions>>;\n}\nexport declare namespace UsersModel {\n    interface ListGroupManagersOptions extends PaginationOptions {\n        teamIds?: number[];\n        orderBy?: string;\n    }\n    interface ListProjectMembersOptions extends PaginationOptions {\n        search?: string;\n        role?: Role;\n        languageId?: string;\n        workflowStepId?: number;\n        orderBy?: string;\n    }\n    interface ListUsersOptions extends PaginationOptions {\n        status?: Status;\n        search?: string;\n        twoFactor?: TwoFactor;\n        orderBy?: string;\n        organizationRoles?: OrganizationRoles[];\n        teamId?: number;\n        projectIds?: string;\n        projectRoles?: ProjectRoles[];\n        languageIds?: string;\n        groupIds?: string;\n        lastSeenFrom?: string;\n        lastSeenTo?: string;\n    }\n    interface InviteUserRequest {\n        email: string;\n        firstName?: string;\n        lastName?: string;\n        timezone?: string;\n        adminAccess?: boolean;\n    }\n    interface User {\n        id: number;\n        username: string;\n        email: string;\n        firstName: string;\n        lastName: string;\n        status: Status;\n        avatarUrl: string;\n        fields: Record<string, any>;\n        createdAt: string;\n        lastSeen: string;\n        twoFactor: TwoFactor;\n        isAdmin: boolean;\n        timezone: string;\n        emailVerified: string;\n    }\n    type Status = 'active' | 'pending' | 'blocked';\n    type TwoFactor = 'enabled' | 'disabled';\n    type OrganizationRoles = 'admin' | 'manager' | 'vendor' | 'client';\n    interface GroupManager {\n        id: number;\n        user: User;\n        teams: TeamsModel.Team[];\n    }\n    interface ProjectMember {\n        id: number;\n        username: string;\n        fullName: string;\n        role: Role;\n        permissions: Permissions;\n        avatarUrl: string;\n        joinedAt: string;\n        timezone: string;\n        roles: ProjectRole[];\n    }\n    interface EnterpriseProjectMember {\n        id: number;\n        username: string;\n        firstName: string;\n        lastName: string;\n        isManager: boolean;\n        isDeveloperr: boolean;\n        managerOfGroup: Group;\n        accessToAllWorkflowSteps: boolean;\n        permissions: Permissions;\n        givenAccessAt: string;\n        roles: ProjectRole[];\n    }\n    interface Group {\n        id: number;\n        name: string;\n    }\n    type Role = 'all' | 'owner' | 'manager' | 'proofreader' | 'translator' | 'blocked';\n    type LanguageRole = 'proofreader' | 'translator' | 'denied';\n    interface AddProjectMemberRequest {\n        userIds?: number[];\n        usernames?: string[];\n        emails?: string[];\n        managerAccess?: boolean;\n        roles?: ProjectRole[];\n        developerAccess?: boolean;\n        accessToAllWorkflowSteps?: boolean;\n        permissions?: Permissions;\n    }\n    interface AddProjectMemberResponse {\n        skipped: ResponseObject<ProjectMember | EnterpriseProjectMember>[];\n        added: ResponseObject<ProjectMember | EnterpriseProjectMember>[];\n        pagination: Pagination;\n    }\n    interface ReplaceProjectMemberRequest {\n        managerAccess?: boolean;\n        developerAccess?: boolean;\n        roles?: ProjectRole[];\n        accessToAllWorkflowSteps?: boolean;\n        permissions?: Permissions;\n    }\n    interface ProjectPermissions {\n        id: number;\n        roles: ProjectRole[];\n        project: ProjectsGroupsModel.Project | ProjectsGroupsModel.ProjectSettings;\n        teams: TeamsModel.Team[];\n    }\n    interface Contributions {\n        id: number;\n        translated: Contribution;\n        approved: Contribution;\n        voted: Contribution;\n        commented: Contribution;\n        project: ProjectsGroupsModel.Project | ProjectsGroupsModel.ProjectSettings;\n    }\n    interface Contribution {\n        strings: number;\n        words?: number;\n    }\n    interface Permissions {\n        [lang: string]: string | {\n            workflowStepIds: number[] | 'all';\n        };\n    }\n}\n```\n\n##### vendors/index.d.ts\n\n```typescript\nimport { CrowdinApi, PaginationOptions, ResponseList } from '../core';\nexport declare class Vendors extends CrowdinApi {\n    listVendors(options?: PaginationOptions): Promise<ResponseList<VendorsModel.Vendor>>;\n    listVendors(limit?: number, offset?: number): Promise<ResponseList<VendorsModel.Vendor>>;\n}\nexport declare namespace VendorsModel {\n    interface Vendor {\n        id: number;\n        name: string;\n        description: string;\n        status: 'pending' | 'confirmed' | 'rejected';\n        webUrl: string;\n    }\n}\n```\n\n##### webhooks/index.d.ts\n\n```typescript\nimport { CrowdinApi, PaginationOptions, PatchRequest, ResponseList, ResponseObject } from '../core';\nexport declare class Webhooks extends CrowdinApi {\n    listWebhooks(projectId: number, options?: PaginationOptions): Promise<ResponseList<WebhooksModel.Webhook>>;\n    listWebhooks(projectId: number, limit?: number, offset?: number): Promise<ResponseList<WebhooksModel.Webhook>>;\n    addWebhook(projectId: number, request: WebhooksModel.AddWebhookRequest): Promise<ResponseObject<WebhooksModel.Webhook>>;\n    getWebhook(projectId: number, webhookId: number): Promise<ResponseObject<WebhooksModel.Webhook>>;\n    deleteWebhook(projectId: number, webhookId: number): Promise<void>;\n    editWebhook(projectId: number, webhookId: number, request: PatchRequest[]): Promise<ResponseObject<WebhooksModel.Webhook>>;\n}\nexport declare namespace WebhooksModel {\n    interface Webhook {\n        id: number;\n        projectId: number;\n        name: string;\n        url: string;\n        events: Event[];\n        headers: Record<string, string>;\n        payload: Record<string, any>;\n        isActive: boolean;\n        batchingEnabled: boolean;\n        requestType: RequestType;\n        contentType: ContentType;\n        createdAt: string;\n        updatedAt: string;\n    }\n    interface AddWebhookRequest {\n        name: string;\n        url: string;\n        events: Event[];\n        requestType: RequestType;\n        isActive?: boolean;\n        batchingEnabled?: boolean;\n        contentType?: ContentType;\n        headers?: Record<string, string>;\n        payload?: Record<string, any>;\n    }\n    type ContentType = 'multipart/form-data' | 'application/json' | 'application/x-www-form-urlencoded';\n    type Event = 'file.added' | 'file.updated' | 'file.reverted' | 'file.deleted' | 'file.translated' | 'file.approved' | 'project.translated' | 'project.approved' | 'project.built' | 'translation.updated' | 'string.added' | 'string.updated' | 'string.deleted' | 'stringComment.created' | 'stringComment.updated' | 'stringComment.deleted' | 'stringComment.restored' | 'suggestion.added' | 'suggestion.updated' | 'suggestion.deleted' | 'suggestion.approved' | 'suggestion.disapproved' | 'task.added' | 'task.statusChanged' | 'task.deleted';\n    type RequestType = 'POST' | 'GET';\n}\n```\n\n##### workflows/index.d.ts\n\n```typescript\nimport { CrowdinApi, PaginationOptions, PatchRequest, ResponseList, ResponseObject } from '../core';\nimport { SourceStringsModel } from '../sourceStrings';\nexport declare class Workflows extends CrowdinApi {\n    listWorkflowSteps(projectId: number, options?: PaginationOptions): Promise<ResponseList<WorkflowModel.WorkflowStep>>;\n    listWorkflowSteps(projectId: number, limit?: number, offset?: number): Promise<ResponseList<WorkflowModel.WorkflowStep>>;\n    getWorkflowStep(projectId: number, stepId: number): Promise<ResponseObject<WorkflowModel.WorkflowStep>>;\n    listStringsOnTheWorkflowStep(projectId: number, stepId: number, options?: WorkflowModel.ListStringsOntheWorkflowStepOptions): Promise<ResponseList<SourceStringsModel.String>>;\n    listWorkflowTemplates(options?: WorkflowModel.ListWorkflowTemplatesOptions): Promise<ResponseList<WorkflowModel.Workflow>>;\n    listWorkflowTemplates(groupId?: number, limit?: number, offset?: number): Promise<ResponseList<WorkflowModel.Workflow>>;\n    getWorkflowTemplateInfo(templateId: number): Promise<ResponseObject<WorkflowModel.Workflow>>;\n    updateWorkflowStepStringStatus(projectId: number, stepId: number, languageId: string, request: PatchRequest[]): Promise<ResponseList<WorkflowModel.WorkflowStepStringStatus>>;\n    getWorkflowStepStringStatus(projectId: number, stepId: number, languageId: string, options?: PaginationOptions): Promise<ResponseList<WorkflowModel.WorkflowStepStringStatus>>;\n}\nexport declare namespace WorkflowModel {\n    interface WorkflowStep {\n        id: number;\n        title: string;\n        type: string;\n        languages: string[];\n        config: {\n            assignees: {\n                [language: string]: number[];\n            };\n        };\n    }\n    interface ListWorkflowTemplatesOptions extends PaginationOptions {\n        groupId?: number;\n    }\n    interface ListStringsOntheWorkflowStepOptions extends PaginationOptions {\n        languageIds?: string;\n        orderBy?: string;\n        status?: 'todo' | 'done' | 'pending' | 'incomplete' | 'need_review';\n    }\n    interface Workflow {\n        id: number;\n        title: string;\n        description: string;\n        groupId: number;\n        isDefault: boolean;\n        webUrl: string;\n        steps: {\n            id: number;\n            languages: string[];\n            assignees: number[];\n            vendorId: number;\n            config: {\n                minRelevant: number;\n                autoSubstitution: boolean;\n            };\n            mtId: number;\n        }[];\n    }\n    interface WorkflowStepStringStatus {\n        stringId: number;\n        languageId: string;\n        stepId: number;\n        status: string;\n        output: string;\n    }\n}\n```\n\n<!-- CROWDIN_API_CLIENT_TYPES_END -->\n\n### App Metadata Storage\n\n#### Overview\n\nApp Metadata Storage is a built-in key-value storage system provided by the Crowdin Apps SDK. It allows your app to persist data across sessions without needing external databases or storage services.\n\n**Available Methods:**\n- `crowdinApp.saveMetadata(key, data, crowdinId)` - Save or update metadata (recommended)\n- `crowdinApp.getMetadata(key)` - Retrieve metadata\n- `crowdinApp.deleteMetadata(key)` - Delete metadata\n\n**Alternative approach:**\n- `crowdinModule.metadataStore.saveMetadata(key, data, crowdinId)`\n- `crowdinModule.metadataStore.getMetadata(key)`\n- `crowdinModule.metadataStore.deleteMetadata(key)`\n\n#### Official Documentation\n\n**üìö Complete Documentation:** Refer to Crowdin Apps SDK documentation for metadata storage\n\n**‚ö†Ô∏è CRITICAL**: Metadata is stored at the organization level. Always include `organizationId` in your keys to properly scope data.\n\n#### Common Examples\n\n**Save Metadata:**\n```typescript\napp.post('/api/save-data', async (req: Request, res: Response) => {\n    try {\n        const jwt = req.query.jwt as string;\n        const { data } = req.body;\n\n        if (!jwt) {\n            return res.status(400).json({ success: false, error: 'JWT token is required' });\n        }\n        \n        if (!crowdinApp.establishCrowdinConnection) {\n            return res.status(500).json({ success: false, error: 'Crowdin connection method not available' });\n        }\n\n        const connection = await crowdinApp.establishCrowdinConnection(jwt, undefined);\n\n        if (!connection.client) {\n            return res.status(500).json({ success: false, error: 'Crowdin API client not available' });\n        }\n\n        const userId = connection.context.jwtPayload.context.user_id;\n        const organizationId = connection.context.jwtPayload.context.organization_id;\n        \n        // Create a namespaced key\n        const key = `org_${organizationId}_user_${userId}_preferences`;\n        \n        // Save data to metadata storage\n        await crowdinApp.saveMetadata(key, data, connection.context.crowdinId);\n        res.json({ success: true, message: 'Data saved successfully' });\n    } catch (error) {\n        console.error('Save error:', error);\n        res.status(500).json({ success: false, error: 'Failed to save data' });\n    }\n});\n```\n\n**Get Metadata:**\n```typescript\napp.get('/api/get-data', async (req: Request, res: Response) => {\n    try {\n        const jwt = req.query.jwt as string;\n        \n        if (!jwt) {\n            return res.status(400).json({ success: false, error: 'JWT token is required' });\n        }\n        \n        if (!crowdinApp.establishCrowdinConnection) {\n            return res.status(500).json({ success: false, error: 'Crowdin connection method not available' });\n        }\n\n        const connection = await crowdinApp.establishCrowdinConnection(jwt, undefined);\n\n        if (!connection.client) {\n            return res.status(500).json({ success: false, error: 'Crowdin API client not available' });\n        }\n\n        const userId = connection.context.jwtPayload.context.user_id;\n        const organizationId = connection.context.jwtPayload.context.organization_id;\n        \n        const key = `org_${organizationId}_user_${userId}_preferences`;\n        \n        // Retrieve data from metadata storage\n        const data = await crowdinApp.getMetadata(key);\n            \n        // Handle case when no data exists\n        if (!data) {\n            return res.json({ \n                success: true, \n                data: null, \n                message: 'No data found' \n            });\n        }\n        \n        res.json({ success: true, data });\n    } catch (error) {\n        console.error('Get error:', error);\n        res.status(500).json({ success: false, error: 'Failed to retrieve data' });\n    }\n});\n```\n\n**Delete Metadata:**\n```typescript\napp.delete('/api/delete-data', async (req: Request, res: Response) => {\n    try {\n        const jwt = req.query.jwt as string;\n        \n        if (!jwt) {\n            return res.status(400).json({ success: false, error: 'JWT token is required' });\n        }\n        \n        if (!crowdinApp.establishCrowdinConnection) {\n            return res.status(500).json({ success: false, error: 'Crowdin connection method not available' });\n        }\n\n        const connection = await crowdinApp.establishCrowdinConnection(jwt, undefined);\n\n        if (!connection.client) {\n            return res.status(500).json({ success: false, error: 'Crowdin API client not available' });\n        }\n\n        const userId = connection.context.jwtPayload.context.user_id;\n        const organizationId = connection.context.jwtPayload.context.organization_id;\n        \n        const key = `org_${organizationId}_user_${userId}_preferences`;\n        \n        // Delete data from metadata storage\n        await crowdinApp.deleteMetadata(key);\n        res.json({ success: true, message: 'Data deleted successfully' });\n    } catch (error) {\n        console.error('Delete error:', error);\n        res.status(500).json({ success: false, error: 'Failed to delete data' });\n    }\n});\n```\n\n**Get All Metadata:**\n```typescript\napp.get('/api/all-metadata', async (req: Request, res: Response) => {\n    try {\n        const jwt = req.query.jwt as string;\n        \n        if (!jwt) {\n            return res.status(400).json({ success: false, error: 'JWT token is required' });\n        }\n        \n        if (!crowdinApp.establishCrowdinConnection) {\n            return res.status(500).json({ success: false, error: 'Crowdin connection method not available' });\n        }\n\n        const connection = await crowdinApp.establishCrowdinConnection(jwt, undefined);\n\n        if (!connection.client) {\n            return res.status(500).json({ success: false, error: 'Crowdin API client not available' });\n        }\n\n        // Retrieve all metadata records from storage\n        const allMetadata = await crowdinApp.storage.getAllMetadata();\n        \n        // allMetadata structure:\n        // [\n        //   {\n        //     id: \"org_123_user_456_preferences\",  // key\n        //     data: \"{\"theme\":\"dark\",\"lang\":\"en\"}\", // JSON stringified value\n        //     crowdin_id: \"domain\"     // crowdin identifier (from connection.context.crowdinId during save)\n        //   },\n        //   ...\n        // ]\n        \n        // Parse and format data\n        const formattedData = allMetadata.map(record => ({\n            key: record.id,\n            value: JSON.parse(record.data || '{}'),\n            crowdinId: record.crowdin_id\n        }));\n        \n        res.json({ success: true, metadata: formattedData, count: formattedData.length });\n    } catch (error) {\n        console.error('Error retrieving all metadata:', error);\n        res.status(500).json({ success: false, error: 'Failed to retrieve metadata' });\n    }\n});\n```\n\n**Store Complex Objects:**\n```typescript\n// Save complex user preferences\nconst preferences = {\n    theme: 'dark',\n    language: 'en',\n    notifications: {\n        email: true,\n        push: false,\n        digest: 'weekly'\n    },\n    lastUpdated: new Date().toISOString(),\n    settings: {\n        autoSave: true,\n        confirmActions: true\n    }\n};\n\nconst key = `org_${organizationId}_user_${userId}_preferences`;\nawait crowdinApp.saveMetadata(key, preferences, connection.context.crowdinId);\n\n// Retrieve and update\nconst currentPrefs = await crowdinApp.getMetadata(key) || {};\nconst updatedPrefs = {\n    ...currentPrefs,\n    theme: 'light',\n    lastUpdated: new Date().toISOString()\n};\nawait crowdinApp.saveMetadata(key, updatedPrefs, connection.context.crowdinId);\n```\n\n#### Best Practices\n\n1. **Always use namespaced keys**\n   ```typescript\n   // ‚úÖ CORRECT - includes organization and entity identifiers\n   const key = `org_${organizationId}_user_${userId}_preferences`;\n   const key = `org_${organizationId}_project_${projectId}_cache`;\n   \n   // ‚ùå WRONG - no organization scope, may cause conflicts\n   const key = `user_preferences`;\n   const key = `${userId}_data`;\n   ```\n\n2. **Handle missing data gracefully**\n   ```typescript\n   // ‚úÖ CORRECT - provide defaults for missing data\n   const data = await crowdinApp.getMetadata(key) || { \n       theme: 'auto', \n       language: 'en' \n   };\n   \n   // ‚úÖ CORRECT - check for null/undefined\n   const data = await crowdinApp.getMetadata(key);\n   if (!data) {\n       return defaultSettings;\n   }\n   \n   // ‚ùå WRONG - may cause errors if data is null\n   const theme = data.theme; // Error if data is null\n   ```\n\n3. **Always use the correct identifier for the third parameter**\n   ```typescript\n   // ‚úÖ CORRECT - when connection object is available\n   await crowdinApp.saveMetadata(key, data, connection.context.crowdinId);\n   \n   // ‚úÖ CORRECT - when using webhookContext (no connection object, crowdinApp not available)\n   await crowdinModule.metadataStore.saveMetadata(key, data, `${webhookContext.domain || webhookContext.organizationId}`);\n   \n   // ‚ùå WRONG - don't use organizationId directly\n   await crowdinApp.saveMetadata(key, data, String(organizationId));\n   ```\n\n4. **Use descriptive key patterns**\n   ```typescript\n   // ‚úÖ CORRECT - clear, hierarchical structure\n   `org_${orgId}_user_${userId}_preferences`\n   `org_${orgId}_project_${projectId}_settings`\n   `org_${orgId}_cache_${cacheType}_${identifier}`\n   \n   // ‚ùå WRONG - unclear, hard to maintain\n   `data_${id}`\n   `temp_storage`\n   ```\n\n5. **Handle errors properly**\n   ```typescript\n   // ‚úÖ CORRECT - comprehensive error handling\n   try {\n       await crowdinApp.saveMetadata(key, data, connection.context.crowdinId);\n       return { success: true };\n   } catch (error: any) {\n       console.error('Metadata save failed:', error);\n       return { \n           success: false, \n           error: 'Failed to save data'\n       };\n   }\n   ```\n\n7. **Store only JSON-serializable data**\n   ```typescript\n   // ‚úÖ CORRECT - simple JSON-serializable objects\n   const data = {\n       name: 'John',\n       age: 30,\n       preferences: ['option1', 'option2'],\n       metadata: { key: 'value' }\n   };\n   \n   // ‚ùå WRONG - functions, dates, circular references\n   const data = {\n       name: 'John',\n       callback: () => {},           // Functions don't serialize\n       created: new Date(),           // Dates become strings\n       circular: data                 // Circular reference\n   };\n   \n   // ‚úÖ CORRECT - convert dates to ISO strings\n   const data = {\n       name: 'John',\n       created: new Date().toISOString()\n   };\n   ```\n\n8. **NEVER use KVStore for configurations - use metadata storage instead**\n   ```typescript\n   // ‚úÖ CORRECT - use metadata storage for ALL configuration storage\n   const config = {\n       apiKey: userApiKey,\n       apiEndpoint: 'https://api.example.com',\n       languageMapping: { 'en': 'en-US' }\n   };\n   await crowdinApp.saveMetadata(\n       `config_org_${organizationId}`, \n       config, \n       connection.context.crowdinId\n   );\n   \n   // ‚úÖ CORRECT - read configuration from metadata storage\n   const config = await crowdinApp.getMetadata(`config_org_${organizationId}`) || {};\n   \n   // ‚ùå WRONG - using KVStore for configuration storage\n   const config = {\n       apiKey: userApiKey,\n       apiEndpoint: 'https://api.example.com',\n       languageMapping: { 'en': 'en-US' }\n   };\n   await env.KVStore.put(\n       `config_org_${organizationId}`, \n       JSON.stringify(config)\n   );\n   \n   // ‚ùå WRONG - reading configuration from KVStore\n   const configData = await env.KVStore.get(`config_org_${organizationId}`);\n   const config = JSON.parse(configData || '{}');\n   ```\n\n9. **Use crowdinApp.saveMetadata or crowdinModule.metadataStore.saveMetadata - both implement upsert**\n   ```typescript\n   // ‚úÖ CORRECT - implements upsert (insert or update)\n   await crowdinApp.saveMetadata(\n       key, \n       data, \n       connection.context.crowdinId\n   );\n   \n   // ‚úÖ CORRECT - also implements upsert (insert or update)\n   await crowdinModule.metadataStore.saveMetadata(\n       key, \n       data, \n       connection.context.crowdinId\n   );\n   \n   // ‚ùå WRONG - only insert, NOT upsert (will fail if key already exists)\n   await crowdinApp.storage.saveMetadata(\n       key, \n       data, \n       connection.context.crowdinId\n   );\n   ```\n\n### Cron Scheduling\n\n#### Overview\n\nCron Scheduling allows your app to execute background tasks at specified time intervals.\n\n#### Official Documentation\n\n**üìö Complete Documentation:** Refer to Crowdin Apps SDK documentation for cron scheduling\n\n**‚ö†Ô∏è CRITICAL**: Only specific cron intervals are supported. Using unsupported intervals will result in an error.\n\n#### Supported Intervals\n\nThe following cron expressions are supported:\n\n| Cron Expression | Description | Frequency |\n|----------------|-------------|-----------|\n| `0 * * * *` | Every hour | Runs at minute 0 of every hour |\n| `0 */3 * * *` | Every 3 hours | Runs at minute 0 every 3 hours |\n| `0 */6 * * *` | Every 6 hours | Runs at minute 0 every 6 hours |\n| `0 */12 * * *` | Every 12 hours | Runs at minute 0 every 12 hours |\n| `0 0 * * *` | Daily | Runs at midnight (00:00) every day |\n| `0 0 * * SUN` | Weekly | Runs at midnight (00:00) every Sunday |\n| `0 0 1 * *` | Monthly | Runs at midnight (00:00) on the 1st of each month |\n\n#### Common Examples\n\n**Simple Hourly Task:**\n```typescript\n// In worker/app.ts, after initializing crowdinApp\nconst crowdinApp = crowdinModule.addCrowdinEndpoints(app, configuration) as CrowdinAppUtilities;\n\n// Register cron job - runs every hour\ncrowdinApp.cron.schedule('0 * * * *', async () => {\n    try {\n        console.log('Hourly task started at', new Date().toISOString());\n        \n        // Perform your scheduled task\n        // Example: Check status, update cache, etc.\n        \n        console.log('Task completed');\n    } catch (error) {\n        console.error('Cron job error:', error);\n    }\n});\n```\n\n**Multiple Tasks for Same Schedule:**\n```typescript\n// In worker/app.ts, after initializing crowdinApp\nconst crowdinApp = crowdinModule.addCrowdinEndpoints(app, configuration) as CrowdinAppUtilities;\n\n// Both tasks will run daily at midnight\ncrowdinApp.cron.schedule('0 0 * * *', async () => {\n    try {\n        console.log('Daily cleanup started');\n        // Cleanup old data\n    } catch (error) {\n        console.error('Cleanup error:', error);\n    }\n});\n\ncrowdinApp.cron.schedule('0 0 * * *', async () => {\n    try {\n        console.log('Daily report started');\n        // Generate reports\n    } catch (error) {\n        console.error('Report error:', error);\n    }\n});\n```\n\n**Using Crowdin API Client in Cron Jobs:**\n```typescript\n// In worker/app.ts, after initializing crowdinApp\nconst crowdinApp = crowdinModule.addCrowdinEndpoints(app, configuration) as CrowdinAppUtilities;\n\n// Register cron job that processes data for multiple organizations\ncrowdinApp.cron.schedule('0 0 * * *', async () => {\n    try {\n        console.log('Daily sync started');\n        \n        // Get all metadata records\n        const allMetadata = await crowdinApp.storage.getAllMetadata();\n        \n        if (!allMetadata || allMetadata.length === 0) {\n            console.log('No metadata found, skipping sync');\n            return;\n        }\n        \n        // Filter metadata by pattern using regex (e.g., find all organization configs)\n        const configPattern = /^org_(\\d+)_config$/;\n        const orgConfigs = allMetadata.filter(record => \n            configPattern.test(record.id)\n        );\n        \n        console.log(`Found ${orgConfigs.length} organization configs to process`);\n        \n        // Process each organization separately\n        for (const configRecord of orgConfigs) {\n            try {\n                const match = configRecord.id.match(configPattern);\n                const organizationId = match?.[1];\n                const crowdinId = configRecord.crowdin_id; // domain or organizationId\n                const configData = JSON.parse(configRecord.data || '{}');\n                \n                console.log(`Processing organization ${organizationId}`);\n                \n                // Create individual Crowdin API client for this organization\n                const encryptedData = crowdinApp.encryptCrowdinConnection({\n                    crowdinId,\n                    extra: {}, // Always pass empty object\n                });\n                \n                const { client } = await crowdinApp.dencryptCrowdinConnection(encryptedData, true);\n                \n                // Use client to make API calls for this specific organization\n                const projects = await client.projectsGroupsApi.withFetchAll().listProjects();\n                console.log(`Organization ${organizationId}: Found ${projects.data.length} projects`);\n                \n                // Process organization-specific configuration\n                if (configData.autoSync) {\n                    console.log(`Organization ${organizationId}: Auto-sync enabled, processing...`);\n                    // Perform sync operations\n                }\n                \n            } catch (error) {\n                console.error(`Error processing organization ${organizationId}:`, error);\n                // Continue with next organization\n            }\n        }\n        \n        console.log('Daily sync completed');\n    } catch (error) {\n        console.error('Cron job error:', error);\n    }\n});\n```\n\n#### Best Practices\n\n1. **Use appropriate intervals for your task**\n   ```typescript\n   // ‚úÖ CORRECT - frequent checks for time-sensitive tasks\n   crowdinApp.cron.schedule('0 * * * *', async () => {\n       // Hourly notification checks\n   });\n   \n   // ‚úÖ CORRECT - less frequent for resource-intensive tasks\n   crowdinApp.cron.schedule('0 0 * * *', async () => {\n       // Daily cleanup or report generation\n   });\n   \n   // ‚ùå WRONG - using unsupported interval\n   crowdinApp.cron.schedule('*/5 * * * *', async () => {\n       // Every 5 minutes - NOT SUPPORTED\n   });\n   ```\n\n2. **Handle errors gracefully**\n   ```typescript\n   // ‚úÖ CORRECT - catch and log errors\n   crowdinApp.cron.schedule('0 * * * *', async () => {\n       try {\n           await performTask();\n       } catch (error) {\n           console.error('Cron job failed:', error);\n           // Log error but don't throw - let job complete\n       }\n   });\n   \n   // ‚ùå WRONG - unhandled errors\n   crowdinApp.cron.schedule('0 * * * *', async () => {\n       await performTask(); // May crash if it throws\n   });\n   ```\n\n3. **Keep cron jobs lightweight**\n   ```typescript\n   // ‚úÖ CORRECT - efficient processing\n   crowdinApp.cron.schedule('0 0 * * *', async () => {\n       const startTime = Date.now();\n       console.log('Task started');\n       \n       // Perform lightweight operations\n       await quickCleanup();\n       \n       console.log(`Completed in ${Date.now() - startTime}ms`);\n   });\n   \n   // ‚ùå WRONG - heavy processing that may timeout\n   crowdinApp.cron.schedule('0 * * * *', async () => {\n       // Processing millions of records - may timeout\n       const allData = await fetchAllData();\n       await processAll(allData);\n   });\n   ```\n\n4. **Always await async operations**\n   ```typescript\n   // ‚úÖ CORRECT - await all async operations\n   crowdinApp.cron.schedule('0 * * * *', async () => {\n       await saveData();\n       await processQueue();\n       console.log('All tasks completed');\n   });\n   \n   // ‚úÖ CORRECT - setTimeout with proper promise wrapper\n   crowdinApp.cron.schedule('0 * * * *', async () => {\n       await new Promise((resolve) => {\n           setTimeout(async () => {\n               await processData();\n               resolve();\n           }, 1000);\n       });\n   });\n   \n   // ‚ùå WRONG - promise without await (will not complete)\n   crowdinApp.cron.schedule('0 * * * *', async () => {\n       saveData(); // This will NOT complete before cron job ends\n       console.log('Done'); // Logs immediately, but saveData is not finished\n   });\n   \n   // ‚ùå WRONG - setTimeout without proper promise wrapper\n   crowdinApp.cron.schedule('0 * * * *', async () => {\n       setTimeout(async () => {\n           await processData(); // This will NOT execute\n       }, 1000);\n   });\n   ```\n\n5. **Log execution for debugging**\n   ```typescript\n   // ‚úÖ CORRECT - comprehensive logging\n   crowdinApp.cron.schedule('0 */6 * * *', async () => {\n       const startTime = Date.now();\n       console.log(`Cron job started at ${new Date().toISOString()}`);\n       \n       try {\n           await performTask();\n           console.log(`Completed in ${Date.now() - startTime}ms`);\n       } catch (error) {\n           console.error(`Failed after ${Date.now() - startTime}ms:`, error);\n       }\n   });\n   ```\n\n### Webhooks\n\n#### Overview\n\nWebhooks allow your app to subscribe to events that occur in Crowdin projects or organizations. When a subscribed event happens, Crowdin automatically sends the event data to your app's callback function.\n\n#### Official Documentation\n\n**üìö Complete Documentation:** [Crowdin Webhooks](https://crowdin.github.io/app-project-module/tools/webhook/)\n\n**üìö Available Events:** [Webhook Events List](https://support.crowdin.com/developer/webhooks/)\n\n**‚ö†Ô∏è CRITICAL**: Only use event names from the official events list. Invalid event names will be ignored.\n\n#### Configuration\n\nConfigure webhooks in your app configuration in `worker/app.ts`:\n\n```typescript\nconst configuration: ClientConfig = {\n    // ... other configuration ...\n    \n    // Webhook subscriptions\n    webhooks: [\n        {\n            // List of events to subscribe to\n            events: ['file.added', 'file.updated', 'file.deleted'],\n            \n            // Callback function that handles events\n            callback({ client, events, webhookContext }) {\n                console.log('Received events:', events);\n                console.log('Organization:', webhookContext.organizationId);\n                console.log('User:', webhookContext.userId);\n                \n                // Process events here\n                events.forEach(event => {\n                    console.log('Event:', event.event, 'Project:', event.file.project.id);\n                });\n            },\n            \n            deferResponse: true\n        },\n        {\n            // You can have multiple webhook subscriptions\n            events: ['suggestion.updated', 'string.added'],\n            callback({ client, events, webhookContext }) {\n                // Handle translation events\n            },\n            \n            deferResponse: true\n        }\n    ]\n};\n```\n\n#### Common Examples\n\n**File Events:**\n```typescript\nwebhooks: [\n    {\n        events: ['file.added', 'file.updated', 'file.deleted', 'file.reverted'],\n        async callback({ client, events, webhookContext }) {\n            for (const event of events) {\n                console.log(`File ${event.event} in project ${event.file.project.id}`);\n                console.log('File details:', event.file);\n                \n                // Example: Get project details when file is added\n                if (event.event === 'file.added') {\n                    const project = await client.projectsGroupsApi.getProject(event.file.project.id);\n                    console.log('Project name:', project.data.name);\n                }\n            }\n        },\n        deferResponse: true\n    }\n]\n```\n\n#### Callback Parameters\n\nThe callback function receives an object with three properties:\n\n```typescript\ninterface WebhookCallback {\n    /**\n     * Crowdin API client - use to make API calls\n     * Same client as connection.client in endpoints\n     */\n    client: CrowdinApi;\n    \n    /**\n     * Array of webhook event objects\n     * Multiple events may be batched together\n     */\n    events: WebhookEvent[];\n    \n    /**\n     * Context information about the webhook\n     */\n    webhookContext: {\n        /** Crowdin domain (e.g., \"crowdin.com\") */\n        domain: string;\n        \n        /** Organization ID where event occurred */\n        organizationId: number;\n        \n        /** User ID who installed the application */\n        userId: number;\n        \n        /** Agent ID (if authenticationType is \"crowdin_agent\") */\n        agentId?: number;\n    };\n}\n```\n\n#### Common Event Types\n\n**Project Events:**\n- `project.created` - New project added\n- `project.deleted` - Project deleted\n- `project.translated` - Project fully translated\n- `project.approved` - Project reviewed\n- `project.built` - Project built\n\n**Group Events:**\n- `group.created` - New group added\n- `group.deleted` - Group deleted\n\n**File Events:**\n- `file.added` - New file added to project\n- `file.updated` - File updated\n- `file.deleted` - File deleted from project\n- `file.reverted` - File reverted to previous version\n- `file.translated` - File fully translated\n- `file.approved` - File reviewed\n\n**String Events:**\n- `string.added` - New source string added\n- `string.updated` - Source string updated\n- `string.deleted` - Source string deleted\n\n**Translation Events:**\n- `suggestion.added` - String translation added\n- `suggestion.updated` - String translation updated\n- `suggestion.deleted` - String translation deleted\n- `suggestion.approved` - String translation approved\n- `suggestion.disapproved` - String translation disapproved\n\n**Comment Events:**\n- `stringComment.created` - String comment added\n- `stringComment.updated` - String comment updated\n- `stringComment.deleted` - String comment deleted\n- `stringComment.restored` - String comment restored\n\n**Task Events:**\n- `task.added` - New task added\n- `task.statusChanged` - Task status changed\n- `task.updated` - Task updated\n- `task.deleted` - Task deleted\n\n#### Best Practices\n\n1. **Always set deferResponse to true**\n   ```typescript\n   // ‚úÖ CORRECT - deferResponse is set to true\n   webhooks: [\n       {\n           events: ['file.added'],\n           callback({ client, events, webhookContext }) {\n               console.log('Processing events');\n           },\n           deferResponse: true  // REQUIRED!\n       }\n   ]\n   \n   // ‚ùå WRONG - missing deferResponse\n   webhooks: [\n       {\n           events: ['file.added'],\n           callback({ client, events, webhookContext }) {\n               console.log('Processing events');\n           }\n           // Missing deferResponse: true - this will cause issues!\n       }\n   ]\n   ```\n\n2. **Handle multiple events in batch**\n   ```typescript\n   // ‚úÖ CORRECT - process all events\n   callback({ client, events, webhookContext }) {\n       events.forEach(event => {\n           console.log('Processing event:', event.event);\n       });\n   }\n   \n   // ‚ùå WRONG - only processes first event\n   callback({ client, events, webhookContext }) {\n       const event = events[0];\n       console.log('Processing event:', event.event);\n   }\n   ```\n\n3. **Handle errors gracefully**\n   ```typescript\n   // ‚úÖ CORRECT - catches and logs errors\n   async callback({ client, events, webhookContext }) {\n       for (const event of events) {\n           try {\n               await processEvent(event);\n           } catch (error) {\n               console.error('Failed to process event:', event.event, error);\n               // Continue processing other events\n           }\n       }\n   }\n   ```\n\n4. **Check event type before processing**\n   ```typescript\n   // ‚úÖ CORRECT - checks event type\n   callback({ client, events, webhookContext }) {\n       events.forEach(event => {\n           if (event.event === 'file.added') {\n               console.log('New file:', event.file?.name);\n           } else if (event.event === 'file.updated') {\n               console.log('Updated file:', event.file?.name);\n           }\n       });\n   }\n   ```\n\n5. **Use webhookContext for scoping**\n   ```typescript\n   // ‚úÖ CORRECT - uses context for organization-specific logic\n   async callback({ client, events, webhookContext }) {\n       const orgId = webhookContext.organizationId;\n       const userId = webhookContext.userId;\n       \n       // Store event in metadata\n       const key = `org_${orgId}_events_${Date.now()}`;\n       // await crowdinModule.metadataStore.saveMetadata(key, events, `${webhookContext.domain || webhookContext.organizationId}`);\n   }\n   ```\n\n6. **Don't perform long-running operations**\n   ```typescript\n   // ‚úÖ CORRECT - quick processing, delegate heavy work\n   async callback({ client, events, webhookContext }) {\n       // Quick logging\n       console.log('Received', events.length, 'events');\n       \n       // Store for later processing\n       const key = `org_${webhookContext.organizationId}_queue`;\n       // await crowdinModule.metadataStore.saveMetadata(key, events, `${webhookContext.domain || webhookContext.organizationId}`);\n   }\n   \n   // ‚ö†Ô∏è PROBLEMATIC - long-running operation blocks webhook\n   async callback({ client, events, webhookContext }) {\n       // This might timeout\n       for (const event of events) {\n           await processLargeFile(event.file?.id);\n           await sendMultipleNotifications(event);\n           await updateExternalDatabase(event);\n       }\n   }\n   ```\n\n#### Event Object Structure\n\nEach event type has its own interface with specific fields. Use these interfaces to understand which data is available for each event:\n\n```typescript\n// ============================================================================\n// SHARED MODELS - Reusable data structures\n// ============================================================================\n\ninterface ProjectModel {\n    id: number;\n    name: string;\n    identifier: string;\n    sourceLanguageId: string;\n    targetLanguageIds: string[];\n}\n\ninterface UserModel {\n    id: number;\n    username: string;\n}\n\ninterface LanguageModel {\n    id: string;\n    name: string;\n}\n\ninterface FileModelBase {\n    id: number;\n    name: string;\n    title: string;\n    type: string;\n    path: string;\n    branchId: number | null;\n    directoryId: number | null;\n}\n\ninterface FileModel extends FileModelBase {\n    project: ProjectModel;\n}\n\ninterface GroupModel {\n    id: number;\n    name: string;\n    parentId: number | null;\n}\n\ninterface StringModelBase {\n    id: number;\n    identifier: string;\n    text: string;\n    context: string | null;\n    isHidden: boolean;\n}\n\ninterface StringModel extends StringModelBase {\n    file: FileModelBase;\n    project: ProjectModel;\n}\n\ninterface TranslationModelBase {\n    id: number;\n    text: string;\n}\n\ninterface TranslationModel extends TranslationModelBase {\n    user: UserModel;\n    targetLanguage: LanguageModel;\n    string: StringModel;\n}\n\ninterface TaskModel {\n    id: number;\n    type: 0 | 1; // 0 - Translate, 1 - Proofread\n    title: string;\n    status: 'todo' | 'in_progress' | 'done' | 'closed' | 'pending' | 'review';\n    sourceLanguage: LanguageModel;\n    targetLanguage: LanguageModel;\n    project: ProjectModel;\n    taskCreator: UserModel;\n}\n\ninterface CommentModelBase {\n    id: number;\n    text: string;\n    type: 'issue' | 'comment';\n    issueType: 'general_question' | 'translation_mistake' |  'context_request' |  'source_mistake';\n    issueStatus: 'resolved' | 'unresolved';\n}\n\ninterface CommentModel extends CommentModelBase {\n    string: StringModel;\n    targetLanguage: LanguageModel;\n    user: UserModel;\n    commentResolver: UserModel | null;\n}\n\ninterface BuildModel {\n    id: number;\n    downloadUrl: string;\n    project: ProjectModel;\n}\n\n// ============================================================================\n// BASE EVENT INTERFACES\n// ============================================================================\n\ninterface BaseEventWithUser {\n    user: UserModel;\n}\n\ninterface BaseProjectEvent {\n    project: ProjectModel;\n}\n\ninterface BaseGroupEvent {\n    group: GroupModel;\n}\n\ninterface BaseFileEvent {\n    file: FileModel;\n}\n\ninterface BaseStringEvent {\n    string: StringModel;\n}\n\ninterface BaseTranslationEvent {\n    translation: TranslationModel;\n}\n\ninterface BaseTaskEvent {\n    task: TaskModel;\n}\n\ninterface BaseCommentEvent {\n    comment: CommentModel;\n}\n\n// ============================================================================\n// PROJECT EVENTS\n// ============================================================================\n\ninterface ProjectCreatedEvent extends BaseProjectEvent, BaseEventWithUser {\n    event: 'project.created';\n}\n\ninterface ProjectDeletedEvent extends BaseProjectEvent, BaseEventWithUser {\n    event: 'project.deleted';\n}\n\ninterface ProjectTranslatedEvent extends BaseProjectEvent {\n    event: 'project.translated';\n    targetLanguage: LanguageModel;\n}\n\ninterface ProjectApprovedEvent extends BaseProjectEvent {\n    event: 'project.approved';\n    targetLanguage: LanguageModel;\n}\n\ninterface ProjectBuiltEvent {\n    event: 'project.built';\n    build: BuildModel;\n}\n\n// ============================================================================\n// GROUP EVENTS\n// ============================================================================\n\ninterface GroupCreatedEvent extends BaseGroupEvent, BaseEventWithUser {\n    event: 'group.created';\n}\n\ninterface GroupDeletedEvent extends BaseGroupEvent, BaseEventWithUser {\n    event: 'group.deleted';\n}\n\n// ============================================================================\n// FILE EVENTS\n// ============================================================================\n\ninterface FileAddedEvent extends BaseFileEvent, BaseEventWithUser {\n    event: 'file.added';\n}\n\ninterface FileUpdatedEvent extends BaseFileEvent, BaseEventWithUser {\n    event: 'file.updated';\n}\n\ninterface FileDeletedEvent extends BaseFileEvent, BaseEventWithUser {\n    event: 'file.deleted';\n}\n\ninterface FileRevertedEvent extends BaseFileEvent, BaseEventWithUser {\n    event: 'file.reverted';\n}\n\ninterface FileTranslatedEvent extends BaseFileEvent {\n    event: 'file.translated';\n    targetLanguage: LanguageModel;\n}\n\ninterface FileApprovedEvent extends BaseFileEvent {\n    event: 'file.approved';\n    targetLanguage: LanguageModel;\n}\n\n// ============================================================================\n// STRING EVENTS\n// ============================================================================\n\ninterface StringAddedEvent extends BaseStringEvent, BaseEventWithUser {\n    event: 'string.added';\n}\n\ninterface StringUpdatedEvent extends BaseStringEvent, BaseEventWithUser {\n    event: 'string.updated';\n}\n\ninterface StringDeletedEvent extends BaseStringEvent, BaseEventWithUser {\n    event: 'string.deleted';\n}\n\n// ============================================================================\n// TRANSLATION/SUGGESTION EVENTS\n// ============================================================================\n\ninterface SuggestionAddedEvent extends BaseTranslationEvent {\n    event: 'suggestion.added';\n}\n\ninterface SuggestionUpdatedEvent extends BaseTranslationEvent {\n    event: 'suggestion.updated';\n}\n\ninterface SuggestionDeletedEvent extends BaseTranslationEvent {\n    event: 'suggestion.deleted';\n}\n\ninterface SuggestionApprovedEvent extends BaseTranslationEvent {\n    event: 'suggestion.approved';\n}\n\ninterface SuggestionDisapprovedEvent extends BaseTranslationEvent {\n    event: 'suggestion.disapproved';\n}\n\ninterface TranslationUpdatedEvent {\n    event: 'translation.updated';\n    newTranslation: TranslationModel;\n}\n\n// ============================================================================\n// COMMENT EVENTS\n// ============================================================================\n\ninterface StringCommentCreatedEvent extends BaseCommentEvent {\n    event: 'stringComment.created';\n}\n\ninterface StringCommentUpdatedEvent extends BaseCommentEvent {\n    event: 'stringComment.updated';\n}\n\ninterface StringCommentDeletedEvent extends BaseCommentEvent {\n    event: 'stringComment.deleted';\n}\n\ninterface StringCommentRestoredEvent extends BaseCommentEvent {\n    event: 'stringComment.restored';\n}\n\n// ============================================================================\n// TASK EVENTS\n// ============================================================================\n\ninterface TaskAddedEvent extends BaseTaskEvent {\n    event: 'task.added';\n}\n\ninterface TaskStatusChangedEvent extends BaseTaskEvent {\n    event: 'task.statusChanged';\n}\n\ninterface TaskUpdatedEvent extends BaseTaskEvent {\n    event: 'task.updated';\n}\n\ninterface TaskDeletedEvent extends BaseTaskEvent {\n    event: 'task.deleted';\n}\n\n// ============================================================================\n// UNION TYPE - All possible webhook events\n// ============================================================================\n\ntype WebhookEvent = \n    // Project events\n    | ProjectCreatedEvent\n    | ProjectDeletedEvent\n    | ProjectTranslatedEvent\n    | ProjectApprovedEvent\n    | ProjectBuiltEvent\n    // Group events\n    | GroupCreatedEvent\n    | GroupDeletedEvent\n    // File events\n    | FileAddedEvent\n    | FileUpdatedEvent\n    | FileDeletedEvent\n    | FileRevertedEvent\n    | FileTranslatedEvent\n    | FileApprovedEvent\n    // String events\n    | StringAddedEvent\n    | StringUpdatedEvent\n    | StringDeletedEvent\n    // Translation/Suggestion events\n    | SuggestionAddedEvent\n    | SuggestionUpdatedEvent\n    | SuggestionDeletedEvent\n    | SuggestionApprovedEvent\n    | SuggestionDisapprovedEvent\n    | TranslationUpdatedEvent\n    // Comment events\n    | StringCommentCreatedEvent\n    | StringCommentUpdatedEvent\n    | StringCommentDeletedEvent\n    | StringCommentRestoredEvent\n    // Task events\n    | TaskAddedEvent\n    | TaskStatusChangedEvent\n    | TaskUpdatedEvent\n    | TaskDeletedEvent;\n```\n\n## Frontend Development\n\n### Crowdin Apps JS API\n\n#### Official Documentation\n\nThe `AP` object provides the Crowdin Apps JS API for interacting with the Crowdin application context.\n\n**üìö Complete API Reference:** https://support.crowdin.com/developer/crowdin-apps-js/\n\n**‚ö†Ô∏è CRITICAL**: Only use methods and types from the Crowdin Apps JS API definitions below.\n\n**Do NOT invent methods or properties that are not listed here.**\n\n#### Common Examples\n\n**Get Context (Promise-based):**\n```typescript\n// Promisified helper\nconst getContext = (): Promise<any> => {\n    return new Promise(resolve => window.AP.getContext(resolve));\n};\n\n// Usage\nconst context = await getContext();\nconsole.log('Project ID:', context.project_id);\n```\n\n**Get JWT Token (Promise-based):**\n```typescript\n// Promisified helper\nconst getJwtToken = (): Promise<string> => {\n    return new Promise(resolve => window.AP.getJwtToken(resolve));\n};\n\n// Usage with fetch\nconst token = await getJwtToken();\nconst response = await fetch(`/api/endpoint?jwt=${token}`);\nconst data = await response.json();\n```\n\n#### Best Practices\n\n1. **Handle errors gracefully**\n   ```typescript\n   try {\n       const context = await getContext();\n       if (!context.organization_id) {\n           throw new Error('Organization ID not found');\n       }\n       // Your code\n   } catch (error) {\n       console.error('Failed to get context:', error);\n   }\n   ```\n\n#### Complete Type Definitions\n\n##### Global AP Object Structure\n\n```typescript\ndeclare namespace AP {\n    // Global Actions\n    function getContext(callback: (context: Context) => void): void;\n    function getJwtToken(callback: (token: string) => void): void;\n    function getTheme(): 'light' | 'dark';\n    function redirect(path: string): void;\n}\n```\n\n##### Type Definitions\n\n```typescript\n// Context Information\ninterface Context {\n    project_id: number;\n    organization_id: number;\n}\n```\n\n## Development Workflow\n\n### 1. Configure Your App Identity\n\n**‚ö†Ô∏è Important**: You MUST update the configuration in `worker/app.ts` before deployment:\n\n```typescript\nconst configuration: ClientConfig = {\n    name: \"Your App Name\",           // Change this to your app's display name\n    identifier: \"your-app-id\",       // Change to unique identifier (lowercase, hyphens)\n    description: \"Your app description\", // Change to describe your app's purpose\n    // ... rest of configuration\n}\n```\n\n**Note**: The `identifier` must be unique across all Crowdin apps. Use format like: `company-ai-provider`\n\n### 2. Key Files to Modify\n\n- `worker/app.ts` - Add new API endpoints here\n- `src/pages/HomePage.tsx` - Main page component (customize for your app logic)\n- `src/components/app-sidebar.tsx` - Sidebar navigation (customize menu items)\n- `src/components/layout/AppLayout.tsx` - Application layout (customize layout structure)\n- `src/index.css` - Customize global styles and Tailwind theme\n- `tailwind.config.js` - Add custom colors and extend theme"
    }
  },
  {
    "name": "crowdin-organization-menu",
    "language": "typescript",
    "frameworks": [
      "@dnd-kit",
      "@hookform/resolvers",
      "autoprefixer",
      "class-variance-authority",
      "cloudflare",
      "clsx",
      "cmdk",
      "date-fns",
      "express",
      "framer-motion",
      "immer",
      "input-otp",
      "next",
      "postcss",
      "react",
      "recharts",
      "sonner",
      "tailwind",
      "tw-animate-css",
      "typescript",
      "vaul",
      "vite",
      "wrangler",
      "zod",
      "zustand"
    ],
    "description": {
      "selection": "# Template Selection\n\nCrowdin app with Organization Menu module.\n\nUse when:\n- Building organization-wide tools and utilities\n- Creating organization management extensions\n- Developing organization-level analytics and reporting tools\n- Building organization-wide integrations with external APIs\n- Creating custom workflows for groups and projects management\n- Managing organization members and permissions\n\nAvoid when:\n- Integrating custom AI providers (use AI Provider instead)\n- Building machine translation integrations (use Custom MT instead)\n- Building editor extensions (use Editor Right Panel instead)\n- Transforming files during import/export (use File Processing instead)\n- Building user profile tools (use Profile Resources Menu instead)\n- Building project-specific tools (use Project Tools instead)\n\nBuilt with:\n- Crowdin Apps JS API\n- Crowdin Apps SDK (@crowdin/app-project-module)\n- React\n- ShadCN UI\n- Tailwind\n- Lucide Icons\n- ESLint\n- Vite\n- TypeScript\n- Express.js\n- Cloudflare Workers",
      "usage": "# Usage\n\n## Overview\nCrowdin app with Organization Menu module for organization-wide functionality.\n- Backend: TypeScript with Express.js and Crowdin Apps SDK\n- Frontend: React + TypeScript + ShadCN UI + Crowdin Apps JS API\n\n## Tech Stack\n- Crowdin Apps JS API\n- Crowdin Apps SDK (@crowdin/app-project-module)\n- React\n- ShadCN UI\n- Tailwind\n- Lucide Icons\n- ESLint\n- Vite\n- TypeScript\n- Express.js\n- Cloudflare Workers\n\n## Development Restrictions\n- **Tailwind Colors**: Hardcode custom colors in `tailwind.config.js`, NOT in `index.css`\n- **Components**: Use existing ShadCN components instead of writing custom ones\n- **Icons**: Import from `lucide-react` directly\n- **Error Handling**: ErrorBoundary components are pre-implemented\n- **Authentication**: Always use JWT tokens from Crowdin for API requests\n- **Organization Menu Configuration**: Don't modify the organizationMenu configuration structure\n- **Scopes**: Ensure your app has appropriate API scopes\n- **Storage Keys**: Always include organizationId in metadata keys to isolate data per organization\n\n## Styling\n- Responsive, accessible\n- Prefer ShadCN components; Tailwind for layout/spacing/typography\n- Use framer-motion sparingly for micro-interactions\n\n## Project Structure\n\n### Backend Structure\n- `worker/app.ts` - Express app factory with Organization Menu configuration\n- `worker/index.ts` - Cloudflare Worker entry point (HTTP handler, cron scheduler, middleware)\n- `worker/types/` - Backend TypeScript type definitions\n  - `cloudflare-env.d.ts` - Cloudflare environment types (KV storage, secrets)\n\n### Frontend Structure\n- `index.html` - HTML entry point with Crowdin Apps JS API script\n- `src/main.tsx` - React entry point with ErrorBoundary wrapper\n- `src/index.css` - Global styles and Tailwind CSS customizations\n- `src/components/` - React components\n  - `app-sidebar.tsx` - Application sidebar navigation\n  - `ErrorBoundary.tsx` - React error boundary with backend error reporting\n  - `ErrorFallback.tsx` - Fallback UI component for error states\n  - `RouteErrorBoundary.tsx` - Error boundary for routing errors\n  - `layout/` - Layout components\n    - `AppLayout.tsx` - Main application layout wrapper\n  - `ui/` - ShadCN UI components (button, card, sonner, etc.)\n- `src/pages/` - Page components\n  - `HomePage.tsx` - Home page component (main entry point for your app logic)\n- `src/hooks/` - Custom React hooks\n  - `use-mobile.tsx` - Hook for detecting mobile breakpoints\n- `src/lib/` - Utility modules\n  - `utils.ts` - Tailwind utility functions (`cn` for class merging)\n  - `errorReporter.ts` - Client-side error reporting to backend\n  - `apiClient.ts` - Generic API call wrapper with JWT token handling\n- `src/types/` - TypeScript type definitions\n  - `global.d.ts` - Global type declarations\n  - `vite-env.d.ts` - Vite environment types\n\n## Backend Development\n\n### App Configuration\n\nConfigure your app identity in `worker/app.ts`:\n\n```typescript\nconst configuration: ClientConfig = {\n    name: \"Your App Name\",                    // Display name shown in Crowdin UI\n    identifier: \"your-unique-app-identifier\", // Unique ID (lowercase, hyphens)\n    description: \"Your app description\",      // Brief description of functionality\n    // ... rest of configuration\n}\n```\n\n**Guidelines:**\n- **identifier**: Must be unique across all Crowdin apps. Format: `company-organization-menu`\n- **name**: User-friendly display name (e.g., \"Organization Manager\")\n- **description**: Brief explanation of what your app does\n\n#### Required Scopes\n\nAdd scopes to configuration in `worker/app.ts` based on your app's functionality.\n\n**‚ö†Ô∏è IMPORTANT**: Only use scopes from the list below. Do not invent or use non-existent scopes!\n\n```typescript\nconst configuration: ClientConfig = {\n    // ... other configuration ...\n    scopes: [\n        // Choose from the following valid scopes:\n        \n        // General scopes\n        crowdinModule.Scope.NOTIFICATIONS,               // 'notification' - Notifications management\n        \n        // Project-level scopes\n        crowdinModule.Scope.PROJECTS,                    // 'project' - Project management\n        crowdinModule.Scope.TASKS,                       // 'project.task' - Project tasks\n        crowdinModule.Scope.REPORTS,                     // 'project.report' - Project reports\n        crowdinModule.Scope.TRANSLATION_STATUS,          // 'project.status' - Translation status\n        crowdinModule.Scope.SOURCE_FILES_AND_STRINGS,    // 'project.source' - Source files and strings\n        crowdinModule.Scope.WEBHOOKS,                    // 'project.webhook' - Project webhooks\n        crowdinModule.Scope.TRANSLATIONS,                // 'project.translation' - Translations\n        crowdinModule.Scope.SCREENSHOTS,                 // 'project.screenshot' - Screenshots\n        \n        // Organization-level scopes\n        crowdinModule.Scope.USERS,                       // 'user' - User management\n        crowdinModule.Scope.TEAMS,                       // 'team' - Team management\n        crowdinModule.Scope.GROUPS,                      // 'group' - Group management\n        crowdinModule.Scope.ORGANIZATION_WEBHOOKS,       // 'webhook' - Organization webhooks\n        crowdinModule.Scope.VENDORS,                     // 'vendor' - Vendor management\n        crowdinModule.Scope.FIELDS,                      // 'field' - Custom fields\n        crowdinModule.Scope.SECURITY_LOGS,               // 'security-log' - Security logs\n        crowdinModule.Scope.APPLICATIONS,                // 'application' - Applications management\n        \n        // Resources\n        crowdinModule.Scope.TRANSLATION_MEMORIES,        // 'tm' - Translation memories\n        crowdinModule.Scope.MACHINE_TRANSLATION_ENGINES, // 'mt' - Machine translation engines\n        crowdinModule.Scope.GLOSSARIES,                  // 'glossary' - Glossaries\n        \n        // AI-related scopes\n        crowdinModule.Scope.AI,                          // 'ai' - AI features\n        crowdinModule.Scope.AI_PROVIDERS,                // 'ai.provider' - AI providers\n        crowdinModule.Scope.AI_PROMPTS,                  // 'ai.prompt' - AI prompts\n        crowdinModule.Scope.AI_PROXIES,                  // 'ai.proxy' - AI proxies\n    ]\n}\n```\n\n### Organization Menu Module Configuration\n\nConfigure the Organization Menu module in `worker/app.ts`:\n\n```typescript\nconst configuration: ClientConfig = {\n    // ... other configuration ...\n\n    organizationMenu: {\n      fileName: 'index.html',\n      uiPath: '/'\n    }\n}\n```\n\n### API Endpoints Best Practices\n\n#### Common Examples\n\n**Standard Endpoint:**\n```typescript\napp.post('/api/process-data', async (req: Request, res: Response) => {\n    try {\n        const jwt = req.query.jwt as string;\n        const { data } = req.body;\n        \n        if (!jwt) {\n            return res.status(400).json({ success: false, error: 'JWT token is required' });\n        }\n        if (!data) {\n            return res.status(400).json({ success: false, error: 'Data is required' });\n        }\n\n        const connection = await crowdinApp.establishCrowdinConnection(jwt, undefined);\n        \n        // Your async logic here\n        const result = await processData(data);\n        \n        res.json({ \n            success: true, \n            result\n        });\n    } catch (error) {\n        console.error('Error:', error);\n        res.status(500).json({ success: false, error: 'Operation failed' });\n    }\n});\n```\n\n#### Best Practices\n\n1. **Always await async operations**\n   ```typescript\n   // ‚úÖ CORRECT - all operations are awaited\n   app.post('/api/save-config', async (req: Request, res: Response) => {\n       const jwt = req.query.jwt as string;\n       const connection = await crowdinApp.establishCrowdinConnection(jwt, undefined);\n       \n       await crowdinApp.saveMetadata(key, data, connection.context.crowdinId);\n       \n       res.json({ success: true });\n   });\n   \n   // ‚ùå WRONG - missing await, operation will NOT complete\n   app.post('/api/save-config', async (req: Request, res: Response) => {\n       const jwt = req.query.jwt as string;\n       const connection = await crowdinApp.establishCrowdinConnection(jwt, undefined);\n       \n       // This will NOT save! Response is sent before operation completes\n       crowdinApp.saveMetadata(key, data, connection.context.crowdinId);\n       \n       res.json({ success: true });\n   });\n   ```\n\n2. **Always return response after all operations complete**\n   ```typescript\n   // ‚úÖ CORRECT - response sent after all operations\n   app.post('/api/update', async (req: Request, res: Response) => {\n       const connection = await crowdinApp.establishCrowdinConnection(jwt, undefined);\n       \n       await operation1();\n       await operation2();\n       await operation3();\n       \n       res.json({ success: true }); // All operations completed\n   });\n   \n   // ‚ùå WRONG - response sent too early\n   app.post('/api/update', async (req: Request, res: Response) => {\n       const connection = await crowdinApp.establishCrowdinConnection(jwt, undefined);\n       \n       res.json({ success: true }); // Sent immediately\n       \n       await operation1(); // These will NOT execute\n       await operation2();\n       await operation3();\n   });\n   ```\n\n3. **Use Promise.all for independent parallel operations**\n   ```typescript\n   // ‚úÖ CORRECT - parallel operations (faster)\n   const [result1, result2, result3] = await Promise.all([\n       connection.client.projectsGroupsApi.getProject(id1),\n       connection.client.projectsGroupsApi.getProject(id2),\n       connection.client.projectsGroupsApi.getProject(id3)\n   ]);\n   \n   // ‚ùå WRONG - sequential operations (slower)\n   const result1 = await connection.client.projectsGroupsApi.getProject(id1);\n   const result2 = await connection.client.projectsGroupsApi.getProject(id2);\n   const result3 = await connection.client.projectsGroupsApi.getProject(id3);\n   ```\n\n4. **Wrap all async code in try-catch**\n   ```typescript\n   // ‚úÖ CORRECT - comprehensive error handling\n   app.get('/api/data', async (req: Request, res: Response) => {\n       try {\n           const connection = await crowdinApp.establishCrowdinConnection(jwt, undefined);\n           const data = await fetchData();\n           res.json({ success: true, data });\n       } catch (error) {\n           console.error('Error:', error);\n           res.status(500).json({ success: false, error: 'Operation failed' });\n       }\n   });\n   \n   // ‚ùå WRONG - no error handling\n   app.get('/api/data', async (req: Request, res: Response) => {\n       const connection = await crowdinApp.establishCrowdinConnection(jwt, undefined);\n       const data = await fetchData(); // May throw unhandled error\n       res.json({ success: true, data });\n   });\n   ```\n\n5. **Never use setTimeout without proper promise wrapper**\n   ```typescript\n   // ‚úÖ CORRECT - setTimeout with promise wrapper\n   app.get('/api/delayed', async (req: Request, res: Response) => {\n       await new Promise((resolve) => {\n           setTimeout(async () => {\n               await saveData();\n               resolve(undefined);\n           }, 1000);\n       });\n       \n       res.json({ success: true });\n   });\n   \n   // ‚ùå WRONG - setTimeout without await (will NOT execute)\n   app.get('/api/delayed', async (req: Request, res: Response) => {\n       setTimeout(async () => {\n           await saveData(); // This will NOT execute\n       }, 1000);\n       \n       res.json({ success: true }); // Sent immediately\n   });\n   ```\n\n6. **Always check for required parameters early**\n   ```typescript\n   // ‚úÖ CORRECT - validate parameters first\n   app.post('/api/process', async (req: Request, res: Response) => {\n       const jwt = req.query.jwt as string;\n       const { projectId, data } = req.body;\n       \n       // Validate early\n       if (!jwt) {\n           return res.status(400).json({ error: 'JWT token is required' });\n       }\n       if (!projectId) {\n           return res.status(400).json({ error: 'Project ID is required' });\n       }\n       if (!data) {\n           return res.status(400).json({ error: 'Data is required' });\n       }\n       \n       // Continue with processing\n       const connection = await crowdinApp.establishCrowdinConnection(jwt, undefined);\n       // ... rest of the logic\n   });\n   ```\n\n### Crowdin API Client\n\n#### Official Documentation\n\nThe `connection.client` object is an instance of `@crowdin/crowdin-api-client`.\n\n**üìö Complete API Reference:** https://crowdin.github.io/crowdin-api-client-js/modules.html\n\n**‚ö†Ô∏è CRITICAL**: Only use methods documented in the official API reference. Do NOT invent or assume methods exist.\n\n#### Common Examples\n\n**Standard Endpoint Template:**\n```typescript\napp.get('/api/your-endpoint', async (req: Request, res: Response) => {\n    try {\n        const jwt = req.query.jwt as string;\n        if (!jwt) {\n            return res.status(400).json({ success: false, error: 'JWT token is required' });\n        }\n\n        if (!crowdinApp.establishCrowdinConnection) {\n            return res.status(500).json({ success: false, error: 'Crowdin connection method not available' });\n        }\n\n        const connection = await crowdinApp.establishCrowdinConnection(jwt, undefined);\n\n        if (!connection.client) {\n            return res.status(500).json({ success: false, error: 'Crowdin API client not available' });\n        }\n\n        const userId = connection.context.jwtPayload.context.user_id;\n        const organizationId = connection.context.jwtPayload.context.organization_id;\n\n        // Your logic here using connection.client API\n        \n        res.status(200).json({ success: true, data: result });\n    } catch (error) {\n        console.error('Error:', error);\n        res.status(500).json({ success: false, error: 'Operation failed' });\n    }\n});\n```\n\n**Get Project Details:**\n```typescript\nconst response = await connection.client.projectsGroupsApi.getProject(projectId);\n\n// Access project properties\nconst project = response.data;\nconst projectName = project.name;                    // string\nconst sourceLanguageId = project.sourceLanguageId;   // string\nconst targetLanguageIds = project.targetLanguageIds; // string[]\nconst description = project.description;             // string | null\n```\n\n**List All Projects (with pagination):**\n```typescript\nconst response = await connection.client.projectsGroupsApi.withFetchAll().listProjects();\n\n// Iterate through all projects\nresponse.data.forEach((projectItem: ResponseObject<ProjectsGroupsModel.Project>) => {\n  const projectId = projectItem.data.id;\n  const projectName = projectItem.data.name;\n  const groupId = projectItem.data.groupId; // number | null\n});\n```\n\n**Get Supported Languages:**\n```typescript\nconst response = await connection.client.languagesApi.withFetchAll().listSupportedLanguages();\n\n// Filter languages\nconst targetLanguageIds = ['uk', 'pl', 'de'];\nconst projectLanguages = response.data.filter(\n  (lang: ResponseObject<LanguagesModel.Language>) => targetLanguageIds.includes(lang.data.id)\n);\n\n// Map to simpler structure\nconst languages = projectLanguages.map((lang: ResponseObject<LanguagesModel.Language>) => ({\n  id: lang.data.id,           // string: \"uk\"\n  name: lang.data.name,       // string: \"Ukrainian\"\n  locale: lang.data.locale,   // string: \"uk-UA\"\n  osxLocale: lang.data.osxLocale // string\n}));\n```\n\n**List Source Files:**\n```typescript\nconst response = await connection.client.sourceFilesApi.withFetchAll().listProjectFiles(projectId);\n\nresponse.data.forEach((fileItem: ResponseObject<SourceFilesModel.File>) => {\n  const file = fileItem.data;\n  const fileId = file.id;             // number\n  const fileName = file.name;         // string\n  const branchId = file.branchId;     // number | null\n  const directoryId = file.directoryId; // number | null\n});\n```\n\n#### Best Practices\n\n1. **Always access data via `.data` property**\n   ```typescript\n   // ‚úÖ CORRECT\n   const project = response.data;\n   const projectName = response.data.name;\n   \n   // ‚ùå WRONG - will be undefined\n   const projectName = response.name;\n   ```\n\n2. **Use withFetchAll() for complete data**\n   ```typescript\n   // ‚úÖ CORRECT - gets all items\n   const response = await connection.client.languagesApi.withFetchAll().listSupportedLanguages();\n   \n   // ‚ö†Ô∏è PARTIAL - only first page (25 items)\n   const response = await connection.client.languagesApi.listSupportedLanguages();\n   ```\n\n3. **Handle nullable properties**\n   ```typescript\n   const description = response.data.description || 'No description';\n   const groupId = response.data.groupId ?? null;\n   ```\n\n4. **Handle errors properly**\n   ```typescript\n   try {\n     const response = await connection.client.projectsGroupsApi.getProject(projectId);\n     const project = response.data;\n     // Use project data\n   } catch (error: any) {\n     console.error('Crowdin API Error:', error);\n\n     // API errors have specific structure\n     if (error.code === 404) {\n       return res.status(404).json({ error: 'Project not found' });\n     }\n     \n     return res.status(500).json({\n       error: 'API request failed',\n       details: error.message\n     });\n   }\n   ```\n\n5. **Use TypeScript types**\n   ```typescript\n   import type { ResponseObject, ProjectsGroupsModel } from '@crowdin/crowdin-api-client';\n   \n   // Use in your code\n   const response: ResponseObject<ProjectsGroupsModel.Project> = await connection.client.projectsGroupsApi.getProject(projectId);\n   const project: ProjectsGroupsModel.Project = response.data;\n   ```\n\n6. **Always sort data explicitly when order matters**\n   ```typescript\n   // ‚úÖ CORRECT - sort projects by creation date (newest first)\n   const response = await connection.client.projectsGroupsApi.withFetchAll().listProjects();\n   const sortedByDate = response.data.sort(\n     (a: ResponseObject<ProjectsGroupsModel.Project>, b: ResponseObject<ProjectsGroupsModel.Project>) => {\n       const dateA = new Date(a.data.createdAt).getTime();\n       const dateB = new Date(b.data.createdAt).getTime();\n       return dateB - dateA; // Descending order (newest first)\n     }\n   );\n   \n   // ‚ùå WRONG - assuming data is already sorted by date\n   const response = await connection.client.projectsGroupsApi.withFetchAll().listProjects();\n   // Directly using response.data without sorting - order is not guaranteed!\n   ```\n\n7. **Never use CroQL - fetch all data and filter manually**\n   ```typescript\n   // ‚úÖ CORRECT - fetch all strings and filter manually\n   const allStrings = await connection.client.sourceStringsApi.withFetchAll().listProjectStrings(projectId);\n   \n   // Filter for specific criteria\n   const filteredStrings = allStrings.data.filter(\n     (item: ResponseObject<SourceStringsModel.String>) => {\n       const str = item.data;\n       return str.text.includes('welcome') && !str.isHidden;\n     }\n   );\n   \n   // ‚ùå WRONG - using CroQL queries\n   const response = await connection.client.sourceStringsApi.listProjectStrings(projectId, {\n     croql: 'text contains \"welcome\" AND isHidden = false'\n   });\n   // CroQL should be avoided - fetch all data and filter in your code instead\n   ```\n\n#### Complete Type Definitions\n\n**‚ö†Ô∏è CRITICAL**: Only use methods and types from `@crowdin/crowdin-api-client` definitions below.\n\n**Do NOT invent methods or properties that are not listed here.**\n\n<!-- CROWDIN_API_CLIENT_TYPES_START -->\n\n##### ai/index.d.ts\n\n```typescript\nimport { CrowdinApi, DownloadLink, PaginationOptions, PatchRequest, PlainObject, ResponseList, ResponseObject, Status } from '../core';\nexport declare class Ai extends CrowdinApi {\n    listAiOrganizationCustomPlaceholders(options?: PaginationOptions): Promise<ResponseList<AiModel.CustomPlaceholder>>;\n    addAiOrganizationCustomPlaceholder(request: AiModel.AddCustomPlaceholderRequest): Promise<ResponseObject<AiModel.CustomPlaceholder>>;\n    getAiOrganizationCustomPlaceholder(aiCustomPlaceholderId: number): Promise<ResponseObject<AiModel.CustomPlaceholder>>;\n    deleteAiOrganizationCustomPlaceholder(aiCustomPlaceholderId: number): Promise<void>;\n    editAiOrganizationCustomPlaceholder(aiCustomPlaceholderId: number, request: PatchRequest[]): Promise<ResponseObject<AiModel.CustomPlaceholder>>;\n    generateAiOrganizationPromptFineTuningDataset(aiPromptId: number, request: AiModel.GenerateFineTuningDataset): Promise<ResponseObject<Status<AiModel.FineTuningDataset>>>;\n    getAiOrganizationPromptFineTuningDatasetStatus(aiPromptId: number, jobIdentifier: string): Promise<ResponseObject<Status<AiModel.FineTuningDataset>>>;\n    listAiOrganizationPromptFineTuningEvents(aiPromptId: number, jobIdentifier: string, options?: PaginationOptions): Promise<ResponseList<AiModel.PromptFineTuningEvent>>;\n    listAiOrganizationPromptFineTuningJobs(options?: AiModel.ListPromptFineTuningJobsOptions): Promise<ResponseList<Status<AiModel.FineTuningJob>>>;\n    createAiOrganizationPromptFineTuningJob(aiPromptId: number, request: AiModel.GenerateFineTuningJob): Promise<ResponseObject<Status<AiModel.FineTuningJob>>>;\n    getAiOrganizationPromptFineTuningJobStatus(aiPromptId: number, jobIdentifier: string): Promise<ResponseObject<Status<AiModel.FineTuningJob>>>;\n    downloadAiOrganizationPromptFineTuningDataset(aiPromptId: number, jobIdentifier: string): Promise<ResponseObject<DownloadLink>>;\n    cloneAiOrganizationPrompt(aiPromptId: number, request?: {\n        name?: string;\n    }): Promise<ResponseObject<AiModel.AiPromptResponse>>;\n    listAiOrganizationPrompts(options?: AiModel.ListAiPromptsOptions): Promise<ResponseList<AiModel.AiPromptResponse>>;\n    addAiOrganizationPrompt(request: AiModel.AddAiPromptRequest): Promise<ResponseObject<AiModel.AiPromptResponse>>;\n    generateAiOrganizationPromptCompletion(aiPromptId: number, request: AiModel.GenerateAiPromptCompletionRequest): Promise<ResponseObject<Status<AiModel.AiPromptCompletionAttribute>>>;\n    getAiOrganizationPromptCompletionStatus(aiPromptId: number, completionId: string): Promise<ResponseObject<Status<AiModel.AiPromptCompletionAttribute>>>;\n    cancelAiOrganizationPromptCompletion(aiPromptId: number, completionId: string): Promise<void>;\n    downloadAiOrganizationPromptCompletion(aiPromptId: number, completionId: string): Promise<ResponseObject<DownloadLink>>;\n    getAiOrganizationPrompt(aiPromptId: number): Promise<ResponseObject<AiModel.AiPromptResponse>>;\n    deleteAiOrganizationPrompt(aiPromptId: number): Promise<void>;\n    editAiOrganizationPrompt(aiPromptId: number, request: PatchRequest[]): Promise<ResponseObject<AiModel.AiPromptResponse>>;\n    listAiOrganizationProviders(options?: PaginationOptions): Promise<ResponseList<AiModel.AiProviderResponse>>;\n    addAiOrganizationProvider(request: AiModel.AddAiProviderRequest): Promise<ResponseObject<AiModel.AiProviderResponse>>;\n    getAiOrganizationProvider(aiProviderId: number): Promise<ResponseObject<AiModel.AiProviderResponse>>;\n    deleteAiOrganizationProvider(aiProviderId: number): Promise<void>;\n    editAiOrganizationProvider(aiProviderId: number, request: PatchRequest[]): Promise<ResponseObject<AiModel.AiProviderResponse>>;\n    listAiOrganizationProviderModels(aiProviderId: number, options?: PaginationOptions): Promise<ResponseList<AiModel.AiProviderModelResponse>>;\n    listAiOrganizationAllProviderModels(options?: PaginationOptions): Promise<ResponseList<AiModel.AiProviderModelResponse>>;\n    createAiOrganizationProxyChatCompletion(aiProviderId: number, request?: AiModel.OtherChatCompletionRequest | AiModel.GoogleGeminiChatCompletionRequest): Promise<ResponseObject<AiModel.AiProviderProxyResponseData>>;\n    generateAiOrganizationReport(request: AiModel.AiReport): Promise<ResponseObject<Status<AiModel.AiReport>>>;\n    checkAiOrganizationReportStatus(aiReportId: string): Promise<ResponseObject<Status<AiModel.AiReport>>>;\n    downloadAiOrganizationReport(aiReportId: string): Promise<ResponseObject<DownloadLink>>;\n    getAiOrganizationSettings(): Promise<ResponseObject<AiModel.AiSettings>>;\n    editAiOrganizationSettings(request: PatchRequest[]): Promise<ResponseObject<AiModel.AiSettings>>;\n    listAiUserCustomPlaceholders(userId: number, options?: PaginationOptions): Promise<ResponseList<AiModel.CustomPlaceholder>>;\n    addAiUserCustomPlaceholder(userId: number, request: AiModel.AddCustomPlaceholderRequest): Promise<ResponseObject<AiModel.CustomPlaceholder>>;\n    getAiUserCustomPlaceholder(userId: number, aiCustomPlaceholderId: number): Promise<ResponseObject<AiModel.CustomPlaceholder>>;\n    deleteAiUserCustomPlaceholder(userId: number, aiCustomPlaceholderId: number): Promise<void>;\n    editAiUserCustomPlaceholder(userId: number, aiCustomPlaceholderId: number, request: PatchRequest[]): Promise<ResponseObject<AiModel.CustomPlaceholder>>;\n    generateAiUserPromptFineTuningDataset(userId: number, aiPromptId: number, request: AiModel.GenerateFineTuningDataset): Promise<ResponseObject<Status<AiModel.FineTuningDataset>>>;\n    getAiUserPromptFineTuningDatasetStatus(userId: number, aiPromptId: number, jobIdentifier: string): Promise<ResponseObject<Status<AiModel.FineTuningDataset>>>;\n    listAiUserPromptFineTuningEvents(userId: number, aiPromptId: number, jobIdentifier: string, options?: PaginationOptions): Promise<ResponseList<AiModel.PromptFineTuningEvent>>;\n    listAiUserPromptFineTuningJobs(userId: number, options?: AiModel.ListPromptFineTuningJobsOptions): Promise<ResponseList<Status<AiModel.FineTuningJob>>>;\n    createAiUserPromptFineTuningJob(userId: number, aiPromptId: number, request: AiModel.GenerateFineTuningJob): Promise<ResponseObject<Status<AiModel.FineTuningJob>>>;\n    getAiUserPromptFineTuningJobStatus(userId: number, aiPromptId: number, jobIdentifier: string): Promise<ResponseObject<Status<AiModel.FineTuningJob>>>;\n    downloadAiUserPromptFineTuningDataset(userId: number, aiPromptId: number, jobIdentifier: string): Promise<ResponseObject<DownloadLink>>;\n    cloneAiUserPrompt(userId: number, aiPromptId: number, request?: {\n        name?: string;\n    }): Promise<ResponseObject<AiModel.AiPromptResponse>>;\n    listAiUserPrompts(userId: number, options?: AiModel.ListAiPromptsOptions): Promise<ResponseList<AiModel.AiPromptResponse>>;\n    addAiUserPrompt(userId: number, request: AiModel.AddAiPromptRequest): Promise<ResponseObject<AiModel.AiPromptResponse>>;\n    generateAiUserPromptCompletion(userId: number, aiPromptId: number, request: AiModel.GenerateAiPromptCompletionRequest): Promise<ResponseObject<Status<AiModel.AiPromptCompletionAttribute>>>;\n    getAiUserPromptCompletionStatus(userId: number, aiPromptId: number, completionId: string): Promise<ResponseObject<Status<AiModel.AiPromptCompletionAttribute>>>;\n    cancelAiUserPromptCompletion(userId: number, aiPromptId: number, completionId: string): Promise<void>;\n    downloadAiUserPromptCompletion(userId: number, aiPromptId: number, completionId: string): Promise<ResponseObject<DownloadLink>>;\n    getAiUserPrompt(userId: number, aiPromptId: number): Promise<ResponseObject<AiModel.AiPromptResponse>>;\n    deleteAiUserPrompt(userId: number, aiPromptId: number): Promise<void>;\n    editAiUserPrompt(userId: number, aiPromptId: number, request: PatchRequest[]): Promise<ResponseObject<AiModel.AiPromptResponse>>;\n    listAiUserProviders(userId: number, options?: PaginationOptions): Promise<ResponseList<AiModel.AiProviderResponse>>;\n    addAiUserProvider(userId: number, request: AiModel.AddAiProviderRequest): Promise<ResponseObject<AiModel.AiProviderResponse>>;\n    getAiUserProvider(userId: number, aiProviderId: number): Promise<ResponseObject<AiModel.AiProviderResponse>>;\n    deleteAiUserProvider(userId: number, aiProviderId: number): Promise<void>;\n    editAiUserProvider(userId: number, aiProviderId: number, request: PatchRequest[]): Promise<ResponseObject<AiModel.AiProviderResponse>>;\n    listAiUserProviderModels(userId: number, aiProviderId: number, options?: PaginationOptions): Promise<ResponseList<AiModel.AiProviderModelResponse>>;\n    listAiUserAllProviderModels(userId: number, options?: PaginationOptions): Promise<ResponseList<AiModel.AiProviderModelResponse>>;\n    createAiUserProxyChatCompletion(userId: number, aiProviderId: number, request?: AiModel.OtherChatCompletionRequest | AiModel.GoogleGeminiChatCompletionRequest): Promise<ResponseObject<AiModel.AiProviderProxyResponseData>>;\n    generateAiUserReport(userId: number, request: AiModel.AiReport): Promise<ResponseObject<Status<AiModel.AiReport>>>;\n    checkAiUserReportStatus(userId: number, aiReportId: string): Promise<ResponseObject<Status<AiModel.AiReport>>>;\n    downloadAiUserReport(userId: number, aiReportId: string): Promise<ResponseObject<DownloadLink>>;\n    getAiUsertSettings(userId: number): Promise<ResponseObject<AiModel.AiSettings>>;\n    editAiUserSettings(userId: number, request: PatchRequest[]): Promise<ResponseObject<AiModel.AiSettings>>;\n}\nexport declare namespace AiModel {\n    interface CustomPlaceholder {\n        id: number;\n        description: string;\n        placeholder: string;\n        value: string;\n        createdAt: string;\n        updatedAt: string;\n    }\n    interface AddCustomPlaceholderRequest {\n        description: string;\n        placeholder: string;\n        value: string;\n    }\n    interface FineTuningDataset {\n        projectIds: number[];\n        tmIds: number[];\n        purpose: 'training' | 'validation';\n        dateFrom: string;\n        dateTo: string;\n        maxFileSize: number;\n        minExamplesCount: number;\n        maxExamplesCount: number;\n    }\n    interface GenerateFineTuningDataset {\n        projectIds?: number[];\n        tmIds?: number[];\n        purpose?: 'training' | 'validation';\n        dateFrom?: string;\n        dateTo?: string;\n        maxFileSize?: number;\n        minExamplesCount?: number;\n        maxExamplesCount?: number;\n    }\n    interface GenerateFineTuningJob {\n        dryRun?: boolean;\n        hyperparameters?: {\n            batchSize: number;\n            learningRateMultiplier: number;\n            nEpochs: number;\n        };\n        trainingOptions: Omit<GenerateFineTuningDataset, 'purpose'>;\n        validationOptions?: Omit<GenerateFineTuningDataset, 'purpose'>;\n    }\n    interface FineTuningJob {\n        dryRun: boolean;\n        aiPromptId: number;\n        hyperparameters: {\n            batchSize: number;\n            learningRateMultiplier: number;\n            nEpochs: number;\n        };\n        trainingOptions: Omit<GenerateFineTuningDataset, 'purpose'>;\n        validationOptions: Omit<GenerateFineTuningDataset, 'purpose'>;\n        baseModel: string;\n        fineTunedModel: string;\n        trainedTokensCount: number;\n        trainingDatasetUrl: string;\n        validationDatasetUrl: string;\n        metadata: PlainObject;\n    }\n    interface PromptFineTuningEvent {\n        id: string;\n        type: string;\n        message: string;\n        data: {\n            step: number;\n            totalSteps: number;\n            trainingLoss: number;\n            validationLoss: number;\n            fullValidationLoss: number;\n        };\n        createdAt: string;\n    }\n    interface ListPromptFineTuningJobsOptions extends PaginationOptions {\n        statuses: string;\n        orderBy: string;\n    }\n    interface ListAiPromptsOptions extends PaginationOptions {\n        projectId?: number;\n        action?: Action;\n    }\n    interface AiPromptResponse {\n        id: number;\n        name: string;\n        action: Action;\n        aiProviderId: number;\n        aiModelId: string;\n        isEnabled: boolean;\n        enabledProjectIds: number[];\n        config: AiModel.AiPromptConfigBasicPreTranslate | AiModel.AiPromptConfigBasicAssistAction | AiModel.AiPromptConfigBasicAligmentAction | AiModel.AiPromptConfigAdvanced | AiModel.AiPromptConfigExternal;\n        promptPreview: string;\n        isFineTuningAvailable: boolean;\n        createdAt: string;\n        updatedAt: string;\n    }\n    interface AiPromptConfigBasicOtherLanguageTranslations {\n        isEnabled?: boolean;\n        languageIds?: string[];\n    }\n    interface AiPromptConfigBasicPreTranslate {\n        mode: 'basic';\n        companyDescription?: string;\n        projectDescription?: string;\n        audienceDescription?: string;\n        customPlaceholders?: string[];\n        otherLanguageTranslations?: AiModel.AiPromptConfigBasicOtherLanguageTranslations;\n        glossaryTerms?: boolean;\n        tmSuggestions?: boolean;\n        fileContent?: boolean;\n        fileContext?: boolean;\n        screenshots?: boolean;\n        publicProjectDescription?: boolean;\n        siblingsStrings?: boolean;\n    }\n    interface AiPromptConfigBasicAssistAction {\n        mode: 'basic';\n        companyDescription?: string;\n        projectDescription?: string;\n        audienceDescription?: string;\n        otherLanguageTranslations?: AiModel.AiPromptConfigBasicOtherLanguageTranslations;\n        glossaryTerms?: boolean;\n        tmSuggestions?: boolean;\n        fileContext?: boolean;\n        screenshots?: boolean;\n        publicProjectDescription?: boolean;\n        siblingsStrings?: boolean;\n        filteredStrings?: boolean;\n    }\n    interface AiPromptConfigBasicAligmentAction {\n        mode: 'basic';\n        customPlaceholders?: string[];\n        publicProjectDescription?: boolean;\n    }\n    interface AiPromptConfigAdvanced {\n        mode: 'advanced';\n        screenshots?: boolean;\n        prompt: string;\n        otherLanguageTranslations?: AiModel.AiPromptConfigBasicOtherLanguageTranslations;\n    }\n    interface AiPromptConfigExternal {\n        mode: 'external';\n        identifier: string;\n        key: string;\n        options?: any;\n    }\n    interface AddAiPromptRequest {\n        name: string;\n        action: Action;\n        aiProviderId?: number;\n        aiModelId?: string;\n        isEnabled?: boolean;\n        enabledProjectIds?: number[];\n        config: AiModel.AiPromptConfigBasicPreTranslate | AiModel.AiPromptConfigBasicAssistAction | AiModel.AiPromptConfigBasicAligmentAction | AiModel.AiPromptConfigAdvanced | AiPromptConfigExternal;\n    }\n    interface GenerateAiPromptCompletionRequest {\n        resources: AiModel.AiPromptResourceWithPreTranslate | AiModel.AiPromptResourceWithAssist | AiModel.AiPromptResourceWithAlignment | AiModel.AiPromptResourceWithCustom;\n        tools?: {\n            tool: {\n                type: 'function';\n                function: {\n                    description?: string;\n                    name: string;\n                    parameters?: PlainObject;\n                };\n            };\n        }[];\n        tool_choice?: string | PlainObject;\n    }\n    interface AiPromptCompletionAttribute {\n        aiPromptId: number;\n    }\n    interface AiPromptResourceWithPreTranslate {\n        projectId: number;\n        sourceLanguageId?: string;\n        targetLanguageId?: string;\n        stringIds?: number[];\n        overridePromptValues?: OverridePromptValues;\n    }\n    interface AiPromptResourceWithAlignment {\n        projectId: number;\n        sourceLanguageId?: string;\n        targetLanguageId?: string;\n        stringIds?: number[];\n        overridePromptValues?: OverridePromptValues;\n    }\n    interface AiPromptResourceWithAssist {\n        projectId: number;\n        sourceLanguageId?: string;\n        targetLanguageId?: string;\n        stringIds?: number[];\n        filteredStringsIds?: number[];\n        overridePromptValues?: OverridePromptValues;\n    }\n    interface AiPromptResourceWithCustom {\n        projectId: number;\n        sourceLanguageId?: string;\n        targetLanguageId?: string;\n        stringIds?: number[];\n        overridePromptValues?: OverridePromptValues;\n        customInstruction?: string;\n    }\n    interface OverridePromptValues {\n        [key: string]: any;\n    }\n    interface AiProviderResponse {\n        id: number;\n        name: string;\n        type: ProviderType;\n        credentials: AiModel.AiProviderCredentialsBasic | AiModel.AiProviderCredentialsAzureOpenAi | AiProviderCredentialsGoogleGemini | AiProviderCredentialsCustom;\n        config: AiModel.AiProviderConfig;\n        isEnabled: boolean;\n        useSystemCredentials: boolean;\n        createdAt: string;\n        updatedAt: string;\n        promptsCount: string;\n    }\n    interface AiProviderCredentialsBasic {\n        apiKey: string;\n    }\n    interface AiProviderCredentialsAzureOpenAi extends AiProviderCredentialsBasic {\n        resourceName: string;\n        deploymentName: string;\n        apiVersion: string;\n    }\n    interface AiProviderCredentialsGoogleGemini {\n        project: string;\n        region: string;\n        serviceAccountKey: string;\n    }\n    interface AiProviderCredentialsWatsonx {\n        apiKey: string;\n        projectId: string;\n        region: string;\n    }\n    interface AiProviderCredentialsCustom {\n        identifier: string;\n        key: string;\n    }\n    interface AiProviderConfig {\n        actionRules?: AiModel.AiProviderConfigActionRule[];\n    }\n    interface AiProviderConfigActionRule {\n        action?: 'pre_translate' | 'assist';\n        availableAiModelIds?: string[];\n    }\n    interface AddAiProviderRequest {\n        name: string;\n        type: ProviderType;\n        credentials?: AiModel.AiProviderCredentialsBasic | AiModel.AiProviderCredentialsAzureOpenAi | AiProviderCredentialsGoogleGemini | AiProviderCredentialsWatsonx | AiProviderCredentialsCustom;\n        config?: AiModel.AiProviderConfig;\n        isEnabled?: boolean;\n        useSystemCredentials?: boolean;\n    }\n    interface AiProviderModelResponse {\n        id: string;\n    }\n    interface AiProviderProxyResponseData {\n        data: object;\n    }\n    interface OtherChatCompletionRequest {\n        stream?: boolean;\n        [key: string]: any;\n    }\n    interface GoogleGeminiChatCompletionRequest extends OtherChatCompletionRequest {\n        model: string;\n    }\n    type AiReport = AiReportTokenUsage;\n    interface AiReportTokenUsage {\n        type: 'tokens-usage-raw-data';\n        schema: AiReportGeneralSchema;\n    }\n    interface AiReportGeneralSchema {\n        dateFrom: string;\n        dateTo: string;\n        format?: 'json' | 'csv';\n        projectIds?: number[];\n        promptIds?: number[];\n        userIds?: number[];\n    }\n    interface AiSettings {\n        assistActionAiPromptId: number;\n        showSuggestion: boolean;\n        shortcuts: {\n            name: string;\n            prompt: string;\n            enabled: boolean;\n        }[];\n    }\n    type Action = 'pre_translate' | 'assist';\n    type ProviderType = 'open_ai' | 'azure_open_ai' | 'google_gemini' | 'mistral_ai' | 'anthropic' | 'custom_ai' | 'x_ai' | 'deepseek' | 'watsonx';\n}\n```\n\n##### applications/index.d.ts\n\n```typescript\nimport { CrowdinApi, ResponseObject, PatchRequest, Pagination, ResponseList } from '../core';\nexport declare class Applications extends CrowdinApi {\n    listApplicationInstallations(options?: Pagination): Promise<ResponseList<ApplicationsModel.Application>>;\n    installApplication(request: ApplicationsModel.InstallApplication): Promise<ResponseObject<ApplicationsModel.Application>>;\n    getApplicationInstallation(applicationId: string): Promise<ResponseObject<ApplicationsModel.Application>>;\n    deleteApplicationInstallation(applicationId: string, force?: boolean): Promise<ResponseObject<ApplicationsModel.Application>>;\n    editApplicationInstallation(applicationId: string, request: PatchRequest[]): Promise<ResponseObject<ApplicationsModel.Application>>;\n    getApplicationData(applicationId: string, path: string): Promise<ResponseObject<any>>;\n    updateOrRestoreApplicationData(applicationId: string, path: string, request: any): Promise<ResponseObject<any>>;\n    addApplicationData(applicationId: string, path: string, request: any): Promise<ResponseObject<any>>;\n    deleteApplicationData(applicationId: string, path: string): Promise<void>;\n    editApplicationData(applicationId: string, path: string, request: any): Promise<ResponseObject<any>>;\n}\nexport declare namespace ApplicationsModel {\n    interface Application {\n        identifier: string;\n        name: string;\n        description: string;\n        logo: string;\n        baseUrl: string;\n        manifestUrl: string;\n        createdAt: string;\n        modules: ApplicationModule[];\n        scopes: string[];\n        permissions: ApplicationPermissions;\n        defaultPermissions: any;\n        limitReached: boolean;\n    }\n    interface InstallApplication {\n        url: string;\n        permissions?: ApplicationPermissions;\n        modules?: ApplicationModule[];\n    }\n    interface ApplicationPermissions {\n        user: {\n            value: 'all' | 'owner' | 'managers' | 'guests' | 'restricted';\n            ids: number[];\n        };\n        project: {\n            value: 'own' | 'restricted';\n            ids: number[];\n        };\n    }\n    interface ApplicationModule {\n        key: string;\n        type?: string;\n        data?: any;\n        authenticationType?: string;\n        permissions: Omit<ApplicationPermissions, 'project'>;\n    }\n}\n```\n\n##### bundles/index.d.ts\n\n```typescript\nimport { CrowdinApi, DownloadLink, PaginationOptions, PatchRequest, ResponseList, ResponseObject, Status } from '../core';\nimport { SourceFilesModel } from '../sourceFiles';\nexport declare class Bundles extends CrowdinApi {\n    listBundles(projectId: number, options?: PaginationOptions): Promise<ResponseList<BundlesModel.Bundle>>;\n    addBundle(projectId: number, request: BundlesModel.CreateBundleRequest): Promise<ResponseObject<BundlesModel.Bundle>>;\n    getBundle(projectId: number, bundleId: number): Promise<ResponseObject<BundlesModel.Bundle>>;\n    deleteBundle(projectId: number, bundleId: number): Promise<void>;\n    editBundle(projectId: number, bundleId: number, request: PatchRequest[]): Promise<ResponseObject<BundlesModel.Bundle>>;\n    downloadBundle(projectId: number, bundleId: number, exportId: string): Promise<ResponseObject<DownloadLink>>;\n    exportBundle(projectId: number, bundleId: number): Promise<ResponseObject<Status<BundlesModel.ExportAttributes>>>;\n    checkBundleExportStatus(projectId: number, bundleId: number, exportId: string): Promise<ResponseObject<Status<BundlesModel.ExportAttributes>>>;\n    listBundleFiles(projectId: number, bundleId: number, options?: PaginationOptions): Promise<ResponseList<SourceFilesModel.File>>;\n    listBundleBranches(projectId: number, bundleId: number, options?: PaginationOptions): Promise<ResponseList<SourceFilesModel.Branch>>;\n}\nexport declare namespace BundlesModel {\n    interface Bundle {\n        id: number;\n        name: string;\n        format: string;\n        sourcePatterns: string[];\n        ignorePatterns: string[];\n        exportPattern: string;\n        isMultilingual: boolean;\n        includeProjectSourceLanguage: boolean;\n        labelIds: number[];\n        excludeLabelIds: number[];\n        createdAt: string;\n        webUrl: string;\n        updatedAt: string;\n    }\n    interface CreateBundleRequest {\n        name: string;\n        format: string;\n        sourcePatterns: string[];\n        ignorePatterns?: string[];\n        exportPattern: string;\n        isMultilingual?: boolean;\n        includeProjectSourceLanguage?: boolean;\n        includeInContextPseudoLanguage?: boolean;\n        labelIds?: number[];\n        excludeLabelIds?: number[];\n    }\n    interface ExportAttributes {\n        bundleId: number;\n    }\n}\n```\n\n##### clients/index.d.ts\n\n```typescript\nimport { CrowdinApi, PaginationOptions, ResponseList } from '../core';\nexport declare class Clients extends CrowdinApi {\n    listClients(options?: PaginationOptions): Promise<ResponseList<ClientsModel.Client>>;\n}\nexport declare namespace ClientsModel {\n    interface Client {\n        id: number;\n        name: string;\n        description: string;\n        status: 'pending' | 'confirmed' | 'rejected';\n        webUrl: string;\n    }\n}\n```\n\n##### core/http-client-error.d.ts\n\n```typescript\nimport { AxiosError } from 'axios';\nimport { FetchClientJsonPayloadError } from './internal/fetch/fetchClientError';\nexport type HttpClientError = AxiosError | FetchClientJsonPayloadError | Error;\nexport declare const toHttpClientError: (error?: unknown) => HttpClientError;\n```\n\n##### core/index.d.ts\n\n```typescript\nimport { HttpClientError } from './http-client-error';\nimport { RetryConfig, RetryService } from './internal/retry';\nexport interface HttpClient {\n    get<T>(url: string, config?: {\n        headers: Record<string, string>;\n    }): Promise<T>;\n    delete<T>(url: string, config?: {\n        headers: Record<string, string>;\n    }): Promise<T>;\n    head<T>(url: string, config?: {\n        headers: Record<string, string>;\n    }): Promise<T>;\n    post<T>(url: string, data?: unknown, config?: {\n        headers: Record<string, string>;\n    }): Promise<T>;\n    put<T>(url: string, data?: unknown, config?: {\n        headers: Record<string, string>;\n    }): Promise<T>;\n    patch<T>(url: string, data?: unknown, config?: {\n        headers: Record<string, string>;\n    }): Promise<T>;\n}\nexport type HttpClientType = 'axios' | 'fetch';\nexport interface Credentials {\n    token: string;\n    organization?: string;\n    baseUrl?: string;\n}\nexport interface ClientConfig {\n    httpClientType?: HttpClientType;\n    httpClient?: HttpClient;\n    userAgent?: string;\n    integrationUserAgent?: string;\n    retryConfig?: RetryConfig;\n    httpRequestTimeout?: number;\n}\nexport interface ResponseList<T> {\n    data: ResponseObject<T>[];\n    pagination: Pagination;\n}\nexport interface ResponseObject<T> {\n    data: T;\n}\nexport interface Pagination {\n    offset: number;\n    limit: number;\n}\nexport type PaginationOptions = Partial<Pagination>;\nexport interface PatchRequest {\n    value?: any;\n    op: PatchOperation;\n    path: string;\n}\nexport type PatchOperation = 'add' | 'remove' | 'replace' | 'move' | 'copy' | 'test';\nexport type ProjectRoles = 'manager' | 'developer' | 'translator' | 'proofreader' | 'language_coordinator' | 'member';\nexport interface DownloadLink {\n    url: string;\n    expireIn: string;\n}\nexport declare enum BooleanInt {\n    TRUE = 1,\n    FALSE = 0\n}\nexport interface Status<T> {\n    identifier: string;\n    status: string;\n    progress: number;\n    attributes: T;\n    createdAt: string;\n    updatedAt: string;\n    startedAt: string;\n    finishedAt: string;\n    eta: string;\n}\nexport interface Attribute {\n    [key: string]: string;\n}\nexport type PlainObject = Record<string, any>;\nexport declare class CrowdinError extends Error {\n    apiError: any;\n    code: number;\n    constructor(message: string, code: number, apiError: any);\n}\nexport declare class CrowdinValidationError extends CrowdinError {\n    validationCodes: {\n        key: string;\n        codes: string[];\n    }[];\n    constructor(message: string, validationCodes: {\n        key: string;\n        codes: string[];\n    }[], apiError: any);\n}\nexport declare function handleHttpClientError(error: HttpClientError): never;\nexport declare abstract class CrowdinApi {\n    private static readonly CROWDIN_URL_SUFFIX;\n    private static readonly AXIOS_INSTANCE;\n    private static readonly FETCH_INSTANCE;\n    readonly token: string;\n    readonly organization?: string;\n    readonly url: string;\n    readonly config: ClientConfig | undefined;\n    readonly retryService: RetryService;\n    protected fetchAllFlag: boolean;\n    protected maxLimit: number | undefined;\n    constructor(credentials: Credentials, config?: ClientConfig);\n    graphql<T>(req: {\n        query: string;\n        operationName?: string;\n        variables?: any;\n    }, config?: {\n        url?: string;\n    }): Promise<ResponseObject<T>>;\n    protected addQueryParam(url: string, name: string, value?: string | number): string;\n    protected defaultConfig(): {\n        headers: Record<string, string>;\n    };\n    get httpClient(): HttpClient;\n    withFetchAll(maxLimit?: number): this;\n    protected getList<T = any>(url: string, limit?: number, offset?: number, config?: {\n        headers: Record<string, string>;\n    }): Promise<ResponseList<T>>;\n    protected fetchAll<T>(url: string, config: {\n        headers: Record<string, string>;\n    }, maxAmount?: number): Promise<ResponseList<T>>;\n    protected encodeUrlParam(param: string | number | boolean): string;\n    protected get<T>(url: string, config?: {\n        headers: Record<string, string>;\n    }): Promise<T>;\n    protected delete<T>(url: string, config?: {\n        headers: Record<string, string>;\n    }): Promise<T>;\n    protected head<T>(url: string, config?: {\n        headers: Record<string, string>;\n    }): Promise<T>;\n    protected post<T>(url: string, data?: unknown, config?: {\n        headers: Record<string, string>;\n    }): Promise<T>;\n    protected put<T>(url: string, data?: unknown, config?: {\n        headers: Record<string, string>;\n    }): Promise<T>;\n    protected patch<T>(url: string, data?: unknown, config?: {\n        headers: Record<string, string>;\n    }): Promise<T>;\n}\nexport declare function isOptionalString(parameter: string | unknown, parameterInArgs: boolean): parameter is string | undefined;\nexport declare function isOptionalNumber(parameter: number | unknown, parameterInArgs: boolean): parameter is number | undefined;\nexport interface ProjectRole {\n    name: string;\n    permissions: ProjectRolePermissions;\n}\nexport interface ProjectRolePermissions {\n    allLanguages: boolean;\n    languagesAccess: {\n        [lang: string]: {\n            allContent: boolean;\n            workflowStepIds: number[];\n        };\n    };\n}\n```\n\n##### dictionaries/index.d.ts\n\n```typescript\nimport { CrowdinApi, PatchRequest, ResponseList, ResponseObject } from '../core';\nexport declare class Dictionaries extends CrowdinApi {\n    listDictionaries(projectId: number, options?: DictionariesModel.ListDictionariesOptions): Promise<ResponseList<DictionariesModel.Dictionary>>;\n    listDictionaries(projectId: number, languageIds?: string): Promise<ResponseList<DictionariesModel.Dictionary>>;\n    editDictionary(projectId: number, languageId: string, request: PatchRequest[]): Promise<ResponseObject<DictionariesModel.Dictionary>>;\n}\nexport declare namespace DictionariesModel {\n    interface Dictionary {\n        languageId: string;\n        words: string[];\n    }\n    interface ListDictionariesOptions {\n        languageIds?: string;\n    }\n}\n```\n\n##### distributions/index.d.ts\n\n```typescript\nimport { CrowdinApi, PaginationOptions, PatchRequest, ResponseList, ResponseObject } from '../core';\nexport declare class Distributions extends CrowdinApi {\n    listDistributions(projectId: number, options?: PaginationOptions): Promise<ResponseList<DistributionsModel.Distribution>>;\n    listDistributions(projectId: number, limit?: number, offset?: number): Promise<ResponseList<DistributionsModel.Distribution>>;\n    createDistribution(projectId: number, request: DistributionsModel.CreateDistributionRequest | DistributionsModel.CreateDistributionStringsBasedRequest): Promise<ResponseObject<DistributionsModel.Distribution>>;\n    getDistribution(projectId: number, hash: string): Promise<ResponseObject<DistributionsModel.Distribution>>;\n    deleteDistribution(projectId: number, hash: string): Promise<void>;\n    editDistribution(projectId: number, hash: string, request: PatchRequest[]): Promise<ResponseObject<DistributionsModel.Distribution>>;\n    getDistributionRelease(projectId: number, hash: string): Promise<ResponseObject<DistributionsModel.DistributionRelease | DistributionsModel.DistributionStringsBasedRelease>>;\n    createDistributionRelease(projectId: number, hash: string): Promise<ResponseObject<DistributionsModel.DistributionRelease | DistributionsModel.DistributionStringsBasedRelease>>;\n}\nexport declare namespace DistributionsModel {\n    interface Distribution {\n        hash: string;\n        manifestUrl: string;\n        name: string;\n        bundleIds: number[];\n        createdAt: string;\n        updatedAt: string;\n        exportMode: ExportMode;\n        fileIds: number[];\n    }\n    interface CreateDistributionRequest {\n        exportMode?: ExportMode;\n        name: string;\n        fileIds?: number[];\n        bundleIds?: number[];\n    }\n    interface CreateDistributionStringsBasedRequest {\n        name: string;\n        bundleIds: number[];\n    }\n    interface DistributionRelease {\n        status: string;\n        progress: number;\n        currentLanguageId: string;\n        currentFileId: number;\n        date: string;\n    }\n    interface DistributionStringsBasedRelease {\n        status: string;\n        progress: number;\n        currentLanguageId: string;\n        currentBranchId: number;\n        date: string;\n    }\n    type ExportMode = 'default' | 'bundle';\n}\n```\n\n##### fields/index.d.ts\n\n```typescript\nimport { CrowdinApi, PaginationOptions, PatchRequest, ResponseList, ResponseObject } from '../core';\nexport declare class Fields extends CrowdinApi {\n    listFields(options?: FieldsModel.ListFieldsParams): Promise<ResponseList<FieldsModel.Field>>;\n    addField(request: FieldsModel.AddFieldRequest): Promise<ResponseObject<FieldsModel.Field>>;\n    getField(fieldId: number): Promise<ResponseObject<FieldsModel.Field>>;\n    deleteField(fieldId: number): Promise<void>;\n    editField(fieldId: number, request: PatchRequest[]): Promise<ResponseObject<FieldsModel.Field>>;\n}\nexport declare namespace FieldsModel {\n    type Entity = 'project' | 'user' | 'task' | 'file' | 'translation' | 'string';\n    type Type = 'checkbox' | 'radiobuttons' | 'date' | 'datetime' | 'number' | 'labels' | 'select' | 'multiselect' | 'text' | 'textarea' | 'url';\n    type Place = 'projectCreateModal' | 'projectHeader' | 'projectDetails' | 'projectCrowdsourceDetails' | 'projectSettings' | 'projectTaskEditCreate' | 'projectTaskDetails' | 'projectTaskBoardCard' | 'fileDetails' | 'fileSettings' | 'userEditModal' | 'userDetails' | 'userPopover' | 'stringEditModal' | 'stringDetails' | 'translationUnderContent';\n    interface Location {\n        place: Place;\n    }\n    interface Option {\n        label: string;\n        value: string;\n    }\n    interface OtherFieldConfig {\n        locations: Location[];\n    }\n    interface ListFieldConfig extends OtherFieldConfig {\n        options: Option[];\n    }\n    interface NumberFieldConfig extends OtherFieldConfig {\n        min: number;\n        max: number;\n        units: string;\n    }\n    type Config = ListFieldConfig | NumberFieldConfig | OtherFieldConfig;\n    interface ListFieldsParams extends PaginationOptions {\n        search?: string;\n        entity?: Entity;\n        type?: Type;\n    }\n    interface Field {\n        id: number;\n        name: string;\n        slug: string;\n        type: Type;\n        description: string;\n        entities: Entity[];\n        config: Config;\n        createdAt: string;\n        updatedAt: string;\n    }\n    interface AddFieldRequest {\n        name: string;\n        slug: string;\n        type: Type;\n        description?: string;\n        entities: Entity[];\n        config?: Config;\n    }\n}\n```\n\n##### glossaries/index.d.ts\n\n```typescript\nimport { CrowdinApi, DownloadLink, PaginationOptions, PatchRequest, ResponseList, ResponseObject, Status } from '../core';\nexport declare class Glossaries extends CrowdinApi {\n    listGlossaries(options?: GlossariesModel.ListGlossariesOptions): Promise<ResponseList<GlossariesModel.Glossary>>;\n    listGlossaries(groupId?: number, limit?: number, offset?: number): Promise<ResponseList<GlossariesModel.Glossary>>;\n    addGlossary(request: GlossariesModel.CreateGlossaryRequest): Promise<ResponseObject<GlossariesModel.Glossary>>;\n    getGlossary(glossaryId: number): Promise<ResponseObject<GlossariesModel.Glossary>>;\n    deleteGlossary(glossaryId: number): Promise<void>;\n    editGlossary(glossaryId: number, request: PatchRequest[]): Promise<ResponseObject<GlossariesModel.Glossary>>;\n    exportGlossary(glossaryId: number, request: GlossariesModel.ExportGlossaryRequest): Promise<ResponseObject<Status<GlossariesModel.GlossaryExportStatusAttribute>>>;\n    checkGlossaryExportStatus(glossaryId: number, exportId: string): Promise<ResponseObject<Status<GlossariesModel.GlossaryExportStatusAttribute>>>;\n    downloadGlossary(glossaryId: number, exportId: string): Promise<ResponseObject<DownloadLink>>;\n    importGlossaryFile(glossaryId: number, request: GlossariesModel.GlossaryFile): Promise<ResponseObject<Status<GlossariesModel.GlossaryImportStatusAttribute>>>;\n    checkGlossaryImportStatus(glossaryId: number, importId: string): Promise<ResponseObject<Status<GlossariesModel.GlossaryImportStatusAttribute>>>;\n    listTerms(glossaryId: number, options?: GlossariesModel.ListTermsOptions): Promise<ResponseList<GlossariesModel.Term>>;\n    listTerms(glossaryId: number, userId?: number, limit?: number, offset?: number, languageId?: string, translationOfTermId?: number, conceptId?: number): Promise<ResponseList<GlossariesModel.Term>>;\n    addTerm(glossaryId: number, request: GlossariesModel.CreateTermRequest): Promise<ResponseObject<GlossariesModel.Term>>;\n    clearGlossary(glossaryId: number, options?: GlossariesModel.ClearGlossaryOptions): Promise<ResponseObject<GlossariesModel.Term>>;\n    clearGlossary(glossaryId: number, languageId?: number, translationOfTermId?: number, conceptId?: number): Promise<ResponseObject<GlossariesModel.Term>>;\n    getTerm(glossaryId: number, termId: number): Promise<ResponseObject<GlossariesModel.Term>>;\n    deleteTerm(glossaryId: number, termId: number): Promise<void>;\n    editTerm(glossaryId: number, termId: number, request: PatchRequest[]): Promise<ResponseObject<GlossariesModel.Term>>;\n    listConcepts(glossaryId: number, options?: {\n        orderBy?: string;\n    } & PaginationOptions): Promise<ResponseList<GlossariesModel.Concept>>;\n    getConcept(glossaryId: number, conceptId: number): Promise<ResponseObject<GlossariesModel.Concept>>;\n    updateConcept(glossaryId: number, conceptId: number, request: GlossariesModel.UpdateConceptRequest): Promise<ResponseObject<GlossariesModel.Concept>>;\n    deleteConcept(glossaryId: number, conceptId: number): Promise<void>;\n    concordanceSearch(projectId: number, request: GlossariesModel.ConcordanceSearchRequest): Promise<ResponseList<GlossariesModel.ConcordanceSearchResponse>>;\n}\nexport declare namespace GlossariesModel {\n    interface Glossary {\n        id: number;\n        name: string;\n        groupId: number;\n        userId: number;\n        terms: number;\n        languageId: string;\n        languageIds: string[];\n        defaultProjectIds: number[];\n        projectIds: number[];\n        webUrl: string;\n        createdAt: string;\n    }\n    interface CreateGlossaryRequest {\n        name: string;\n        languageId: string;\n        groupId?: number;\n    }\n    type ExportField = 'term' | 'description' | 'partOfSpeech' | 'type' | 'status' | 'gender' | 'note' | 'url' | 'conceptDefinition' | 'conceptSubject' | 'conceptNote' | 'conceptUrl' | 'conceptFigure';\n    interface ExportGlossaryRequest {\n        format?: GlossaryFormat;\n        exportFields?: ExportField[];\n    }\n    interface GlossaryExportStatusAttribute {\n        format: string;\n        exportFields: ExportField[];\n    }\n    interface GlossaryImportStatusAttribute {\n        storageId: number;\n        scheme: unknown;\n        firstLineContainsHeader: boolean;\n    }\n    interface GlossaryFile {\n        storageId: number;\n        scheme?: GlossaryFileScheme;\n        firstLineContainsHeader?: boolean;\n    }\n    interface ListTermsOptions extends PaginationOptions {\n        userId?: number;\n        languageId?: string;\n        conceptId?: number;\n        orderBy?: string;\n        croql?: string;\n        translationOfTermId?: number;\n    }\n    interface Term {\n        id: number;\n        userId: number;\n        glossaryId: number;\n        languageId: string;\n        text: string;\n        description: string;\n        partOfSpeech: PartOfSpeech;\n        status: Status;\n        type: Type;\n        gender: Gender;\n        note: string;\n        url: string;\n        conceptId: number;\n        lemma: string;\n        createdAt: string;\n        updatedAt: string;\n    }\n    interface CreateTermRequest {\n        languageId: string;\n        text: string;\n        description?: string;\n        partOfSpeech?: PartOfSpeech;\n        status?: Status;\n        type?: Type;\n        gender?: Gender;\n        note?: string;\n        url?: string;\n        conceptId?: number;\n        translationOfTermId?: number;\n    }\n    interface ConcordanceSearchRequest extends PaginationOptions {\n        sourceLanguageId: string;\n        targetLanguageId: string;\n        expressions: string[];\n        expression?: string;\n    }\n    interface ConcordanceSearchResponse {\n        glossary: Glossary;\n        concept: Concept;\n        sourceTerms: Term[];\n        targetTerms: Term[];\n    }\n    type Status = 'preferred' | 'admitted' | 'not recommended' | 'obsolete';\n    type Type = 'full form' | 'acronym' | 'abbreviation' | 'short form' | 'phrase' | 'variant';\n    type Gender = 'masculine' | 'feminine' | 'neuter' | 'other';\n    type GlossaryFormat = 'tbx' | 'tbx_v3' | 'csv' | 'xlsx';\n    interface GlossaryFileScheme {\n        [key: string]: number;\n    }\n    type PartOfSpeech = 'adjective' | 'adposition' | 'adverb' | 'auxiliary' | 'coordinating conjunction' | 'determiner' | 'interjection' | 'noun' | 'numeral' | 'particle' | 'pronoun' | 'proper noun' | 'subordinating conjunction' | 'verb' | 'other';\n    interface ListGlossariesOptions extends PaginationOptions {\n        groupId?: number;\n        userId?: number;\n        orderBy?: string;\n    }\n    interface ClearGlossaryOptions {\n        languageId?: number;\n        translationOfTermId?: number;\n        conceptId?: number;\n    }\n    interface Concept {\n        id: number;\n        userId: number;\n        glossaryId: number;\n        subject: string;\n        definition: string;\n        translatable: boolean;\n        note: string;\n        url: string;\n        figure: string;\n        languagesDetails: LanguageDetails[];\n        createdAt: string;\n        updatedAt: string;\n    }\n    interface LanguageDetails {\n        languageId: string;\n        userId: number;\n        definition: string;\n        note: string;\n        createdAt: string;\n        updatedAt: string;\n    }\n    interface UpdateConceptRequest {\n        subject?: string;\n        definition?: string;\n        translatable?: boolean;\n        note?: string;\n        url?: string;\n        figure?: string;\n        languagesDetails?: {\n            languageId: string;\n            definition: string;\n            note?: string;\n        }[];\n    }\n}\n```\n\n##### index.d.ts\n\n```typescript\nimport { Ai } from './ai';\nimport { Applications } from './applications';\nimport { Bundles } from './bundles';\nimport { Clients } from './clients';\nimport { ClientConfig, Credentials, CrowdinApi } from './core';\nimport { Dictionaries } from './dictionaries';\nimport { Distributions } from './distributions';\nimport { Fields } from './fields';\nimport { Glossaries } from './glossaries';\nimport { Issues } from './issues';\nimport { Labels } from './labels';\nimport { Languages } from './languages';\nimport { MachineTranslation } from './machineTranslation';\nimport { Notifications } from './notifications';\nimport { OrganizationWebhooks } from './organizationWebhooks';\nimport { ProjectsGroups } from './projectsGroups';\nimport { Reports } from './reports';\nimport { Screenshots } from './screenshots';\nimport { SecurityLogs } from './securityLogs';\nimport { SourceFiles } from './sourceFiles';\nimport { SourceStrings } from './sourceStrings';\nimport { StringComments } from './stringComments';\nimport { StringCorrections } from './stringCorrections';\nimport { StringTranslations } from './stringTranslations';\nimport { Tasks } from './tasks';\nimport { Teams } from './teams';\nimport { TranslationMemory } from './translationMemory';\nimport { TranslationStatus } from './translationStatus';\nimport { Translations } from './translations';\nimport { UploadStorage } from './uploadStorage';\nimport { Users } from './users';\nimport { Vendors } from './vendors';\nimport { Webhooks } from './webhooks';\nimport { Workflows } from './workflows';\nexport * from './ai';\nexport * from './applications';\nexport * from './bundles';\nexport * from './clients';\nexport * from './core';\nexport * from './dictionaries';\nexport * from './distributions';\nexport * from './fields';\nexport * from './glossaries';\nexport * from './issues';\nexport * from './labels';\nexport * from './languages';\nexport * from './machineTranslation';\nexport * from './notifications';\nexport * from './organizationWebhooks';\nexport * from './projectsGroups';\nexport * from './reports';\nexport * from './screenshots';\nexport * from './securityLogs';\nexport * from './sourceFiles';\nexport * from './sourceStrings';\nexport * from './stringComments';\nexport * from './stringCorrections';\nexport * from './stringTranslations';\nexport * from './tasks';\nexport * from './teams';\nexport * from './translationMemory';\nexport * from './translationStatus';\nexport * from './translations';\nexport * from './uploadStorage';\nexport * from './users';\nexport * from './vendors';\nexport * from './webhooks';\nexport * from './workflows';\nexport default class Client extends CrowdinApi {\n    readonly aiApi: Ai;\n    readonly applicationsApi: Applications;\n    readonly sourceFilesApi: SourceFiles;\n    readonly glossariesApi: Glossaries;\n    readonly languagesApi: Languages;\n    readonly translationsApi: Translations;\n    readonly translationStatusApi: TranslationStatus;\n    readonly projectsGroupsApi: ProjectsGroups;\n    readonly reportsApi: Reports;\n    readonly screenshotsApi: Screenshots;\n    readonly sourceStringsApi: SourceStrings;\n    readonly uploadStorageApi: UploadStorage;\n    readonly tasksApi: Tasks;\n    readonly translationMemoryApi: TranslationMemory;\n    readonly webhooksApi: Webhooks;\n    readonly organizationWebhooksApi: OrganizationWebhooks;\n    readonly machineTranslationApi: MachineTranslation;\n    readonly stringTranslationsApi: StringTranslations;\n    readonly workflowsApi: Workflows;\n    readonly usersApi: Users;\n    readonly vendorsApi: Vendors;\n    readonly issuesApi: Issues;\n    readonly teamsApi: Teams;\n    readonly distributionsApi: Distributions;\n    readonly dictionariesApi: Dictionaries;\n    readonly labelsApi: Labels;\n    readonly stringCommentsApi: StringComments;\n    readonly bundlesApi: Bundles;\n    readonly notificationsApi: Notifications;\n    readonly clientsApi: Clients;\n    readonly securityLogsApi: SecurityLogs;\n    readonly fieldsApi: Fields;\n    readonly stringCorrectionsApi: StringCorrections;\n    constructor(credentials: Credentials, config?: ClientConfig);\n}\nexport { Client };\n```\n\n##### issues/index.d.ts\n\n```typescript\nimport { CrowdinApi, PaginationOptions, PatchRequest, ResponseList, ResponseObject } from '../core';\nexport declare class Issues extends CrowdinApi {\n    listReportedIssues(projectId: number, options?: IssuesModel.ListReportedIssuesOptions): Promise<ResponseList<IssuesModel.Issue>>;\n    listReportedIssues(projectId: number, limit?: number, offset?: number, type?: IssuesModel.Type, status?: IssuesModel.Status): Promise<ResponseList<IssuesModel.Issue>>;\n    editIssue(projectId: number, issueId: number, request: PatchRequest[]): Promise<ResponseObject<IssuesModel.Issue>>;\n}\nexport declare namespace IssuesModel {\n    type Type = 'all' | 'general_question' | 'translation_mistake' | 'context_request' | 'source_mistake';\n    type Status = 'all' | 'resolved' | 'unresolved';\n    interface Issue {\n        id: number;\n        text: string;\n        userId: number;\n        stringId: number;\n        user: User;\n        string: string;\n        languageId: string;\n        type: Type;\n        status: Status;\n        createdAt: string;\n    }\n    interface User {\n        id: number;\n        username: string;\n        fullName: string;\n        avatarUrl: string;\n    }\n    interface String {\n        id: number;\n        text: string;\n        type: string;\n        hasPlurals: boolean;\n        isIcu: boolean;\n        context: string;\n        fileId: number;\n    }\n    interface ListReportedIssuesOptions extends PaginationOptions {\n        type?: IssuesModel.Type;\n        status?: IssuesModel.Status;\n    }\n}\n```\n\n##### labels/index.d.ts\n\n```typescript\nimport { CrowdinApi, PaginationOptions, PatchRequest, ResponseList, ResponseObject } from '../core';\nimport { ScreenshotsModel } from '../screenshots';\nimport { SourceStringsModel } from '../sourceStrings';\nexport declare class Labels extends CrowdinApi {\n    listLabels(projectId: number, options?: LabelsModel.ListLabelsParams): Promise<ResponseList<LabelsModel.Label>>;\n    listLabels(projectId: number, limit?: number, offset?: number): Promise<ResponseList<LabelsModel.Label>>;\n    addLabel(projectId: number, request: LabelsModel.AddLabelRequest): Promise<ResponseObject<LabelsModel.Label>>;\n    getLabel(projectId: number, labelId: number): Promise<ResponseObject<LabelsModel.Label>>;\n    deleteLabel(projectId: number, labelId: number): Promise<void>;\n    editLabel(projectId: number, labelId: number, request: PatchRequest[]): Promise<ResponseObject<LabelsModel.Label>>;\n    assignLabelToScreenshots(projectId: number, labelId: number, request: LabelsModel.AssignLabelToScreenshotsRequet): Promise<ResponseList<ScreenshotsModel.Screenshot>>;\n    unassignLabelFromScreenshots(projectId: number, labelId: number, screenshotIds: string): Promise<ResponseList<ScreenshotsModel.Screenshot>>;\n    assignLabelToString(projectId: number, labelId: number, request: LabelsModel.AssignLabelToStringsRequet): Promise<ResponseList<SourceStringsModel.String>>;\n    unassignLabelFromString(projectId: number, labelId: number, stringIds: string): Promise<ResponseList<SourceStringsModel.String>>;\n}\nexport declare namespace LabelsModel {\n    interface ListLabelsParams extends PaginationOptions {\n        orderBy?: string;\n    }\n    interface Label {\n        id: number;\n        title: string;\n        isSystem?: boolean;\n    }\n    interface AddLabelRequest {\n        title: string;\n    }\n    interface AssignLabelToStringsRequet {\n        stringIds: number[];\n    }\n    interface AssignLabelToScreenshotsRequet {\n        screenshotIds: number[];\n    }\n}\n```\n\n##### languages/index.d.ts\n\n```typescript\nimport { CrowdinApi, PaginationOptions, PatchRequest, ResponseList, ResponseObject } from '../core';\nexport declare class Languages extends CrowdinApi {\n    listSupportedLanguages(options?: PaginationOptions): Promise<ResponseList<LanguagesModel.Language>>;\n    listSupportedLanguages(limit?: number, offset?: number): Promise<ResponseList<LanguagesModel.Language>>;\n    addCustomLanguage(request: LanguagesModel.AddLanguageRequest): Promise<ResponseObject<LanguagesModel.Language>>;\n    getLanguage(languageId: string): Promise<ResponseObject<LanguagesModel.Language>>;\n    deleteCustomLanguage(languageId: string): Promise<void>;\n    editCustomLanguage(languageId: string, request: PatchRequest[]): Promise<ResponseObject<LanguagesModel.Language>>;\n}\nexport declare namespace LanguagesModel {\n    interface Language {\n        id: string;\n        name: string;\n        editorCode: string;\n        twoLettersCode: string;\n        threeLettersCode: string;\n        locale: string;\n        androidCode: string;\n        osxCode: string;\n        osxLocale: string;\n        pluralCategoryNames: string[];\n        pluralRules: string;\n        pluralExamples: string[];\n        textDirection: TextDirection;\n        dialectOf: string;\n    }\n    interface AddLanguageRequest {\n        name: string;\n        code: string;\n        localeCode: string;\n        textDirection: TextDirection;\n        pluralCategoryNames: string[];\n        threeLettersCode: string;\n        twoLettersCode?: string;\n        dialectOf?: string;\n    }\n    type TextDirection = 'ltr' | 'rtl';\n}\n```\n\n##### machineTranslation/index.d.ts\n\n```typescript\nimport { CrowdinApi, PaginationOptions, PatchRequest, ResponseList, ResponseObject } from '../core';\nexport declare class MachineTranslation extends CrowdinApi {\n    listMts(options?: MachineTranslationModel.ListMTsOptions): Promise<ResponseList<MachineTranslationModel.MachineTranslation>>;\n    listMts(groupId?: number, limit?: number, offset?: number): Promise<ResponseList<MachineTranslationModel.MachineTranslation>>;\n    createMt(request: MachineTranslationModel.CreateMachineTranslationRequest): Promise<ResponseObject<MachineTranslationModel.MachineTranslation>>;\n    getMt(mtId: number): Promise<ResponseObject<MachineTranslationModel.MachineTranslation>>;\n    deleteMt(mtId: number): Promise<void>;\n    updateMt(mtId: number, request: PatchRequest[]): Promise<ResponseObject<MachineTranslationModel.MachineTranslation>>;\n    translate(mtId: number, request: MachineTranslationModel.TranslateRequest): Promise<ResponseObject<MachineTranslationModel.TranslateResponse>>;\n}\nexport declare namespace MachineTranslationModel {\n    interface MachineTranslation {\n        id: number;\n        groupId: number;\n        name: string;\n        type: number;\n        credentials: Credentials;\n        projectIds: number[];\n        supportedLanguageIds: string[];\n        supportedLanguagePairs: Record<string, string[]>;\n        enabledLanguageIds: string[];\n        enabledProjectIds: number[];\n        isEnabled: boolean;\n    }\n    type Credentials = {\n        apiKey: string;\n    } | {\n        credentials: string;\n    } | {\n        model: string;\n        apiKey: string;\n    } | {\n        isSystemCredentials: boolean;\n        apiKey: string;\n    } | {\n        endpoint: string;\n        apiKey: string;\n    } | {\n        url: string;\n    } | {\n        accessKey: string;\n        secretKey: string;\n    };\n    interface CreateMachineTranslationRequest {\n        name: string;\n        type: string;\n        credentials: Credentials;\n        groupId?: number;\n        enabledLanguageIds?: string[];\n        enabledProjectIds?: number[];\n        isEnabled?: boolean;\n    }\n    interface TranslateRequest {\n        languageRecognitionProvider?: LanguageRecognitionProvider;\n        sourceLanguageId?: string;\n        targetLanguageId: string;\n        strings?: string[];\n    }\n    interface TranslateResponse {\n        sourceLanguageId: string;\n        targetLanguageId: string;\n        strings: string[];\n        translations: string[];\n    }\n    type LanguageRecognitionProvider = 'crowdin' | 'engine';\n    interface ListMTsOptions extends PaginationOptions {\n        groupId?: number;\n    }\n}\n```\n\n##### notifications/index.d.ts\n\n```typescript\nimport { CrowdinApi } from '../core';\nexport declare class Notifications extends CrowdinApi {\n    sendNotificationToAuthenticatedUser(request: NotificationsModel.Notification): Promise<void>;\n    sendNotificationToProjectMembers(projectId: number, request: NotificationsModel.NotificationByUsers | NotificationsModel.NotificationByRole): Promise<void>;\n    sendNotificationToOrganizationMembers(request: NotificationsModel.Notification | NotificationsModel.NotificationByUsers | NotificationsModel.NotificationByRole): Promise<void>;\n}\nexport declare namespace NotificationsModel {\n    interface Notification {\n        message: string;\n    }\n    interface NotificationByUsers extends Notification {\n        userIds: number[];\n    }\n    interface NotificationByRole extends Notification {\n        role: 'owner' | 'admin';\n    }\n}\n```\n\n##### organizationWebhooks/index.d.ts\n\n```typescript\nimport { CrowdinApi, PaginationOptions, PatchRequest, ResponseList, ResponseObject } from '../core';\nimport { WebhooksModel } from '../webhooks';\nexport declare class OrganizationWebhooks extends CrowdinApi {\n    listWebhooks(options?: PaginationOptions): Promise<ResponseList<OrganizationWebhooksModel.OrganizationWebhook>>;\n    addWebhook(request: OrganizationWebhooksModel.AddOrganizationWebhookRequest): Promise<ResponseObject<OrganizationWebhooksModel.OrganizationWebhook>>;\n    getWebhook(webhookId: number): Promise<ResponseObject<OrganizationWebhooksModel.OrganizationWebhook>>;\n    deleteWebhook(webhookId: number): Promise<void>;\n    editWebhook(webhookId: number, request: PatchRequest[]): Promise<ResponseObject<OrganizationWebhooksModel.OrganizationWebhook>>;\n}\nexport declare namespace OrganizationWebhooksModel {\n    type OrganizationWebhook = Omit<WebhooksModel.Webhook, 'projectId' | 'events'> & {\n        events: Event[];\n    };\n    type AddOrganizationWebhookRequest = Omit<WebhooksModel.AddWebhookRequest, 'events'> & {\n        events: Event[];\n    };\n    type Event = 'group.created' | 'group.deleted' | 'project.created' | 'project.deleted';\n}\n```\n\n##### projectsGroups/index.d.ts\n\n```typescript\nimport { BooleanInt, CrowdinApi, DownloadLink, PaginationOptions, PatchRequest, ResponseList, ResponseObject } from '../core';\nimport { LanguagesModel } from '../languages';\nexport declare class ProjectsGroups extends CrowdinApi {\n    listGroups(options?: ProjectsGroupsModel.ListGroupsOptions): Promise<ResponseList<ProjectsGroupsModel.Group>>;\n    listGroups(parentId?: number, offset?: number, userId?: number, limit?: number): Promise<ResponseList<ProjectsGroupsModel.Group>>;\n    addGroup(request: ProjectsGroupsModel.AddGroupRequest): Promise<ResponseObject<ProjectsGroupsModel.Group>>;\n    getGroup(groupId: number): Promise<ResponseObject<ProjectsGroupsModel.Group>>;\n    deleteGroup(groupId: number): Promise<void>;\n    editGroup(groupId: number, request: PatchRequest[]): Promise<ResponseObject<ProjectsGroupsModel.Group>>;\n    listProjects(options?: ProjectsGroupsModel.ListProjectsOptions): Promise<ResponseList<ProjectsGroupsModel.Project | ProjectsGroupsModel.ProjectSettings>>;\n    listProjects(groupId?: number, hasManagerAccess?: BooleanInt, limit?: number, offset?: number): Promise<ResponseList<ProjectsGroupsModel.Project | ProjectsGroupsModel.ProjectSettings>>;\n    addProject(request: ProjectsGroupsModel.CreateProjectEnterpriseRequest | ProjectsGroupsModel.CreateProjectRequest): Promise<ResponseObject<ProjectsGroupsModel.Project | ProjectsGroupsModel.ProjectSettings>>;\n    getProject(projectId: number): Promise<ResponseObject<ProjectsGroupsModel.Project | ProjectsGroupsModel.ProjectSettings>>;\n    deleteProject(projectId: number): Promise<void>;\n    editProject(projectId: number, request: PatchRequest[]): Promise<ResponseObject<ProjectsGroupsModel.Project | ProjectsGroupsModel.ProjectSettings>>;\n    downloadProjectFileFormatSettingsCustomSegmentation(projectId: number, fileFormatSettingsId: number): Promise<ResponseObject<DownloadLink>>;\n    resetProjectFileFormatSettingsCustomSegmentation(projectId: number, fileFormatSettingsId: number): Promise<ResponseObject<DownloadLink>>;\n    listProjectFileFormatSettings(projectId: number, options?: PaginationOptions): Promise<ResponseList<ProjectsGroupsModel.ProjectFileFormatSettings>>;\n    addProjectFileFormatSettings(projectId: number, request: ProjectsGroupsModel.AddProjectFileFormatSettingsRequest): Promise<ResponseObject<ProjectsGroupsModel.ProjectFileFormatSettings>>;\n    getProjectFileFormatSettings(projectId: number, fileFormatSettingsId: number): Promise<ResponseObject<ProjectsGroupsModel.ProjectFileFormatSettings>>;\n    deleteProjectFileFormatSettings(projectId: number, fileFormatSettingsId: number): Promise<void>;\n    editProjectFileFormatSettings(projectId: number, fileFormatSettingsId: number, request: PatchRequest[]): Promise<ResponseObject<ProjectsGroupsModel.ProjectFileFormatSettings>>;\n    listProjectStringsExporterSettings(projectId: number, options?: PaginationOptions): Promise<ResponseList<ProjectsGroupsModel.ProjectStringsExporterSettings>>;\n    addProjectStringsExporterSettings(projectId: number, request: ProjectsGroupsModel.AddProjectStringsExporterSettingsRequest): Promise<ResponseObject<ProjectsGroupsModel.ProjectStringsExporterSettings>>;\n    getProjectStringsExporterSettings(projectId: number, systemStringsExporterSettingsId: number): Promise<ResponseObject<ProjectsGroupsModel.ProjectStringsExporterSettings>>;\n    deleteProjectStringsExporterSettings(projectId: number, systemStringsExporterSettingsId: number): Promise<void>;\n    editProjectStringsExporterSettings(projectId: number, systemStringsExporterSettingsId: number, request: ProjectsGroupsModel.AddProjectStringsExporterSettingsRequest): Promise<ResponseObject<ProjectsGroupsModel.ProjectStringsExporterSettings>>;\n}\nexport declare namespace ProjectsGroupsModel {\n    interface Group {\n        id: number;\n        name: string;\n        description: string;\n        parentId: number;\n        organizationId: number;\n        userId: number;\n        subgroupsCount: number;\n        projectsCount: number;\n        webUrl: string;\n        createdAt: string;\n        updatedAt: string;\n    }\n    interface AddGroupRequest {\n        name: string;\n        parentId?: number;\n        description?: string;\n    }\n    interface Project {\n        id: number;\n        type: Type;\n        userId: number;\n        sourceLanguageId: string;\n        targetLanguageIds: string[];\n        languageAccessPolicy: LanguageAccessPolicy;\n        name: string;\n        identifier: string;\n        description: string;\n        visibility: string;\n        logo: string;\n        publicDownloads: boolean;\n        createdAt: string;\n        updatedAt: string;\n        lastActivity: string;\n        sourceLanguage: LanguagesModel.Language;\n        targetLanguages: LanguagesModel.Language[];\n        webUrl: string;\n        savingsReportSettingsTemplateId: number;\n        fields: Record<string, any>;\n        cname: string;\n        groupId: number;\n        background: string;\n        isExternal: boolean;\n        externalType: string;\n        externalProjectId: number;\n        externalOrganizationId: number;\n        workflowId: number;\n        hasCrowdsourcing: boolean;\n        publicUrl: string;\n    }\n    interface CreateProjectRequest {\n        name: string;\n        identifier: string;\n        sourceLanguageId: string;\n        targetLanguageIds?: string[];\n        visibility?: JoinPolicy;\n        languageAccessPolicy?: LanguageAccessPolicy;\n        cname?: string;\n        description?: string;\n        tagDetection?: TagDetection;\n        isMtAllowed?: boolean;\n        taskBasedAccessControl?: boolean;\n        autoSubstitution?: boolean;\n        autoTranslateDialects?: boolean;\n        publicDownloads?: boolean;\n        hiddenStringsProofreadersAccess?: boolean;\n        useGlobalTm?: boolean;\n        showTmSuggestionsDialects?: boolean;\n        tmApprovedSuggestionsOnly?: boolean;\n        skipUntranslatedStrings?: boolean;\n        exportApprovedOnly?: boolean;\n        qaCheckIsActive?: boolean;\n        qaCheckCategories?: CheckCategories;\n        qaChecksIgnorableCategories?: CheckCategories;\n        languageMapping?: LanguageMapping;\n        glossaryAccess?: boolean;\n        glossaryAccessOption?: GlossaryAccessOption;\n        normalizePlaceholder?: boolean;\n        notificationSettings?: NotificationSettings;\n        tmPreTranslate?: ProjectSettings['tmPreTranslate'];\n        mtPreTranslate?: ProjectSettings['mtPreTranslate'];\n        aiPreTranslate?: ProjectSettings['aiPreTranslate'];\n        assistActionAiPromptId?: number;\n        editorSuggestionAiPromptId?: number;\n        savingsReportSettingsTemplateId?: number;\n        defaultTmId?: number;\n        defaultGlossaryId?: number;\n        inContext?: boolean;\n        inContextProcessHiddenStrings?: boolean;\n        inContextPseudoLanguageId?: string;\n        saveMetaInfoInSource?: boolean;\n        type?: BooleanInt;\n        skipUntranslatedFiles?: boolean;\n        tmContextType?: TmContextType;\n    }\n    interface CreateProjectEnterpriseRequest {\n        name: string;\n        sourceLanguageId: string;\n        templateId?: number;\n        steps?: WorkflowTemplateStepConfig[];\n        groupId?: number;\n        targetLanguageIds?: string[];\n        vendorId?: number;\n        mtEngineId?: number;\n        description?: string;\n        translateDuplicates?: TranslateDuplicates;\n        tagsDetection?: TagDetection;\n        isMtAllowed?: boolean;\n        taskBasedAccessControl?: boolean;\n        taskReviewerIds?: number[];\n        autoSubstitution?: boolean;\n        showTmSuggestionsDialects?: boolean;\n        tmApprovedSuggestionsOnly?: boolean;\n        autoTranslateDialects?: boolean;\n        publicDownloads?: boolean;\n        hiddenStringsProofreadersAccess?: boolean;\n        delayedWorkflowStart?: boolean;\n        skipUntranslatedStrings?: boolean;\n        exportWithMinApprovalsCount?: number;\n        exportStringsThatPassedWorkflow?: number;\n        normalizePlaceholder?: boolean;\n        qaCheckIsActive?: boolean;\n        qaApprovalsCount?: number;\n        qaCheckCategories?: CheckCategories;\n        qaChecksIgnorableCategories?: CheckCategories;\n        customQaCheckIds?: number[];\n        languageMapping?: LanguageMapping;\n        glossaryAccess?: boolean;\n        glossaryAccessOption?: GlossaryAccessOption;\n        notificationSettings?: NotificationSettings;\n        savingsReportSettingsTemplateId?: number;\n        fields?: Record<string, any>;\n        assistActionAiPromptId?: number;\n        editorSuggestionAiPromptId?: number;\n        alignmentActionAiPromptId?: number;\n        defaultTmId?: number;\n        defaultGlossaryId?: number;\n        inContext?: boolean;\n        inContextProcessHiddenStrings?: boolean;\n        inContextPseudoLanguageId?: string;\n        saveMetaInfoInSource?: boolean;\n        type?: BooleanInt;\n        skipUntranslatedFiles?: boolean;\n        tmContextType?: TmContextType;\n    }\n    type GlossaryAccessOption = 'readOnly' | 'fullAccess' | 'manageDrafts';\n    interface ProjectSettings extends Project {\n        translateDuplicates: TranslateDuplicates;\n        tagsDetection: TagDetection;\n        glossaryAccess: boolean;\n        glossaryAccessOption: GlossaryAccessOption;\n        isMtAllowed: boolean;\n        taskBasedAccessControl: boolean;\n        hiddenStringsProofreadersAccess: boolean;\n        autoSubstitution: boolean;\n        exportTranslatedOnly: boolean;\n        skipUntranslatedStrings: boolean;\n        exportApprovedOnly: boolean;\n        autoTranslateDialects: boolean;\n        useGlobalTm: boolean;\n        showTmSuggestionsDialects: boolean;\n        tmApprovedSuggestionsOnly: boolean;\n        isSuspended: boolean;\n        qaCheckIsActive: boolean;\n        qaCheckCategories: CheckCategories;\n        qaChecksIgnorableCategories: CheckCategories;\n        languageMapping: LanguageMapping;\n        notificationSettings: NotificationSettings;\n        defaultTmId: number;\n        defaultGlossaryId: number;\n        assignedTms: {\n            [id: string]: {\n                priority: number;\n            };\n        };\n        assignedGlossaries: number[];\n        tmPenalties: {\n            autoSubstitution: number;\n            tmPriority: {\n                priority: number;\n                penalty: number;\n            };\n            multipleTranslations: number;\n            timeSinceLastUsage: {\n                months: number;\n                penalty: number;\n            };\n            timeSinceLastModified: {\n                months: number;\n                penalty: number;\n            };\n        };\n        normalizePlaceholder: boolean;\n        tmPreTranslate: {\n            enabled: boolean;\n            autoApproveOption: 'all' | 'perfectMatchOnly' | 'exceptAutoSubstituted' | 'perfectMatchApprovedOnly' | 'none';\n            minimumMatchRatio: 'perfect' | '100';\n        };\n        mtPreTranslate: {\n            enabled: boolean;\n            mts: {\n                mtId: number;\n                languageIds: string[];\n            }[];\n        };\n        aiPreTranslate: {\n            enabled: boolean;\n            aiPrompts: {\n                aiPromptId: number;\n                languageIds: string[];\n            }[];\n        };\n        assistActionAiPromptId: number;\n        editorSuggestionAiPromptId: number;\n        inContext: boolean;\n        inContextProcessHiddenStrings: string;\n        inContextPseudoLanguageId: string;\n        inContextPseudoLanguage: LanguagesModel.Language;\n        saveMetaInfoInSource: boolean;\n        skipUntranslatedFiles: boolean;\n        tmContextType: TmContextType;\n        clientOrganizationId: number;\n        taskReviewerIds: number[];\n        exportWithMinApprovalsCount: number;\n        exportStringsThatPassedWorkflow: boolean;\n        qaApprovalsCount: number;\n        customQaCheckIds: number[];\n        externalQaCheckIds: number[];\n        delayedWorkflowStart: boolean;\n        alignmentActionAiPromptId: number;\n    }\n    enum Type {\n        FILES_BASED = 0,\n        STRINGS_BASED = 1\n    }\n    enum TagDetection {\n        AUTO = 0,\n        COUNT_TAGS = 1,\n        SKIP_TAGS = 2\n    }\n    type JoinPolicy = 'open' | 'private';\n    type LanguageAccessPolicy = 'open' | 'moderate';\n    interface CheckCategories {\n        empty: boolean;\n        size: boolean;\n        tags: boolean;\n        spaces: boolean;\n        variables: boolean;\n        punctuation: boolean;\n        symbolRegister: boolean;\n        specialSymbols: boolean;\n        wrongTranslation: boolean;\n        spellcheck: boolean;\n        icu: boolean;\n        terms: boolean;\n        duplicate: boolean;\n        ftl: boolean;\n        android: boolean;\n    }\n    interface LanguageMapping {\n        [key: string]: LanguageMappingEntity;\n    }\n    interface LanguageMappingEntity {\n        name: string;\n        two_letters_code: string;\n        three_letters_code: string;\n        locale: string;\n        locale_with_underscore: string;\n        android_code: string;\n        osx_code: string;\n        osx_locale: string;\n    }\n    enum TranslateDuplicates {\n        SHOW = 0,\n        HIDE_REGULAR_DETECTION = 1,\n        SHOW_AUTO_TRANSLATE = 2,\n        SHOW_WITHIN_VERION_BRANCH_REGULAR_DETECTION = 3,\n        HIDE_STRICT_DETECTION = 4,\n        SHOW_WITHIN_VERION_BRANCH_STRICT_DETECTION = 5\n    }\n    interface NotificationSettings {\n        translatorNewStrings?: boolean;\n        managerNewStrings?: boolean;\n        managerLanguageCompleted?: boolean;\n    }\n    interface ListGroupsOptions extends PaginationOptions {\n        parentId?: number;\n        userId?: number;\n        orderBy?: string;\n    }\n    interface ListProjectsOptions extends PaginationOptions {\n        groupId?: number;\n        hasManagerAccess?: BooleanInt;\n        orderBy?: string;\n        type?: BooleanInt;\n    }\n    type Settings = PropertyFileFormatSettings | CommonFileFormatSettings | XmlFileFormatSettings | MdxV2FormatSettings | FmHtmlFormatSettings | HtmlFormatSettings | JsonFormatSettings | MdxV1FormatSettings | JavaScriptFileFormatSettings | DocxFileFormatSettings;\n    interface ProjectFileFormatSettings {\n        id: number;\n        name: string;\n        format: string;\n        extensions: string[];\n        settings: Settings;\n        createdAt: string;\n        updatedAt: string;\n    }\n    interface AddProjectFileFormatSettingsRequest {\n        format: string;\n        settings: Settings;\n    }\n    interface PropertyFileFormatSettings {\n        escapeQuotes?: 0 | 1 | 2 | 3;\n        escapeSpecialCharacters?: 0 | 1;\n        exportPattern?: string;\n    }\n    interface JavaScriptFileFormatSettings {\n        exportPattern?: 'string';\n        exportQuotes?: 'single' | 'double';\n    }\n    interface CommonFileFormatSettings {\n        contentSegmentation?: boolean;\n        srxStorageId?: number;\n        exportPattern?: string;\n    }\n    interface XmlFileFormatSettings extends CommonFileFormatSettings {\n        translateContent?: boolean;\n        translateAttributes?: boolean;\n        translatableElements?: string[];\n    }\n    interface JsonFormatSettings extends CommonFileFormatSettings {\n        type?: 'i18next_json' | 'nestjs_i18n';\n    }\n    interface MdxV2FormatSettings extends CommonFileFormatSettings {\n        excludeCodeBlocks?: boolean;\n        excludedFrontMatterElements?: string[];\n    }\n    interface MdxV1FormatSettings extends CommonFileFormatSettings {\n        excludeCodeBlocks?: boolean;\n        excludedFrontMatterElements?: string[];\n        type?: 'mdx_v1' | 'mdx_v2';\n    }\n    interface FmHtmlFormatSettings extends CommonFileFormatSettings {\n        excludedElements?: boolean;\n        excludedFrontMatterElements?: string[];\n    }\n    interface HtmlFormatSettings extends CommonFileFormatSettings {\n        excludedElements?: boolean;\n    }\n    interface DocxFileFormatSettings extends CommonFileFormatSettings {\n        cleanTagsAggressively?: boolean;\n        translateHiddenText?: boolean;\n        translateHyperlinkUrls?: boolean;\n        translateHiddenRowsAndColumns?: boolean;\n        importNotes?: boolean;\n        importHiddenSlides?: boolean;\n    }\n    type TmContextType = 'segmentContext' | 'auto' | 'prevAndNextSegment';\n    type WorkflowTemplateStepConfig = WorkflowTemplateStepConfigTranslateProofread | WorkflowTemplateStepConfigVendor | WorkflowTemplateStepConfigTMPreTranslate | WorkflowTemplateStepConfigMTPreTranslate;\n    interface WorkflowTemplateStepConfigTranslateProofread {\n        id: number;\n        languages?: string[];\n        assignees?: number[];\n        config?: {\n            assignees: {\n                [key: string]: number[];\n            };\n        };\n    }\n    interface WorkflowTemplateStepConfigVendor {\n        id: number;\n        languages?: string[];\n        vendorId?: number;\n    }\n    interface WorkflowTemplateStepConfigTMPreTranslate {\n        id: number;\n        languages?: string[];\n        config?: {\n            minRelevant?: number;\n            autoSubstitution?: boolean;\n        };\n    }\n    interface WorkflowTemplateStepConfigMTPreTranslate {\n        id: number;\n        languages?: string[];\n        mtId?: number;\n    }\n    type StringsExporterSettings = AndroidStringsExporterSettings | MacOSXStringsExporterSettings | XliffStringsExporterSettings;\n    interface ProjectStringsExporterSettings {\n        id: number;\n        format: string;\n        settings: StringsExporterSettings;\n        createdAt: string;\n        updatedAt: string;\n    }\n    interface AndroidStringsExporterSettings {\n        convertPlaceholders?: boolean;\n        convertLineBreaks?: boolean;\n        useCdataForStringsWithTags?: boolean;\n    }\n    interface MacOSXStringsExporterSettings {\n        convertPlaceholders?: boolean;\n        convertLineBreaks?: boolean;\n    }\n    interface XliffStringsExporterSettings {\n        languagePairMapping?: {\n            [key: string]: {\n                sourceLanguageId: string;\n            };\n        };\n        copySourceToEmptyTarget?: boolean;\n        exportTranslatorsComment?: boolean;\n    }\n    interface AddProjectStringsExporterSettingsRequest {\n        format: string;\n        settings: StringsExporterSettings;\n    }\n}\n```\n\n##### reports/index.d.ts\n\n```typescript\nimport { CrowdinApi, DownloadLink, PaginationOptions, PatchRequest, ResponseList, ResponseObject, Status } from '../core';\nexport declare class Reports extends CrowdinApi {\n    listOrganizationReportArchives(options?: ReportsModel.ListReportArchiveParams): Promise<ResponseList<ReportsModel.ReportArchive>>;\n    getOrganizationReportArchive(archiveId: number): Promise<ResponseObject<ReportsModel.ReportArchive>>;\n    deleteOrganizationReportArchive(archiveId: number): Promise<void>;\n    exportOrganizationReportArchive(archiveId: number, request?: {\n        format?: ReportsModel.Format;\n    }): Promise<ResponseObject<Status<ReportsModel.ReportArchiveStatusAttribute>>>;\n    checkOrganizationReportArchiveStatus(archiveId: number, exportId: string): Promise<ResponseObject<Status<ReportsModel.ReportArchiveStatusAttribute>>>;\n    downloadOrganizationReportArchive(archiveId: number, exportId: string): Promise<ResponseObject<DownloadLink>>;\n    listUserReportArchives(userId: number, options?: ReportsModel.ListReportArchiveParams): Promise<ResponseList<ReportsModel.ReportArchive>>;\n    getUserReportArchive(userId: number, archiveId: number): Promise<ResponseObject<ReportsModel.ReportArchive>>;\n    deleteUserReportArchive(userId: number, archiveId: number): Promise<void>;\n    exportUserReportArchive(userId: number, archiveId: number, request?: {\n        format?: ReportsModel.Format;\n    }): Promise<ResponseObject<Status<ReportsModel.ReportArchiveStatusAttribute>>>;\n    checkUserReportArchiveStatus(userId: number, archiveId: number, exportId: string): Promise<ResponseObject<Status<ReportsModel.ReportArchiveStatusAttribute>>>;\n    downloadUserReportArchive(userId: number, archiveId: number, exportId: string): Promise<ResponseObject<DownloadLink>>;\n    generateGroupReport(groupId: number, request: ReportsModel.GenerateGroupReportRequest): Promise<ResponseObject<Status<ReportsModel.ReportStatusAttributes<ReportsModel.GroupReportSchema>>>>;\n    checkGroupReportStatus(groupId: number, reportId: string): Promise<ResponseObject<Status<ReportsModel.ReportStatusAttributes<ReportsModel.GroupReportSchema>>>>;\n    downloadGroupReport(groupId: number, reportId: string): Promise<ResponseObject<DownloadLink>>;\n    listOrganizationReportSettingsTemplates(options?: ReportsModel.ListOrganizationReportSettingsParams): Promise<ResponseList<ReportsModel.OrganizationReportSettings>>;\n    addOrganizationReportSettingsTemplate(request: ReportsModel.AddOrganizationReportSettingsRequest): Promise<ResponseObject<ReportsModel.OrganizationReportSettings>>;\n    getOrganizationReportSettingsTemplate(reportSettingsTemplateId: number): Promise<ResponseObject<ReportsModel.OrganizationReportSettings>>;\n    editOrganizationReportSettingsTemplate(reportSettingsTemplateId: number, request: PatchRequest[]): Promise<ResponseObject<ReportsModel.OrganizationReportSettings>>;\n    deleteOrganizationReportSettingsTemplate(reportSettingsTemplateId: number): Promise<void>;\n    generateOrganizationReport(request: ReportsModel.GenerateOrganizationReportRequest): Promise<ResponseObject<Status<ReportsModel.ReportStatusAttributes<ReportsModel.OrganizationReportSchema>>>>;\n    checkOrganizationReportStatus(reportId: string): Promise<ResponseObject<Status<ReportsModel.ReportStatusAttributes<ReportsModel.OrganizationReportSchema>>>>;\n    downloadOrganizationReport(reportId: string): Promise<ResponseObject<DownloadLink>>;\n    generateReport(projectId: number, request: ReportsModel.GenerateReportRequest): Promise<ResponseObject<Status<ReportsModel.ReportStatusAttributes<ReportsModel.ReportSchema>>>>;\n    checkReportStatus(projectId: number, reportId: string): Promise<ResponseObject<Status<ReportsModel.ReportStatusAttributes<ReportsModel.ReportSchema>>>>;\n    downloadReport(projectId: number, reportId: string): Promise<ResponseObject<DownloadLink>>;\n    listReportSettingsTemplates(projectId: number, options?: PaginationOptions): Promise<ResponseList<ReportsModel.ReportSettings>>;\n    addReportSettingsTemplate(projectId: number, request: ReportsModel.AddReportSettingsRequest): Promise<ResponseObject<ReportsModel.ReportSettings>>;\n    getReportSettingsTemplate(projectId: number, reportSettingsTemplateId: number): Promise<ResponseObject<ReportsModel.ReportSettings>>;\n    editReportSettingsTemplate(projectId: number, reportSettingsTemplateId: number, request: PatchRequest[]): Promise<ResponseObject<ReportsModel.ReportSettings>>;\n    deleteReportSettingsTemplate(projectId: number, reportSettingsTemplateId: number): Promise<void>;\n    listUserReportSettingsTemplates(userId: number, options?: PaginationOptions): Promise<ResponseList<ReportsModel.UserReportSettings>>;\n    addUserReportSettingsTemplate(userId: number, request: ReportsModel.AddUserReportSettingsRequest): Promise<ResponseObject<ReportsModel.UserReportSettings>>;\n    getUserReportSettingsTemplate(userId: number, reportSettingsTemplateId: number): Promise<ResponseObject<ReportsModel.UserReportSettings>>;\n    editUserReportSettingsTemplate(userId: number, reportSettingsTemplateId: number, request: PatchRequest[]): Promise<ResponseObject<ReportsModel.UserReportSettings>>;\n    deleteUserReportSettingsTemplate(userId: number, reportSettingsTemplateId: number): Promise<void>;\n}\nexport declare namespace ReportsModel {\n    interface ReportArchive {\n        id: number;\n        scopeType: string;\n        scopeId: number;\n        userId: number;\n        name: string;\n        webUrl: string;\n        scheme: any;\n        createdAt: string;\n    }\n    interface ListReportArchiveParams extends PaginationOptions {\n        scopeType: string;\n        scopeId: number;\n    }\n    interface ReportArchiveStatusAttribute {\n        format: Format;\n        reportName: string;\n        schema: any;\n    }\n    type GroupReportSchema = GroupTranslationCostsPostEditingSchema | GroupTopMembersSchema | GroupTaskUsageSchema | GroupQaCheckIssuesSchema | GroupTranslationActivitySchema;\n    type OrganizationReportSchema = GroupTranslationCostsPostEditingSchema | GroupTopMembersSchema | GroupTaskUsageSchema | GroupQaCheckIssuesSchema | GroupTranslationActivitySchema;\n    interface GenerateGroupReportRequest {\n        name: string;\n        schema: GroupReportSchema;\n    }\n    interface GenerateOrganizationReportRequest {\n        name: string;\n        schema: OrganizationReportSchema;\n    }\n    interface GroupTranslationCostsPostEditingSchema {\n        projectIds?: number[];\n        unit?: Unit;\n        currency?: Currency;\n        format?: Format;\n        baseRates: BaseRate;\n        individualRates: IndividualRate[];\n        netRateSchemes: NetRateSchemas;\n        excludeApprovalsForEditedTranslations?: boolean;\n        preTranslatedStringsCategorizationAdjustment?: boolean;\n        groupBy?: GroupBy;\n        dateFrom?: string;\n        dateTo?: string;\n        userIds?: number[];\n    }\n    interface GroupTranslationCostsPerEditingByTaskSchema {\n        unit?: Unit;\n        currency?: Currency;\n        format?: Format;\n        baseRates: BaseRate;\n        individualRates: IndividualRate[];\n        netRateSchemes: NetRateSchemas;\n        taskId?: number;\n    }\n    interface CostsEstimationSchema {\n        projectIds?: number[];\n        unit?: Unit;\n        currency?: Currency;\n        format?: Format;\n        baseRates: BaseRate;\n        individualRates: IndividualRate[];\n        netRateSchemes: NetRateSchemas;\n        calculateInternalMatches?: boolean;\n        includePreTranslatedStrings?: boolean;\n        languageId?: string;\n        branchIds?: number[];\n        dateFrom?: string;\n        dateTo?: string;\n        labelIds?: number[];\n        labelIncludeType?: LabelIncludeType;\n    }\n    interface CostsEstimationByTaskSchema {\n        unit?: Unit;\n        currency?: Currency;\n        format?: Format;\n        baseRates?: BaseRate;\n        individualRates?: IndividualRate[];\n        netRateSchemes?: NetRateSchemas;\n        calculateInternalMatches?: boolean;\n        includePreTranslatedStrings?: boolean;\n        taskId?: number;\n    }\n    interface GroupTopMembersSchema {\n        projectIds?: number[];\n        unit?: Unit;\n        languageId?: string;\n        format?: Format;\n        dateFrom?: string;\n        dateTo?: string;\n    }\n    interface RawDataSchema {\n        mode: ContributionMode;\n        unit?: Unit;\n        languageId?: string;\n        userId?: number;\n        dateFrom?: string;\n        dateTo?: string;\n    }\n    type GenerateReportRequest = PreTranslateEfficeincy | PreTranslateAccuracy | TranslateAccuracy | CostEstimationPostEnding | TranslationCostsPostEnding | TopMembers | ContributionRawData | SourceContentUpdates | ProjectMembers | EditorIssues | QaCheckIssues | SavingActivity | TranslationActivity;\n    type ReportSchema = Pick<GenerateReportRequest, 'schema'>;\n    interface PreTranslateEfficeincy {\n        name: 'pre-translate-efficiency';\n        schema: PreTranslateAccuracySchema | PreTranslateAccuracySchemaByTask;\n    }\n    interface PreTranslateAccuracy {\n        name: 'pre-translate-accuracy';\n        schema: PreTranslateAccuracySchema | PreTranslateAccuracySchemaByTask;\n    }\n    interface TranslateAccuracy {\n        name: 'translator-accuracy';\n        schema: TranslateAccuracySchema;\n    }\n    interface CostEstimationPostEnding {\n        name: 'costs-estimation-pe';\n        schema: CostEstimationPostEndingSchema | CostEstimationPostEndingSchemaByTask;\n    }\n    interface TranslationCostsPostEnding {\n        name: 'translation-costs-pe';\n        schema: TranslationCostsPostEndingSchema | TranslationCostsPostEndingSchemaByTask;\n    }\n    interface TopMembers {\n        name: 'top-members';\n        schema: TopMembersSchema;\n    }\n    interface ContributionRawData {\n        name: 'contribution-raw-data';\n        schema: ContributionRawDataSchema | ContributionRawDataSchemaByTask;\n    }\n    interface SourceContentUpdates {\n        name: 'source-content-updates';\n        schema: SourceContentUpdatesSchema;\n    }\n    interface ProjectMembers {\n        name: 'project-members';\n        schema: MembersSchema;\n    }\n    interface EditorIssues {\n        name: 'editor-issues';\n        schema: EditorIssuesSchema;\n    }\n    interface QaCheckIssues {\n        name: 'qa-check-issues';\n        schema: ProjectQaCheckIssuesSchema;\n    }\n    interface SavingActivity {\n        name: 'saving-activity';\n        schema: SavingActivitySchema;\n    }\n    interface TranslationActivity {\n        name: 'translation-activity';\n        schema: ProjectConsumptionSchema;\n    }\n    interface ReportStatusAttributes<S> {\n        format: Format;\n        reportName: string;\n        schema: S;\n    }\n    interface PreTranslateAccuracySchema {\n        unit?: Unit;\n        format?: Format;\n        postEditingCategories?: string[];\n        languageId?: string;\n        dateFrom?: string;\n        dateTo?: string;\n    }\n    interface PreTranslateAccuracySchemaByTask {\n        unit?: Unit;\n        format?: Format;\n        postEditingCategories?: string[];\n        taskId?: number;\n    }\n    interface TranslateAccuracySchema {\n        unit?: Unit;\n        format?: Format;\n        postEditingCategories?: string[];\n        languageId?: string;\n        userIds?: number[];\n        dateFrom?: string;\n        dateTo?: string;\n    }\n    interface CostEstimationPostEndingSchema {\n        unit?: Unit;\n        currency?: Currency;\n        format?: Format;\n        baseRates: BaseRate;\n        individualRates: IndividualRate[];\n        netRateSchemes: Omit<NetRateSchemas, 'mtMatch' | 'suggestionMatch'>;\n        calculateInternalMatches?: boolean;\n        includePreTranslatedStrings?: boolean;\n        languageId?: string;\n        fileIds?: number[];\n        directoryIds?: number[];\n        branchIds?: number[];\n        dateFrom?: string;\n        dateTo?: string;\n        labelIds?: number[];\n        labelIncludeType?: LabelIncludeType;\n        workflowStepId?: number;\n    }\n    interface CostEstimationPostEndingSchemaByTask {\n        unit?: Unit;\n        currency?: Currency;\n        format?: Format;\n        baseRates?: BaseRate;\n        individualRates?: IndividualRate[];\n        netRateSchemes?: Omit<NetRateSchemas, 'mtMatch' | 'suggestionMatch'>;\n        calculateInternalMatches?: boolean;\n        includePreTranslatedStrings?: boolean;\n        taskId?: number;\n    }\n    interface TranslationCostsPostEndingSchemaByTask {\n        unit?: Unit;\n        currency?: Currency;\n        format?: Format;\n        baseRates: BaseRate;\n        individualRates: IndividualRate[];\n        netRateSchemes: NetRateSchemas;\n        taskId?: number;\n        excludeApprovalsForEditedTranslations?: boolean;\n        preTranslatedStringsCategorizationAdjustment?: boolean;\n    }\n    interface TranslationCostsPostEndingSchema {\n        unit?: Unit;\n        currency?: Currency;\n        format?: Format;\n        baseRates: BaseRate;\n        individualRates: IndividualRate[];\n        netRateSchemes: NetRateSchemas;\n        excludeApprovalsForEditedTranslations?: boolean;\n        preTranslatedStringsCategorizationAdjustment?: boolean;\n        groupBy?: GroupBy;\n        dateFrom?: string;\n        dateTo?: string;\n        languageId?: string;\n        userIds?: number[];\n        fileIds?: number[];\n        directoryIds?: number[];\n        branchIds?: number[];\n        labelIds?: number;\n        labelIncludeType?: LabelIncludeType;\n        workflowStepId?: number;\n    }\n    interface TopMembersSchema {\n        unit?: Unit;\n        languageId?: string;\n        format?: Format;\n        dateFrom?: string;\n        dateTo?: string;\n    }\n    interface ContributionRawDataSchema {\n        mode: ContributionMode;\n        unit?: Unit;\n        languageId?: string;\n        userId?: string;\n        columns?: Column[];\n        fileIds?: number[];\n        directoryIds?: number[];\n        branchIds?: number[];\n        tmIds?: number[];\n        mtIds?: number[];\n        aiPromptIds?: number[];\n        dateFrom?: string;\n        dateTo?: string;\n    }\n    interface ContributionRawDataSchemaByTask {\n        mode: ContributionMode;\n        unit?: Unit;\n        taskId: number;\n        columns?: Column[];\n        tmIds?: number[];\n        mtIds?: number[];\n        aiPromptIds?: number[];\n        dateFrom?: string;\n        dateTo?: string;\n    }\n    interface PreTranslateEfficiencySchema {\n        unit?: Unit;\n        format?: Format;\n        postEditingCategories?: string[];\n        languageId?: string;\n        dateFrom?: string;\n        dateTo?: string;\n    }\n    interface ListOrganizationReportSettingsParams extends PaginationOptions {\n        projectId?: number;\n        groupId?: number;\n    }\n    interface ReportSettings {\n        id: number;\n        name: string;\n        currency: Currency;\n        unit: Unit;\n        config: ReportSettinsConfig;\n        isPublic: boolean;\n        isGlobal: boolean;\n        createdAt: string;\n        updatedAt: string;\n    }\n    interface AddReportSettingsRequest {\n        name: string;\n        currency: Currency;\n        unit: Unit;\n        config: ReportSettinsConfig;\n        isPublic?: boolean;\n        isGlobal?: boolean;\n    }\n    type UserReportSettings = Omit<ReportSettings, 'isPublic' | 'isGlobal'>;\n    type AddUserReportSettingsRequest = Omit<AddReportSettingsRequest, 'isPublic' | 'isGlobal'>;\n    type OrganizationReportSettings = Omit<ReportSettings, 'isGlobal'> & {\n        projectId: number;\n        groupId: number;\n    };\n    type AddOrganizationReportSettingsRequest = Omit<AddReportSettingsRequest, 'isGlobal'> & {\n        projectId?: number;\n        groupId?: number;\n    };\n    interface ReportSettinsConfig {\n        baseRates: BaseRate;\n        netRateSchemes: NetRateSchemas[];\n        individualRates: IndividualRate[];\n    }\n    type Unit = 'strings' | 'words' | 'chars' | 'chars_with_spaces';\n    type Currency = 'USD' | 'EUR' | 'JPY' | 'GBP' | 'AUD' | 'CAD' | 'CHF' | 'CNY' | 'SEK' | 'NZD' | 'MXN' | 'SGD' | 'HKD' | 'NOK' | 'KRW' | 'TRY' | 'RUB' | 'INR' | 'BRL' | 'ZAR' | 'GEL' | 'UAH';\n    type Format = 'xlsx' | 'csv' | 'json';\n    interface BaseRate {\n        fullTranslation: number;\n        proofread: number;\n    }\n    interface IndividualRate extends BaseRate {\n        languageIds: string[];\n        userIds: number[];\n        fullTranslation: number;\n        proofread: number;\n    }\n    interface NetRateSchemas {\n        tmMatch: {\n            matchType: Mode;\n            price: number;\n        }[];\n        mtMatch: {\n            matchType: Mode;\n            price: number;\n        }[];\n        suggestionMatch: {\n            matchType: Mode;\n            price: number;\n        }[];\n        aiMatch?: {\n            matchType: Mode;\n            price: number;\n        }[];\n    }\n    type Mode = 'no_match' | 'tm_match' | 'approval' | '99-95' | '94-90' | '89-80' | 'perfect' | '100';\n    type ContributionMode = 'translations' | 'approvals' | 'votes';\n    type GroupBy = 'user' | 'language';\n    type LabelIncludeType = 'strings_with_label' | 'strings_without_label';\n    type Column = 'userId' | 'languageId' | 'stringId' | 'translationId' | 'fileId' | 'filePath' | 'pluralForm' | 'sourceStringTextHash' | 'mtEngine' | 'mtId' | 'tmName' | 'tmId' | 'aiPromptName' | 'aiPromptId' | 'preTranslated' | 'tmMatch' | 'mtMatch' | 'aiMatch' | 'suggestionMatch' | 'sourceUnits' | 'targetUnits' | 'createdAt' | 'updatedAt' | 'mark';\n    interface SourceContentUpdatesSchema {\n        unit?: Unit;\n        format?: Format;\n        dateFrom?: string;\n        dateTo?: string;\n        languageId?: string;\n        userIds?: number[];\n        fileIds?: number[];\n        directoryIds?: number[];\n        branchIds?: number[];\n        labelIds?: number[];\n        labelIncludeType?: LabelIncludeType;\n    }\n    interface MembersSchema {\n        format?: Format;\n        dateFrom?: string;\n        dateTo?: string;\n    }\n    interface EditorIssuesSchema {\n        dateFrom?: string;\n        dateTo?: string;\n        format?: Format;\n        languageId?: string;\n        userId?: number;\n    }\n    interface ProjectQaCheckIssuesSchema {\n        format?: Format;\n        dateFrom?: string;\n        dateTo?: string;\n        languageId?: string;\n    }\n    interface SavingActivitySchema {\n        unit?: Unit;\n        languageId?: string;\n        format?: Format;\n        dateFrom?: string;\n        dateTo?: string;\n        userIds?: number[];\n        fileIds?: number[];\n        directoryIds?: number[];\n        branchIds?: number[];\n        labelIds?: number[];\n        labelIncludeType?: LabelIncludeType;\n    }\n    interface ProjectConsumptionSchema {\n        unit?: Unit;\n        languageId?: string;\n        format?: Format;\n        dateFrom?: string;\n        dateTo?: string;\n        userIds?: number[];\n        fileIds?: number[];\n        directoryIds?: number[];\n        branchIds?: number[];\n        labelIds?: number[];\n        labelIncludeType?: LabelIncludeType;\n    }\n    interface GroupTaskUsageSchema {\n        format: Format;\n        type: 'workload' | 'create-vs-resolve' | 'performance' | 'time' | 'cost';\n        projectIds?: number[];\n        assigneeId?: number;\n        creatorId?: number;\n        dateFrom?: string;\n        dateTo?: string;\n        wordsCountFrom?: number;\n        wordsCountTo?: number;\n        excludeApprovalsForEditedTranslations?: boolean;\n        currency?: Currency;\n        baseRates?: BaseRate;\n        individualRates?: IndividualRate[];\n        netRateSchemes?: NetRateSchemas;\n    }\n    interface GroupQaCheckIssuesSchema {\n        projectIds?: number[];\n        format?: Format;\n        dateFrom?: string;\n        dateTo?: string;\n        languageId?: string;\n    }\n    interface GroupTranslationActivitySchema {\n        projectIds?: number[];\n        unit?: Unit;\n        languageId?: string;\n        format?: Format;\n        dateFrom?: string;\n        dateTo?: string;\n        userIds?: number[];\n        fileIds?: number[];\n        directoryIds?: number[];\n        branchIds?: number[];\n        labelIds?: number[];\n        labelIncludeType?: LabelIncludeType;\n    }\n}\n```\n\n##### screenshots/index.d.ts\n\n```typescript\nimport { CrowdinApi, PaginationOptions, PatchRequest, ResponseList, ResponseObject } from '../core';\nexport declare class Screenshots extends CrowdinApi {\n    listScreenshots(projectId: number, options?: ScreenshotsModel.ListScreenshotParams): Promise<ResponseList<ScreenshotsModel.Screenshot>>;\n    listScreenshots(projectId: number, limit?: number, offset?: number): Promise<ResponseList<ScreenshotsModel.Screenshot>>;\n    addScreenshot(projectId: number, request: ScreenshotsModel.CreateScreenshotRequest): Promise<ResponseObject<ScreenshotsModel.Screenshot>>;\n    getScreenshot(projectId: number, screenshotId: number): Promise<ResponseObject<ScreenshotsModel.Screenshot>>;\n    updateScreenshot(projectId: number, screenshotId: number, request: ScreenshotsModel.UpdateScreenshotRequest): Promise<ResponseObject<ScreenshotsModel.Screenshot>>;\n    deleteScreenshot(projectId: number, screenshotId: number): Promise<void>;\n    editScreenshot(projectId: number, screenshotId: number, request: PatchRequest[]): Promise<ResponseObject<ScreenshotsModel.Screenshot>>;\n    listScreenshotTags(projectId: number, screenshotId: number, options?: PaginationOptions): Promise<ResponseList<ScreenshotsModel.Tag>>;\n    listScreenshotTags(projectId: number, screenshotId: number, limit?: number, offset?: number): Promise<ResponseList<ScreenshotsModel.Tag>>;\n    replaceTags(projectId: number, screenshotId: number, request: ScreenshotsModel.ReplaceTagRequest[] | ScreenshotsModel.AutoTagRequest): Promise<void>;\n    addTag(projectId: number, screenshotId: number, request: ScreenshotsModel.ReplaceTagRequest[]): Promise<ResponseObject<ScreenshotsModel.Tag>>;\n    clearTags(projectId: number, screenshotId: number): Promise<void>;\n    getTag(projectId: number, screenshotId: number, tagId: number): Promise<ResponseObject<ScreenshotsModel.Tag>>;\n    deleteTag(projectId: number, screenshotId: number, tagId: number): Promise<void>;\n    updateTag(projectId: number, screenshotId: number, tagId: number, request: PatchRequest[]): Promise<ResponseObject<ScreenshotsModel.Screenshot>>;\n}\nexport declare namespace ScreenshotsModel {\n    interface ListScreenshotParams extends PaginationOptions {\n        stringIds?: number[];\n        stringId?: number;\n        labelIds?: string;\n        excludeLabelIds?: string;\n        orderBy?: string;\n    }\n    interface Screenshot {\n        id: number;\n        userId: number;\n        url: string;\n        webUrl: string;\n        name: string;\n        size: Size;\n        tagsCount: number;\n        tags: Tag[];\n        labels: number[];\n        labelIds: number[];\n        createdAt: string;\n        updatedAt: string;\n    }\n    interface CreateScreenshotRequest {\n        storageId: number;\n        name: string;\n        autoTag?: boolean;\n        fileId?: number;\n        branchId?: number;\n        directoryId?: number;\n        labelIds?: number[];\n    }\n    interface UpdateScreenshotRequest {\n        storageId: number;\n        name: string;\n    }\n    interface Tag {\n        id: number;\n        screenshotId: number;\n        stringId: number;\n        position: Position;\n        createdAt: string;\n    }\n    interface ReplaceTagRequest {\n        stringId: number;\n        position?: Position;\n    }\n    interface AutoTagRequest {\n        autoTag: boolean;\n        fileId?: number;\n        branchId?: number;\n        directoryId?: number;\n    }\n    interface Size {\n        width: number;\n        height: number;\n    }\n    interface Position {\n        x: number;\n        y: number;\n        width: number;\n        height: number;\n    }\n}\n```\n\n##### securityLogs/index.d.ts\n\n```typescript\nimport { CrowdinApi, PaginationOptions, ResponseList, ResponseObject } from '../core';\nexport declare class SecurityLogs extends CrowdinApi {\n    listOrganizationSecurityLogs(options?: SecurityLogsModel.ListOrganizationSecurityLogsParams): Promise<ResponseList<SecurityLogsModel.SecurityLog>>;\n    getOrganizationSecurityLog(securityLogId: number): Promise<ResponseObject<SecurityLogsModel.SecurityLog>>;\n    listUserSecurityLogs(userId: number, options?: SecurityLogsModel.ListUserSecurityLogsParams): Promise<ResponseList<SecurityLogsModel.SecurityLog>>;\n    getUserSecurityLog(userId: number, securityLogId: number): Promise<ResponseObject<SecurityLogsModel.SecurityLog>>;\n}\nexport declare namespace SecurityLogsModel {\n    type Event = 'login' | 'password.set' | 'password.change' | 'email.change' | 'login.change' | 'personal_token.issued' | 'personal_token.revoked' | 'mfa.enabled' | 'mfa.disabled' | 'session.revoke' | 'session.revoke_all' | 'sso.connect' | 'sso.disconnect' | 'user.remove' | 'application.connected' | 'application.disconnected' | 'webauthn.created' | 'webauthn.deleted' | 'trusted_device.remove' | 'trusted_device.remove_all' | 'device_verification.enabled' | 'device_verification.disabled';\n    interface ListOrganizationSecurityLogsParams extends PaginationOptions {\n        event?: Event;\n        createdAfter?: string;\n        createdBefore?: string;\n        ipAddress?: string;\n        userId?: number;\n    }\n    type ListUserSecurityLogsParams = Omit<ListOrganizationSecurityLogsParams, 'userId'>;\n    interface SecurityLog {\n        id: number;\n        event: string;\n        info: string;\n        userId: number;\n        location: string;\n        ipAddress: string;\n        deviceName: string;\n        createdAt: string;\n    }\n}\n```\n\n##### sourceFiles/index.d.ts\n\n```typescript\nimport { CrowdinApi, DownloadLink, PaginationOptions, PatchRequest, ResponseList, ResponseObject, Status } from '../core';\nexport declare class SourceFiles extends CrowdinApi {\n    getClonedBranch(projectId: number, branchId: number, cloneId: string): Promise<ResponseObject<SourceFilesModel.Branch>>;\n    clonedBranch(projectId: number, branchId: number, request: SourceFilesModel.CloneBranchRequest): Promise<ResponseObject<Status<object>>>;\n    checkBranchClonedStatus(projectId: number, branchId: number, cloneId: string): Promise<ResponseObject<Status<object>>>;\n    listProjectBranches(projectId: number, options?: SourceFilesModel.ListProjectBranchesOptions): Promise<ResponseList<SourceFilesModel.Branch>>;\n    listProjectBranches(projectId: number, name?: string, limit?: number, offset?: number): Promise<ResponseList<SourceFilesModel.Branch>>;\n    createBranch(projectId: number, request: SourceFilesModel.CreateBranchRequest): Promise<ResponseObject<SourceFilesModel.Branch>>;\n    getBranch(projectId: number, branchId: number): Promise<ResponseObject<SourceFilesModel.Branch>>;\n    deleteBranch(projectId: number, branchId: number): Promise<void>;\n    editBranch(projectId: number, branchId: number, request: PatchRequest[]): Promise<ResponseObject<SourceFilesModel.Branch>>;\n    mergeBranch(projectId: number, branchId: number, request: SourceFilesModel.MergeBranchRequest): Promise<ResponseObject<Status<SourceFilesModel.MergeBranchAttributes>>>;\n    checkBranchMergeStatus(projectId: number, branchId: number, mergeId: string): Promise<ResponseObject<Status<SourceFilesModel.MergeBranchAttributes>>>;\n    getBranchMergeSummary(projectId: number, branchId: number, mergeId: string): Promise<ResponseObject<SourceFilesModel.MergeBranchSummary>>;\n    listProjectDirectories(projectId: number, options?: SourceFilesModel.ListProjectDirectoriesOptions): Promise<ResponseList<SourceFilesModel.Directory>>;\n    listProjectDirectories(projectId: number, branchId?: number, directoryId?: number, limit?: number, offset?: number, filter?: string, recursion?: string): Promise<ResponseList<SourceFilesModel.Directory>>;\n    createDirectory(projectId: number, request: SourceFilesModel.CreateDirectoryRequest): Promise<ResponseObject<SourceFilesModel.Directory>>;\n    getDirectory(projectId: number, directoryId: number): Promise<ResponseObject<SourceFilesModel.Directory>>;\n    deleteDirectory(projectId: number, directoryId: number): Promise<void>;\n    editDirectory(projectId: number, directoryId: number, request: PatchRequest[]): Promise<ResponseObject<SourceFilesModel.Directory>>;\n    listProjectFiles(projectId: number, options?: SourceFilesModel.ListProjectFilesOptions): Promise<ResponseList<SourceFilesModel.File>>;\n    listProjectFiles(projectId: number, branchId?: number, directoryId?: number, limit?: number, offset?: number, recursion?: any, filter?: string): Promise<ResponseList<SourceFilesModel.File>>;\n    createFile(projectId: number, request: SourceFilesModel.CreateFileRequest): Promise<ResponseObject<SourceFilesModel.File>>;\n    getFile(projectId: number, fileId: number): Promise<ResponseObject<SourceFilesModel.File>>;\n    updateOrRestoreFile(projectId: number, fileId: number, request: SourceFilesModel.ReplaceFileFromStorageRequest | SourceFilesModel.RestoreFile): Promise<ResponseObject<SourceFilesModel.File>>;\n    deleteFile(projectId: number, fileId: number): Promise<void>;\n    editFile(projectId: number, fileId: number, request: PatchRequest[]): Promise<ResponseObject<SourceFilesModel.File>>;\n    downloadFilePreview(projectId: number, fileId: number): Promise<ResponseObject<DownloadLink>>;\n    downloadFile(projectId: number, fileId: number): Promise<ResponseObject<DownloadLink>>;\n    listAssetReferences(projectId: number, fileId: number, options?: PaginationOptions): Promise<ResponseList<SourceFilesModel.AssetReference>>;\n    getAssetReference(projectId: number, fileId: number, referenceId: number): Promise<ResponseObject<SourceFilesModel.AssetReference>>;\n    addAssetReference(projectId: number, fileId: number, request: SourceFilesModel.AssetReferenceRequest): Promise<ResponseObject<SourceFilesModel.AssetReference>>;\n    deleteAssetReference(projectId: number, fileId: number, referenceId: number): Promise<void>;\n    listFileRevisions(projectId: number, fileId: number, options?: PaginationOptions): Promise<ResponseList<SourceFilesModel.FileRevision>>;\n    listFileRevisions(projectId: number, fileId: number, limit?: number, offset?: number): Promise<ResponseList<SourceFilesModel.FileRevision>>;\n    getFileRevision(projectId: number, fileId: number, revisionId: number): Promise<ResponseObject<SourceFilesModel.FileRevision>>;\n    listReviewedSourceFilesBuild(projectId: number, options?: SourceFilesModel.ListReviewedSourceFilesBuildOptions): Promise<ResponseList<SourceFilesModel.ReviewedSourceFilesBuild>>;\n    listReviewedSourceFilesBuild(projectId: number, branchId?: number, limit?: number, offset?: number): Promise<ResponseList<SourceFilesModel.ReviewedSourceFilesBuild>>;\n    buildReviewedSourceFiles(projectId: number, request?: SourceFilesModel.BuildReviewedSourceFilesRequest): Promise<ResponseObject<SourceFilesModel.ReviewedSourceFilesBuild>>;\n    checkReviewedSourceFilesBuildStatus(projectId: number, buildId: number): Promise<ResponseObject<SourceFilesModel.ReviewedSourceFilesBuild>>;\n    downloadReviewedSourceFiles(projectId: number, buildId: number): Promise<ResponseObject<DownloadLink>>;\n}\nexport declare namespace SourceFilesModel {\n    interface Branch {\n        id: number;\n        projectId: number;\n        name: string;\n        title: string;\n        exportPattern: string;\n        priority: Priority;\n        createdAt: string;\n        updatedAt: string;\n    }\n    interface CreateBranchRequest {\n        name: string;\n        title?: string;\n        exportPattern?: string;\n        priority?: Priority;\n    }\n    interface CloneBranchRequest {\n        name: string;\n        title?: string;\n    }\n    interface MergeBranchRequest {\n        deleteAfterMerge?: boolean;\n        sourceBranchId: number;\n        acceptSourceChanges?: boolean;\n        dryRun?: boolean;\n    }\n    interface MergeBranchAttributes {\n        sourceBranchId: number;\n        deleteAfterMerge: boolean;\n        acceptSourceChanges?: boolean;\n    }\n    interface MergeBranchSummary {\n        status: string;\n        sourceBranchId: number;\n        targetBranchId: number;\n        dryRun: boolean;\n        details: {\n            added: number;\n            deleted: number;\n            updated: number;\n            conflicted: number;\n        };\n    }\n    type Priority = 'low' | 'normal' | 'high';\n    interface ListProjectDirectoriesOptions extends PaginationOptions {\n        branchId?: number;\n        directoryId?: number;\n        filter?: string;\n        recursion?: string;\n        orderBy?: string;\n    }\n    interface Directory {\n        id: number;\n        projectId: number;\n        branchId: number;\n        directoryId: number;\n        name: string;\n        title: string;\n        exportPattern: string;\n        path: string;\n        priority: Priority;\n        createdAt: string;\n        updatedAt: string;\n    }\n    interface CreateDirectoryRequest {\n        name: string;\n        branchId?: number;\n        directoryId?: number;\n        title?: string;\n        exportPattern?: string;\n        priority?: Priority;\n    }\n    interface ListProjectFilesOptions extends PaginationOptions {\n        branchId?: number;\n        directoryId?: number;\n        recursion?: any;\n        filter?: string;\n        orderBy?: string;\n    }\n    interface File {\n        id: number;\n        projectId: number;\n        branchId: number;\n        directoryId: number;\n        name: string;\n        title: string;\n        context: string;\n        type: string;\n        path: string;\n        status: string;\n        revisionId: number;\n        priority: Priority;\n        importOptions: ImportOptions;\n        exportOptions: GeneralExportOptions | PropertyExportOptions;\n        excludedTargetLanguages: string[];\n        parserVersion: number;\n        createdAt: string;\n        updatedAt: string;\n        fields: Record<string, any>;\n    }\n    interface CreateFileRequest {\n        storageId: number;\n        name: string;\n        branchId?: number;\n        directoryId?: number;\n        title?: string;\n        context?: string;\n        type?: FileType;\n        parserVersion?: number;\n        importOptions?: ImportOptions;\n        exportOptions?: ExportOptions;\n        excludedTargetLanguages?: string[];\n        attachLabelIds?: number[];\n        fields?: Record<string, any>;\n    }\n    interface ReplaceFileFromStorageRequest {\n        storageId: number;\n        name?: string;\n        updateOption?: UpdateOption;\n        importOptions?: ImportOptions;\n        exportOptions?: ExportOptions;\n        attachLabelIds?: number[];\n        detachLabelIds?: number[];\n        replaceModifiedContext?: boolean;\n    }\n    type ExportOptions = GeneralExportOptions | PropertyExportOptions | JavaScriptExportOptions | MdExportOptions;\n    type ImportOptions = SpreadsheetImportOptions | XmlImportOptions | WebXmlImportOptions | DocxFileImportOptions | HtmlFileImportOptions | HtmlFrontMatterFileImportOptions | MdxFileImportOptions | MdFileImportOptions | StringCatalogFileImportOptions | AdocFileImportOptions | OtherImportOptions;\n    interface RestoreFile {\n        revisionId: number;\n    }\n    interface FileRevision {\n        id: number;\n        projectId: number;\n        fileId: number;\n        restoreToRevision: number;\n        info: FileRevisionInfo;\n        date: string;\n    }\n    interface FileRevisionInfo {\n        added: FileRevisionInfoAttribute;\n        deleted: FileRevisionInfoAttribute;\n        updated: FileRevisionInfoAttribute;\n    }\n    interface FileRevisionInfoAttribute {\n        strings: number;\n        words: number;\n    }\n    type FileType = 'auto' | 'android' | 'macosx' | 'resx' | 'properties' | 'gettext' | 'yaml' | 'php' | 'json' | 'xml' | 'ini' | 'rc' | 'resw' | 'resjson' | 'qtts' | 'joomla' | 'chrome' | 'dtd' | 'dklang' | 'flex' | 'nsh' | 'wxl' | 'xliff' | 'xliff_two' | 'html' | 'haml' | 'txt' | 'csv' | 'md' | 'flsnp' | 'fm_html' | 'fm_md' | 'mediawiki' | 'docx' | 'xlsx' | 'sbv' | 'properties_play' | 'properties_xml' | 'maxthon' | 'go_json' | 'dita' | 'mif' | 'idml' | 'stringsdict' | 'plist' | 'vtt' | 'vdf' | 'srt' | 'stf' | 'toml' | 'contentful_rt' | 'svg' | 'js' | 'coffee' | 'nestjs_i18n' | 'webxml';\n    interface SpreadsheetImportOptions {\n        firstLineContainsHeader?: boolean;\n        contentSegmentation?: boolean;\n        srxStorageId?: number;\n        importTranslations?: boolean;\n        scheme?: Scheme;\n    }\n    interface Scheme {\n        none: number;\n        identifier: number;\n        sourcePhrase: number;\n        sourceOrTranslation: number;\n        translation: number;\n        context: number;\n        maxLength: number;\n        labels: number;\n        [key: string]: number;\n    }\n    interface XmlImportOptions {\n        translateContent?: boolean;\n        translateAttributes?: boolean;\n        inlineTags?: string[];\n        contentSegmentation?: boolean;\n        translatableElements?: string[];\n        srxStorageId?: number;\n    }\n    interface WebXmlImportOptions {\n        inlineTags?: string[];\n        contentSegmentation?: boolean;\n        srxStorageId?: number;\n    }\n    interface DocxFileImportOptions {\n        cleanTagsAggressively?: boolean;\n        translateHiddenText?: boolean;\n        translateHyperlinkUrls?: boolean;\n        translateHiddenRowsAndColumns?: boolean;\n        importNotes?: boolean;\n        importHiddenSlides?: boolean;\n        contentSegmentation?: boolean;\n        srxStorageId?: number;\n    }\n    interface HtmlFileImportOptions {\n        excludedElements?: string[];\n        inlineTags?: string[];\n        contentSegmentation?: boolean;\n        srxStorageId?: number;\n    }\n    interface HtmlFrontMatterFileImportOptions extends HtmlFileImportOptions {\n        excludedFrontMatterElements?: string[];\n    }\n    interface MdxFileImportOptions {\n        excludedFrontMatterElements?: string[];\n        excludeCodeBlocks?: boolean;\n        contentSegmentation?: boolean;\n        srxStorageId?: number;\n    }\n    interface MdFileImportOptions {\n        excludedFrontMatterElements?: string[];\n        excludeCodeBlocks?: boolean;\n        inlineTags?: string[];\n        contentSegmentation?: boolean;\n        srxStorageId?: number;\n    }\n    interface StringCatalogFileImportOptions {\n        importKeyAsSource?: boolean;\n    }\n    interface AdocFileImportOptions {\n        excludeIncludeDirectives?: boolean;\n    }\n    interface OtherImportOptions {\n        contentSegmentation: boolean;\n        srxStorageId: number;\n    }\n    interface GeneralExportOptions {\n        exportPattern?: string;\n    }\n    interface PropertyExportOptions {\n        escapeQuotes?: EscapeQuotes;\n        exportPattern?: string;\n        escapeSpecialCharacters?: 0 | 1;\n    }\n    interface JavaScriptExportOptions {\n        exportPattern?: string;\n        exportQuotes?: ExportQuotes;\n    }\n    interface MdExportOptions {\n        exportPattern?: string;\n        strongMarker?: 'asterisk' | 'underscore';\n        emphasisMarker?: 'asterisk' | 'underscore';\n        unorderedListBullet?: 'asterisks' | 'plus' | 'plus';\n        tableColumnWidth?: 'consolidate' | 'evenly_distribute_cells';\n    }\n    enum EscapeQuotes {\n        ZERO = 0,\n        ONE = 1,\n        TWO = 2,\n        THREE = 3\n    }\n    enum ExportQuotes {\n        SINGLE = \"single\",\n        DOUBLE = \"double\"\n    }\n    type UpdateOption = 'clear_translations_and_approvals' | 'keep_translations' | 'keep_translations_and_approvals';\n    interface ReviewedSourceFilesBuild {\n        id: number;\n        projectId: number;\n        status: string;\n        progress: number;\n        attributes: ReviewedSourceFilesBuildAttributes;\n    }\n    interface ReviewedSourceFilesBuildAttributes {\n        branchId: number;\n        targetLanguageId: string;\n    }\n    interface BuildReviewedSourceFilesRequest {\n        branchId?: number;\n    }\n    interface ListProjectBranchesOptions extends PaginationOptions {\n        name?: string;\n        orderBy?: string;\n    }\n    interface ListReviewedSourceFilesBuildOptions extends PaginationOptions {\n        branchId?: number;\n    }\n    interface User {\n        id: number;\n        username: string;\n        fullName: string;\n        avatarUrl: string;\n    }\n    interface AssetReference {\n        id: number;\n        name: string;\n        user: User;\n        createdAt: string;\n        mimeType: string;\n    }\n    interface AssetReferenceRequest {\n        storageId: number;\n        name: string;\n    }\n}\n```\n\n##### sourceStrings/index.d.ts\n\n```typescript\nimport { BooleanInt, CrowdinApi, PaginationOptions, PatchRequest, ResponseList, ResponseObject, Status } from '../core';\nimport { SourceFilesModel } from '../sourceFiles';\nexport declare class SourceStrings extends CrowdinApi {\n    uploadStringsStatus(projectId: number, uploadId: string): Promise<ResponseObject<Status<SourceStringsModel.UploadStringsStatus>>>;\n    uploadStrings(projectId: number, request: SourceStringsModel.UploadStringsRequest): Promise<ResponseObject<Status<SourceStringsModel.UploadStringsStatus>>>;\n    listProjectStrings(projectId: number, options?: SourceStringsModel.ListProjectStringsOptions): Promise<ResponseList<SourceStringsModel.String>>;\n    listProjectStrings(projectId: number, fileId?: number, limit?: number, offset?: number, filter?: string, denormalizePlaceholders?: BooleanInt, labelIds?: string, scope?: SourceStringsModel.Scope, croql?: string, branchId?: number, directoryId?: number): Promise<ResponseList<SourceStringsModel.String>>;\n    addString(projectId: number, request: SourceStringsModel.CreateStringRequest | SourceStringsModel.CreateStringStringsBasedRequest): Promise<ResponseObject<SourceStringsModel.String>>;\n    stringBatchOperations(projectId: number, request: PatchRequest[]): Promise<ResponseList<SourceStringsModel.String>>;\n    getString(projectId: number, stringId: number, query?: {\n        denormalizePlaceholders: BooleanInt;\n    }): Promise<ResponseObject<SourceStringsModel.String>>;\n    deleteString(projectId: number, stringId: number): Promise<void>;\n    editString(projectId: number, stringId: number, request: PatchRequest[]): Promise<ResponseObject<SourceStringsModel.String>>;\n}\nexport declare namespace SourceStringsModel {\n    type UploadStringsType = 'auto' | 'android' | 'macosx' | 'arb' | 'csv' | 'json' | 'xliff' | 'xliff_two' | 'xlsx';\n    interface UploadStringsStatus {\n        branchId: number;\n        storageId: number;\n        fileType: UploadStringsType;\n        parserVersion: number;\n        labelIds: number[];\n        importOptions: {\n            firstLineContainsHeader: boolean;\n            importTranslations: boolean;\n            scheme: SourceFilesModel.Scheme;\n        };\n        updateStrings: boolean;\n        cleanupMode: boolean;\n        updateOption: UpdateOption;\n    }\n    interface UploadStringsRequest {\n        branchId: number;\n        storageId: number;\n        type?: UploadStringsType;\n        parserVersion?: number;\n        labelIds?: number[];\n        updateStrings?: boolean;\n        cleanupMode?: boolean;\n        importOptions?: {\n            firstLineContainsHeader: boolean;\n            importTranslations: boolean;\n            scheme: SourceFilesModel.Scheme;\n        };\n        updateOption?: UpdateOption;\n    }\n    interface ListProjectStringsOptions extends PaginationOptions {\n        orderBy?: string;\n        denormalizePlaceholders?: BooleanInt;\n        labelIds?: string;\n        fileId?: number;\n        branchId?: number;\n        directoryId?: number;\n        taskId?: number;\n        croql?: string;\n        filter?: string;\n        scope?: SourceStringsModel.Scope;\n    }\n    interface String {\n        id: number;\n        projectId: number;\n        branchId: number;\n        identifier: string;\n        text: string | PluralText;\n        type: Type;\n        context: string;\n        maxLength: number;\n        isHidden: boolean;\n        isDuplicate: boolean;\n        masterStringId: boolean;\n        hasPlurals: boolean;\n        isIcu: boolean;\n        labelIds: number[];\n        webUrl: string;\n        createdAt: string;\n        updatedAt: string;\n        fileId: number;\n        directoryId: number;\n        revision: number;\n        fields: Record<string, any>;\n    }\n    interface CreateStringRequest {\n        text: string | PluralText;\n        identifier?: string;\n        fileId: number;\n        context?: string;\n        isHidden?: boolean;\n        maxLength?: number;\n        labelIds?: number[];\n        fields?: Record<string, any>;\n    }\n    interface CreateStringStringsBasedRequest {\n        text: string | PluralText;\n        identifier: string;\n        branchId: number;\n        context?: string;\n        isHidden?: boolean;\n        maxLength?: number;\n        labelIds?: number[];\n        fields?: Record<string, any>;\n    }\n    interface PluralText {\n        zero?: string;\n        one?: string;\n        two?: string;\n        few?: string;\n        many?: string;\n        other?: string;\n    }\n    enum Type {\n        TEXT = 0,\n        ASSET = 1,\n        ICU = 2\n    }\n    type Scope = 'identifier' | 'text' | 'context';\n    type UpdateOption = 'clear_translations_and_approvals' | 'keep_translations' | 'keep_translations_and_approvals';\n}\n```\n\n##### stringComments/index.d.ts\n\n```typescript\nimport { CrowdinApi, PaginationOptions, PatchRequest, ResponseList, ResponseObject } from '../core';\nexport declare class StringComments extends CrowdinApi {\n    listStringComments(projectId: number, options?: StringCommentsModel.ListStringCommentsOptions): Promise<ResponseList<StringCommentsModel.StringComment>>;\n    listStringComments(projectId: number, stringId?: number, type?: StringCommentsModel.Type, targetLanguageId?: string, issueType?: StringCommentsModel.IssueType, issueStatus?: StringCommentsModel.IssueStatus): Promise<ResponseList<StringCommentsModel.StringComment>>;\n    addStringComment(projectId: number, request: StringCommentsModel.AddStringCommentRequest): Promise<ResponseObject<StringCommentsModel.StringComment>>;\n    getStringComment(projectId: number, stringCommentId: number): Promise<ResponseObject<StringCommentsModel.StringComment>>;\n    deleteStringComment(projectId: number, stringCommentId: number): Promise<void>;\n    editStringComment(projectId: number, stringCommentId: number, request: PatchRequest[]): Promise<ResponseObject<StringCommentsModel.StringComment>>;\n    stringCommentBatchOperations(projectId: number, request: PatchRequest[]): Promise<ResponseList<StringCommentsModel.StringComment>>;\n}\nexport declare namespace StringCommentsModel {\n    interface ListStringCommentsOptions extends PaginationOptions {\n        stringId?: number;\n        type?: Type;\n        targetLanguageId?: string;\n        issueType?: IssueType;\n        issueStatus?: IssueStatus;\n        orderBy?: string;\n    }\n    interface StringComment {\n        id: number;\n        isShared?: boolean;\n        text: string;\n        userId: number;\n        stringId: number;\n        user: User;\n        string: StringModel;\n        projectId: number;\n        languageId: string;\n        type: Type;\n        issueType: IssueType;\n        issueStatus: IssueStatus;\n        resolverId: number;\n        senderOrganization: {\n            id: number;\n            domain: string;\n        };\n        resolverOrganization: {\n            id: number;\n            domain: string;\n        };\n        resolver: User;\n        resolvedAt: string;\n        createdAt: string;\n    }\n    interface User {\n        id: number;\n        username: string;\n        fullName: string;\n        avatarUrl: string;\n    }\n    interface StringModel {\n        id: number;\n        text: string;\n        type: string;\n        hasPlurals: boolean;\n        isIcu: boolean;\n        context: string;\n        fileId: number;\n    }\n    interface AddStringCommentRequest {\n        stringId: number;\n        text: string;\n        targetLanguageId: string;\n        type: Type;\n        isShared?: boolean;\n        issueType?: IssueType;\n    }\n    type Type = 'comment' | 'issue';\n    type IssueType = 'general_question' | 'translation_mistake' | 'context_request' | 'source_mistake';\n    type IssueStatus = 'unresolved' | 'resolved';\n}\n```\n\n##### stringCorrections/index.d.ts\n\n```typescript\nimport { BooleanInt, CrowdinApi, PaginationOptions, ResponseList, ResponseObject } from '../core';\nexport declare class StringCorrections extends CrowdinApi {\n    listStringCorrections(projectId: number, options: StringCorrectionsModel.ListStringCorrectionsParams): Promise<ResponseList<StringCorrectionsModel.StringCorrection>>;\n    addStringCorrection(projectId: number, request: StringCorrectionsModel.AddStringCorrectionRequest): Promise<ResponseObject<StringCorrectionsModel.StringCorrection>>;\n    deleteStringCorrections(projectId: number, stringId: number): Promise<void>;\n    getStringCorrection(projectId: number, correctionId: number, params?: {\n        denormalizePlaceholders?: BooleanInt;\n    }): Promise<ResponseObject<StringCorrectionsModel.StringCorrection>>;\n    restoreStringCorrection(projectId: number, correctionId: number): Promise<ResponseObject<StringCorrectionsModel.StringCorrection>>;\n    deleteStringCorrection(projectId: number, correctionId: number): Promise<void>;\n}\nexport declare namespace StringCorrectionsModel {\n    interface ListStringCorrectionsParams extends PaginationOptions {\n        stringId: number;\n        orderBy?: string;\n        denormalizePlaceholders?: BooleanInt;\n    }\n    interface StringCorrection {\n        id: number;\n        text: string;\n        pluralCategoryName: PluralCategoryName;\n        user: {\n            id: number;\n            username: string;\n            fullName: string;\n            avatarUrl: string;\n        };\n        createdAt: string;\n    }\n    type PluralCategoryName = 'zero' | 'one' | 'two' | 'few' | 'many' | 'other';\n    interface AddStringCorrectionRequest {\n        stringId: number;\n        text: string;\n        pluralCategoryName?: PluralCategoryName;\n    }\n}\n```\n\n##### stringTranslations/index.d.ts\n\n```typescript\nimport { BooleanInt, CrowdinApi, PaginationOptions, PatchRequest, ResponseList, ResponseObject } from '../core';\nexport declare class StringTranslations extends CrowdinApi {\n    listTranslationApprovals(projectId: number, options?: StringTranslationsModel.ListTranslationApprovalsOptions): Promise<ResponseList<StringTranslationsModel.Approval>>;\n    listTranslationApprovals(projectId: number, stringId?: number, languageId?: string, translationId?: number, limit?: number, offset?: number, fileId?: number, labelIds?: string, excludeLabelIds?: string): Promise<ResponseList<StringTranslationsModel.Approval>>;\n    addApproval(projectId: number, request: StringTranslationsModel.AddApprovalRequest): Promise<ResponseObject<StringTranslationsModel.Approval>>;\n    removeStringApprovals(projectId: number, stringId: number): Promise<void>;\n    approvalInfo(projectId: number, approvalId: number): Promise<ResponseObject<StringTranslationsModel.Approval>>;\n    approvalBatchOperations(projectId: number, request: PatchRequest[]): Promise<ResponseList<StringTranslationsModel.Approval>>;\n    removeApproval(projectId: number, approvalId: number): Promise<void>;\n    listLanguageTranslations(projectId: number, languageId: string, options?: StringTranslationsModel.ListLanguageTranslationsOptions): Promise<ResponseList<StringTranslationsModel.PlainLanguageTranslation | StringTranslationsModel.PluralLanguageTranslation | StringTranslationsModel.IcuLanguageTranslation>>;\n    listLanguageTranslations(projectId: number, languageId: string, stringIds?: string, fileId?: number, limit?: number, offset?: number, labelIds?: string, denormalizePlaceholders?: BooleanInt, croql?: string): Promise<ResponseList<StringTranslationsModel.PlainLanguageTranslation | StringTranslationsModel.PluralLanguageTranslation | StringTranslationsModel.IcuLanguageTranslation>>;\n    translationAlignment(projectId: number, request: StringTranslationsModel.TranslationAlignmentRequest): Promise<ResponseObject<StringTranslationsModel.TranslationAlignmentResponse>>;\n    listStringTranslations(projectId: number, stringId: number, languageId: string, options?: StringTranslationsModel.ListStringTranslationsOptions): Promise<ResponseList<StringTranslationsModel.StringTranslation>>;\n    listStringTranslations(projectId: number, stringId: number, languageId: string, limit?: number, offset?: number, denormalizePlaceholders?: BooleanInt): Promise<ResponseList<StringTranslationsModel.StringTranslation>>;\n    addTranslation(projectId: number, request: StringTranslationsModel.AddStringTranslationRequest): Promise<ResponseObject<StringTranslationsModel.StringTranslation>>;\n    deleteAllTranslations(projectId: number, stringId: number, languageId?: string): Promise<void>;\n    translationInfo(projectId: number, translationId: number): Promise<ResponseObject<StringTranslationsModel.StringTranslation>>;\n    restoreTranslation(projectId: number, translationId: number): Promise<ResponseObject<StringTranslationsModel.StringTranslation>>;\n    translationBatchOperations(projectId: number, request: PatchRequest[]): Promise<ResponseList<StringTranslationsModel.StringTranslation>>;\n    deleteTranslation(projectId: number, translationId: number): Promise<void>;\n    listTranslationVotes(projectId: number, options?: StringTranslationsModel.ListTranslationVotesOptions): Promise<ResponseList<StringTranslationsModel.Vote>>;\n    listTranslationVotes(projectId: number, stringId?: number, languageId?: string, translationId?: number, labelIds?: string, excludeLabelIds?: string, limit?: number, offset?: number): Promise<ResponseList<StringTranslationsModel.Vote>>;\n    addVote(projectId: number, request: StringTranslationsModel.AddVoteRequest): Promise<ResponseObject<StringTranslationsModel.Vote>>;\n    voteInfo(projectId: number, voteId: number): Promise<ResponseObject<StringTranslationsModel.Vote>>;\n    cancelVote(projectId: number, voteId: number): Promise<void>;\n}\nexport declare namespace StringTranslationsModel {\n    interface ListTranslationApprovalsOptions extends PaginationOptions {\n        stringId?: number;\n        languageId?: string;\n        translationId?: number;\n        fileId?: number;\n        labelIds?: string;\n        excludeLabelIds?: string;\n        orderBy?: string;\n    }\n    interface Approval {\n        id: number;\n        user: User;\n        translationId: number;\n        stringId: number;\n        languageId: string;\n        createdAt: string;\n    }\n    interface AddApprovalRequest {\n        translationId: number;\n    }\n    interface StringTranslation {\n        id: number;\n        text: string;\n        pluralCategoryName: PluralCategoryName;\n        user: User;\n        rating: number;\n        provider: string;\n        isPreTranslated: boolean;\n        createdAt: string;\n    }\n    interface ListLanguageTranslationsOptions extends PaginationOptions {\n        stringIds?: string;\n        fileId?: number;\n        labelIds?: string;\n        denormalizePlaceholders?: BooleanInt;\n        croql?: string;\n        approvedOnly?: BooleanInt;\n        passedWorkflow?: BooleanInt;\n        orderBy?: string;\n        branchId?: number;\n        minApprovalCount?: number;\n        directoryId?: number;\n    }\n    interface PlainLanguageTranslation {\n        stringId: number;\n        contentType: string;\n        translationId: number;\n        text: string;\n        user: User;\n        createdAt: string;\n    }\n    interface PluralLanguageTranslation {\n        stringId: number;\n        contentType: string;\n        plurals: Plural[];\n    }\n    interface IcuLanguageTranslation {\n        stringId: number;\n        contentType: string;\n        translationId: number;\n        text: string;\n        user: User;\n        createdAt: string;\n    }\n    interface Plural {\n        translationId: number;\n        text: string;\n        pluralForm: string;\n        user: User;\n        createdAt: string;\n    }\n    interface TranslationAlignmentRequest {\n        sourceLanguageId: string;\n        targetLanguageId: string;\n        text: string;\n    }\n    interface TranslationAlignmentResponse {\n        words: {\n            text: string;\n            alignments: {\n                sourceWord: string;\n                sourceLemma: string;\n                targetWord: string;\n                targetLemma: string;\n                match: number;\n                probability: number;\n            }[];\n        }[];\n    }\n    interface AddStringTranslationRequest {\n        stringId: number;\n        languageId: string;\n        text: string;\n        pluralCategoryName?: PluralCategoryName;\n        addToTm?: boolean;\n    }\n    interface ListTranslationVotesOptions extends PaginationOptions {\n        stringId?: number;\n        languageId?: string;\n        translationId?: number;\n        fileId?: number;\n        labelIds?: string;\n        excludeLabelIds?: string;\n    }\n    interface Vote {\n        id: number;\n        user: User;\n        translationId: number;\n        votedAt: string;\n        mark: Mark;\n    }\n    interface AddVoteRequest {\n        mark: Mark;\n        translationId: number;\n    }\n    interface User {\n        id: number;\n        username: string;\n        fullName: string;\n        avatarUrl: string;\n    }\n    type Mark = 'up' | 'down';\n    interface ListStringTranslationsOptions extends PaginationOptions {\n        denormalizePlaceholders?: BooleanInt;\n        orderBy?: string;\n    }\n    type PluralCategoryName = 'zero' | 'one' | 'two' | 'few' | 'many' | 'other';\n}\n```\n\n##### tasks/index.d.ts\n\n```typescript\nimport { BooleanInt, CrowdinApi, DownloadLink, PaginationOptions, PatchRequest, ResponseList, ResponseObject } from '../core';\nimport { LanguagesModel } from '../languages';\nexport declare class Tasks extends CrowdinApi {\n    listTasks(projectId: number, options?: TasksModel.ListTasksOptions): Promise<ResponseList<TasksModel.Task>>;\n    listTasks(projectId: number, limit?: number, offset?: number, status?: TasksModel.Status): Promise<ResponseList<TasksModel.Task>>;\n    addTask(projectId: number, request: TasksModel.CreateTaskRequest): Promise<ResponseObject<TasksModel.Task>>;\n    exportTaskStrings(projectId: number, taskId: number): Promise<ResponseObject<DownloadLink>>;\n    getTask(projectId: number, taskId: number): Promise<ResponseObject<TasksModel.Task>>;\n    deleteTask(projectId: number, taskId: number): Promise<void>;\n    editTask(projectId: number, taskId: number, request: PatchRequest[]): Promise<ResponseObject<TasksModel.Task>>;\n    listTasksComments(projectId: number, taskId: number, options?: PaginationOptions): Promise<ResponseList<TasksModel.TaskComment>>;\n    addTaskComment(projectId: number, taskId: number, request: TasksModel.CreateTaskCommentRequest): Promise<ResponseObject<TasksModel.TaskComment>>;\n    getTaskComment(projectId: number, taskId: number, commentId: number): Promise<ResponseObject<TasksModel.TaskComment>>;\n    deleteTaskComment(projectId: number, taskId: number, commentId: number): Promise<void>;\n    editTaskComment(projectId: number, taskId: number, commentId: number, request: PatchRequest[]): Promise<ResponseObject<TasksModel.TaskComment>>;\n    listUserTasks(options?: TasksModel.ListUserTasksOptions): Promise<ResponseList<TasksModel.UserTask>>;\n    listUserTasks(limit?: number, offset?: number, status?: TasksModel.Status, isArchived?: BooleanInt): Promise<ResponseList<TasksModel.UserTask>>;\n    editTaskArchivedStatus(projectId: number, taskId: number, request: PatchRequest[]): Promise<ResponseObject<TasksModel.UserTask>>;\n    listTaskSettingsTemplates(projectId: number, options?: PaginationOptions): Promise<ResponseList<TasksModel.TaskSettingsTemplate>>;\n    addTaskSettingsTemplate(projectId: number, request: TasksModel.AddTaskSettingsTemplate): Promise<ResponseObject<TasksModel.TaskSettingsTemplate>>;\n    getTaskSettingsTemplate(projectId: number, taskSettingsId: number): Promise<ResponseObject<TasksModel.TaskSettingsTemplate>>;\n    deleteTaskSettingsTemplate(projectId: number, taskSettingsId: number): Promise<void>;\n    editTaskSettingsTemplate(projectId: number, taskSettingsId: number, request: PatchRequest[]): Promise<ResponseObject<TasksModel.TaskSettingsTemplate>>;\n}\nexport declare namespace TasksModel {\n    interface Task {\n        id: number;\n        projectId: number;\n        creatorId: number;\n        type: Type | TypeVendor;\n        status: Status;\n        title: string;\n        assignees: Assignee[];\n        assignedTeams: AssignedTeam[];\n        progress: Progress;\n        translateProgress: Progress;\n        sourceLanguageId: string;\n        targetLanguageId: string;\n        description: string;\n        translationUrl: string;\n        webUrl: string;\n        wordsCount: number;\n        commentsCount: number;\n        deadline: string;\n        startedAt: string;\n        resolvedAt: string;\n        timeRange: string;\n        workflowStepId: number;\n        buyUrl: string;\n        createdAt: string;\n        updatedAt: string;\n        sourceLanguage: LanguagesModel.Language;\n        targetLanguages: LanguagesModel.Language[];\n        labelIds: number[];\n        excludeLabelIds: number[];\n        precedingTaskId: number;\n        filesCount: number;\n        fileIds: number[];\n        branchIds: number[];\n        vendor: string;\n        fields: Record<string, any>;\n    }\n    interface ListUserTasksOptions extends PaginationOptions {\n        status?: Status;\n        isArchived?: BooleanInt;\n        orderBy?: string;\n    }\n    interface UserTask extends Task {\n        isArchived: boolean;\n    }\n    type CreateTaskRequest = CreateTaskEnterpriseByBranchIds | CreateTaskEnterpriseByFileIds | CreateTaskEnterpriseByStringIds | CreateTaskEnterpriseVendorByBranchIds | CreateTaskEnterpriseVendorByFileIds | CreateTaskEnterpriseVendorByStringIds | CreateTaskEnterprisePendingTask | CreateTaskByFileIds | CreateTaskByStringIds | CreateTaskByBranchIds | CreateTaskByFileIdsLanguageService | CreateTaskByStringIdsLanguageService | CreateTaskByBranchIdsLanguageService | CreateTaskVendorOhtByFileIds | CreateTaskVendorOhtByStringIds | CreateTaskVendorOhtByBranchIds | CreateTaskVendorGengoByFileIds | CreateTaskVendorGengoByStringIds | CreateTaskVendorGengoByBranchIds | CreateTaskVendorManualByFileIds | CreateTaskVendorManualByStringIds | CreateTaskVendorManualByBranchIds | CreateTaskPendingTask | CreateTaskPendingTaskLanguageService | CreateTaskPendingTaskVendorManual;\n    interface CreateTaskEnterpriseByBranchIds {\n        type: Type;\n        workflowStepId: number;\n        title: string;\n        languageId: string;\n        branchIds: number[];\n        labelIds?: number[];\n        excludeLabelIds?: number[];\n        status?: RequestStatus;\n        description?: string;\n        splitContent?: boolean;\n        skipAssignedStrings?: boolean;\n        assignees?: CreateTaskAssignee[];\n        assignedTeams?: AssignedTeam[];\n        includePreTranslatedStringsOnly?: boolean;\n        deadline?: string;\n        startedAt?: string;\n        dateFrom?: string;\n        dateTo?: string;\n        fields?: Record<string, any>;\n    }\n    interface CreateTaskEnterpriseByStringIds {\n        type: Type;\n        workflowStepId: number;\n        title: string;\n        languageId: string;\n        stringIds: number[];\n        status?: RequestStatus;\n        description?: string;\n        splitContent?: boolean;\n        skipAssignedStrings?: boolean;\n        assignees?: CreateTaskAssignee[];\n        assignedTeams?: AssignedTeam[];\n        includePreTranslatedStringsOnly?: boolean;\n        deadline?: string;\n        startedAt?: string;\n        dateFrom?: string;\n        dateTo?: string;\n        fields?: Record<string, any>;\n    }\n    type CreateTaskEnterpriseVendorByStringIds = Omit<CreateTaskEnterpriseByStringIds, 'type' | 'status' | 'splitContent' | 'assignees' | 'assignedTeams'>;\n    type CreateTaskEnterpriseVendorByBranchIds = Omit<CreateTaskEnterpriseByBranchIds, 'type' | 'status' | 'splitContent' | 'assignees' | 'assignedTeams'>;\n    type CreateTaskEnterpriseByFileIds = Omit<CreateTaskEnterpriseByBranchIds, 'branchIds'> & {\n        fileIds: number[];\n    };\n    type CreateTaskEnterpriseVendorByFileIds = Omit<CreateTaskEnterpriseByFileIds, 'type' | 'status' | 'splitContent' | 'assignees' | 'assignedTeams'>;\n    interface CreateTaskEnterprisePendingTask {\n        precedingTaskId: number;\n        type: Type.PROOFREAD;\n        title: string;\n        description?: string;\n        assignees?: CreateTaskAssignee[];\n        assignedTeams?: AssignedTeam[];\n        deadline?: string;\n    }\n    interface CreateTaskByFileIds {\n        title: string;\n        languageId: string;\n        type: Type;\n        fileIds: number[];\n        labelIds?: number[];\n        excludeLabelIds?: number[];\n        status?: RequestStatus;\n        description?: string;\n        splitContent?: boolean;\n        skipAssignedStrings?: boolean;\n        includePreTranslatedStringsOnly?: boolean;\n        assignees?: CreateTaskAssignee[];\n        deadline?: string;\n        startedAt?: string;\n        dateFrom?: string;\n        dateTo?: string;\n    }\n    type CreateTaskByStringIds = Omit<CreateTaskByFileIds, 'fileIds' | 'labelIds' | 'excludeLabelIds'> & {\n        stringIds: number;\n    };\n    type CreateTaskByBranchIds = Omit<CreateTaskByFileIds, 'fileIds'> & {\n        branchIds: number;\n    };\n    interface CreateTaskByFileIdsLanguageService {\n        title: string;\n        languageId: string;\n        type: TypeVendor;\n        vendor: 'crowdin_language_service';\n        fileIds: number[];\n        labelIds?: number[];\n        excludeLabelIds?: number[];\n        status?: RequestStatus;\n        description?: string;\n        includePreTranslatedStringsOnly?: boolean;\n        assignees?: CreateTaskAssignee[];\n        dateFrom?: string;\n        dateTo?: string;\n    }\n    type CreateTaskByStringIdsLanguageService = Omit<CreateTaskByFileIdsLanguageService, 'fileIds' | 'labelIds' | 'excludeLabelIds'> & {\n        stringIds: number[];\n    };\n    type CreateTaskByBranchIdsLanguageService = Omit<CreateTaskByFileIdsLanguageService, 'fileIds'> & {\n        branchIds: number[];\n    };\n    interface CreateTaskVendorOhtByFileIds {\n        title: string;\n        languageId: string;\n        type: TypeVendor;\n        vendor: 'oht';\n        fileIds: number[];\n        labelIds?: number[];\n        excludeLabelIds?: number[];\n        status?: RequestStatus;\n        description?: string;\n        expertise?: Expertise;\n        editService?: boolean;\n        includePreTranslatedStringsOnly?: boolean;\n        dateFrom?: string;\n        dateTo?: string;\n    }\n    type CreateTaskVendorOhtByStringIds = Omit<CreateTaskVendorOhtByFileIds, 'fileIds' | 'labelIds' | 'excludeLabelIds'> & {\n        stringIds: number[];\n    };\n    type CreateTaskVendorOhtByBranchIds = Omit<CreateTaskVendorOhtByFileIds, 'fileIds'> & {\n        branchIds: number[];\n    };\n    interface CreateTaskVendorGengoByFileIds {\n        title: string;\n        languageId: string;\n        type: TypeVendor.TRANSLATE_BY_VENDOR;\n        vendor: 'gengo';\n        fileIds: number[];\n        labelIds?: number[];\n        excludeLabelIds?: number[];\n        status?: RequestStatus;\n        description?: string;\n        expertise?: 'standard' | 'pro';\n        tone?: Tone;\n        purpose?: Purpose;\n        customerMessage?: string;\n        usePreferred?: boolean;\n        editService?: boolean;\n        dateFrom?: string;\n        dateTo?: string;\n    }\n    type CreateTaskVendorGengoByStringIds = Omit<CreateTaskVendorGengoByFileIds, 'fileIds' | 'labelIds' | 'excludeLabelIds'> & {\n        stringIds: number[];\n    };\n    type CreateTaskVendorGengoByBranchIds = Omit<CreateTaskVendorGengoByFileIds, 'fileIds'> & {\n        branchIds: number[];\n    };\n    interface CreateTaskVendorManualByFileIds {\n        title: string;\n        languageId: string;\n        type: TypeVendor;\n        vendor: 'alconost' | 'babbleon' | 'tomedes' | 'e2f' | 'write_path_admin' | 'inlingo' | 'acclaro' | 'translate_by_humans' | 'lingo24' | 'assertio_language_services' | 'gte_localize' | 'kettu_solutions' | 'languageline_solutions';\n        fileIds: number[];\n        labelIds?: number[];\n        excludeLabelIds?: number[];\n        status?: RequestStatus;\n        description?: string;\n        skipAssignedStrings?: boolean;\n        includePreTranslatedStringsOnly?: boolean;\n        assignees?: CreateTaskAssignee[];\n        deadline?: string;\n        startedAt?: string;\n        dateFrom?: string;\n        dateTo?: string;\n    }\n    type CreateTaskVendorManualByStringIds = Omit<CreateTaskVendorManualByFileIds, 'fileIds' | 'labelIds' | 'excludeLabelIds'> & {\n        stringIds: number[];\n    };\n    type CreateTaskVendorManualByBranchIds = Omit<CreateTaskVendorManualByFileIds, 'fileIds'> & {\n        branchIds: number[];\n    };\n    interface CreateTaskPendingTask {\n        precedingTaskId: number;\n        type: Type.PROOFREAD;\n        title: string;\n        description?: string;\n        assignees?: CreateTaskAssignee[];\n        deadline?: string;\n    }\n    interface CreateTaskPendingTaskLanguageService {\n        precedingTaskId: number;\n        type: TypeVendor.PROOFREAD_BY_VENDOR;\n        vendor: 'crowdin_language_service';\n        title: string;\n        description?: string;\n        deadline?: string;\n    }\n    interface CreateTaskPendingTaskVendorManual {\n        precedingTaskId: number;\n        type: TypeVendor.PROOFREAD_BY_VENDOR;\n        vendor: CreateTaskVendorManualByFileIds['vendor'];\n        title: string;\n        description?: string;\n        deadline?: string;\n    }\n    interface CreateTaskAssignee {\n        id: number;\n        wordsCount?: number;\n    }\n    type Status = 'todo' | 'in_progress' | 'done' | 'closed';\n    type RequestStatus = Extract<Status, 'todo' | 'in_progress'>;\n    enum Type {\n        TRANSLATE = 0,\n        PROOFREAD = 1\n    }\n    enum TypeVendor {\n        TRANSLATE_BY_VENDOR = 2,\n        PROOFREAD_BY_VENDOR = 3\n    }\n    interface Assignee {\n        id: number;\n        username: string;\n        fullName: string;\n        avatarUrl: string;\n        wordsCount: number;\n        wordsLeft: number;\n    }\n    interface AssignedTeam {\n        id: number;\n        wordsCount: number;\n    }\n    interface Progress {\n        total: number;\n        done: number;\n        percent: number;\n    }\n    type Expertise = 'standard' | 'mobile-applications' | 'software-it' | 'gaming-video-games' | 'technical-engineering' | 'marketing-consumer-media' | 'business-finance' | 'legal-certificate' | 'medical' | 'ad-words-banners' | 'automotive-aerospace' | 'scientific' | 'scientific-academic' | 'tourism' | 'training-employee-handbooks' | 'forex-crypto';\n    enum TranslatedExpertise {\n        ECONOMY = \"P\",\n        PROFESSIONAL = \"T\",\n        PREMIUM = \"R\"\n    }\n    type Tone = '' | 'Informal' | 'Friendly' | 'Business' | 'Formal' | 'other';\n    type Purpose = 'standard' | 'Personal use' | 'Business' | 'Online content' | 'App/Web localization' | 'Media content' | 'Semi-technical' | 'other';\n    type Subject = 'general' | 'accounting_finance' | 'aerospace_defence' | 'architecture' | 'art' | 'automotive' | 'certificates_diplomas_licences_cv_etc' | 'chemical' | 'civil_engineering_construction' | 'corporate_social_responsibility' | 'cosmetics' | 'culinary' | 'electronics_electrical_engineering' | 'energy_power_generation_oil_gas' | 'environment' | 'fashion' | 'games_viseogames_casino' | 'general_business_commerce' | 'history_archaeology' | 'information_technology' | 'insurance' | 'internet_e-commerce' | 'legal_documents_contracts' | 'literary_translations' | 'marketing_advertising_material_public_relations' | 'matematics_and_physics' | 'mechanical_manufacturing' | 'media_journalism_publishing' | 'medical_pharmaceutical' | 'music' | 'private_correspondence_letters' | 'religion' | 'science' | 'shipping_sailing_maritime' | 'social_science' | 'telecommunications' | 'travel_tourism';\n    interface ListTasksOptions extends PaginationOptions {\n        status?: TasksModel.Status;\n        assigneeId?: number;\n        orderBy?: string;\n    }\n    interface TaskSettingsTemplate {\n        id: number;\n        name: string;\n        config: TaskSettingsTemplateConfig;\n        createdAt: string;\n        updatedAt: string;\n    }\n    interface AddTaskSettingsTemplate {\n        name: string;\n        config: TaskSettingsTemplateConfig;\n    }\n    interface TaskSettingsTemplateConfig {\n        languages: {\n            languageId?: string;\n            userIds?: number[];\n            teamIds?: number[];\n        }[];\n    }\n    interface TaskComment {\n        id: number;\n        userId: number;\n        taskId: number;\n        text: string;\n        timeSpent: number;\n        createdAt: string;\n        updatedAt: string;\n    }\n    interface CreateTaskCommentRequest {\n        text?: string;\n        timeSpent?: number;\n    }\n}\n```\n\n##### teams/index.d.ts\n\n```typescript\nimport { CrowdinApi, Pagination, PaginationOptions, PatchRequest, ProjectRole, ProjectRoles, ResponseList, ResponseObject } from '../core';\nimport { ProjectsGroupsModel } from '../projectsGroups';\nexport declare class Teams extends CrowdinApi {\n    listGroupTeams(groupId: number, options?: TeamsModel.ListGroupTeamsOptions): Promise<ResponseList<TeamsModel.TeamGroup>>;\n    updateGroupTeams(groupId: number, request: PatchRequest[]): Promise<ResponseList<TeamsModel.TeamGroup>>;\n    getGroupTeam(groupId: number, teamId: number): Promise<ResponseObject<TeamsModel.TeamGroup>>;\n    listTeamProjectPermissions(teamId: number, options?: PaginationOptions): Promise<ResponseList<TeamsModel.ProjectPermissions>>;\n    editTeamProjectPermissions(teamId: number, request: PatchRequest[]): Promise<ResponseList<TeamsModel.ProjectPermissions>>;\n    addTeamToProject(projectId: number, request: TeamsModel.AddTeamToProjectRequest): Promise<TeamsModel.ProjectTeamResources>;\n    listTeams(options?: TeamsModel.ListTeamsOptions): Promise<ResponseList<TeamsModel.Team>>;\n    listTeams(limit?: number, offset?: number): Promise<ResponseList<TeamsModel.Team>>;\n    addTeam(request: TeamsModel.AddTeamRequest): Promise<ResponseObject<TeamsModel.Team>>;\n    getTeam(teamId: number): Promise<ResponseObject<TeamsModel.Team>>;\n    deleteTeam(teamId: number): Promise<void>;\n    editTeam(teamId: number, request: PatchRequest[]): Promise<ResponseObject<TeamsModel.Team>>;\n    teamMembersList(teamId: number, options?: PaginationOptions): Promise<ResponseList<TeamsModel.TeamMember>>;\n    teamMembersList(teamId: number, limit?: number, offset?: number): Promise<ResponseList<TeamsModel.TeamMember>>;\n    addTeamMembers(teamId: number, request: TeamsModel.AddTeamMembersRequest): Promise<TeamsModel.AddTeamMembersResponse>;\n    deleteAllTeamMembers(teamId: number): Promise<void>;\n    deleteTeamMember(teamId: number, memberId: number): Promise<void>;\n}\nexport declare namespace TeamsModel {\n    interface ListGroupTeamsOptions extends PaginationOptions {\n        orderBy?: string;\n    }\n    interface ProjectPermissions {\n        id: number;\n        roles: ProjectRole[];\n        project: ProjectsGroupsModel.Project | ProjectsGroupsModel.ProjectSettings;\n    }\n    interface AddTeamToProjectRequest {\n        teamId: number;\n        managerAccess?: boolean;\n        developerAccess?: boolean;\n        roles?: ProjectRole[];\n        accessToAllWorkflowSteps?: boolean;\n        permissions?: Permissions;\n    }\n    interface ListTeamsOptions extends PaginationOptions {\n        search?: string;\n        projectIds?: string;\n        projectRoles?: ProjectRoles[];\n        languageIds?: string;\n        groupIds?: string;\n        orderBy?: string;\n    }\n    interface ProjectTeamResources {\n        skipped: ProjectTeamResource;\n        added: ProjectTeamResource;\n    }\n    interface ProjectTeamResource {\n        id: number;\n        hasManagerAccess: boolean;\n        hasDeveloperAccess: boolean;\n        hasAccessToAllWorkflowSteps: boolean;\n        permissions: Permissions;\n        roles: ProjectRole[];\n    }\n    interface Permissions {\n        [lang: string]: {\n            workflowStepIds: number[] | 'all';\n        };\n    }\n    interface Team {\n        id: number;\n        name: string;\n        totalMembers: number;\n        webUrl: string;\n        createdAt: string;\n        updatedAt: string;\n    }\n    interface TeamGroup {\n        id: number;\n        team: Team;\n    }\n    interface AddTeamRequest {\n        name: string;\n    }\n    interface TeamMember {\n        id: number;\n        username: string;\n        firstName: string;\n        lastName: string;\n        avatarUrl: string;\n        addedAt: string;\n    }\n    interface AddTeamMembersRequest {\n        userIds: number[];\n    }\n    interface AddTeamMembersResponse {\n        skipped: ResponseObject<TeamMember>[];\n        added: ResponseObject<TeamMember>[];\n        pagination: Pagination;\n    }\n}\n```\n\n##### translationMemory/index.d.ts\n\n```typescript\nimport { CrowdinApi, DownloadLink, PaginationOptions, PatchRequest, ResponseList, ResponseObject, Status } from '../core';\nexport declare class TranslationMemory extends CrowdinApi {\n    listTm(options?: TranslationMemoryModel.ListTMsOptions): Promise<ResponseList<TranslationMemoryModel.TranslationMemory>>;\n    listTm(groupId?: number, limit?: number, offset?: number): Promise<ResponseList<TranslationMemoryModel.TranslationMemory>>;\n    addTm(request: TranslationMemoryModel.AddTranslationMemoryRequest): Promise<ResponseObject<TranslationMemoryModel.TranslationMemory>>;\n    getTm(tmId: number): Promise<ResponseObject<TranslationMemoryModel.TranslationMemory>>;\n    deleteTm(tmId: number): Promise<void>;\n    editTm(tmId: number, request: PatchRequest[]): Promise<ResponseObject<TranslationMemoryModel.TranslationMemory>>;\n    listTmSegments(tmId: number, options?: TranslationMemoryModel.ListSegmentsOptions): Promise<ResponseList<TranslationMemoryModel.TMSegment>>;\n    addTmSegment(tmId: number, request: TranslationMemoryModel.AddTMSegment): Promise<ResponseObject<TranslationMemoryModel.TMSegment>>;\n    clearTm(tmId: number): Promise<void>;\n    exportTm(tmId: number, request?: TranslationMemoryModel.ExportTranslationMemoryRequest): Promise<ResponseObject<Status<TranslationMemoryModel.ExportTranslationMemoryAttribute>>>;\n    checkExportStatus(tmId: number, exportId: string): Promise<ResponseObject<Status<TranslationMemoryModel.ExportTranslationMemoryAttribute>>>;\n    downloadTm(tmId: number, exportId: string): Promise<ResponseObject<DownloadLink>>;\n    concordanceSearch(projectId: number, request: TranslationMemoryModel.ConcordanceSearchRequest): Promise<ResponseList<TranslationMemoryModel.ConcordanceSearchResponse>>;\n    importTm(tmId: number, request: TranslationMemoryModel.ImportTranslationMemoryRequest): Promise<ResponseObject<Status<TranslationMemoryModel.ImportTranslationMemoryAttribute>>>;\n    checkImportStatus(tmId: number, importId: string): Promise<ResponseObject<Status<TranslationMemoryModel.ImportTranslationMemoryAttribute>>>;\n    getTmSegment(tmId: number, segmentId: number): Promise<ResponseObject<TranslationMemoryModel.TMSegment>>;\n    deleteTmSegment(tmId: number, segmentId: number): Promise<void>;\n    editTmSegment(tmId: number, segmentId: number, request: PatchRequest[]): Promise<ResponseObject<TranslationMemoryModel.TMSegment>>;\n    deleteTmSegmentRecord(tmId: number, segmentId: number, recordId: number): Promise<void>;\n    editTmSegmentRecord(tmId: number, segmentId: number, recordId: number, request: PatchRequest[]): Promise<ResponseObject<TranslationMemoryModel.TMSegment>>;\n    addTmSegmentRecords(tmId: number, segmentId: number, request: TranslationMemoryModel.AddTMSegment): Promise<ResponseObject<TranslationMemoryModel.TMSegment>>;\n}\nexport declare namespace TranslationMemoryModel {\n    interface TranslationMemory {\n        id: number;\n        groupId: number;\n        userId: number;\n        name: string;\n        languageId: string;\n        languageIds: string[];\n        segmentsCount: number;\n        defaultProjectIds: number[];\n        projectIds: number[];\n        createdAt: string;\n        webUrl: string;\n    }\n    interface AddTranslationMemoryRequest {\n        name: string;\n        languageId: string;\n        groupId?: number;\n    }\n    interface ConcordanceSearchRequest {\n        sourceLanguageId: string;\n        targetLanguageId: string;\n        autoSubstitution: boolean;\n        minRelevant: number;\n        expressions: string[];\n        expression?: string;\n    }\n    interface ConcordanceSearchResponse {\n        tm: TranslationMemory;\n        recordId: number;\n        source: string;\n        target: string;\n        relevant: number;\n        substituted: string;\n        updatedAt: string;\n    }\n    interface ExportTranslationMemoryRequest {\n        sourceLanguageId?: number;\n        targetLanguageId?: number;\n        format?: Format;\n    }\n    interface ImportTranslationMemoryRequest {\n        storageId: number;\n        firstLineContainsHeader?: boolean;\n        scheme?: Scheme;\n    }\n    interface ExportTranslationMemoryAttribute {\n        sourceLanguageId: string;\n        targetLanguageId: string;\n        format: string;\n    }\n    interface ImportTranslationMemoryAttribute {\n        tmId: number;\n        storageId: number;\n        firstLineContainsHeader: number;\n        scheme: Scheme;\n    }\n    type Format = 'tmx' | 'csv' | 'xlsx';\n    interface Scheme {\n        [key: string]: number;\n    }\n    interface ListTMsOptions extends PaginationOptions {\n        groupId?: number;\n        userId?: number;\n        orderBy?: string;\n    }\n    interface ListSegmentsOptions extends PaginationOptions {\n        croql?: string;\n        orderBy?: string;\n    }\n    interface TMSegment {\n        id: number;\n        records: TMSegmentRecord[];\n    }\n    interface TMSegmentRecord {\n        id: number;\n        languageId: string;\n        text: string;\n        usageCount: number;\n        createdBy: number;\n        updatedBy: number;\n        createdAt: string;\n        updatedAt: string;\n    }\n    interface AddTMSegment {\n        records: AddTMSegmentRecord[];\n    }\n    interface AddTMSegmentRecord {\n        languageId: string;\n        text: string;\n    }\n}\n```\n\n##### translationStatus/index.d.ts\n\n```typescript\nimport { CrowdinApi, PaginationOptions, ResponseList } from '../core';\nimport { LanguagesModel } from '../languages';\nexport declare class TranslationStatus extends CrowdinApi {\n    getBranchProgress(projectId: number, branchId: number, options?: PaginationOptions): Promise<ResponseList<TranslationStatusModel.LanguageProgress>>;\n    getBranchProgress(projectId: number, branchId: number, limit?: number, offset?: number): Promise<ResponseList<TranslationStatusModel.LanguageProgress>>;\n    getDirectoryProgress(projectId: number, directoryId: number, options?: PaginationOptions): Promise<ResponseList<TranslationStatusModel.LanguageProgress>>;\n    getDirectoryProgress(projectId: number, directoryId: number, limit?: number, offset?: number): Promise<ResponseList<TranslationStatusModel.LanguageProgress>>;\n    getFileProgress(projectId: number, fileId: number, options?: PaginationOptions): Promise<ResponseList<TranslationStatusModel.LanguageProgress>>;\n    getFileProgress(projectId: number, fileId: number, limit?: number, offset?: number): Promise<ResponseList<TranslationStatusModel.LanguageProgress>>;\n    getLanguageProgress(projectId: number, languageId: string, options?: PaginationOptions): Promise<ResponseList<TranslationStatusModel.FileProgress>>;\n    getLanguageProgress(projectId: number, languageId: string, limit?: number, offset?: number): Promise<ResponseList<TranslationStatusModel.FileProgress>>;\n    getProjectProgress(projectId: number, options?: PaginationOptions): Promise<ResponseList<TranslationStatusModel.LanguageProgress>>;\n    getProjectProgress(projectId: number, limit?: number, offset?: number, languageIds?: string): Promise<ResponseList<TranslationStatusModel.LanguageProgress>>;\n    listQaCheckIssues(projectId: number, options?: TranslationStatusModel.ListQaCheckIssuesOptions): Promise<ResponseList<TranslationStatusModel.QaCheck>>;\n    listQaCheckIssues(projectId: number, limit?: number, offset?: number, category?: TranslationStatusModel.Category, validation?: TranslationStatusModel.Validation, languageIds?: string): Promise<ResponseList<TranslationStatusModel.QaCheck>>;\n}\nexport declare namespace TranslationStatusModel {\n    interface LanguageProgress {\n        words: Words;\n        phrases: Words;\n        translationProgress: number;\n        approvalProgress: number;\n        eTag: string;\n        languageId: string;\n        language: LanguagesModel.Language;\n    }\n    interface FileProgress {\n        words: Words;\n        phrases: Words;\n        translationProgress: number;\n        approvalProgress: number;\n        branchId: number;\n        fileId: number;\n        eTag: string;\n    }\n    interface Words {\n        total: number;\n        translated: number;\n        approved: number;\n        preTranslateAppliedTo: number;\n    }\n    type Category = 'empty' | 'variables' | 'tags' | 'punctuation' | 'symbol_register' | 'spaces' | 'size' | 'special_symbols' | 'wrong_translation' | 'spellcheck' | 'icu';\n    type Validation = 'empty_string_check' | 'empty_suggestion_check' | 'max_length_check' | 'tags_check' | 'mismatch_ids_check' | 'cdata_check' | 'specials_symbols_check' | 'leading_newlines_check' | 'trailing_newlines_check' | 'leading_spaces_check' | 'trailing_spaces_check' | 'multiple_spaces_check' | 'custom_blocked_variables_check' | 'highest_priority_custom_variables_check' | 'highest_priority_variables_check' | 'c_variables_check' | 'python_variables_check' | 'rails_variables_check' | 'java_variables_check' | 'dot_net_variables_check' | 'twig_variables_check' | 'php_variables_check' | 'freemarker_variables_check' | 'lowest_priority_variable_check' | 'lowest_priority_custom_variables_check' | 'punctuation_check' | 'spaces_before_punctuation_check' | 'spaces_after_punctuation_check' | 'non_breaking_spaces_check' | 'capitalize_check' | 'multiple_uppercase_check' | 'parentheses_check' | 'entities_check' | 'escaped_quotes_check' | 'wrong_translation_issue_check' | 'spellcheck' | 'icu_check';\n    interface ListQaCheckIssuesOptions extends PaginationOptions {\n        category?: Category | Category[];\n        validation?: Validation | Validation[];\n        languageIds?: string;\n    }\n    interface QaCheck {\n        stringId: number;\n        languageId: string;\n        category: Category;\n        categoryDescription: string;\n        validation: Validation;\n        validationDescription: string;\n        pluralId: number;\n        text: string;\n    }\n    interface GetProjectProgressOptions extends PaginationOptions {\n        languageIds?: string;\n    }\n}\n```\n\n##### translations/index.d.ts\n\n```typescript\nimport { CrowdinApi, DownloadLink, PaginationOptions, PatchRequest, ResponseList, ResponseObject, Status } from '../core';\nimport { ProjectsGroupsModel } from '../projectsGroups';\nexport declare class Translations extends CrowdinApi {\n    listPreTranslations(projectId: number, options?: PaginationOptions): Promise<ResponseList<Status<TranslationsModel.PreTranslationStatusAttributes>>>;\n    preTranslationStatus(projectId: number, preTranslationId: string): Promise<ResponseObject<Status<TranslationsModel.PreTranslationStatusAttributes>>>;\n    applyPreTranslation(projectId: number, request: TranslationsModel.PreTranslateRequest | TranslationsModel.PreTranslateStringsRequest): Promise<ResponseObject<Status<TranslationsModel.PreTranslationStatusAttributes>>>;\n    editPreTranslation(projectId: number, preTranslationId: string, request: PatchRequest[]): Promise<ResponseObject<Status<TranslationsModel.PreTranslationStatusAttributes>>>;\n    getPreTranslationReport(projectId: number, preTranslationId: string): Promise<ResponseObject<TranslationsModel.PreTranslationReport>>;\n    buildProjectDirectoryTranslation(projectId: number, directoryId: number, request?: TranslationsModel.BuildProjectDirectoryTranslationRequest): Promise<ResponseObject<TranslationsModel.BuildProjectDirectoryTranslationResponse>>;\n    buildProjectFileTranslation(projectId: number, fileId: number, request: TranslationsModel.BuildProjectFileTranslationRequest, eTag?: string): Promise<ResponseObject<TranslationsModel.BuildProjectFileTranslationResponse>>;\n    listProjectBuilds(projectId: number, options?: TranslationsModel.ListProjectBuildsOptions): Promise<ResponseList<TranslationsModel.Build>>;\n    listProjectBuilds(projectId: number, branchId?: number, limit?: number, offset?: number): Promise<ResponseList<TranslationsModel.Build>>;\n    buildProject(projectId: number, request?: TranslationsModel.BuildRequest | TranslationsModel.PseudoBuildRequest): Promise<ResponseObject<TranslationsModel.Build>>;\n    uploadTranslation(projectId: number, languageId: string, request: TranslationsModel.UploadTranslationRequest): Promise<ResponseObject<TranslationsModel.UploadTranslationResponse>>;\n    uploadTranslationStrings(projectId: number, languageId: string, request: TranslationsModel.UploadTranslationStringsRequest): Promise<ResponseObject<TranslationsModel.UploadTranslationStringsResponse>>;\n    downloadTranslations(projectId: number, buildId: number): Promise<ResponseObject<DownloadLink>>;\n    checkBuildStatus(projectId: number, buildId: number): Promise<ResponseObject<TranslationsModel.Build>>;\n    cancelBuild(projectId: number, buildId: number): Promise<void>;\n    exportProjectTranslation(projectId: number, request: TranslationsModel.ExportProjectTranslationRequest): Promise<ResponseObject<DownloadLink>>;\n}\nexport declare namespace TranslationsModel {\n    interface PreTranslateRequest {\n        languageIds: string[];\n        fileIds: number[];\n        method?: Method;\n        engineId?: number;\n        aiPromptId?: number;\n        autoApproveOption?: AutoApproveOption;\n        duplicateTranslations?: boolean;\n        skipApprovedTranslations?: boolean;\n        translateUntranslatedOnly?: boolean;\n        translateWithPerfectMatchOnly?: boolean;\n        fallbackLanguages?: {\n            languageId?: string[];\n        };\n        labelIds?: number[];\n        excludeLabelIds?: number[];\n    }\n    interface PreTranslateStringsRequest {\n        languageIds: string[];\n        branchIds?: number[];\n        method?: Method;\n        engineId?: number;\n        aiPromptId?: number;\n        autoApproveOption?: AutoApproveOption;\n        duplicateTranslations?: boolean;\n        skipApprovedTranslations?: boolean;\n        translateUntranslatedOnly?: boolean;\n        translateWithPerfectMatchOnly?: boolean;\n        fallbackLanguages?: {\n            languageId: string[];\n        };\n        labelIds?: number[];\n        excludeLabelIds?: number[];\n    }\n    interface BuildProjectDirectoryTranslationRequest {\n        targetLanguageIds?: string[];\n        skipUntranslatedStrings?: boolean;\n        skipUntranslatedFiles?: boolean;\n        preserveFolderHierarchy?: boolean;\n        exportStringsThatPassedWorkflow?: boolean;\n        exportWithMinApprovalsCount?: number;\n        exportApprovedOnly?: boolean;\n    }\n    interface BuildProjectDirectoryTranslationResponse {\n        id: number;\n        projectId: number;\n        status: BuildStatus;\n        progress: number;\n        createdAt: string;\n        updatedAt: string;\n        finishedAt: string;\n    }\n    type BuildStatus = 'created' | 'inProgress' | 'canceled' | 'failed' | 'finished';\n    interface BuildProjectFileTranslationRequest {\n        targetLanguageId: string;\n        exportAsXliff?: boolean;\n        skipUntranslatedStrings?: boolean;\n        skipUntranslatedFiles?: boolean;\n        exportApprovedOnly?: boolean;\n        exportWithMinApprovalsCount?: number;\n        exportStringsThatPassedWorkflow?: boolean;\n    }\n    interface BuildProjectFileTranslationResponse extends DownloadLink {\n        etag: string;\n    }\n    interface PreTranslationStatusAttributes {\n        languageIds: string[];\n        fileIds: number[];\n        branchIds: number[];\n        method: Method;\n        autoApproveOption: AutoApproveOption;\n        duplicateTranslations: boolean;\n        skipApprovedTranslations: boolean;\n        translateUntranslatedOnly: boolean;\n        translateWithPerfectMatchOnly: boolean;\n    }\n    type Method = 'tm' | 'mt' | 'ai';\n    type AutoApproveOption = 'all' | 'exceptAutoSubstituted' | 'perfectMatchOnly' | 'none';\n    type CharTransformation = 'asian' | 'european' | 'arabic' | 'cyrillic';\n    interface Build {\n        id: number;\n        projectId: number;\n        status: BuildStatus;\n        progress: number;\n        attributes: Attribute;\n        createdAt: string;\n        updatedAt: string;\n        finishedAt: string;\n    }\n    interface Attribute {\n        branchId: number;\n        directoryId: number;\n        targetLanguageIds: string[];\n        skipUntranslatedStrings: boolean;\n        skipUntranslatedFiles: boolean;\n        exportApprovedOnly: boolean;\n        exportWithMinApprovalsCount: number;\n        exportStringsThatPassedWorkflow: boolean;\n    }\n    interface BuildRequest {\n        branchId?: number;\n        targetLanguageIds?: string[];\n        skipUntranslatedStrings?: boolean;\n        skipUntranslatedFiles?: boolean;\n        exportApprovedOnly?: boolean;\n        exportWithMinApprovalsCount?: number;\n        exportStringsThatPassedWorkflow?: boolean;\n    }\n    interface PseudoBuildRequest {\n        pseudo: boolean;\n        branchId?: number;\n        prefix?: string;\n        suffix?: string;\n        lengthTransformation?: number;\n        charTransformation?: CharTransformation;\n    }\n    interface UploadTranslationRequest {\n        storageId: number;\n        fileId?: number;\n        importEqSuggestions?: boolean;\n        autoApproveImported?: boolean;\n        translateHidden?: boolean;\n        addToTm?: boolean;\n    }\n    interface UploadTranslationStringsRequest {\n        storageId: number;\n        branchId?: number;\n        importEqSuggestions?: boolean;\n        autoApproveImported?: boolean;\n        translateHidden?: boolean;\n        addToTm?: boolean;\n    }\n    interface UploadTranslationResponse {\n        projectId: number;\n        storageId: number;\n        languageId: string;\n        fileId: number;\n    }\n    interface UploadTranslationStringsResponse {\n        projectId: number;\n        storageId: number;\n        languageId: string;\n        branchId: number;\n    }\n    interface ExportProjectTranslationRequest {\n        targetLanguageId: string;\n        format?: string;\n        labelIds?: number[];\n        branchIds?: number[];\n        directoryIds?: number[];\n        fileIds?: number[];\n        skipUntranslatedStrings?: boolean;\n        skipUntranslatedFiles?: boolean;\n        exportApprovedOnly?: boolean;\n        exportWithMinApprovalsCount?: number;\n        exportStringsThatPassedWorkflow?: boolean;\n    }\n    interface ListProjectBuildsOptions extends PaginationOptions {\n        branchId?: number;\n    }\n    interface PreTranslationReport {\n        languages: TargetLanguage[];\n        preTranslateType: Method;\n    }\n    interface TargetLanguage {\n        id: string;\n        files: TargetLanguageFile[];\n        skipped: SkippedInfo;\n        skippedQaCheckCategories: ProjectsGroupsModel.CheckCategories;\n    }\n    interface TargetLanguageFile {\n        id: string;\n        statistics: TargetLanguageFileStatistics;\n    }\n    interface TargetLanguageFileStatistics {\n        phrases: number;\n        words: number;\n    }\n    interface SkippedInfo {\n        [key: string]: any;\n    }\n}\n```\n\n##### uploadStorage/index.d.ts\n\n```typescript\nimport { CrowdinApi, PaginationOptions, ResponseList, ResponseObject } from '../core';\nexport declare class UploadStorage extends CrowdinApi {\n    listStorages(options?: PaginationOptions): Promise<ResponseList<UploadStorageModel.Storage>>;\n    listStorages(limit?: number, offset?: number): Promise<ResponseList<UploadStorageModel.Storage>>;\n    addStorage(fileName: string, request: any, contentType?: string): Promise<ResponseObject<UploadStorageModel.Storage>>;\n    getStorage(storageId: number): Promise<ResponseObject<UploadStorageModel.Storage>>;\n    deleteStorage(storageId: number): Promise<void>;\n}\nexport declare namespace UploadStorageModel {\n    interface Storage {\n        id: number;\n        fileName: string;\n    }\n}\n```\n\n##### users/index.d.ts\n\n```typescript\nimport { CrowdinApi, Pagination, PaginationOptions, PatchRequest, ProjectRole, ProjectRoles, ResponseList, ResponseObject } from '../core';\nimport { ProjectsGroupsModel } from '../projectsGroups';\nimport { TeamsModel } from '../teams';\nexport declare class Users extends CrowdinApi {\n    listGroupManagers(groupId: number, options?: UsersModel.ListGroupManagersOptions): Promise<ResponseList<UsersModel.GroupManager>>;\n    updateGroupManagers(groupId: number, request: PatchRequest[]): Promise<ResponseList<UsersModel.GroupManager>>;\n    getGroupManager(groupId: number, userId: number): Promise<ResponseObject<UsersModel.GroupManager>>;\n    listProjectMembers(projectId: number, options?: UsersModel.ListProjectMembersOptions): Promise<ResponseList<UsersModel.ProjectMember | UsersModel.EnterpriseProjectMember>>;\n    listProjectMembers(projectId: number, search?: string, role?: UsersModel.Role, languageId?: string, limit?: number, offset?: number): Promise<ResponseList<UsersModel.ProjectMember | UsersModel.EnterpriseProjectMember>>;\n    addProjectMember(projectId: number, request: UsersModel.AddProjectMemberRequest): Promise<UsersModel.AddProjectMemberResponse>;\n    getProjectMemberPermissions(projectId: number, memberId: number): Promise<ResponseObject<UsersModel.ProjectMember | UsersModel.EnterpriseProjectMember>>;\n    replaceProjectMemberPermissions(projectId: number, memberId: number, request?: UsersModel.ReplaceProjectMemberRequest): Promise<ResponseObject<UsersModel.ProjectMember | UsersModel.EnterpriseProjectMember>>;\n    deleteMemberFromProject(projectId: number, memberId: number): Promise<void>;\n    listUsers(options?: UsersModel.ListUsersOptions): Promise<ResponseList<UsersModel.User>>;\n    listUsers(status?: UsersModel.Status, search?: string, twoFactor?: UsersModel.TwoFactor, limit?: number, offset?: number): Promise<ResponseList<UsersModel.User>>;\n    inviteUser(request: UsersModel.InviteUserRequest): Promise<ResponseObject<UsersModel.User>>;\n    getUserInfo(userId: number): Promise<ResponseObject<UsersModel.User>>;\n    deleteUser(userId: number): Promise<void>;\n    editUser(userId: number, request: PatchRequest[]): Promise<ResponseObject<UsersModel.User>>;\n    getAuthenticatedUser(): Promise<ResponseObject<UsersModel.User>>;\n    editAuthenticatedUser(request: PatchRequest[]): Promise<ResponseObject<UsersModel.User>>;\n    listUserProjectPermissions(userId: number, options?: PaginationOptions): Promise<ResponseList<UsersModel.ProjectPermissions>>;\n    editUserProjectPermissions(userId: number, request: PatchRequest[]): Promise<ResponseList<UsersModel.ProjectPermissions>>;\n    listUserProjectContributions(userId: number, options?: PaginationOptions): Promise<ResponseList<UsersModel.ProjectPermissions>>;\n}\nexport declare namespace UsersModel {\n    interface ListGroupManagersOptions extends PaginationOptions {\n        teamIds?: number[];\n        orderBy?: string;\n    }\n    interface ListProjectMembersOptions extends PaginationOptions {\n        search?: string;\n        role?: Role;\n        languageId?: string;\n        workflowStepId?: number;\n        orderBy?: string;\n    }\n    interface ListUsersOptions extends PaginationOptions {\n        status?: Status;\n        search?: string;\n        twoFactor?: TwoFactor;\n        orderBy?: string;\n        organizationRoles?: OrganizationRoles[];\n        teamId?: number;\n        projectIds?: string;\n        projectRoles?: ProjectRoles[];\n        languageIds?: string;\n        groupIds?: string;\n        lastSeenFrom?: string;\n        lastSeenTo?: string;\n    }\n    interface InviteUserRequest {\n        email: string;\n        firstName?: string;\n        lastName?: string;\n        timezone?: string;\n        adminAccess?: boolean;\n    }\n    interface User {\n        id: number;\n        username: string;\n        email: string;\n        firstName: string;\n        lastName: string;\n        status: Status;\n        avatarUrl: string;\n        fields: Record<string, any>;\n        createdAt: string;\n        lastSeen: string;\n        twoFactor: TwoFactor;\n        isAdmin: boolean;\n        timezone: string;\n        emailVerified: string;\n    }\n    type Status = 'active' | 'pending' | 'blocked';\n    type TwoFactor = 'enabled' | 'disabled';\n    type OrganizationRoles = 'admin' | 'manager' | 'vendor' | 'client';\n    interface GroupManager {\n        id: number;\n        user: User;\n        teams: TeamsModel.Team[];\n    }\n    interface ProjectMember {\n        id: number;\n        username: string;\n        fullName: string;\n        role: Role;\n        permissions: Permissions;\n        avatarUrl: string;\n        joinedAt: string;\n        timezone: string;\n        roles: ProjectRole[];\n    }\n    interface EnterpriseProjectMember {\n        id: number;\n        username: string;\n        firstName: string;\n        lastName: string;\n        isManager: boolean;\n        isDeveloperr: boolean;\n        managerOfGroup: Group;\n        accessToAllWorkflowSteps: boolean;\n        permissions: Permissions;\n        givenAccessAt: string;\n        roles: ProjectRole[];\n    }\n    interface Group {\n        id: number;\n        name: string;\n    }\n    type Role = 'all' | 'owner' | 'manager' | 'proofreader' | 'translator' | 'blocked';\n    type LanguageRole = 'proofreader' | 'translator' | 'denied';\n    interface AddProjectMemberRequest {\n        userIds?: number[];\n        usernames?: string[];\n        emails?: string[];\n        managerAccess?: boolean;\n        roles?: ProjectRole[];\n        developerAccess?: boolean;\n        accessToAllWorkflowSteps?: boolean;\n        permissions?: Permissions;\n    }\n    interface AddProjectMemberResponse {\n        skipped: ResponseObject<ProjectMember | EnterpriseProjectMember>[];\n        added: ResponseObject<ProjectMember | EnterpriseProjectMember>[];\n        pagination: Pagination;\n    }\n    interface ReplaceProjectMemberRequest {\n        managerAccess?: boolean;\n        developerAccess?: boolean;\n        roles?: ProjectRole[];\n        accessToAllWorkflowSteps?: boolean;\n        permissions?: Permissions;\n    }\n    interface ProjectPermissions {\n        id: number;\n        roles: ProjectRole[];\n        project: ProjectsGroupsModel.Project | ProjectsGroupsModel.ProjectSettings;\n        teams: TeamsModel.Team[];\n    }\n    interface Contributions {\n        id: number;\n        translated: Contribution;\n        approved: Contribution;\n        voted: Contribution;\n        commented: Contribution;\n        project: ProjectsGroupsModel.Project | ProjectsGroupsModel.ProjectSettings;\n    }\n    interface Contribution {\n        strings: number;\n        words?: number;\n    }\n    interface Permissions {\n        [lang: string]: string | {\n            workflowStepIds: number[] | 'all';\n        };\n    }\n}\n```\n\n##### vendors/index.d.ts\n\n```typescript\nimport { CrowdinApi, PaginationOptions, ResponseList } from '../core';\nexport declare class Vendors extends CrowdinApi {\n    listVendors(options?: PaginationOptions): Promise<ResponseList<VendorsModel.Vendor>>;\n    listVendors(limit?: number, offset?: number): Promise<ResponseList<VendorsModel.Vendor>>;\n}\nexport declare namespace VendorsModel {\n    interface Vendor {\n        id: number;\n        name: string;\n        description: string;\n        status: 'pending' | 'confirmed' | 'rejected';\n        webUrl: string;\n    }\n}\n```\n\n##### webhooks/index.d.ts\n\n```typescript\nimport { CrowdinApi, PaginationOptions, PatchRequest, ResponseList, ResponseObject } from '../core';\nexport declare class Webhooks extends CrowdinApi {\n    listWebhooks(projectId: number, options?: PaginationOptions): Promise<ResponseList<WebhooksModel.Webhook>>;\n    listWebhooks(projectId: number, limit?: number, offset?: number): Promise<ResponseList<WebhooksModel.Webhook>>;\n    addWebhook(projectId: number, request: WebhooksModel.AddWebhookRequest): Promise<ResponseObject<WebhooksModel.Webhook>>;\n    getWebhook(projectId: number, webhookId: number): Promise<ResponseObject<WebhooksModel.Webhook>>;\n    deleteWebhook(projectId: number, webhookId: number): Promise<void>;\n    editWebhook(projectId: number, webhookId: number, request: PatchRequest[]): Promise<ResponseObject<WebhooksModel.Webhook>>;\n}\nexport declare namespace WebhooksModel {\n    interface Webhook {\n        id: number;\n        projectId: number;\n        name: string;\n        url: string;\n        events: Event[];\n        headers: Record<string, string>;\n        payload: Record<string, any>;\n        isActive: boolean;\n        batchingEnabled: boolean;\n        requestType: RequestType;\n        contentType: ContentType;\n        createdAt: string;\n        updatedAt: string;\n    }\n    interface AddWebhookRequest {\n        name: string;\n        url: string;\n        events: Event[];\n        requestType: RequestType;\n        isActive?: boolean;\n        batchingEnabled?: boolean;\n        contentType?: ContentType;\n        headers?: Record<string, string>;\n        payload?: Record<string, any>;\n    }\n    type ContentType = 'multipart/form-data' | 'application/json' | 'application/x-www-form-urlencoded';\n    type Event = 'file.added' | 'file.updated' | 'file.reverted' | 'file.deleted' | 'file.translated' | 'file.approved' | 'project.translated' | 'project.approved' | 'project.built' | 'translation.updated' | 'string.added' | 'string.updated' | 'string.deleted' | 'stringComment.created' | 'stringComment.updated' | 'stringComment.deleted' | 'stringComment.restored' | 'suggestion.added' | 'suggestion.updated' | 'suggestion.deleted' | 'suggestion.approved' | 'suggestion.disapproved' | 'task.added' | 'task.statusChanged' | 'task.deleted';\n    type RequestType = 'POST' | 'GET';\n}\n```\n\n##### workflows/index.d.ts\n\n```typescript\nimport { CrowdinApi, PaginationOptions, PatchRequest, ResponseList, ResponseObject } from '../core';\nimport { SourceStringsModel } from '../sourceStrings';\nexport declare class Workflows extends CrowdinApi {\n    listWorkflowSteps(projectId: number, options?: PaginationOptions): Promise<ResponseList<WorkflowModel.WorkflowStep>>;\n    listWorkflowSteps(projectId: number, limit?: number, offset?: number): Promise<ResponseList<WorkflowModel.WorkflowStep>>;\n    getWorkflowStep(projectId: number, stepId: number): Promise<ResponseObject<WorkflowModel.WorkflowStep>>;\n    listStringsOnTheWorkflowStep(projectId: number, stepId: number, options?: WorkflowModel.ListStringsOntheWorkflowStepOptions): Promise<ResponseList<SourceStringsModel.String>>;\n    listWorkflowTemplates(options?: WorkflowModel.ListWorkflowTemplatesOptions): Promise<ResponseList<WorkflowModel.Workflow>>;\n    listWorkflowTemplates(groupId?: number, limit?: number, offset?: number): Promise<ResponseList<WorkflowModel.Workflow>>;\n    getWorkflowTemplateInfo(templateId: number): Promise<ResponseObject<WorkflowModel.Workflow>>;\n    updateWorkflowStepStringStatus(projectId: number, stepId: number, languageId: string, request: PatchRequest[]): Promise<ResponseList<WorkflowModel.WorkflowStepStringStatus>>;\n    getWorkflowStepStringStatus(projectId: number, stepId: number, languageId: string, options?: PaginationOptions): Promise<ResponseList<WorkflowModel.WorkflowStepStringStatus>>;\n}\nexport declare namespace WorkflowModel {\n    interface WorkflowStep {\n        id: number;\n        title: string;\n        type: string;\n        languages: string[];\n        config: {\n            assignees: {\n                [language: string]: number[];\n            };\n        };\n    }\n    interface ListWorkflowTemplatesOptions extends PaginationOptions {\n        groupId?: number;\n    }\n    interface ListStringsOntheWorkflowStepOptions extends PaginationOptions {\n        languageIds?: string;\n        orderBy?: string;\n        status?: 'todo' | 'done' | 'pending' | 'incomplete' | 'need_review';\n    }\n    interface Workflow {\n        id: number;\n        title: string;\n        description: string;\n        groupId: number;\n        isDefault: boolean;\n        webUrl: string;\n        steps: {\n            id: number;\n            languages: string[];\n            assignees: number[];\n            vendorId: number;\n            config: {\n                minRelevant: number;\n                autoSubstitution: boolean;\n            };\n            mtId: number;\n        }[];\n    }\n    interface WorkflowStepStringStatus {\n        stringId: number;\n        languageId: string;\n        stepId: number;\n        status: string;\n        output: string;\n    }\n}\n```\n\n<!-- CROWDIN_API_CLIENT_TYPES_END -->\n\n### App Metadata Storage\n\n#### Overview\n\nApp Metadata Storage is a built-in key-value storage system provided by the Crowdin Apps SDK. It allows your app to persist data across sessions without needing external databases or storage services.\n\n**Available Methods:**\n- `crowdinApp.saveMetadata(key, data, crowdinId)` - Save or update metadata (recommended)\n- `crowdinApp.getMetadata(key)` - Retrieve metadata\n- `crowdinApp.deleteMetadata(key)` - Delete metadata\n\n**Alternative approach:**\n- `crowdinModule.metadataStore.saveMetadata(key, data, crowdinId)`\n- `crowdinModule.metadataStore.getMetadata(key)`\n- `crowdinModule.metadataStore.deleteMetadata(key)`\n\n#### Official Documentation\n\n**üìö Complete Documentation:** Refer to Crowdin Apps SDK documentation for metadata storage\n\n**‚ö†Ô∏è CRITICAL**: Metadata is stored at the organization level. Always include `organizationId` in your keys to properly scope data.\n\n#### Common Examples\n\n**Save Metadata:**\n```typescript\napp.post('/api/save-data', async (req: Request, res: Response) => {\n    try {\n        const jwt = req.query.jwt as string;\n        const { data } = req.body;\n\n        if (!jwt) {\n            return res.status(400).json({ success: false, error: 'JWT token is required' });\n        }\n        \n        if (!crowdinApp.establishCrowdinConnection) {\n            return res.status(500).json({ success: false, error: 'Crowdin connection method not available' });\n        }\n\n        const connection = await crowdinApp.establishCrowdinConnection(jwt, undefined);\n\n        if (!connection.client) {\n            return res.status(500).json({ success: false, error: 'Crowdin API client not available' });\n        }\n\n        const userId = connection.context.jwtPayload.context.user_id;\n        const organizationId = connection.context.jwtPayload.context.organization_id;\n        \n        // Create a namespaced key\n        const key = `org_${organizationId}_user_${userId}_preferences`;\n        \n        // Save data to metadata storage\n        await crowdinApp.saveMetadata(key, data, connection.context.crowdinId);\n        res.json({ success: true, message: 'Data saved successfully' });\n    } catch (error) {\n        console.error('Save error:', error);\n        res.status(500).json({ success: false, error: 'Failed to save data' });\n    }\n});\n```\n\n**Get Metadata:**\n```typescript\napp.get('/api/get-data', async (req: Request, res: Response) => {\n    try {\n        const jwt = req.query.jwt as string;\n        \n        if (!jwt) {\n            return res.status(400).json({ success: false, error: 'JWT token is required' });\n        }\n        \n        if (!crowdinApp.establishCrowdinConnection) {\n            return res.status(500).json({ success: false, error: 'Crowdin connection method not available' });\n        }\n\n        const connection = await crowdinApp.establishCrowdinConnection(jwt, undefined);\n\n        if (!connection.client) {\n            return res.status(500).json({ success: false, error: 'Crowdin API client not available' });\n        }\n\n        const userId = connection.context.jwtPayload.context.user_id;\n        const organizationId = connection.context.jwtPayload.context.organization_id;\n        \n        const key = `org_${organizationId}_user_${userId}_preferences`;\n        \n        // Retrieve data from metadata storage\n        const data = await crowdinApp.getMetadata(key);\n            \n        // Handle case when no data exists\n        if (!data) {\n            return res.json({ \n                success: true, \n                data: null, \n                message: 'No data found' \n            });\n        }\n        \n        res.json({ success: true, data });\n    } catch (error) {\n        console.error('Get error:', error);\n        res.status(500).json({ success: false, error: 'Failed to retrieve data' });\n    }\n});\n```\n\n**Delete Metadata:**\n```typescript\napp.delete('/api/delete-data', async (req: Request, res: Response) => {\n    try {\n        const jwt = req.query.jwt as string;\n        \n        if (!jwt) {\n            return res.status(400).json({ success: false, error: 'JWT token is required' });\n        }\n        \n        if (!crowdinApp.establishCrowdinConnection) {\n            return res.status(500).json({ success: false, error: 'Crowdin connection method not available' });\n        }\n\n        const connection = await crowdinApp.establishCrowdinConnection(jwt, undefined);\n\n        if (!connection.client) {\n            return res.status(500).json({ success: false, error: 'Crowdin API client not available' });\n        }\n\n        const userId = connection.context.jwtPayload.context.user_id;\n        const organizationId = connection.context.jwtPayload.context.organization_id;\n        \n        const key = `org_${organizationId}_user_${userId}_preferences`;\n        \n        // Delete data from metadata storage\n        await crowdinApp.deleteMetadata(key);\n        res.json({ success: true, message: 'Data deleted successfully' });\n    } catch (error) {\n        console.error('Delete error:', error);\n        res.status(500).json({ success: false, error: 'Failed to delete data' });\n    }\n});\n```\n\n**Get All Metadata:**\n```typescript\napp.get('/api/all-metadata', async (req: Request, res: Response) => {\n    try {\n        const jwt = req.query.jwt as string;\n        \n        if (!jwt) {\n            return res.status(400).json({ success: false, error: 'JWT token is required' });\n        }\n        \n        if (!crowdinApp.establishCrowdinConnection) {\n            return res.status(500).json({ success: false, error: 'Crowdin connection method not available' });\n        }\n\n        const connection = await crowdinApp.establishCrowdinConnection(jwt, undefined);\n\n        if (!connection.client) {\n            return res.status(500).json({ success: false, error: 'Crowdin API client not available' });\n        }\n\n        // Retrieve all metadata records from storage\n        const allMetadata = await crowdinApp.storage.getAllMetadata();\n        \n        // allMetadata structure:\n        // [\n        //   {\n        //     id: \"org_123_user_456_preferences\",  // key\n        //     data: \"{\"theme\":\"dark\",\"lang\":\"en\"}\", // JSON stringified value\n        //     crowdin_id: \"domain\"     // crowdin identifier (from connection.context.crowdinId during save)\n        //   },\n        //   ...\n        // ]\n        \n        // Parse and format data\n        const formattedData = allMetadata.map(record => ({\n            key: record.id,\n            value: JSON.parse(record.data || '{}'),\n            crowdinId: record.crowdin_id\n        }));\n        \n        res.json({ success: true, metadata: formattedData, count: formattedData.length });\n    } catch (error) {\n        console.error('Error retrieving all metadata:', error);\n        res.status(500).json({ success: false, error: 'Failed to retrieve metadata' });\n    }\n});\n```\n\n**Store Complex Objects:**\n```typescript\n// Save complex user preferences\nconst preferences = {\n    theme: 'dark',\n    language: 'en',\n    notifications: {\n        email: true,\n        push: false,\n        digest: 'weekly'\n    },\n    lastUpdated: new Date().toISOString(),\n    settings: {\n        autoSave: true,\n        confirmActions: true\n    }\n};\n\nconst key = `org_${organizationId}_user_${userId}_preferences`;\nawait crowdinApp.saveMetadata(key, preferences, connection.context.crowdinId);\n\n// Retrieve and update\nconst currentPrefs = await crowdinApp.getMetadata(key) || {};\nconst updatedPrefs = {\n    ...currentPrefs,\n    theme: 'light',\n    lastUpdated: new Date().toISOString()\n};\nawait crowdinApp.saveMetadata(key, updatedPrefs, connection.context.crowdinId);\n```\n\n#### Best Practices\n\n1. **Always use namespaced keys**\n   ```typescript\n   // ‚úÖ CORRECT - includes organization and entity identifiers\n   const key = `org_${organizationId}_user_${userId}_preferences`;\n   const key = `org_${organizationId}_project_${projectId}_cache`;\n   \n   // ‚ùå WRONG - no organization scope, may cause conflicts\n   const key = `user_preferences`;\n   const key = `${userId}_data`;\n   ```\n\n2. **Handle missing data gracefully**\n   ```typescript\n   // ‚úÖ CORRECT - provide defaults for missing data\n   const data = await crowdinApp.getMetadata(key) || { \n       theme: 'auto', \n       language: 'en' \n   };\n   \n   // ‚úÖ CORRECT - check for null/undefined\n   const data = await crowdinApp.getMetadata(key);\n   if (!data) {\n       return defaultSettings;\n   }\n   \n   // ‚ùå WRONG - may cause errors if data is null\n   const theme = data.theme; // Error if data is null\n   ```\n\n3. **Always use the correct identifier for the third parameter**\n   ```typescript\n   // ‚úÖ CORRECT - when connection object is available\n   await crowdinApp.saveMetadata(key, data, connection.context.crowdinId);\n   \n   // ‚úÖ CORRECT - when using webhookContext (no connection object, crowdinApp not available)\n   await crowdinModule.metadataStore.saveMetadata(key, data, `${webhookContext.domain || webhookContext.organizationId}`);\n   \n   // ‚ùå WRONG - don't use organizationId directly\n   await crowdinApp.saveMetadata(key, data, String(organizationId));\n   ```\n\n4. **Use descriptive key patterns**\n   ```typescript\n   // ‚úÖ CORRECT - clear, hierarchical structure\n   `org_${orgId}_user_${userId}_preferences`\n   `org_${orgId}_project_${projectId}_settings`\n   `org_${orgId}_cache_${cacheType}_${identifier}`\n   \n   // ‚ùå WRONG - unclear, hard to maintain\n   `data_${id}`\n   `temp_storage`\n   ```\n\n5. **Handle errors properly**\n   ```typescript\n   // ‚úÖ CORRECT - comprehensive error handling\n   try {\n       await crowdinApp.saveMetadata(key, data, connection.context.crowdinId);\n       return { success: true };\n   } catch (error: any) {\n       console.error('Metadata save failed:', error);\n       return { \n           success: false, \n           error: 'Failed to save data'\n       };\n   }\n   ```\n\n7. **Store only JSON-serializable data**\n   ```typescript\n   // ‚úÖ CORRECT - simple JSON-serializable objects\n   const data = {\n       name: 'John',\n       age: 30,\n       preferences: ['option1', 'option2'],\n       metadata: { key: 'value' }\n   };\n   \n   // ‚ùå WRONG - functions, dates, circular references\n   const data = {\n       name: 'John',\n       callback: () => {},           // Functions don't serialize\n       created: new Date(),           // Dates become strings\n       circular: data                 // Circular reference\n   };\n   \n   // ‚úÖ CORRECT - convert dates to ISO strings\n   const data = {\n       name: 'John',\n       created: new Date().toISOString()\n   };\n   ```\n\n8. **NEVER use KVStore for configurations - use metadata storage instead**\n   ```typescript\n   // ‚úÖ CORRECT - use metadata storage for ALL configuration storage\n   const config = {\n       apiKey: userApiKey,\n       apiEndpoint: 'https://api.example.com',\n       languageMapping: { 'en': 'en-US' }\n   };\n   await crowdinApp.saveMetadata(\n       `config_org_${organizationId}`, \n       config, \n       connection.context.crowdinId\n   );\n   \n   // ‚úÖ CORRECT - read configuration from metadata storage\n   const config = await crowdinApp.getMetadata(`config_org_${organizationId}`) || {};\n   \n   // ‚ùå WRONG - using KVStore for configuration storage\n   const config = {\n       apiKey: userApiKey,\n       apiEndpoint: 'https://api.example.com',\n       languageMapping: { 'en': 'en-US' }\n   };\n   await env.KVStore.put(\n       `config_org_${organizationId}`, \n       JSON.stringify(config)\n   );\n   \n   // ‚ùå WRONG - reading configuration from KVStore\n   const configData = await env.KVStore.get(`config_org_${organizationId}`);\n   const config = JSON.parse(configData || '{}');\n   ```\n\n9. **Use crowdinApp.saveMetadata or crowdinModule.metadataStore.saveMetadata - both implement upsert**\n   ```typescript\n   // ‚úÖ CORRECT - implements upsert (insert or update)\n   await crowdinApp.saveMetadata(\n       key, \n       data, \n       connection.context.crowdinId\n   );\n   \n   // ‚úÖ CORRECT - also implements upsert (insert or update)\n   await crowdinModule.metadataStore.saveMetadata(\n       key, \n       data, \n       connection.context.crowdinId\n   );\n   \n   // ‚ùå WRONG - only insert, NOT upsert (will fail if key already exists)\n   await crowdinApp.storage.saveMetadata(\n       key, \n       data, \n       connection.context.crowdinId\n   );\n   ```\n\n### Cron Scheduling\n\n#### Overview\n\nCron Scheduling allows your app to execute background tasks at specified time intervals.\n\n#### Official Documentation\n\n**üìö Complete Documentation:** Refer to Crowdin Apps SDK documentation for cron scheduling\n\n**‚ö†Ô∏è CRITICAL**: Only specific cron intervals are supported. Using unsupported intervals will result in an error.\n\n#### Supported Intervals\n\nThe following cron expressions are supported:\n\n| Cron Expression | Description | Frequency |\n|----------------|-------------|-----------|\n| `0 * * * *` | Every hour | Runs at minute 0 of every hour |\n| `0 */3 * * *` | Every 3 hours | Runs at minute 0 every 3 hours |\n| `0 */6 * * *` | Every 6 hours | Runs at minute 0 every 6 hours |\n| `0 */12 * * *` | Every 12 hours | Runs at minute 0 every 12 hours |\n| `0 0 * * *` | Daily | Runs at midnight (00:00) every day |\n| `0 0 * * SUN` | Weekly | Runs at midnight (00:00) every Sunday |\n| `0 0 1 * *` | Monthly | Runs at midnight (00:00) on the 1st of each month |\n\n#### Common Examples\n\n**Simple Hourly Task:**\n```typescript\n// In worker/app.ts, after initializing crowdinApp\nconst crowdinApp = crowdinModule.addCrowdinEndpoints(app, configuration) as CrowdinAppUtilities;\n\n// Register cron job - runs every hour\ncrowdinApp.cron.schedule('0 * * * *', async () => {\n    try {\n        console.log('Hourly task started at', new Date().toISOString());\n        \n        // Perform your scheduled task\n        // Example: Check status, update cache, etc.\n        \n        console.log('Task completed');\n    } catch (error) {\n        console.error('Cron job error:', error);\n    }\n});\n```\n\n**Multiple Tasks for Same Schedule:**\n```typescript\n// In worker/app.ts, after initializing crowdinApp\nconst crowdinApp = crowdinModule.addCrowdinEndpoints(app, configuration) as CrowdinAppUtilities;\n\n// Both tasks will run daily at midnight\ncrowdinApp.cron.schedule('0 0 * * *', async () => {\n    try {\n        console.log('Daily cleanup started');\n        // Cleanup old data\n    } catch (error) {\n        console.error('Cleanup error:', error);\n    }\n});\n\ncrowdinApp.cron.schedule('0 0 * * *', async () => {\n    try {\n        console.log('Daily report started');\n        // Generate reports\n    } catch (error) {\n        console.error('Report error:', error);\n    }\n});\n```\n\n**Using Crowdin API Client in Cron Jobs:**\n```typescript\n// In worker/app.ts, after initializing crowdinApp\nconst crowdinApp = crowdinModule.addCrowdinEndpoints(app, configuration) as CrowdinAppUtilities;\n\n// Register cron job that processes data for multiple organizations\ncrowdinApp.cron.schedule('0 0 * * *', async () => {\n    try {\n        console.log('Daily sync started');\n        \n        // Get all metadata records\n        const allMetadata = await crowdinApp.storage.getAllMetadata();\n        \n        if (!allMetadata || allMetadata.length === 0) {\n            console.log('No metadata found, skipping sync');\n            return;\n        }\n        \n        // Filter metadata by pattern using regex (e.g., find all organization configs)\n        const configPattern = /^org_(\\d+)_config$/;\n        const orgConfigs = allMetadata.filter(record => \n            configPattern.test(record.id)\n        );\n        \n        console.log(`Found ${orgConfigs.length} organization configs to process`);\n        \n        // Process each organization separately\n        for (const configRecord of orgConfigs) {\n            try {\n                const match = configRecord.id.match(configPattern);\n                const organizationId = match?.[1];\n                const crowdinId = configRecord.crowdin_id; // domain or organizationId\n                const configData = JSON.parse(configRecord.data || '{}');\n                \n                console.log(`Processing organization ${organizationId}`);\n                \n                // Create individual Crowdin API client for this organization\n                const encryptedData = crowdinApp.encryptCrowdinConnection({\n                    crowdinId,\n                    extra: {}, // Always pass empty object\n                });\n                \n                const { client } = await crowdinApp.dencryptCrowdinConnection(encryptedData, true);\n                \n                // Use client to make API calls for this specific organization\n                const projects = await client.projectsGroupsApi.withFetchAll().listProjects();\n                console.log(`Organization ${organizationId}: Found ${projects.data.length} projects`);\n                \n                // Process organization-specific configuration\n                if (configData.autoSync) {\n                    console.log(`Organization ${organizationId}: Auto-sync enabled, processing...`);\n                    // Perform sync operations\n                }\n                \n            } catch (error) {\n                console.error(`Error processing organization ${organizationId}:`, error);\n                // Continue with next organization\n            }\n        }\n        \n        console.log('Daily sync completed');\n    } catch (error) {\n        console.error('Cron job error:', error);\n    }\n});\n```\n\n#### Best Practices\n\n1. **Use appropriate intervals for your task**\n   ```typescript\n   // ‚úÖ CORRECT - frequent checks for time-sensitive tasks\n   crowdinApp.cron.schedule('0 * * * *', async () => {\n       // Hourly notification checks\n   });\n   \n   // ‚úÖ CORRECT - less frequent for resource-intensive tasks\n   crowdinApp.cron.schedule('0 0 * * *', async () => {\n       // Daily cleanup or report generation\n   });\n   \n   // ‚ùå WRONG - using unsupported interval\n   crowdinApp.cron.schedule('*/5 * * * *', async () => {\n       // Every 5 minutes - NOT SUPPORTED\n   });\n   ```\n\n2. **Handle errors gracefully**\n   ```typescript\n   // ‚úÖ CORRECT - catch and log errors\n   crowdinApp.cron.schedule('0 * * * *', async () => {\n       try {\n           await performTask();\n       } catch (error) {\n           console.error('Cron job failed:', error);\n           // Log error but don't throw - let job complete\n       }\n   });\n   \n   // ‚ùå WRONG - unhandled errors\n   crowdinApp.cron.schedule('0 * * * *', async () => {\n       await performTask(); // May crash if it throws\n   });\n   ```\n\n3. **Keep cron jobs lightweight**\n   ```typescript\n   // ‚úÖ CORRECT - efficient processing\n   crowdinApp.cron.schedule('0 0 * * *', async () => {\n       const startTime = Date.now();\n       console.log('Task started');\n       \n       // Perform lightweight operations\n       await quickCleanup();\n       \n       console.log(`Completed in ${Date.now() - startTime}ms`);\n   });\n   \n   // ‚ùå WRONG - heavy processing that may timeout\n   crowdinApp.cron.schedule('0 * * * *', async () => {\n       // Processing millions of records - may timeout\n       const allData = await fetchAllData();\n       await processAll(allData);\n   });\n   ```\n\n4. **Always await async operations**\n   ```typescript\n   // ‚úÖ CORRECT - await all async operations\n   crowdinApp.cron.schedule('0 * * * *', async () => {\n       await saveData();\n       await processQueue();\n       console.log('All tasks completed');\n   });\n   \n   // ‚úÖ CORRECT - setTimeout with proper promise wrapper\n   crowdinApp.cron.schedule('0 * * * *', async () => {\n       await new Promise((resolve) => {\n           setTimeout(async () => {\n               await processData();\n               resolve();\n           }, 1000);\n       });\n   });\n   \n   // ‚ùå WRONG - promise without await (will not complete)\n   crowdinApp.cron.schedule('0 * * * *', async () => {\n       saveData(); // This will NOT complete before cron job ends\n       console.log('Done'); // Logs immediately, but saveData is not finished\n   });\n   \n   // ‚ùå WRONG - setTimeout without proper promise wrapper\n   crowdinApp.cron.schedule('0 * * * *', async () => {\n       setTimeout(async () => {\n           await processData(); // This will NOT execute\n       }, 1000);\n   });\n   ```\n\n5. **Log execution for debugging**\n   ```typescript\n   // ‚úÖ CORRECT - comprehensive logging\n   crowdinApp.cron.schedule('0 */6 * * *', async () => {\n       const startTime = Date.now();\n       console.log(`Cron job started at ${new Date().toISOString()}`);\n       \n       try {\n           await performTask();\n           console.log(`Completed in ${Date.now() - startTime}ms`);\n       } catch (error) {\n           console.error(`Failed after ${Date.now() - startTime}ms:`, error);\n       }\n   });\n   ```\n\n### Webhooks\n\n#### Overview\n\nWebhooks allow your app to subscribe to events that occur in Crowdin projects or organizations. When a subscribed event happens, Crowdin automatically sends the event data to your app's callback function.\n\n#### Official Documentation\n\n**üìö Complete Documentation:** [Crowdin Webhooks](https://crowdin.github.io/app-project-module/tools/webhook/)\n\n**üìö Available Events:** [Webhook Events List](https://support.crowdin.com/developer/webhooks/)\n\n**‚ö†Ô∏è CRITICAL**: Only use event names from the official events list. Invalid event names will be ignored.\n\n#### Configuration\n\nConfigure webhooks in your app configuration in `worker/app.ts`:\n\n```typescript\nconst configuration: ClientConfig = {\n    // ... other configuration ...\n    \n    // Webhook subscriptions\n    webhooks: [\n        {\n            // List of events to subscribe to\n            events: ['file.added', 'file.updated', 'file.deleted'],\n            \n            // Callback function that handles events\n            callback({ client, events, webhookContext }) {\n                console.log('Received events:', events);\n                console.log('Organization:', webhookContext.organizationId);\n                console.log('User:', webhookContext.userId);\n                \n                // Process events here\n                events.forEach(event => {\n                    console.log('Event:', event.event, 'Project:', event.file.project.id);\n                });\n            },\n            \n            deferResponse: true\n        },\n        {\n            // You can have multiple webhook subscriptions\n            events: ['suggestion.updated', 'string.added'],\n            callback({ client, events, webhookContext }) {\n                // Handle translation events\n            },\n            \n            deferResponse: true\n        }\n    ]\n};\n```\n\n#### Common Examples\n\n**File Events:**\n```typescript\nwebhooks: [\n    {\n        events: ['file.added', 'file.updated', 'file.deleted', 'file.reverted'],\n        async callback({ client, events, webhookContext }) {\n            for (const event of events) {\n                console.log(`File ${event.event} in project ${event.file.project.id}`);\n                console.log('File details:', event.file);\n                \n                // Example: Get project details when file is added\n                if (event.event === 'file.added') {\n                    const project = await client.projectsGroupsApi.getProject(event.file.project.id);\n                    console.log('Project name:', project.data.name);\n                }\n            }\n        },\n        deferResponse: true\n    }\n]\n```\n\n#### Callback Parameters\n\nThe callback function receives an object with three properties:\n\n```typescript\ninterface WebhookCallback {\n    /**\n     * Crowdin API client - use to make API calls\n     * Same client as connection.client in endpoints\n     */\n    client: CrowdinApi;\n    \n    /**\n     * Array of webhook event objects\n     * Multiple events may be batched together\n     */\n    events: WebhookEvent[];\n    \n    /**\n     * Context information about the webhook\n     */\n    webhookContext: {\n        /** Crowdin domain (e.g., \"crowdin.com\") */\n        domain: string;\n        \n        /** Organization ID where event occurred */\n        organizationId: number;\n        \n        /** User ID who installed the application */\n        userId: number;\n        \n        /** Agent ID (if authenticationType is \"crowdin_agent\") */\n        agentId?: number;\n    };\n}\n```\n\n#### Common Event Types\n\n**Project Events:**\n- `project.created` - New project added\n- `project.deleted` - Project deleted\n- `project.translated` - Project fully translated\n- `project.approved` - Project reviewed\n- `project.built` - Project built\n\n**Group Events:**\n- `group.created` - New group added\n- `group.deleted` - Group deleted\n\n**File Events:**\n- `file.added` - New file added to project\n- `file.updated` - File updated\n- `file.deleted` - File deleted from project\n- `file.reverted` - File reverted to previous version\n- `file.translated` - File fully translated\n- `file.approved` - File reviewed\n\n**String Events:**\n- `string.added` - New source string added\n- `string.updated` - Source string updated\n- `string.deleted` - Source string deleted\n\n**Translation Events:**\n- `suggestion.added` - String translation added\n- `suggestion.updated` - String translation updated\n- `suggestion.deleted` - String translation deleted\n- `suggestion.approved` - String translation approved\n- `suggestion.disapproved` - String translation disapproved\n\n**Comment Events:**\n- `stringComment.created` - String comment added\n- `stringComment.updated` - String comment updated\n- `stringComment.deleted` - String comment deleted\n- `stringComment.restored` - String comment restored\n\n**Task Events:**\n- `task.added` - New task added\n- `task.statusChanged` - Task status changed\n- `task.updated` - Task updated\n- `task.deleted` - Task deleted\n\n#### Best Practices\n\n1. **Always set deferResponse to true**\n   ```typescript\n   // ‚úÖ CORRECT - deferResponse is set to true\n   webhooks: [\n       {\n           events: ['file.added'],\n           callback({ client, events, webhookContext }) {\n               console.log('Processing events');\n           },\n           deferResponse: true  // REQUIRED!\n       }\n   ]\n   \n   // ‚ùå WRONG - missing deferResponse\n   webhooks: [\n       {\n           events: ['file.added'],\n           callback({ client, events, webhookContext }) {\n               console.log('Processing events');\n           }\n           // Missing deferResponse: true - this will cause issues!\n       }\n   ]\n   ```\n\n2. **Handle multiple events in batch**\n   ```typescript\n   // ‚úÖ CORRECT - process all events\n   callback({ client, events, webhookContext }) {\n       events.forEach(event => {\n           console.log('Processing event:', event.event);\n       });\n   }\n   \n   // ‚ùå WRONG - only processes first event\n   callback({ client, events, webhookContext }) {\n       const event = events[0];\n       console.log('Processing event:', event.event);\n   }\n   ```\n\n3. **Handle errors gracefully**\n   ```typescript\n   // ‚úÖ CORRECT - catches and logs errors\n   async callback({ client, events, webhookContext }) {\n       for (const event of events) {\n           try {\n               await processEvent(event);\n           } catch (error) {\n               console.error('Failed to process event:', event.event, error);\n               // Continue processing other events\n           }\n       }\n   }\n   ```\n\n4. **Check event type before processing**\n   ```typescript\n   // ‚úÖ CORRECT - checks event type\n   callback({ client, events, webhookContext }) {\n       events.forEach(event => {\n           if (event.event === 'file.added') {\n               console.log('New file:', event.file?.name);\n           } else if (event.event === 'file.updated') {\n               console.log('Updated file:', event.file?.name);\n           }\n       });\n   }\n   ```\n\n5. **Use webhookContext for scoping**\n   ```typescript\n   // ‚úÖ CORRECT - uses context for organization-specific logic\n   async callback({ client, events, webhookContext }) {\n       const orgId = webhookContext.organizationId;\n       const userId = webhookContext.userId;\n       \n       // Store event in metadata\n       const key = `org_${orgId}_events_${Date.now()}`;\n       // await crowdinModule.metadataStore.saveMetadata(key, events, `${webhookContext.domain || webhookContext.organizationId}`);\n   }\n   ```\n\n6. **Don't perform long-running operations**\n   ```typescript\n   // ‚úÖ CORRECT - quick processing, delegate heavy work\n   async callback({ client, events, webhookContext }) {\n       // Quick logging\n       console.log('Received', events.length, 'events');\n       \n       // Store for later processing\n       const key = `org_${webhookContext.organizationId}_queue`;\n       // await crowdinModule.metadataStore.saveMetadata(key, events, `${webhookContext.domain || webhookContext.organizationId}`);\n   }\n   \n   // ‚ö†Ô∏è PROBLEMATIC - long-running operation blocks webhook\n   async callback({ client, events, webhookContext }) {\n       // This might timeout\n       for (const event of events) {\n           await processLargeFile(event.file?.id);\n           await sendMultipleNotifications(event);\n           await updateExternalDatabase(event);\n       }\n   }\n   ```\n\n#### Event Object Structure\n\nEach event type has its own interface with specific fields. Use these interfaces to understand which data is available for each event:\n\n```typescript\n// ============================================================================\n// SHARED MODELS - Reusable data structures\n// ============================================================================\n\ninterface ProjectModel {\n    id: number;\n    name: string;\n    identifier: string;\n    sourceLanguageId: string;\n    targetLanguageIds: string[];\n}\n\ninterface UserModel {\n    id: number;\n    username: string;\n}\n\ninterface LanguageModel {\n    id: string;\n    name: string;\n}\n\ninterface FileModelBase {\n    id: number;\n    name: string;\n    title: string;\n    type: string;\n    path: string;\n    branchId: number | null;\n    directoryId: number | null;\n}\n\ninterface FileModel extends FileModelBase {\n    project: ProjectModel;\n}\n\ninterface GroupModel {\n    id: number;\n    name: string;\n    parentId: number | null;\n}\n\ninterface StringModelBase {\n    id: number;\n    identifier: string;\n    text: string;\n    context: string | null;\n    isHidden: boolean;\n}\n\ninterface StringModel extends StringModelBase {\n    file: FileModelBase;\n    project: ProjectModel;\n}\n\ninterface TranslationModelBase {\n    id: number;\n    text: string;\n}\n\ninterface TranslationModel extends TranslationModelBase {\n    user: UserModel;\n    targetLanguage: LanguageModel;\n    string: StringModel;\n}\n\ninterface TaskModel {\n    id: number;\n    type: 0 | 1; // 0 - Translate, 1 - Proofread\n    title: string;\n    status: 'todo' | 'in_progress' | 'done' | 'closed' | 'pending' | 'review';\n    sourceLanguage: LanguageModel;\n    targetLanguage: LanguageModel;\n    project: ProjectModel;\n    taskCreator: UserModel;\n}\n\ninterface CommentModelBase {\n    id: number;\n    text: string;\n    type: 'issue' | 'comment';\n    issueType: 'general_question' | 'translation_mistake' |  'context_request' |  'source_mistake';\n    issueStatus: 'resolved' | 'unresolved';\n}\n\ninterface CommentModel extends CommentModelBase {\n    string: StringModel;\n    targetLanguage: LanguageModel;\n    user: UserModel;\n    commentResolver: UserModel | null;\n}\n\ninterface BuildModel {\n    id: number;\n    downloadUrl: string;\n    project: ProjectModel;\n}\n\n// ============================================================================\n// BASE EVENT INTERFACES\n// ============================================================================\n\ninterface BaseEventWithUser {\n    user: UserModel;\n}\n\ninterface BaseProjectEvent {\n    project: ProjectModel;\n}\n\ninterface BaseGroupEvent {\n    group: GroupModel;\n}\n\ninterface BaseFileEvent {\n    file: FileModel;\n}\n\ninterface BaseStringEvent {\n    string: StringModel;\n}\n\ninterface BaseTranslationEvent {\n    translation: TranslationModel;\n}\n\ninterface BaseTaskEvent {\n    task: TaskModel;\n}\n\ninterface BaseCommentEvent {\n    comment: CommentModel;\n}\n\n// ============================================================================\n// PROJECT EVENTS\n// ============================================================================\n\ninterface ProjectCreatedEvent extends BaseProjectEvent, BaseEventWithUser {\n    event: 'project.created';\n}\n\ninterface ProjectDeletedEvent extends BaseProjectEvent, BaseEventWithUser {\n    event: 'project.deleted';\n}\n\ninterface ProjectTranslatedEvent extends BaseProjectEvent {\n    event: 'project.translated';\n    targetLanguage: LanguageModel;\n}\n\ninterface ProjectApprovedEvent extends BaseProjectEvent {\n    event: 'project.approved';\n    targetLanguage: LanguageModel;\n}\n\ninterface ProjectBuiltEvent {\n    event: 'project.built';\n    build: BuildModel;\n}\n\n// ============================================================================\n// GROUP EVENTS\n// ============================================================================\n\ninterface GroupCreatedEvent extends BaseGroupEvent, BaseEventWithUser {\n    event: 'group.created';\n}\n\ninterface GroupDeletedEvent extends BaseGroupEvent, BaseEventWithUser {\n    event: 'group.deleted';\n}\n\n// ============================================================================\n// FILE EVENTS\n// ============================================================================\n\ninterface FileAddedEvent extends BaseFileEvent, BaseEventWithUser {\n    event: 'file.added';\n}\n\ninterface FileUpdatedEvent extends BaseFileEvent, BaseEventWithUser {\n    event: 'file.updated';\n}\n\ninterface FileDeletedEvent extends BaseFileEvent, BaseEventWithUser {\n    event: 'file.deleted';\n}\n\ninterface FileRevertedEvent extends BaseFileEvent, BaseEventWithUser {\n    event: 'file.reverted';\n}\n\ninterface FileTranslatedEvent extends BaseFileEvent {\n    event: 'file.translated';\n    targetLanguage: LanguageModel;\n}\n\ninterface FileApprovedEvent extends BaseFileEvent {\n    event: 'file.approved';\n    targetLanguage: LanguageModel;\n}\n\n// ============================================================================\n// STRING EVENTS\n// ============================================================================\n\ninterface StringAddedEvent extends BaseStringEvent, BaseEventWithUser {\n    event: 'string.added';\n}\n\ninterface StringUpdatedEvent extends BaseStringEvent, BaseEventWithUser {\n    event: 'string.updated';\n}\n\ninterface StringDeletedEvent extends BaseStringEvent, BaseEventWithUser {\n    event: 'string.deleted';\n}\n\n// ============================================================================\n// TRANSLATION/SUGGESTION EVENTS\n// ============================================================================\n\ninterface SuggestionAddedEvent extends BaseTranslationEvent {\n    event: 'suggestion.added';\n}\n\ninterface SuggestionUpdatedEvent extends BaseTranslationEvent {\n    event: 'suggestion.updated';\n}\n\ninterface SuggestionDeletedEvent extends BaseTranslationEvent {\n    event: 'suggestion.deleted';\n}\n\ninterface SuggestionApprovedEvent extends BaseTranslationEvent {\n    event: 'suggestion.approved';\n}\n\ninterface SuggestionDisapprovedEvent extends BaseTranslationEvent {\n    event: 'suggestion.disapproved';\n}\n\ninterface TranslationUpdatedEvent {\n    event: 'translation.updated';\n    newTranslation: TranslationModel;\n}\n\n// ============================================================================\n// COMMENT EVENTS\n// ============================================================================\n\ninterface StringCommentCreatedEvent extends BaseCommentEvent {\n    event: 'stringComment.created';\n}\n\ninterface StringCommentUpdatedEvent extends BaseCommentEvent {\n    event: 'stringComment.updated';\n}\n\ninterface StringCommentDeletedEvent extends BaseCommentEvent {\n    event: 'stringComment.deleted';\n}\n\ninterface StringCommentRestoredEvent extends BaseCommentEvent {\n    event: 'stringComment.restored';\n}\n\n// ============================================================================\n// TASK EVENTS\n// ============================================================================\n\ninterface TaskAddedEvent extends BaseTaskEvent {\n    event: 'task.added';\n}\n\ninterface TaskStatusChangedEvent extends BaseTaskEvent {\n    event: 'task.statusChanged';\n}\n\ninterface TaskUpdatedEvent extends BaseTaskEvent {\n    event: 'task.updated';\n}\n\ninterface TaskDeletedEvent extends BaseTaskEvent {\n    event: 'task.deleted';\n}\n\n// ============================================================================\n// UNION TYPE - All possible webhook events\n// ============================================================================\n\ntype WebhookEvent = \n    // Project events\n    | ProjectCreatedEvent\n    | ProjectDeletedEvent\n    | ProjectTranslatedEvent\n    | ProjectApprovedEvent\n    | ProjectBuiltEvent\n    // Group events\n    | GroupCreatedEvent\n    | GroupDeletedEvent\n    // File events\n    | FileAddedEvent\n    | FileUpdatedEvent\n    | FileDeletedEvent\n    | FileRevertedEvent\n    | FileTranslatedEvent\n    | FileApprovedEvent\n    // String events\n    | StringAddedEvent\n    | StringUpdatedEvent\n    | StringDeletedEvent\n    // Translation/Suggestion events\n    | SuggestionAddedEvent\n    | SuggestionUpdatedEvent\n    | SuggestionDeletedEvent\n    | SuggestionApprovedEvent\n    | SuggestionDisapprovedEvent\n    | TranslationUpdatedEvent\n    // Comment events\n    | StringCommentCreatedEvent\n    | StringCommentUpdatedEvent\n    | StringCommentDeletedEvent\n    | StringCommentRestoredEvent\n    // Task events\n    | TaskAddedEvent\n    | TaskStatusChangedEvent\n    | TaskUpdatedEvent\n    | TaskDeletedEvent;\n```\n\n## Frontend Development\n\n### Crowdin Apps JS API\n\n#### Official Documentation\n\nThe `AP` object provides the Crowdin Apps JS API for interacting with the Crowdin application context.\n\n**üìö Complete API Reference:** https://support.crowdin.com/developer/crowdin-apps-js/\n\n**‚ö†Ô∏è CRITICAL**: Only use methods and types from the Crowdin Apps JS API definitions below.\n\n**Do NOT invent methods or properties that are not listed here.**\n\n#### Common Examples\n\n**Get Context (Promise-based):**\n```typescript\n// Promisified helper\nconst getContext = (): Promise<any> => {\n    return new Promise(resolve => window.AP.getContext(resolve));\n};\n\n// Usage\nconst context = await getContext();\nconsole.log('Project ID:', context.project_id);\n```\n\n**Get JWT Token (Promise-based):**\n```typescript\n// Promisified helper\nconst getJwtToken = (): Promise<string> => {\n    return new Promise(resolve => window.AP.getJwtToken(resolve));\n};\n\n// Usage with fetch\nconst token = await getJwtToken();\nconst response = await fetch(`/api/endpoint?jwt=${token}`);\nconst data = await response.json();\n```\n\n#### Best Practices\n\n1. **Handle errors gracefully**\n   ```typescript\n   try {\n       const context = await getContext();\n       if (!context.organization_id) {\n           throw new Error('Organization ID not found');\n       }\n       // Your code\n   } catch (error) {\n       console.error('Failed to get context:', error);\n   }\n   ```\n\n#### Complete Type Definitions\n\n##### Global AP Object Structure\n\n```typescript\ndeclare namespace AP {\n    // Global Actions\n    function getContext(callback: (context: Context) => void): void;\n    function getJwtToken(callback: (token: string) => void): void;\n    function getTheme(): 'light' | 'dark';\n    function redirect(path: string): void;\n}\n```\n\n##### Type Definitions\n\n```typescript\n// Context Information\ninterface Context {\n    project_id: number;\n    organization_id: number;\n}\n```\n\n## Development Workflow\n\n### 1. Configure Your App Identity\n\n**‚ö†Ô∏è Important**: You MUST update the configuration in `worker/app.ts` before deployment:\n\n```typescript\nconst configuration: ClientConfig = {\n    name: \"Your App Name\",           // Change this to your app's display name\n    identifier: \"your-app-id\",       // Change to unique identifier (lowercase, hyphens)\n    description: \"Your app description\", // Change to describe your app's purpose\n    // ... rest of configuration\n}\n```\n\n**Note**: The `identifier` must be unique across all Crowdin apps. Use format like: `company-organization-menu`\n\n### 2. Key Files to Modify\n\n- `worker/app.ts` - Add new API endpoints here\n- `src/pages/HomePage.tsx` - Main page component (customize for your app logic)\n- `src/components/app-sidebar.tsx` - Sidebar navigation (customize menu items)\n- `src/components/layout/AppLayout.tsx` - Application layout (customize layout structure)\n- `src/index.css` - Customize global styles and Tailwind theme\n- `tailwind.config.js` - Add custom colors and extend theme"
    }
  },
  {
    "name": "crowdin-profile-resources-menu",
    "language": "typescript",
    "frameworks": [
      "@dnd-kit",
      "@hookform/resolvers",
      "autoprefixer",
      "class-variance-authority",
      "cloudflare",
      "clsx",
      "cmdk",
      "date-fns",
      "express",
      "framer-motion",
      "immer",
      "input-otp",
      "next",
      "postcss",
      "react",
      "recharts",
      "sonner",
      "tailwind",
      "tw-animate-css",
      "typescript",
      "vaul",
      "vite",
      "wrangler",
      "zod",
      "zustand"
    ],
    "description": {
      "selection": "# Template Selection\n\nCrowdin app with Profile Resources Menu module.\n\nUse when:\n- Building user-specific tools and preferences\n- Creating personal dashboards and settings\n- Developing user profile extensions\n- Building user-level integrations and configurations\n- Managing user preferences and settings\n- Creating personal analytics and statistics tools\n\nAvoid when:\n- Integrating custom AI providers (use AI Provider instead)\n- Building machine translation integrations (use Custom MT instead)\n- Building editor extensions (use Editor Right Panel instead)\n- Transforming files during import/export (use File Processing instead)\n- Building organization-wide tools (use Organization Menu instead)\n- Building project-specific tools (use Project Tools instead)\n\nBuilt with:\n- Crowdin Apps JS API\n- Crowdin Apps SDK (@crowdin/app-project-module)\n- React\n- ShadCN UI\n- Tailwind\n- Lucide Icons\n- ESLint\n- Vite\n- TypeScript\n- Express.js\n- Cloudflare Workers",
      "usage": "# Usage\n\n## Overview\nCrowdin app with Profile Resources Menu module for user-specific functionality.\n- Backend: TypeScript with Express.js and Crowdin Apps SDK\n- Frontend: React + TypeScript + ShadCN UI + Crowdin Apps JS API\n\n## Tech Stack\n- Crowdin Apps JS API\n- Crowdin Apps SDK (@crowdin/app-project-module)\n- React\n- ShadCN UI\n- Tailwind\n- Lucide Icons\n- ESLint\n- Vite\n- TypeScript\n- Express.js\n- Cloudflare Workers\n\n## Development Restrictions\n- **Tailwind Colors**: Hardcode custom colors in `tailwind.config.js`, NOT in `index.css`\n- **Components**: Use existing ShadCN components instead of writing custom ones\n- **Icons**: Import from `lucide-react` directly\n- **Error Handling**: ErrorBoundary components are pre-implemented\n- **Authentication**: Always use JWT tokens from Crowdin for API requests\n- **Profile Resources Menu Configuration**: Don't modify the profileResourcesMenu configuration structure\n- **Scopes**: Ensure your app has appropriate API scopes\n- **Storage Keys**: Always include organizationId in metadata keys to isolate data per organization\n\n## Styling\n- Responsive, accessible\n- Prefer ShadCN components; Tailwind for layout/spacing/typography\n- Use framer-motion sparingly for micro-interactions\n\n## Project Structure\n\n### Backend Structure\n- `worker/app.ts` - Express app factory with Profile Resources Menu configuration\n- `worker/index.ts` - Cloudflare Worker entry point (HTTP handler, cron scheduler, middleware)\n- `worker/types/` - Backend TypeScript type definitions\n  - `cloudflare-env.d.ts` - Cloudflare environment types (KV storage, secrets)\n\n### Frontend Structure\n- `index.html` - HTML entry point with Crowdin Apps JS API script\n- `src/main.tsx` - React entry point with ErrorBoundary wrapper\n- `src/index.css` - Global styles and Tailwind CSS customizations\n- `src/components/` - React components\n  - `app-sidebar.tsx` - Application sidebar navigation\n  - `ErrorBoundary.tsx` - React error boundary with backend error reporting\n  - `ErrorFallback.tsx` - Fallback UI component for error states\n  - `RouteErrorBoundary.tsx` - Error boundary for routing errors\n  - `layout/` - Layout components\n    - `AppLayout.tsx` - Main application layout wrapper\n  - `ui/` - ShadCN UI components (button, card, sonner, etc.)\n- `src/pages/` - Page components\n  - `HomePage.tsx` - Home page component (main entry point for your app logic)\n- `src/hooks/` - Custom React hooks\n  - `use-mobile.tsx` - Hook for detecting mobile breakpoints\n- `src/lib/` - Utility modules\n  - `utils.ts` - Tailwind utility functions (`cn` for class merging)\n  - `errorReporter.ts` - Client-side error reporting to backend\n  - `apiClient.ts` - Generic API call wrapper with JWT token handling\n- `src/types/` - TypeScript type definitions\n  - `global.d.ts` - Global type declarations\n  - `vite-env.d.ts` - Vite environment types\n\n## Backend Development\n\n### App Configuration\n\nConfigure your app identity in `worker/app.ts`:\n\n```typescript\nconst configuration: ClientConfig = {\n    name: \"Your App Name\",                    // Display name shown in Crowdin UI\n    identifier: \"your-unique-app-identifier\", // Unique ID (lowercase, hyphens)\n    description: \"Your app description\",      // Brief description of functionality\n    // ... rest of configuration\n}\n```\n\n**Guidelines:**\n- **identifier**: Must be unique across all Crowdin apps. Format: `company-profile-menu`\n- **name**: User-friendly display name (e.g., \"User Preferences\")\n- **description**: Brief explanation of what your app does\n\n#### Required Scopes\n\nAdd scopes to configuration in `worker/app.ts` based on your app's functionality.\n\n**‚ö†Ô∏è IMPORTANT**: Only use scopes from the list below. Do not invent or use non-existent scopes!\n\n```typescript\nconst configuration: ClientConfig = {\n    // ... other configuration ...\n    scopes: [\n        // Choose from the following valid scopes:\n        \n        // General scopes\n        crowdinModule.Scope.NOTIFICATIONS,               // 'notification' - Notifications management\n        \n        // Project-level scopes\n        crowdinModule.Scope.PROJECTS,                    // 'project' - Project management\n        crowdinModule.Scope.TASKS,                       // 'project.task' - Project tasks\n        crowdinModule.Scope.REPORTS,                     // 'project.report' - Project reports\n        crowdinModule.Scope.TRANSLATION_STATUS,          // 'project.status' - Translation status\n        crowdinModule.Scope.SOURCE_FILES_AND_STRINGS,    // 'project.source' - Source files and strings\n        crowdinModule.Scope.WEBHOOKS,                    // 'project.webhook' - Project webhooks\n        crowdinModule.Scope.TRANSLATIONS,                // 'project.translation' - Translations\n        crowdinModule.Scope.SCREENSHOTS,                 // 'project.screenshot' - Screenshots\n        \n        // Organization-level scopes\n        crowdinModule.Scope.USERS,                       // 'user' - User management\n        crowdinModule.Scope.TEAMS,                       // 'team' - Team management\n        crowdinModule.Scope.GROUPS,                      // 'group' - Group management\n        crowdinModule.Scope.ORGANIZATION_WEBHOOKS,       // 'webhook' - Organization webhooks\n        crowdinModule.Scope.VENDORS,                     // 'vendor' - Vendor management\n        crowdinModule.Scope.FIELDS,                      // 'field' - Custom fields\n        crowdinModule.Scope.SECURITY_LOGS,               // 'security-log' - Security logs\n        crowdinModule.Scope.APPLICATIONS,                // 'application' - Applications management\n        \n        // Resources\n        crowdinModule.Scope.TRANSLATION_MEMORIES,        // 'tm' - Translation memories\n        crowdinModule.Scope.MACHINE_TRANSLATION_ENGINES, // 'mt' - Machine translation engines\n        crowdinModule.Scope.GLOSSARIES,                  // 'glossary' - Glossaries\n        \n        // AI-related scopes\n        crowdinModule.Scope.AI,                          // 'ai' - AI features\n        crowdinModule.Scope.AI_PROVIDERS,                // 'ai.provider' - AI providers\n        crowdinModule.Scope.AI_PROMPTS,                  // 'ai.prompt' - AI prompts\n        crowdinModule.Scope.AI_PROXIES,                  // 'ai.proxy' - AI proxies\n    ]\n}\n```\n\n### Profile Resources Menu Module Configuration\n\nConfigure the Profile Resources Menu module in `worker/app.ts`:\n\n```typescript\nconst configuration: ClientConfig = {\n    // ... other configuration ...\n\n    profileResourcesMenu: {\n      fileName: 'index.html',\n      uiPath: '/'\n    }\n}\n```\n\n### API Endpoints Best Practices\n\n#### Common Examples\n\n**Standard Endpoint:**\n```typescript\napp.post('/api/process-data', async (req: Request, res: Response) => {\n    try {\n        const jwt = req.query.jwt as string;\n        const { data } = req.body;\n        \n        if (!jwt) {\n            return res.status(400).json({ success: false, error: 'JWT token is required' });\n        }\n        if (!data) {\n            return res.status(400).json({ success: false, error: 'Data is required' });\n        }\n\n        const connection = await crowdinApp.establishCrowdinConnection(jwt, undefined);\n        \n        // Your async logic here\n        const result = await processData(data);\n        \n        res.json({ \n            success: true, \n            result\n        });\n    } catch (error) {\n        console.error('Error:', error);\n        res.status(500).json({ success: false, error: 'Operation failed' });\n    }\n});\n```\n\n#### Best Practices\n\n1. **Always await async operations**\n   ```typescript\n   // ‚úÖ CORRECT - all operations are awaited\n   app.post('/api/save-config', async (req: Request, res: Response) => {\n       const jwt = req.query.jwt as string;\n       const connection = await crowdinApp.establishCrowdinConnection(jwt, undefined);\n       \n       await crowdinApp.saveMetadata(key, data, connection.context.crowdinId);\n       \n       res.json({ success: true });\n   });\n   \n   // ‚ùå WRONG - missing await, operation will NOT complete\n   app.post('/api/save-config', async (req: Request, res: Response) => {\n       const jwt = req.query.jwt as string;\n       const connection = await crowdinApp.establishCrowdinConnection(jwt, undefined);\n       \n       // This will NOT save! Response is sent before operation completes\n       crowdinApp.saveMetadata(key, data, connection.context.crowdinId);\n       \n       res.json({ success: true });\n   });\n   ```\n\n2. **Always return response after all operations complete**\n   ```typescript\n   // ‚úÖ CORRECT - response sent after all operations\n   app.post('/api/update', async (req: Request, res: Response) => {\n       const connection = await crowdinApp.establishCrowdinConnection(jwt, undefined);\n       \n       await operation1();\n       await operation2();\n       await operation3();\n       \n       res.json({ success: true }); // All operations completed\n   });\n   \n   // ‚ùå WRONG - response sent too early\n   app.post('/api/update', async (req: Request, res: Response) => {\n       const connection = await crowdinApp.establishCrowdinConnection(jwt, undefined);\n       \n       res.json({ success: true }); // Sent immediately\n       \n       await operation1(); // These will NOT execute\n       await operation2();\n       await operation3();\n   });\n   ```\n\n3. **Use Promise.all for independent parallel operations**\n   ```typescript\n   // ‚úÖ CORRECT - parallel operations (faster)\n   const [result1, result2, result3] = await Promise.all([\n       connection.client.projectsGroupsApi.getProject(id1),\n       connection.client.projectsGroupsApi.getProject(id2),\n       connection.client.projectsGroupsApi.getProject(id3)\n   ]);\n   \n   // ‚ùå WRONG - sequential operations (slower)\n   const result1 = await connection.client.projectsGroupsApi.getProject(id1);\n   const result2 = await connection.client.projectsGroupsApi.getProject(id2);\n   const result3 = await connection.client.projectsGroupsApi.getProject(id3);\n   ```\n\n4. **Wrap all async code in try-catch**\n   ```typescript\n   // ‚úÖ CORRECT - comprehensive error handling\n   app.get('/api/data', async (req: Request, res: Response) => {\n       try {\n           const connection = await crowdinApp.establishCrowdinConnection(jwt, undefined);\n           const data = await fetchData();\n           res.json({ success: true, data });\n       } catch (error) {\n           console.error('Error:', error);\n           res.status(500).json({ success: false, error: 'Operation failed' });\n       }\n   });\n   \n   // ‚ùå WRONG - no error handling\n   app.get('/api/data', async (req: Request, res: Response) => {\n       const connection = await crowdinApp.establishCrowdinConnection(jwt, undefined);\n       const data = await fetchData(); // May throw unhandled error\n       res.json({ success: true, data });\n   });\n   ```\n\n5. **Never use setTimeout without proper promise wrapper**\n   ```typescript\n   // ‚úÖ CORRECT - setTimeout with promise wrapper\n   app.get('/api/delayed', async (req: Request, res: Response) => {\n       await new Promise((resolve) => {\n           setTimeout(async () => {\n               await saveData();\n               resolve(undefined);\n           }, 1000);\n       });\n       \n       res.json({ success: true });\n   });\n   \n   // ‚ùå WRONG - setTimeout without await (will NOT execute)\n   app.get('/api/delayed', async (req: Request, res: Response) => {\n       setTimeout(async () => {\n           await saveData(); // This will NOT execute\n       }, 1000);\n       \n       res.json({ success: true }); // Sent immediately\n   });\n   ```\n\n6. **Always check for required parameters early**\n   ```typescript\n   // ‚úÖ CORRECT - validate parameters first\n   app.post('/api/process', async (req: Request, res: Response) => {\n       const jwt = req.query.jwt as string;\n       const { projectId, data } = req.body;\n       \n       // Validate early\n       if (!jwt) {\n           return res.status(400).json({ error: 'JWT token is required' });\n       }\n       if (!projectId) {\n           return res.status(400).json({ error: 'Project ID is required' });\n       }\n       if (!data) {\n           return res.status(400).json({ error: 'Data is required' });\n       }\n       \n       // Continue with processing\n       const connection = await crowdinApp.establishCrowdinConnection(jwt, undefined);\n       // ... rest of the logic\n   });\n   ```\n\n### Crowdin API Client\n\n#### Official Documentation\n\nThe `connection.client` object is an instance of `@crowdin/crowdin-api-client`.\n\n**üìö Complete API Reference:** https://crowdin.github.io/crowdin-api-client-js/modules.html\n\n**‚ö†Ô∏è CRITICAL**: Only use methods documented in the official API reference. Do NOT invent or assume methods exist.\n\n#### Common Examples\n\n**Standard Endpoint Template:**\n```typescript\napp.get('/api/your-endpoint', async (req: Request, res: Response) => {\n    try {\n        const jwt = req.query.jwt as string;\n        if (!jwt) {\n            return res.status(400).json({ success: false, error: 'JWT token is required' });\n        }\n\n        if (!crowdinApp.establishCrowdinConnection) {\n            return res.status(500).json({ success: false, error: 'Crowdin connection method not available' });\n        }\n\n        const connection = await crowdinApp.establishCrowdinConnection(jwt, undefined);\n\n        if (!connection.client) {\n            return res.status(500).json({ success: false, error: 'Crowdin API client not available' });\n        }\n\n        const userId = connection.context.jwtPayload.context.user_id;\n        const organizationId = connection.context.jwtPayload.context.organization_id;\n\n        // Your logic here using connection.client API\n        \n        res.status(200).json({ success: true, data: result });\n    } catch (error) {\n        console.error('Error:', error);\n        res.status(500).json({ success: false, error: 'Operation failed' });\n    }\n});\n```\n\n**Get Project Details:**\n```typescript\nconst response = await connection.client.projectsGroupsApi.getProject(projectId);\n\n// Access project properties\nconst project = response.data;\nconst projectName = project.name;                    // string\nconst sourceLanguageId = project.sourceLanguageId;   // string\nconst targetLanguageIds = project.targetLanguageIds; // string[]\nconst description = project.description;             // string | null\n```\n\n**List All Projects (with pagination):**\n```typescript\nconst response = await connection.client.projectsGroupsApi.withFetchAll().listProjects();\n\n// Iterate through all projects\nresponse.data.forEach((projectItem: ResponseObject<ProjectsGroupsModel.Project>) => {\n  const projectId = projectItem.data.id;\n  const projectName = projectItem.data.name;\n  const groupId = projectItem.data.groupId; // number | null\n});\n```\n\n**Get Supported Languages:**\n```typescript\nconst response = await connection.client.languagesApi.withFetchAll().listSupportedLanguages();\n\n// Filter languages\nconst targetLanguageIds = ['uk', 'pl', 'de'];\nconst projectLanguages = response.data.filter(\n  (lang: ResponseObject<LanguagesModel.Language>) => targetLanguageIds.includes(lang.data.id)\n);\n\n// Map to simpler structure\nconst languages = projectLanguages.map((lang: ResponseObject<LanguagesModel.Language>) => ({\n  id: lang.data.id,           // string: \"uk\"\n  name: lang.data.name,       // string: \"Ukrainian\"\n  locale: lang.data.locale,   // string: \"uk-UA\"\n  osxLocale: lang.data.osxLocale // string\n}));\n```\n\n**List Source Files:**\n```typescript\nconst response = await connection.client.sourceFilesApi.withFetchAll().listProjectFiles(projectId);\n\nresponse.data.forEach((fileItem: ResponseObject<SourceFilesModel.File>) => {\n  const file = fileItem.data;\n  const fileId = file.id;             // number\n  const fileName = file.name;         // string\n  const branchId = file.branchId;     // number | null\n  const directoryId = file.directoryId; // number | null\n});\n```\n\n#### Best Practices\n\n1. **Always access data via `.data` property**\n   ```typescript\n   // ‚úÖ CORRECT\n   const project = response.data;\n   const projectName = response.data.name;\n   \n   // ‚ùå WRONG - will be undefined\n   const projectName = response.name;\n   ```\n\n2. **Use withFetchAll() for complete data**\n   ```typescript\n   // ‚úÖ CORRECT - gets all items\n   const response = await connection.client.languagesApi.withFetchAll().listSupportedLanguages();\n   \n   // ‚ö†Ô∏è PARTIAL - only first page (25 items)\n   const response = await connection.client.languagesApi.listSupportedLanguages();\n   ```\n\n3. **Handle nullable properties**\n   ```typescript\n   const description = response.data.description || 'No description';\n   const groupId = response.data.groupId ?? null;\n   ```\n\n4. **Handle errors properly**\n   ```typescript\n   try {\n     const response = await connection.client.projectsGroupsApi.getProject(projectId);\n     const project = response.data;\n     // Use project data\n   } catch (error: any) {\n     console.error('Crowdin API Error:', error);\n\n     // API errors have specific structure\n     if (error.code === 404) {\n       return res.status(404).json({ error: 'Project not found' });\n     }\n     \n     return res.status(500).json({\n       error: 'API request failed',\n       details: error.message\n     });\n   }\n   ```\n\n5. **Use TypeScript types**\n   ```typescript\n   import type { ResponseObject, ProjectsGroupsModel } from '@crowdin/crowdin-api-client';\n   \n   // Use in your code\n   const response: ResponseObject<ProjectsGroupsModel.Project> = await connection.client.projectsGroupsApi.getProject(projectId);\n   const project: ProjectsGroupsModel.Project = response.data;\n   ```\n\n6. **Always sort data explicitly when order matters**\n   ```typescript\n   // ‚úÖ CORRECT - sort projects by creation date (newest first)\n   const response = await connection.client.projectsGroupsApi.withFetchAll().listProjects();\n   const sortedByDate = response.data.sort(\n     (a: ResponseObject<ProjectsGroupsModel.Project>, b: ResponseObject<ProjectsGroupsModel.Project>) => {\n       const dateA = new Date(a.data.createdAt).getTime();\n       const dateB = new Date(b.data.createdAt).getTime();\n       return dateB - dateA; // Descending order (newest first)\n     }\n   );\n   \n   // ‚ùå WRONG - assuming data is already sorted by date\n   const response = await connection.client.projectsGroupsApi.withFetchAll().listProjects();\n   // Directly using response.data without sorting - order is not guaranteed!\n   ```\n\n7. **Never use CroQL - fetch all data and filter manually**\n   ```typescript\n   // ‚úÖ CORRECT - fetch all strings and filter manually\n   const allStrings = await connection.client.sourceStringsApi.withFetchAll().listProjectStrings(projectId);\n   \n   // Filter for specific criteria\n   const filteredStrings = allStrings.data.filter(\n     (item: ResponseObject<SourceStringsModel.String>) => {\n       const str = item.data;\n       return str.text.includes('welcome') && !str.isHidden;\n     }\n   );\n   \n   // ‚ùå WRONG - using CroQL queries\n   const response = await connection.client.sourceStringsApi.listProjectStrings(projectId, {\n     croql: 'text contains \"welcome\" AND isHidden = false'\n   });\n   // CroQL should be avoided - fetch all data and filter in your code instead\n   ```\n\n#### Complete Type Definitions\n\n**‚ö†Ô∏è CRITICAL**: Only use methods and types from `@crowdin/crowdin-api-client` definitions below.\n\n**Do NOT invent methods or properties that are not listed here.**\n\n<!-- CROWDIN_API_CLIENT_TYPES_START -->\n\n##### ai/index.d.ts\n\n```typescript\nimport { CrowdinApi, DownloadLink, PaginationOptions, PatchRequest, PlainObject, ResponseList, ResponseObject, Status } from '../core';\nexport declare class Ai extends CrowdinApi {\n    listAiOrganizationCustomPlaceholders(options?: PaginationOptions): Promise<ResponseList<AiModel.CustomPlaceholder>>;\n    addAiOrganizationCustomPlaceholder(request: AiModel.AddCustomPlaceholderRequest): Promise<ResponseObject<AiModel.CustomPlaceholder>>;\n    getAiOrganizationCustomPlaceholder(aiCustomPlaceholderId: number): Promise<ResponseObject<AiModel.CustomPlaceholder>>;\n    deleteAiOrganizationCustomPlaceholder(aiCustomPlaceholderId: number): Promise<void>;\n    editAiOrganizationCustomPlaceholder(aiCustomPlaceholderId: number, request: PatchRequest[]): Promise<ResponseObject<AiModel.CustomPlaceholder>>;\n    generateAiOrganizationPromptFineTuningDataset(aiPromptId: number, request: AiModel.GenerateFineTuningDataset): Promise<ResponseObject<Status<AiModel.FineTuningDataset>>>;\n    getAiOrganizationPromptFineTuningDatasetStatus(aiPromptId: number, jobIdentifier: string): Promise<ResponseObject<Status<AiModel.FineTuningDataset>>>;\n    listAiOrganizationPromptFineTuningEvents(aiPromptId: number, jobIdentifier: string, options?: PaginationOptions): Promise<ResponseList<AiModel.PromptFineTuningEvent>>;\n    listAiOrganizationPromptFineTuningJobs(options?: AiModel.ListPromptFineTuningJobsOptions): Promise<ResponseList<Status<AiModel.FineTuningJob>>>;\n    createAiOrganizationPromptFineTuningJob(aiPromptId: number, request: AiModel.GenerateFineTuningJob): Promise<ResponseObject<Status<AiModel.FineTuningJob>>>;\n    getAiOrganizationPromptFineTuningJobStatus(aiPromptId: number, jobIdentifier: string): Promise<ResponseObject<Status<AiModel.FineTuningJob>>>;\n    downloadAiOrganizationPromptFineTuningDataset(aiPromptId: number, jobIdentifier: string): Promise<ResponseObject<DownloadLink>>;\n    cloneAiOrganizationPrompt(aiPromptId: number, request?: {\n        name?: string;\n    }): Promise<ResponseObject<AiModel.AiPromptResponse>>;\n    listAiOrganizationPrompts(options?: AiModel.ListAiPromptsOptions): Promise<ResponseList<AiModel.AiPromptResponse>>;\n    addAiOrganizationPrompt(request: AiModel.AddAiPromptRequest): Promise<ResponseObject<AiModel.AiPromptResponse>>;\n    generateAiOrganizationPromptCompletion(aiPromptId: number, request: AiModel.GenerateAiPromptCompletionRequest): Promise<ResponseObject<Status<AiModel.AiPromptCompletionAttribute>>>;\n    getAiOrganizationPromptCompletionStatus(aiPromptId: number, completionId: string): Promise<ResponseObject<Status<AiModel.AiPromptCompletionAttribute>>>;\n    cancelAiOrganizationPromptCompletion(aiPromptId: number, completionId: string): Promise<void>;\n    downloadAiOrganizationPromptCompletion(aiPromptId: number, completionId: string): Promise<ResponseObject<DownloadLink>>;\n    getAiOrganizationPrompt(aiPromptId: number): Promise<ResponseObject<AiModel.AiPromptResponse>>;\n    deleteAiOrganizationPrompt(aiPromptId: number): Promise<void>;\n    editAiOrganizationPrompt(aiPromptId: number, request: PatchRequest[]): Promise<ResponseObject<AiModel.AiPromptResponse>>;\n    listAiOrganizationProviders(options?: PaginationOptions): Promise<ResponseList<AiModel.AiProviderResponse>>;\n    addAiOrganizationProvider(request: AiModel.AddAiProviderRequest): Promise<ResponseObject<AiModel.AiProviderResponse>>;\n    getAiOrganizationProvider(aiProviderId: number): Promise<ResponseObject<AiModel.AiProviderResponse>>;\n    deleteAiOrganizationProvider(aiProviderId: number): Promise<void>;\n    editAiOrganizationProvider(aiProviderId: number, request: PatchRequest[]): Promise<ResponseObject<AiModel.AiProviderResponse>>;\n    listAiOrganizationProviderModels(aiProviderId: number, options?: PaginationOptions): Promise<ResponseList<AiModel.AiProviderModelResponse>>;\n    listAiOrganizationAllProviderModels(options?: PaginationOptions): Promise<ResponseList<AiModel.AiProviderModelResponse>>;\n    createAiOrganizationProxyChatCompletion(aiProviderId: number, request?: AiModel.OtherChatCompletionRequest | AiModel.GoogleGeminiChatCompletionRequest): Promise<ResponseObject<AiModel.AiProviderProxyResponseData>>;\n    generateAiOrganizationReport(request: AiModel.AiReport): Promise<ResponseObject<Status<AiModel.AiReport>>>;\n    checkAiOrganizationReportStatus(aiReportId: string): Promise<ResponseObject<Status<AiModel.AiReport>>>;\n    downloadAiOrganizationReport(aiReportId: string): Promise<ResponseObject<DownloadLink>>;\n    getAiOrganizationSettings(): Promise<ResponseObject<AiModel.AiSettings>>;\n    editAiOrganizationSettings(request: PatchRequest[]): Promise<ResponseObject<AiModel.AiSettings>>;\n    listAiUserCustomPlaceholders(userId: number, options?: PaginationOptions): Promise<ResponseList<AiModel.CustomPlaceholder>>;\n    addAiUserCustomPlaceholder(userId: number, request: AiModel.AddCustomPlaceholderRequest): Promise<ResponseObject<AiModel.CustomPlaceholder>>;\n    getAiUserCustomPlaceholder(userId: number, aiCustomPlaceholderId: number): Promise<ResponseObject<AiModel.CustomPlaceholder>>;\n    deleteAiUserCustomPlaceholder(userId: number, aiCustomPlaceholderId: number): Promise<void>;\n    editAiUserCustomPlaceholder(userId: number, aiCustomPlaceholderId: number, request: PatchRequest[]): Promise<ResponseObject<AiModel.CustomPlaceholder>>;\n    generateAiUserPromptFineTuningDataset(userId: number, aiPromptId: number, request: AiModel.GenerateFineTuningDataset): Promise<ResponseObject<Status<AiModel.FineTuningDataset>>>;\n    getAiUserPromptFineTuningDatasetStatus(userId: number, aiPromptId: number, jobIdentifier: string): Promise<ResponseObject<Status<AiModel.FineTuningDataset>>>;\n    listAiUserPromptFineTuningEvents(userId: number, aiPromptId: number, jobIdentifier: string, options?: PaginationOptions): Promise<ResponseList<AiModel.PromptFineTuningEvent>>;\n    listAiUserPromptFineTuningJobs(userId: number, options?: AiModel.ListPromptFineTuningJobsOptions): Promise<ResponseList<Status<AiModel.FineTuningJob>>>;\n    createAiUserPromptFineTuningJob(userId: number, aiPromptId: number, request: AiModel.GenerateFineTuningJob): Promise<ResponseObject<Status<AiModel.FineTuningJob>>>;\n    getAiUserPromptFineTuningJobStatus(userId: number, aiPromptId: number, jobIdentifier: string): Promise<ResponseObject<Status<AiModel.FineTuningJob>>>;\n    downloadAiUserPromptFineTuningDataset(userId: number, aiPromptId: number, jobIdentifier: string): Promise<ResponseObject<DownloadLink>>;\n    cloneAiUserPrompt(userId: number, aiPromptId: number, request?: {\n        name?: string;\n    }): Promise<ResponseObject<AiModel.AiPromptResponse>>;\n    listAiUserPrompts(userId: number, options?: AiModel.ListAiPromptsOptions): Promise<ResponseList<AiModel.AiPromptResponse>>;\n    addAiUserPrompt(userId: number, request: AiModel.AddAiPromptRequest): Promise<ResponseObject<AiModel.AiPromptResponse>>;\n    generateAiUserPromptCompletion(userId: number, aiPromptId: number, request: AiModel.GenerateAiPromptCompletionRequest): Promise<ResponseObject<Status<AiModel.AiPromptCompletionAttribute>>>;\n    getAiUserPromptCompletionStatus(userId: number, aiPromptId: number, completionId: string): Promise<ResponseObject<Status<AiModel.AiPromptCompletionAttribute>>>;\n    cancelAiUserPromptCompletion(userId: number, aiPromptId: number, completionId: string): Promise<void>;\n    downloadAiUserPromptCompletion(userId: number, aiPromptId: number, completionId: string): Promise<ResponseObject<DownloadLink>>;\n    getAiUserPrompt(userId: number, aiPromptId: number): Promise<ResponseObject<AiModel.AiPromptResponse>>;\n    deleteAiUserPrompt(userId: number, aiPromptId: number): Promise<void>;\n    editAiUserPrompt(userId: number, aiPromptId: number, request: PatchRequest[]): Promise<ResponseObject<AiModel.AiPromptResponse>>;\n    listAiUserProviders(userId: number, options?: PaginationOptions): Promise<ResponseList<AiModel.AiProviderResponse>>;\n    addAiUserProvider(userId: number, request: AiModel.AddAiProviderRequest): Promise<ResponseObject<AiModel.AiProviderResponse>>;\n    getAiUserProvider(userId: number, aiProviderId: number): Promise<ResponseObject<AiModel.AiProviderResponse>>;\n    deleteAiUserProvider(userId: number, aiProviderId: number): Promise<void>;\n    editAiUserProvider(userId: number, aiProviderId: number, request: PatchRequest[]): Promise<ResponseObject<AiModel.AiProviderResponse>>;\n    listAiUserProviderModels(userId: number, aiProviderId: number, options?: PaginationOptions): Promise<ResponseList<AiModel.AiProviderModelResponse>>;\n    listAiUserAllProviderModels(userId: number, options?: PaginationOptions): Promise<ResponseList<AiModel.AiProviderModelResponse>>;\n    createAiUserProxyChatCompletion(userId: number, aiProviderId: number, request?: AiModel.OtherChatCompletionRequest | AiModel.GoogleGeminiChatCompletionRequest): Promise<ResponseObject<AiModel.AiProviderProxyResponseData>>;\n    generateAiUserReport(userId: number, request: AiModel.AiReport): Promise<ResponseObject<Status<AiModel.AiReport>>>;\n    checkAiUserReportStatus(userId: number, aiReportId: string): Promise<ResponseObject<Status<AiModel.AiReport>>>;\n    downloadAiUserReport(userId: number, aiReportId: string): Promise<ResponseObject<DownloadLink>>;\n    getAiUsertSettings(userId: number): Promise<ResponseObject<AiModel.AiSettings>>;\n    editAiUserSettings(userId: number, request: PatchRequest[]): Promise<ResponseObject<AiModel.AiSettings>>;\n}\nexport declare namespace AiModel {\n    interface CustomPlaceholder {\n        id: number;\n        description: string;\n        placeholder: string;\n        value: string;\n        createdAt: string;\n        updatedAt: string;\n    }\n    interface AddCustomPlaceholderRequest {\n        description: string;\n        placeholder: string;\n        value: string;\n    }\n    interface FineTuningDataset {\n        projectIds: number[];\n        tmIds: number[];\n        purpose: 'training' | 'validation';\n        dateFrom: string;\n        dateTo: string;\n        maxFileSize: number;\n        minExamplesCount: number;\n        maxExamplesCount: number;\n    }\n    interface GenerateFineTuningDataset {\n        projectIds?: number[];\n        tmIds?: number[];\n        purpose?: 'training' | 'validation';\n        dateFrom?: string;\n        dateTo?: string;\n        maxFileSize?: number;\n        minExamplesCount?: number;\n        maxExamplesCount?: number;\n    }\n    interface GenerateFineTuningJob {\n        dryRun?: boolean;\n        hyperparameters?: {\n            batchSize: number;\n            learningRateMultiplier: number;\n            nEpochs: number;\n        };\n        trainingOptions: Omit<GenerateFineTuningDataset, 'purpose'>;\n        validationOptions?: Omit<GenerateFineTuningDataset, 'purpose'>;\n    }\n    interface FineTuningJob {\n        dryRun: boolean;\n        aiPromptId: number;\n        hyperparameters: {\n            batchSize: number;\n            learningRateMultiplier: number;\n            nEpochs: number;\n        };\n        trainingOptions: Omit<GenerateFineTuningDataset, 'purpose'>;\n        validationOptions: Omit<GenerateFineTuningDataset, 'purpose'>;\n        baseModel: string;\n        fineTunedModel: string;\n        trainedTokensCount: number;\n        trainingDatasetUrl: string;\n        validationDatasetUrl: string;\n        metadata: PlainObject;\n    }\n    interface PromptFineTuningEvent {\n        id: string;\n        type: string;\n        message: string;\n        data: {\n            step: number;\n            totalSteps: number;\n            trainingLoss: number;\n            validationLoss: number;\n            fullValidationLoss: number;\n        };\n        createdAt: string;\n    }\n    interface ListPromptFineTuningJobsOptions extends PaginationOptions {\n        statuses: string;\n        orderBy: string;\n    }\n    interface ListAiPromptsOptions extends PaginationOptions {\n        projectId?: number;\n        action?: Action;\n    }\n    interface AiPromptResponse {\n        id: number;\n        name: string;\n        action: Action;\n        aiProviderId: number;\n        aiModelId: string;\n        isEnabled: boolean;\n        enabledProjectIds: number[];\n        config: AiModel.AiPromptConfigBasicPreTranslate | AiModel.AiPromptConfigBasicAssistAction | AiModel.AiPromptConfigBasicAligmentAction | AiModel.AiPromptConfigAdvanced | AiModel.AiPromptConfigExternal;\n        promptPreview: string;\n        isFineTuningAvailable: boolean;\n        createdAt: string;\n        updatedAt: string;\n    }\n    interface AiPromptConfigBasicOtherLanguageTranslations {\n        isEnabled?: boolean;\n        languageIds?: string[];\n    }\n    interface AiPromptConfigBasicPreTranslate {\n        mode: 'basic';\n        companyDescription?: string;\n        projectDescription?: string;\n        audienceDescription?: string;\n        customPlaceholders?: string[];\n        otherLanguageTranslations?: AiModel.AiPromptConfigBasicOtherLanguageTranslations;\n        glossaryTerms?: boolean;\n        tmSuggestions?: boolean;\n        fileContent?: boolean;\n        fileContext?: boolean;\n        screenshots?: boolean;\n        publicProjectDescription?: boolean;\n        siblingsStrings?: boolean;\n    }\n    interface AiPromptConfigBasicAssistAction {\n        mode: 'basic';\n        companyDescription?: string;\n        projectDescription?: string;\n        audienceDescription?: string;\n        otherLanguageTranslations?: AiModel.AiPromptConfigBasicOtherLanguageTranslations;\n        glossaryTerms?: boolean;\n        tmSuggestions?: boolean;\n        fileContext?: boolean;\n        screenshots?: boolean;\n        publicProjectDescription?: boolean;\n        siblingsStrings?: boolean;\n        filteredStrings?: boolean;\n    }\n    interface AiPromptConfigBasicAligmentAction {\n        mode: 'basic';\n        customPlaceholders?: string[];\n        publicProjectDescription?: boolean;\n    }\n    interface AiPromptConfigAdvanced {\n        mode: 'advanced';\n        screenshots?: boolean;\n        prompt: string;\n        otherLanguageTranslations?: AiModel.AiPromptConfigBasicOtherLanguageTranslations;\n    }\n    interface AiPromptConfigExternal {\n        mode: 'external';\n        identifier: string;\n        key: string;\n        options?: any;\n    }\n    interface AddAiPromptRequest {\n        name: string;\n        action: Action;\n        aiProviderId?: number;\n        aiModelId?: string;\n        isEnabled?: boolean;\n        enabledProjectIds?: number[];\n        config: AiModel.AiPromptConfigBasicPreTranslate | AiModel.AiPromptConfigBasicAssistAction | AiModel.AiPromptConfigBasicAligmentAction | AiModel.AiPromptConfigAdvanced | AiPromptConfigExternal;\n    }\n    interface GenerateAiPromptCompletionRequest {\n        resources: AiModel.AiPromptResourceWithPreTranslate | AiModel.AiPromptResourceWithAssist | AiModel.AiPromptResourceWithAlignment | AiModel.AiPromptResourceWithCustom;\n        tools?: {\n            tool: {\n                type: 'function';\n                function: {\n                    description?: string;\n                    name: string;\n                    parameters?: PlainObject;\n                };\n            };\n        }[];\n        tool_choice?: string | PlainObject;\n    }\n    interface AiPromptCompletionAttribute {\n        aiPromptId: number;\n    }\n    interface AiPromptResourceWithPreTranslate {\n        projectId: number;\n        sourceLanguageId?: string;\n        targetLanguageId?: string;\n        stringIds?: number[];\n        overridePromptValues?: OverridePromptValues;\n    }\n    interface AiPromptResourceWithAlignment {\n        projectId: number;\n        sourceLanguageId?: string;\n        targetLanguageId?: string;\n        stringIds?: number[];\n        overridePromptValues?: OverridePromptValues;\n    }\n    interface AiPromptResourceWithAssist {\n        projectId: number;\n        sourceLanguageId?: string;\n        targetLanguageId?: string;\n        stringIds?: number[];\n        filteredStringsIds?: number[];\n        overridePromptValues?: OverridePromptValues;\n    }\n    interface AiPromptResourceWithCustom {\n        projectId: number;\n        sourceLanguageId?: string;\n        targetLanguageId?: string;\n        stringIds?: number[];\n        overridePromptValues?: OverridePromptValues;\n        customInstruction?: string;\n    }\n    interface OverridePromptValues {\n        [key: string]: any;\n    }\n    interface AiProviderResponse {\n        id: number;\n        name: string;\n        type: ProviderType;\n        credentials: AiModel.AiProviderCredentialsBasic | AiModel.AiProviderCredentialsAzureOpenAi | AiProviderCredentialsGoogleGemini | AiProviderCredentialsCustom;\n        config: AiModel.AiProviderConfig;\n        isEnabled: boolean;\n        useSystemCredentials: boolean;\n        createdAt: string;\n        updatedAt: string;\n        promptsCount: string;\n    }\n    interface AiProviderCredentialsBasic {\n        apiKey: string;\n    }\n    interface AiProviderCredentialsAzureOpenAi extends AiProviderCredentialsBasic {\n        resourceName: string;\n        deploymentName: string;\n        apiVersion: string;\n    }\n    interface AiProviderCredentialsGoogleGemini {\n        project: string;\n        region: string;\n        serviceAccountKey: string;\n    }\n    interface AiProviderCredentialsWatsonx {\n        apiKey: string;\n        projectId: string;\n        region: string;\n    }\n    interface AiProviderCredentialsCustom {\n        identifier: string;\n        key: string;\n    }\n    interface AiProviderConfig {\n        actionRules?: AiModel.AiProviderConfigActionRule[];\n    }\n    interface AiProviderConfigActionRule {\n        action?: 'pre_translate' | 'assist';\n        availableAiModelIds?: string[];\n    }\n    interface AddAiProviderRequest {\n        name: string;\n        type: ProviderType;\n        credentials?: AiModel.AiProviderCredentialsBasic | AiModel.AiProviderCredentialsAzureOpenAi | AiProviderCredentialsGoogleGemini | AiProviderCredentialsWatsonx | AiProviderCredentialsCustom;\n        config?: AiModel.AiProviderConfig;\n        isEnabled?: boolean;\n        useSystemCredentials?: boolean;\n    }\n    interface AiProviderModelResponse {\n        id: string;\n    }\n    interface AiProviderProxyResponseData {\n        data: object;\n    }\n    interface OtherChatCompletionRequest {\n        stream?: boolean;\n        [key: string]: any;\n    }\n    interface GoogleGeminiChatCompletionRequest extends OtherChatCompletionRequest {\n        model: string;\n    }\n    type AiReport = AiReportTokenUsage;\n    interface AiReportTokenUsage {\n        type: 'tokens-usage-raw-data';\n        schema: AiReportGeneralSchema;\n    }\n    interface AiReportGeneralSchema {\n        dateFrom: string;\n        dateTo: string;\n        format?: 'json' | 'csv';\n        projectIds?: number[];\n        promptIds?: number[];\n        userIds?: number[];\n    }\n    interface AiSettings {\n        assistActionAiPromptId: number;\n        showSuggestion: boolean;\n        shortcuts: {\n            name: string;\n            prompt: string;\n            enabled: boolean;\n        }[];\n    }\n    type Action = 'pre_translate' | 'assist';\n    type ProviderType = 'open_ai' | 'azure_open_ai' | 'google_gemini' | 'mistral_ai' | 'anthropic' | 'custom_ai' | 'x_ai' | 'deepseek' | 'watsonx';\n}\n```\n\n##### applications/index.d.ts\n\n```typescript\nimport { CrowdinApi, ResponseObject, PatchRequest, Pagination, ResponseList } from '../core';\nexport declare class Applications extends CrowdinApi {\n    listApplicationInstallations(options?: Pagination): Promise<ResponseList<ApplicationsModel.Application>>;\n    installApplication(request: ApplicationsModel.InstallApplication): Promise<ResponseObject<ApplicationsModel.Application>>;\n    getApplicationInstallation(applicationId: string): Promise<ResponseObject<ApplicationsModel.Application>>;\n    deleteApplicationInstallation(applicationId: string, force?: boolean): Promise<ResponseObject<ApplicationsModel.Application>>;\n    editApplicationInstallation(applicationId: string, request: PatchRequest[]): Promise<ResponseObject<ApplicationsModel.Application>>;\n    getApplicationData(applicationId: string, path: string): Promise<ResponseObject<any>>;\n    updateOrRestoreApplicationData(applicationId: string, path: string, request: any): Promise<ResponseObject<any>>;\n    addApplicationData(applicationId: string, path: string, request: any): Promise<ResponseObject<any>>;\n    deleteApplicationData(applicationId: string, path: string): Promise<void>;\n    editApplicationData(applicationId: string, path: string, request: any): Promise<ResponseObject<any>>;\n}\nexport declare namespace ApplicationsModel {\n    interface Application {\n        identifier: string;\n        name: string;\n        description: string;\n        logo: string;\n        baseUrl: string;\n        manifestUrl: string;\n        createdAt: string;\n        modules: ApplicationModule[];\n        scopes: string[];\n        permissions: ApplicationPermissions;\n        defaultPermissions: any;\n        limitReached: boolean;\n    }\n    interface InstallApplication {\n        url: string;\n        permissions?: ApplicationPermissions;\n        modules?: ApplicationModule[];\n    }\n    interface ApplicationPermissions {\n        user: {\n            value: 'all' | 'owner' | 'managers' | 'guests' | 'restricted';\n            ids: number[];\n        };\n        project: {\n            value: 'own' | 'restricted';\n            ids: number[];\n        };\n    }\n    interface ApplicationModule {\n        key: string;\n        type?: string;\n        data?: any;\n        authenticationType?: string;\n        permissions: Omit<ApplicationPermissions, 'project'>;\n    }\n}\n```\n\n##### bundles/index.d.ts\n\n```typescript\nimport { CrowdinApi, DownloadLink, PaginationOptions, PatchRequest, ResponseList, ResponseObject, Status } from '../core';\nimport { SourceFilesModel } from '../sourceFiles';\nexport declare class Bundles extends CrowdinApi {\n    listBundles(projectId: number, options?: PaginationOptions): Promise<ResponseList<BundlesModel.Bundle>>;\n    addBundle(projectId: number, request: BundlesModel.CreateBundleRequest): Promise<ResponseObject<BundlesModel.Bundle>>;\n    getBundle(projectId: number, bundleId: number): Promise<ResponseObject<BundlesModel.Bundle>>;\n    deleteBundle(projectId: number, bundleId: number): Promise<void>;\n    editBundle(projectId: number, bundleId: number, request: PatchRequest[]): Promise<ResponseObject<BundlesModel.Bundle>>;\n    downloadBundle(projectId: number, bundleId: number, exportId: string): Promise<ResponseObject<DownloadLink>>;\n    exportBundle(projectId: number, bundleId: number): Promise<ResponseObject<Status<BundlesModel.ExportAttributes>>>;\n    checkBundleExportStatus(projectId: number, bundleId: number, exportId: string): Promise<ResponseObject<Status<BundlesModel.ExportAttributes>>>;\n    listBundleFiles(projectId: number, bundleId: number, options?: PaginationOptions): Promise<ResponseList<SourceFilesModel.File>>;\n    listBundleBranches(projectId: number, bundleId: number, options?: PaginationOptions): Promise<ResponseList<SourceFilesModel.Branch>>;\n}\nexport declare namespace BundlesModel {\n    interface Bundle {\n        id: number;\n        name: string;\n        format: string;\n        sourcePatterns: string[];\n        ignorePatterns: string[];\n        exportPattern: string;\n        isMultilingual: boolean;\n        includeProjectSourceLanguage: boolean;\n        labelIds: number[];\n        excludeLabelIds: number[];\n        createdAt: string;\n        webUrl: string;\n        updatedAt: string;\n    }\n    interface CreateBundleRequest {\n        name: string;\n        format: string;\n        sourcePatterns: string[];\n        ignorePatterns?: string[];\n        exportPattern: string;\n        isMultilingual?: boolean;\n        includeProjectSourceLanguage?: boolean;\n        includeInContextPseudoLanguage?: boolean;\n        labelIds?: number[];\n        excludeLabelIds?: number[];\n    }\n    interface ExportAttributes {\n        bundleId: number;\n    }\n}\n```\n\n##### clients/index.d.ts\n\n```typescript\nimport { CrowdinApi, PaginationOptions, ResponseList } from '../core';\nexport declare class Clients extends CrowdinApi {\n    listClients(options?: PaginationOptions): Promise<ResponseList<ClientsModel.Client>>;\n}\nexport declare namespace ClientsModel {\n    interface Client {\n        id: number;\n        name: string;\n        description: string;\n        status: 'pending' | 'confirmed' | 'rejected';\n        webUrl: string;\n    }\n}\n```\n\n##### core/http-client-error.d.ts\n\n```typescript\nimport { AxiosError } from 'axios';\nimport { FetchClientJsonPayloadError } from './internal/fetch/fetchClientError';\nexport type HttpClientError = AxiosError | FetchClientJsonPayloadError | Error;\nexport declare const toHttpClientError: (error?: unknown) => HttpClientError;\n```\n\n##### core/index.d.ts\n\n```typescript\nimport { HttpClientError } from './http-client-error';\nimport { RetryConfig, RetryService } from './internal/retry';\nexport interface HttpClient {\n    get<T>(url: string, config?: {\n        headers: Record<string, string>;\n    }): Promise<T>;\n    delete<T>(url: string, config?: {\n        headers: Record<string, string>;\n    }): Promise<T>;\n    head<T>(url: string, config?: {\n        headers: Record<string, string>;\n    }): Promise<T>;\n    post<T>(url: string, data?: unknown, config?: {\n        headers: Record<string, string>;\n    }): Promise<T>;\n    put<T>(url: string, data?: unknown, config?: {\n        headers: Record<string, string>;\n    }): Promise<T>;\n    patch<T>(url: string, data?: unknown, config?: {\n        headers: Record<string, string>;\n    }): Promise<T>;\n}\nexport type HttpClientType = 'axios' | 'fetch';\nexport interface Credentials {\n    token: string;\n    organization?: string;\n    baseUrl?: string;\n}\nexport interface ClientConfig {\n    httpClientType?: HttpClientType;\n    httpClient?: HttpClient;\n    userAgent?: string;\n    integrationUserAgent?: string;\n    retryConfig?: RetryConfig;\n    httpRequestTimeout?: number;\n}\nexport interface ResponseList<T> {\n    data: ResponseObject<T>[];\n    pagination: Pagination;\n}\nexport interface ResponseObject<T> {\n    data: T;\n}\nexport interface Pagination {\n    offset: number;\n    limit: number;\n}\nexport type PaginationOptions = Partial<Pagination>;\nexport interface PatchRequest {\n    value?: any;\n    op: PatchOperation;\n    path: string;\n}\nexport type PatchOperation = 'add' | 'remove' | 'replace' | 'move' | 'copy' | 'test';\nexport type ProjectRoles = 'manager' | 'developer' | 'translator' | 'proofreader' | 'language_coordinator' | 'member';\nexport interface DownloadLink {\n    url: string;\n    expireIn: string;\n}\nexport declare enum BooleanInt {\n    TRUE = 1,\n    FALSE = 0\n}\nexport interface Status<T> {\n    identifier: string;\n    status: string;\n    progress: number;\n    attributes: T;\n    createdAt: string;\n    updatedAt: string;\n    startedAt: string;\n    finishedAt: string;\n    eta: string;\n}\nexport interface Attribute {\n    [key: string]: string;\n}\nexport type PlainObject = Record<string, any>;\nexport declare class CrowdinError extends Error {\n    apiError: any;\n    code: number;\n    constructor(message: string, code: number, apiError: any);\n}\nexport declare class CrowdinValidationError extends CrowdinError {\n    validationCodes: {\n        key: string;\n        codes: string[];\n    }[];\n    constructor(message: string, validationCodes: {\n        key: string;\n        codes: string[];\n    }[], apiError: any);\n}\nexport declare function handleHttpClientError(error: HttpClientError): never;\nexport declare abstract class CrowdinApi {\n    private static readonly CROWDIN_URL_SUFFIX;\n    private static readonly AXIOS_INSTANCE;\n    private static readonly FETCH_INSTANCE;\n    readonly token: string;\n    readonly organization?: string;\n    readonly url: string;\n    readonly config: ClientConfig | undefined;\n    readonly retryService: RetryService;\n    protected fetchAllFlag: boolean;\n    protected maxLimit: number | undefined;\n    constructor(credentials: Credentials, config?: ClientConfig);\n    graphql<T>(req: {\n        query: string;\n        operationName?: string;\n        variables?: any;\n    }, config?: {\n        url?: string;\n    }): Promise<ResponseObject<T>>;\n    protected addQueryParam(url: string, name: string, value?: string | number): string;\n    protected defaultConfig(): {\n        headers: Record<string, string>;\n    };\n    get httpClient(): HttpClient;\n    withFetchAll(maxLimit?: number): this;\n    protected getList<T = any>(url: string, limit?: number, offset?: number, config?: {\n        headers: Record<string, string>;\n    }): Promise<ResponseList<T>>;\n    protected fetchAll<T>(url: string, config: {\n        headers: Record<string, string>;\n    }, maxAmount?: number): Promise<ResponseList<T>>;\n    protected encodeUrlParam(param: string | number | boolean): string;\n    protected get<T>(url: string, config?: {\n        headers: Record<string, string>;\n    }): Promise<T>;\n    protected delete<T>(url: string, config?: {\n        headers: Record<string, string>;\n    }): Promise<T>;\n    protected head<T>(url: string, config?: {\n        headers: Record<string, string>;\n    }): Promise<T>;\n    protected post<T>(url: string, data?: unknown, config?: {\n        headers: Record<string, string>;\n    }): Promise<T>;\n    protected put<T>(url: string, data?: unknown, config?: {\n        headers: Record<string, string>;\n    }): Promise<T>;\n    protected patch<T>(url: string, data?: unknown, config?: {\n        headers: Record<string, string>;\n    }): Promise<T>;\n}\nexport declare function isOptionalString(parameter: string | unknown, parameterInArgs: boolean): parameter is string | undefined;\nexport declare function isOptionalNumber(parameter: number | unknown, parameterInArgs: boolean): parameter is number | undefined;\nexport interface ProjectRole {\n    name: string;\n    permissions: ProjectRolePermissions;\n}\nexport interface ProjectRolePermissions {\n    allLanguages: boolean;\n    languagesAccess: {\n        [lang: string]: {\n            allContent: boolean;\n            workflowStepIds: number[];\n        };\n    };\n}\n```\n\n##### dictionaries/index.d.ts\n\n```typescript\nimport { CrowdinApi, PatchRequest, ResponseList, ResponseObject } from '../core';\nexport declare class Dictionaries extends CrowdinApi {\n    listDictionaries(projectId: number, options?: DictionariesModel.ListDictionariesOptions): Promise<ResponseList<DictionariesModel.Dictionary>>;\n    listDictionaries(projectId: number, languageIds?: string): Promise<ResponseList<DictionariesModel.Dictionary>>;\n    editDictionary(projectId: number, languageId: string, request: PatchRequest[]): Promise<ResponseObject<DictionariesModel.Dictionary>>;\n}\nexport declare namespace DictionariesModel {\n    interface Dictionary {\n        languageId: string;\n        words: string[];\n    }\n    interface ListDictionariesOptions {\n        languageIds?: string;\n    }\n}\n```\n\n##### distributions/index.d.ts\n\n```typescript\nimport { CrowdinApi, PaginationOptions, PatchRequest, ResponseList, ResponseObject } from '../core';\nexport declare class Distributions extends CrowdinApi {\n    listDistributions(projectId: number, options?: PaginationOptions): Promise<ResponseList<DistributionsModel.Distribution>>;\n    listDistributions(projectId: number, limit?: number, offset?: number): Promise<ResponseList<DistributionsModel.Distribution>>;\n    createDistribution(projectId: number, request: DistributionsModel.CreateDistributionRequest | DistributionsModel.CreateDistributionStringsBasedRequest): Promise<ResponseObject<DistributionsModel.Distribution>>;\n    getDistribution(projectId: number, hash: string): Promise<ResponseObject<DistributionsModel.Distribution>>;\n    deleteDistribution(projectId: number, hash: string): Promise<void>;\n    editDistribution(projectId: number, hash: string, request: PatchRequest[]): Promise<ResponseObject<DistributionsModel.Distribution>>;\n    getDistributionRelease(projectId: number, hash: string): Promise<ResponseObject<DistributionsModel.DistributionRelease | DistributionsModel.DistributionStringsBasedRelease>>;\n    createDistributionRelease(projectId: number, hash: string): Promise<ResponseObject<DistributionsModel.DistributionRelease | DistributionsModel.DistributionStringsBasedRelease>>;\n}\nexport declare namespace DistributionsModel {\n    interface Distribution {\n        hash: string;\n        manifestUrl: string;\n        name: string;\n        bundleIds: number[];\n        createdAt: string;\n        updatedAt: string;\n        exportMode: ExportMode;\n        fileIds: number[];\n    }\n    interface CreateDistributionRequest {\n        exportMode?: ExportMode;\n        name: string;\n        fileIds?: number[];\n        bundleIds?: number[];\n    }\n    interface CreateDistributionStringsBasedRequest {\n        name: string;\n        bundleIds: number[];\n    }\n    interface DistributionRelease {\n        status: string;\n        progress: number;\n        currentLanguageId: string;\n        currentFileId: number;\n        date: string;\n    }\n    interface DistributionStringsBasedRelease {\n        status: string;\n        progress: number;\n        currentLanguageId: string;\n        currentBranchId: number;\n        date: string;\n    }\n    type ExportMode = 'default' | 'bundle';\n}\n```\n\n##### fields/index.d.ts\n\n```typescript\nimport { CrowdinApi, PaginationOptions, PatchRequest, ResponseList, ResponseObject } from '../core';\nexport declare class Fields extends CrowdinApi {\n    listFields(options?: FieldsModel.ListFieldsParams): Promise<ResponseList<FieldsModel.Field>>;\n    addField(request: FieldsModel.AddFieldRequest): Promise<ResponseObject<FieldsModel.Field>>;\n    getField(fieldId: number): Promise<ResponseObject<FieldsModel.Field>>;\n    deleteField(fieldId: number): Promise<void>;\n    editField(fieldId: number, request: PatchRequest[]): Promise<ResponseObject<FieldsModel.Field>>;\n}\nexport declare namespace FieldsModel {\n    type Entity = 'project' | 'user' | 'task' | 'file' | 'translation' | 'string';\n    type Type = 'checkbox' | 'radiobuttons' | 'date' | 'datetime' | 'number' | 'labels' | 'select' | 'multiselect' | 'text' | 'textarea' | 'url';\n    type Place = 'projectCreateModal' | 'projectHeader' | 'projectDetails' | 'projectCrowdsourceDetails' | 'projectSettings' | 'projectTaskEditCreate' | 'projectTaskDetails' | 'projectTaskBoardCard' | 'fileDetails' | 'fileSettings' | 'userEditModal' | 'userDetails' | 'userPopover' | 'stringEditModal' | 'stringDetails' | 'translationUnderContent';\n    interface Location {\n        place: Place;\n    }\n    interface Option {\n        label: string;\n        value: string;\n    }\n    interface OtherFieldConfig {\n        locations: Location[];\n    }\n    interface ListFieldConfig extends OtherFieldConfig {\n        options: Option[];\n    }\n    interface NumberFieldConfig extends OtherFieldConfig {\n        min: number;\n        max: number;\n        units: string;\n    }\n    type Config = ListFieldConfig | NumberFieldConfig | OtherFieldConfig;\n    interface ListFieldsParams extends PaginationOptions {\n        search?: string;\n        entity?: Entity;\n        type?: Type;\n    }\n    interface Field {\n        id: number;\n        name: string;\n        slug: string;\n        type: Type;\n        description: string;\n        entities: Entity[];\n        config: Config;\n        createdAt: string;\n        updatedAt: string;\n    }\n    interface AddFieldRequest {\n        name: string;\n        slug: string;\n        type: Type;\n        description?: string;\n        entities: Entity[];\n        config?: Config;\n    }\n}\n```\n\n##### glossaries/index.d.ts\n\n```typescript\nimport { CrowdinApi, DownloadLink, PaginationOptions, PatchRequest, ResponseList, ResponseObject, Status } from '../core';\nexport declare class Glossaries extends CrowdinApi {\n    listGlossaries(options?: GlossariesModel.ListGlossariesOptions): Promise<ResponseList<GlossariesModel.Glossary>>;\n    listGlossaries(groupId?: number, limit?: number, offset?: number): Promise<ResponseList<GlossariesModel.Glossary>>;\n    addGlossary(request: GlossariesModel.CreateGlossaryRequest): Promise<ResponseObject<GlossariesModel.Glossary>>;\n    getGlossary(glossaryId: number): Promise<ResponseObject<GlossariesModel.Glossary>>;\n    deleteGlossary(glossaryId: number): Promise<void>;\n    editGlossary(glossaryId: number, request: PatchRequest[]): Promise<ResponseObject<GlossariesModel.Glossary>>;\n    exportGlossary(glossaryId: number, request: GlossariesModel.ExportGlossaryRequest): Promise<ResponseObject<Status<GlossariesModel.GlossaryExportStatusAttribute>>>;\n    checkGlossaryExportStatus(glossaryId: number, exportId: string): Promise<ResponseObject<Status<GlossariesModel.GlossaryExportStatusAttribute>>>;\n    downloadGlossary(glossaryId: number, exportId: string): Promise<ResponseObject<DownloadLink>>;\n    importGlossaryFile(glossaryId: number, request: GlossariesModel.GlossaryFile): Promise<ResponseObject<Status<GlossariesModel.GlossaryImportStatusAttribute>>>;\n    checkGlossaryImportStatus(glossaryId: number, importId: string): Promise<ResponseObject<Status<GlossariesModel.GlossaryImportStatusAttribute>>>;\n    listTerms(glossaryId: number, options?: GlossariesModel.ListTermsOptions): Promise<ResponseList<GlossariesModel.Term>>;\n    listTerms(glossaryId: number, userId?: number, limit?: number, offset?: number, languageId?: string, translationOfTermId?: number, conceptId?: number): Promise<ResponseList<GlossariesModel.Term>>;\n    addTerm(glossaryId: number, request: GlossariesModel.CreateTermRequest): Promise<ResponseObject<GlossariesModel.Term>>;\n    clearGlossary(glossaryId: number, options?: GlossariesModel.ClearGlossaryOptions): Promise<ResponseObject<GlossariesModel.Term>>;\n    clearGlossary(glossaryId: number, languageId?: number, translationOfTermId?: number, conceptId?: number): Promise<ResponseObject<GlossariesModel.Term>>;\n    getTerm(glossaryId: number, termId: number): Promise<ResponseObject<GlossariesModel.Term>>;\n    deleteTerm(glossaryId: number, termId: number): Promise<void>;\n    editTerm(glossaryId: number, termId: number, request: PatchRequest[]): Promise<ResponseObject<GlossariesModel.Term>>;\n    listConcepts(glossaryId: number, options?: {\n        orderBy?: string;\n    } & PaginationOptions): Promise<ResponseList<GlossariesModel.Concept>>;\n    getConcept(glossaryId: number, conceptId: number): Promise<ResponseObject<GlossariesModel.Concept>>;\n    updateConcept(glossaryId: number, conceptId: number, request: GlossariesModel.UpdateConceptRequest): Promise<ResponseObject<GlossariesModel.Concept>>;\n    deleteConcept(glossaryId: number, conceptId: number): Promise<void>;\n    concordanceSearch(projectId: number, request: GlossariesModel.ConcordanceSearchRequest): Promise<ResponseList<GlossariesModel.ConcordanceSearchResponse>>;\n}\nexport declare namespace GlossariesModel {\n    interface Glossary {\n        id: number;\n        name: string;\n        groupId: number;\n        userId: number;\n        terms: number;\n        languageId: string;\n        languageIds: string[];\n        defaultProjectIds: number[];\n        projectIds: number[];\n        webUrl: string;\n        createdAt: string;\n    }\n    interface CreateGlossaryRequest {\n        name: string;\n        languageId: string;\n        groupId?: number;\n    }\n    type ExportField = 'term' | 'description' | 'partOfSpeech' | 'type' | 'status' | 'gender' | 'note' | 'url' | 'conceptDefinition' | 'conceptSubject' | 'conceptNote' | 'conceptUrl' | 'conceptFigure';\n    interface ExportGlossaryRequest {\n        format?: GlossaryFormat;\n        exportFields?: ExportField[];\n    }\n    interface GlossaryExportStatusAttribute {\n        format: string;\n        exportFields: ExportField[];\n    }\n    interface GlossaryImportStatusAttribute {\n        storageId: number;\n        scheme: unknown;\n        firstLineContainsHeader: boolean;\n    }\n    interface GlossaryFile {\n        storageId: number;\n        scheme?: GlossaryFileScheme;\n        firstLineContainsHeader?: boolean;\n    }\n    interface ListTermsOptions extends PaginationOptions {\n        userId?: number;\n        languageId?: string;\n        conceptId?: number;\n        orderBy?: string;\n        croql?: string;\n        translationOfTermId?: number;\n    }\n    interface Term {\n        id: number;\n        userId: number;\n        glossaryId: number;\n        languageId: string;\n        text: string;\n        description: string;\n        partOfSpeech: PartOfSpeech;\n        status: Status;\n        type: Type;\n        gender: Gender;\n        note: string;\n        url: string;\n        conceptId: number;\n        lemma: string;\n        createdAt: string;\n        updatedAt: string;\n    }\n    interface CreateTermRequest {\n        languageId: string;\n        text: string;\n        description?: string;\n        partOfSpeech?: PartOfSpeech;\n        status?: Status;\n        type?: Type;\n        gender?: Gender;\n        note?: string;\n        url?: string;\n        conceptId?: number;\n        translationOfTermId?: number;\n    }\n    interface ConcordanceSearchRequest extends PaginationOptions {\n        sourceLanguageId: string;\n        targetLanguageId: string;\n        expressions: string[];\n        expression?: string;\n    }\n    interface ConcordanceSearchResponse {\n        glossary: Glossary;\n        concept: Concept;\n        sourceTerms: Term[];\n        targetTerms: Term[];\n    }\n    type Status = 'preferred' | 'admitted' | 'not recommended' | 'obsolete';\n    type Type = 'full form' | 'acronym' | 'abbreviation' | 'short form' | 'phrase' | 'variant';\n    type Gender = 'masculine' | 'feminine' | 'neuter' | 'other';\n    type GlossaryFormat = 'tbx' | 'tbx_v3' | 'csv' | 'xlsx';\n    interface GlossaryFileScheme {\n        [key: string]: number;\n    }\n    type PartOfSpeech = 'adjective' | 'adposition' | 'adverb' | 'auxiliary' | 'coordinating conjunction' | 'determiner' | 'interjection' | 'noun' | 'numeral' | 'particle' | 'pronoun' | 'proper noun' | 'subordinating conjunction' | 'verb' | 'other';\n    interface ListGlossariesOptions extends PaginationOptions {\n        groupId?: number;\n        userId?: number;\n        orderBy?: string;\n    }\n    interface ClearGlossaryOptions {\n        languageId?: number;\n        translationOfTermId?: number;\n        conceptId?: number;\n    }\n    interface Concept {\n        id: number;\n        userId: number;\n        glossaryId: number;\n        subject: string;\n        definition: string;\n        translatable: boolean;\n        note: string;\n        url: string;\n        figure: string;\n        languagesDetails: LanguageDetails[];\n        createdAt: string;\n        updatedAt: string;\n    }\n    interface LanguageDetails {\n        languageId: string;\n        userId: number;\n        definition: string;\n        note: string;\n        createdAt: string;\n        updatedAt: string;\n    }\n    interface UpdateConceptRequest {\n        subject?: string;\n        definition?: string;\n        translatable?: boolean;\n        note?: string;\n        url?: string;\n        figure?: string;\n        languagesDetails?: {\n            languageId: string;\n            definition: string;\n            note?: string;\n        }[];\n    }\n}\n```\n\n##### index.d.ts\n\n```typescript\nimport { Ai } from './ai';\nimport { Applications } from './applications';\nimport { Bundles } from './bundles';\nimport { Clients } from './clients';\nimport { ClientConfig, Credentials, CrowdinApi } from './core';\nimport { Dictionaries } from './dictionaries';\nimport { Distributions } from './distributions';\nimport { Fields } from './fields';\nimport { Glossaries } from './glossaries';\nimport { Issues } from './issues';\nimport { Labels } from './labels';\nimport { Languages } from './languages';\nimport { MachineTranslation } from './machineTranslation';\nimport { Notifications } from './notifications';\nimport { OrganizationWebhooks } from './organizationWebhooks';\nimport { ProjectsGroups } from './projectsGroups';\nimport { Reports } from './reports';\nimport { Screenshots } from './screenshots';\nimport { SecurityLogs } from './securityLogs';\nimport { SourceFiles } from './sourceFiles';\nimport { SourceStrings } from './sourceStrings';\nimport { StringComments } from './stringComments';\nimport { StringCorrections } from './stringCorrections';\nimport { StringTranslations } from './stringTranslations';\nimport { Tasks } from './tasks';\nimport { Teams } from './teams';\nimport { TranslationMemory } from './translationMemory';\nimport { TranslationStatus } from './translationStatus';\nimport { Translations } from './translations';\nimport { UploadStorage } from './uploadStorage';\nimport { Users } from './users';\nimport { Vendors } from './vendors';\nimport { Webhooks } from './webhooks';\nimport { Workflows } from './workflows';\nexport * from './ai';\nexport * from './applications';\nexport * from './bundles';\nexport * from './clients';\nexport * from './core';\nexport * from './dictionaries';\nexport * from './distributions';\nexport * from './fields';\nexport * from './glossaries';\nexport * from './issues';\nexport * from './labels';\nexport * from './languages';\nexport * from './machineTranslation';\nexport * from './notifications';\nexport * from './organizationWebhooks';\nexport * from './projectsGroups';\nexport * from './reports';\nexport * from './screenshots';\nexport * from './securityLogs';\nexport * from './sourceFiles';\nexport * from './sourceStrings';\nexport * from './stringComments';\nexport * from './stringCorrections';\nexport * from './stringTranslations';\nexport * from './tasks';\nexport * from './teams';\nexport * from './translationMemory';\nexport * from './translationStatus';\nexport * from './translations';\nexport * from './uploadStorage';\nexport * from './users';\nexport * from './vendors';\nexport * from './webhooks';\nexport * from './workflows';\nexport default class Client extends CrowdinApi {\n    readonly aiApi: Ai;\n    readonly applicationsApi: Applications;\n    readonly sourceFilesApi: SourceFiles;\n    readonly glossariesApi: Glossaries;\n    readonly languagesApi: Languages;\n    readonly translationsApi: Translations;\n    readonly translationStatusApi: TranslationStatus;\n    readonly projectsGroupsApi: ProjectsGroups;\n    readonly reportsApi: Reports;\n    readonly screenshotsApi: Screenshots;\n    readonly sourceStringsApi: SourceStrings;\n    readonly uploadStorageApi: UploadStorage;\n    readonly tasksApi: Tasks;\n    readonly translationMemoryApi: TranslationMemory;\n    readonly webhooksApi: Webhooks;\n    readonly organizationWebhooksApi: OrganizationWebhooks;\n    readonly machineTranslationApi: MachineTranslation;\n    readonly stringTranslationsApi: StringTranslations;\n    readonly workflowsApi: Workflows;\n    readonly usersApi: Users;\n    readonly vendorsApi: Vendors;\n    readonly issuesApi: Issues;\n    readonly teamsApi: Teams;\n    readonly distributionsApi: Distributions;\n    readonly dictionariesApi: Dictionaries;\n    readonly labelsApi: Labels;\n    readonly stringCommentsApi: StringComments;\n    readonly bundlesApi: Bundles;\n    readonly notificationsApi: Notifications;\n    readonly clientsApi: Clients;\n    readonly securityLogsApi: SecurityLogs;\n    readonly fieldsApi: Fields;\n    readonly stringCorrectionsApi: StringCorrections;\n    constructor(credentials: Credentials, config?: ClientConfig);\n}\nexport { Client };\n```\n\n##### issues/index.d.ts\n\n```typescript\nimport { CrowdinApi, PaginationOptions, PatchRequest, ResponseList, ResponseObject } from '../core';\nexport declare class Issues extends CrowdinApi {\n    listReportedIssues(projectId: number, options?: IssuesModel.ListReportedIssuesOptions): Promise<ResponseList<IssuesModel.Issue>>;\n    listReportedIssues(projectId: number, limit?: number, offset?: number, type?: IssuesModel.Type, status?: IssuesModel.Status): Promise<ResponseList<IssuesModel.Issue>>;\n    editIssue(projectId: number, issueId: number, request: PatchRequest[]): Promise<ResponseObject<IssuesModel.Issue>>;\n}\nexport declare namespace IssuesModel {\n    type Type = 'all' | 'general_question' | 'translation_mistake' | 'context_request' | 'source_mistake';\n    type Status = 'all' | 'resolved' | 'unresolved';\n    interface Issue {\n        id: number;\n        text: string;\n        userId: number;\n        stringId: number;\n        user: User;\n        string: string;\n        languageId: string;\n        type: Type;\n        status: Status;\n        createdAt: string;\n    }\n    interface User {\n        id: number;\n        username: string;\n        fullName: string;\n        avatarUrl: string;\n    }\n    interface String {\n        id: number;\n        text: string;\n        type: string;\n        hasPlurals: boolean;\n        isIcu: boolean;\n        context: string;\n        fileId: number;\n    }\n    interface ListReportedIssuesOptions extends PaginationOptions {\n        type?: IssuesModel.Type;\n        status?: IssuesModel.Status;\n    }\n}\n```\n\n##### labels/index.d.ts\n\n```typescript\nimport { CrowdinApi, PaginationOptions, PatchRequest, ResponseList, ResponseObject } from '../core';\nimport { ScreenshotsModel } from '../screenshots';\nimport { SourceStringsModel } from '../sourceStrings';\nexport declare class Labels extends CrowdinApi {\n    listLabels(projectId: number, options?: LabelsModel.ListLabelsParams): Promise<ResponseList<LabelsModel.Label>>;\n    listLabels(projectId: number, limit?: number, offset?: number): Promise<ResponseList<LabelsModel.Label>>;\n    addLabel(projectId: number, request: LabelsModel.AddLabelRequest): Promise<ResponseObject<LabelsModel.Label>>;\n    getLabel(projectId: number, labelId: number): Promise<ResponseObject<LabelsModel.Label>>;\n    deleteLabel(projectId: number, labelId: number): Promise<void>;\n    editLabel(projectId: number, labelId: number, request: PatchRequest[]): Promise<ResponseObject<LabelsModel.Label>>;\n    assignLabelToScreenshots(projectId: number, labelId: number, request: LabelsModel.AssignLabelToScreenshotsRequet): Promise<ResponseList<ScreenshotsModel.Screenshot>>;\n    unassignLabelFromScreenshots(projectId: number, labelId: number, screenshotIds: string): Promise<ResponseList<ScreenshotsModel.Screenshot>>;\n    assignLabelToString(projectId: number, labelId: number, request: LabelsModel.AssignLabelToStringsRequet): Promise<ResponseList<SourceStringsModel.String>>;\n    unassignLabelFromString(projectId: number, labelId: number, stringIds: string): Promise<ResponseList<SourceStringsModel.String>>;\n}\nexport declare namespace LabelsModel {\n    interface ListLabelsParams extends PaginationOptions {\n        orderBy?: string;\n    }\n    interface Label {\n        id: number;\n        title: string;\n        isSystem?: boolean;\n    }\n    interface AddLabelRequest {\n        title: string;\n    }\n    interface AssignLabelToStringsRequet {\n        stringIds: number[];\n    }\n    interface AssignLabelToScreenshotsRequet {\n        screenshotIds: number[];\n    }\n}\n```\n\n##### languages/index.d.ts\n\n```typescript\nimport { CrowdinApi, PaginationOptions, PatchRequest, ResponseList, ResponseObject } from '../core';\nexport declare class Languages extends CrowdinApi {\n    listSupportedLanguages(options?: PaginationOptions): Promise<ResponseList<LanguagesModel.Language>>;\n    listSupportedLanguages(limit?: number, offset?: number): Promise<ResponseList<LanguagesModel.Language>>;\n    addCustomLanguage(request: LanguagesModel.AddLanguageRequest): Promise<ResponseObject<LanguagesModel.Language>>;\n    getLanguage(languageId: string): Promise<ResponseObject<LanguagesModel.Language>>;\n    deleteCustomLanguage(languageId: string): Promise<void>;\n    editCustomLanguage(languageId: string, request: PatchRequest[]): Promise<ResponseObject<LanguagesModel.Language>>;\n}\nexport declare namespace LanguagesModel {\n    interface Language {\n        id: string;\n        name: string;\n        editorCode: string;\n        twoLettersCode: string;\n        threeLettersCode: string;\n        locale: string;\n        androidCode: string;\n        osxCode: string;\n        osxLocale: string;\n        pluralCategoryNames: string[];\n        pluralRules: string;\n        pluralExamples: string[];\n        textDirection: TextDirection;\n        dialectOf: string;\n    }\n    interface AddLanguageRequest {\n        name: string;\n        code: string;\n        localeCode: string;\n        textDirection: TextDirection;\n        pluralCategoryNames: string[];\n        threeLettersCode: string;\n        twoLettersCode?: string;\n        dialectOf?: string;\n    }\n    type TextDirection = 'ltr' | 'rtl';\n}\n```\n\n##### machineTranslation/index.d.ts\n\n```typescript\nimport { CrowdinApi, PaginationOptions, PatchRequest, ResponseList, ResponseObject } from '../core';\nexport declare class MachineTranslation extends CrowdinApi {\n    listMts(options?: MachineTranslationModel.ListMTsOptions): Promise<ResponseList<MachineTranslationModel.MachineTranslation>>;\n    listMts(groupId?: number, limit?: number, offset?: number): Promise<ResponseList<MachineTranslationModel.MachineTranslation>>;\n    createMt(request: MachineTranslationModel.CreateMachineTranslationRequest): Promise<ResponseObject<MachineTranslationModel.MachineTranslation>>;\n    getMt(mtId: number): Promise<ResponseObject<MachineTranslationModel.MachineTranslation>>;\n    deleteMt(mtId: number): Promise<void>;\n    updateMt(mtId: number, request: PatchRequest[]): Promise<ResponseObject<MachineTranslationModel.MachineTranslation>>;\n    translate(mtId: number, request: MachineTranslationModel.TranslateRequest): Promise<ResponseObject<MachineTranslationModel.TranslateResponse>>;\n}\nexport declare namespace MachineTranslationModel {\n    interface MachineTranslation {\n        id: number;\n        groupId: number;\n        name: string;\n        type: number;\n        credentials: Credentials;\n        projectIds: number[];\n        supportedLanguageIds: string[];\n        supportedLanguagePairs: Record<string, string[]>;\n        enabledLanguageIds: string[];\n        enabledProjectIds: number[];\n        isEnabled: boolean;\n    }\n    type Credentials = {\n        apiKey: string;\n    } | {\n        credentials: string;\n    } | {\n        model: string;\n        apiKey: string;\n    } | {\n        isSystemCredentials: boolean;\n        apiKey: string;\n    } | {\n        endpoint: string;\n        apiKey: string;\n    } | {\n        url: string;\n    } | {\n        accessKey: string;\n        secretKey: string;\n    };\n    interface CreateMachineTranslationRequest {\n        name: string;\n        type: string;\n        credentials: Credentials;\n        groupId?: number;\n        enabledLanguageIds?: string[];\n        enabledProjectIds?: number[];\n        isEnabled?: boolean;\n    }\n    interface TranslateRequest {\n        languageRecognitionProvider?: LanguageRecognitionProvider;\n        sourceLanguageId?: string;\n        targetLanguageId: string;\n        strings?: string[];\n    }\n    interface TranslateResponse {\n        sourceLanguageId: string;\n        targetLanguageId: string;\n        strings: string[];\n        translations: string[];\n    }\n    type LanguageRecognitionProvider = 'crowdin' | 'engine';\n    interface ListMTsOptions extends PaginationOptions {\n        groupId?: number;\n    }\n}\n```\n\n##### notifications/index.d.ts\n\n```typescript\nimport { CrowdinApi } from '../core';\nexport declare class Notifications extends CrowdinApi {\n    sendNotificationToAuthenticatedUser(request: NotificationsModel.Notification): Promise<void>;\n    sendNotificationToProjectMembers(projectId: number, request: NotificationsModel.NotificationByUsers | NotificationsModel.NotificationByRole): Promise<void>;\n    sendNotificationToOrganizationMembers(request: NotificationsModel.Notification | NotificationsModel.NotificationByUsers | NotificationsModel.NotificationByRole): Promise<void>;\n}\nexport declare namespace NotificationsModel {\n    interface Notification {\n        message: string;\n    }\n    interface NotificationByUsers extends Notification {\n        userIds: number[];\n    }\n    interface NotificationByRole extends Notification {\n        role: 'owner' | 'admin';\n    }\n}\n```\n\n##### organizationWebhooks/index.d.ts\n\n```typescript\nimport { CrowdinApi, PaginationOptions, PatchRequest, ResponseList, ResponseObject } from '../core';\nimport { WebhooksModel } from '../webhooks';\nexport declare class OrganizationWebhooks extends CrowdinApi {\n    listWebhooks(options?: PaginationOptions): Promise<ResponseList<OrganizationWebhooksModel.OrganizationWebhook>>;\n    addWebhook(request: OrganizationWebhooksModel.AddOrganizationWebhookRequest): Promise<ResponseObject<OrganizationWebhooksModel.OrganizationWebhook>>;\n    getWebhook(webhookId: number): Promise<ResponseObject<OrganizationWebhooksModel.OrganizationWebhook>>;\n    deleteWebhook(webhookId: number): Promise<void>;\n    editWebhook(webhookId: number, request: PatchRequest[]): Promise<ResponseObject<OrganizationWebhooksModel.OrganizationWebhook>>;\n}\nexport declare namespace OrganizationWebhooksModel {\n    type OrganizationWebhook = Omit<WebhooksModel.Webhook, 'projectId' | 'events'> & {\n        events: Event[];\n    };\n    type AddOrganizationWebhookRequest = Omit<WebhooksModel.AddWebhookRequest, 'events'> & {\n        events: Event[];\n    };\n    type Event = 'group.created' | 'group.deleted' | 'project.created' | 'project.deleted';\n}\n```\n\n##### projectsGroups/index.d.ts\n\n```typescript\nimport { BooleanInt, CrowdinApi, DownloadLink, PaginationOptions, PatchRequest, ResponseList, ResponseObject } from '../core';\nimport { LanguagesModel } from '../languages';\nexport declare class ProjectsGroups extends CrowdinApi {\n    listGroups(options?: ProjectsGroupsModel.ListGroupsOptions): Promise<ResponseList<ProjectsGroupsModel.Group>>;\n    listGroups(parentId?: number, offset?: number, userId?: number, limit?: number): Promise<ResponseList<ProjectsGroupsModel.Group>>;\n    addGroup(request: ProjectsGroupsModel.AddGroupRequest): Promise<ResponseObject<ProjectsGroupsModel.Group>>;\n    getGroup(groupId: number): Promise<ResponseObject<ProjectsGroupsModel.Group>>;\n    deleteGroup(groupId: number): Promise<void>;\n    editGroup(groupId: number, request: PatchRequest[]): Promise<ResponseObject<ProjectsGroupsModel.Group>>;\n    listProjects(options?: ProjectsGroupsModel.ListProjectsOptions): Promise<ResponseList<ProjectsGroupsModel.Project | ProjectsGroupsModel.ProjectSettings>>;\n    listProjects(groupId?: number, hasManagerAccess?: BooleanInt, limit?: number, offset?: number): Promise<ResponseList<ProjectsGroupsModel.Project | ProjectsGroupsModel.ProjectSettings>>;\n    addProject(request: ProjectsGroupsModel.CreateProjectEnterpriseRequest | ProjectsGroupsModel.CreateProjectRequest): Promise<ResponseObject<ProjectsGroupsModel.Project | ProjectsGroupsModel.ProjectSettings>>;\n    getProject(projectId: number): Promise<ResponseObject<ProjectsGroupsModel.Project | ProjectsGroupsModel.ProjectSettings>>;\n    deleteProject(projectId: number): Promise<void>;\n    editProject(projectId: number, request: PatchRequest[]): Promise<ResponseObject<ProjectsGroupsModel.Project | ProjectsGroupsModel.ProjectSettings>>;\n    downloadProjectFileFormatSettingsCustomSegmentation(projectId: number, fileFormatSettingsId: number): Promise<ResponseObject<DownloadLink>>;\n    resetProjectFileFormatSettingsCustomSegmentation(projectId: number, fileFormatSettingsId: number): Promise<ResponseObject<DownloadLink>>;\n    listProjectFileFormatSettings(projectId: number, options?: PaginationOptions): Promise<ResponseList<ProjectsGroupsModel.ProjectFileFormatSettings>>;\n    addProjectFileFormatSettings(projectId: number, request: ProjectsGroupsModel.AddProjectFileFormatSettingsRequest): Promise<ResponseObject<ProjectsGroupsModel.ProjectFileFormatSettings>>;\n    getProjectFileFormatSettings(projectId: number, fileFormatSettingsId: number): Promise<ResponseObject<ProjectsGroupsModel.ProjectFileFormatSettings>>;\n    deleteProjectFileFormatSettings(projectId: number, fileFormatSettingsId: number): Promise<void>;\n    editProjectFileFormatSettings(projectId: number, fileFormatSettingsId: number, request: PatchRequest[]): Promise<ResponseObject<ProjectsGroupsModel.ProjectFileFormatSettings>>;\n    listProjectStringsExporterSettings(projectId: number, options?: PaginationOptions): Promise<ResponseList<ProjectsGroupsModel.ProjectStringsExporterSettings>>;\n    addProjectStringsExporterSettings(projectId: number, request: ProjectsGroupsModel.AddProjectStringsExporterSettingsRequest): Promise<ResponseObject<ProjectsGroupsModel.ProjectStringsExporterSettings>>;\n    getProjectStringsExporterSettings(projectId: number, systemStringsExporterSettingsId: number): Promise<ResponseObject<ProjectsGroupsModel.ProjectStringsExporterSettings>>;\n    deleteProjectStringsExporterSettings(projectId: number, systemStringsExporterSettingsId: number): Promise<void>;\n    editProjectStringsExporterSettings(projectId: number, systemStringsExporterSettingsId: number, request: ProjectsGroupsModel.AddProjectStringsExporterSettingsRequest): Promise<ResponseObject<ProjectsGroupsModel.ProjectStringsExporterSettings>>;\n}\nexport declare namespace ProjectsGroupsModel {\n    interface Group {\n        id: number;\n        name: string;\n        description: string;\n        parentId: number;\n        organizationId: number;\n        userId: number;\n        subgroupsCount: number;\n        projectsCount: number;\n        webUrl: string;\n        createdAt: string;\n        updatedAt: string;\n    }\n    interface AddGroupRequest {\n        name: string;\n        parentId?: number;\n        description?: string;\n    }\n    interface Project {\n        id: number;\n        type: Type;\n        userId: number;\n        sourceLanguageId: string;\n        targetLanguageIds: string[];\n        languageAccessPolicy: LanguageAccessPolicy;\n        name: string;\n        identifier: string;\n        description: string;\n        visibility: string;\n        logo: string;\n        publicDownloads: boolean;\n        createdAt: string;\n        updatedAt: string;\n        lastActivity: string;\n        sourceLanguage: LanguagesModel.Language;\n        targetLanguages: LanguagesModel.Language[];\n        webUrl: string;\n        savingsReportSettingsTemplateId: number;\n        fields: Record<string, any>;\n        cname: string;\n        groupId: number;\n        background: string;\n        isExternal: boolean;\n        externalType: string;\n        externalProjectId: number;\n        externalOrganizationId: number;\n        workflowId: number;\n        hasCrowdsourcing: boolean;\n        publicUrl: string;\n    }\n    interface CreateProjectRequest {\n        name: string;\n        identifier: string;\n        sourceLanguageId: string;\n        targetLanguageIds?: string[];\n        visibility?: JoinPolicy;\n        languageAccessPolicy?: LanguageAccessPolicy;\n        cname?: string;\n        description?: string;\n        tagDetection?: TagDetection;\n        isMtAllowed?: boolean;\n        taskBasedAccessControl?: boolean;\n        autoSubstitution?: boolean;\n        autoTranslateDialects?: boolean;\n        publicDownloads?: boolean;\n        hiddenStringsProofreadersAccess?: boolean;\n        useGlobalTm?: boolean;\n        showTmSuggestionsDialects?: boolean;\n        tmApprovedSuggestionsOnly?: boolean;\n        skipUntranslatedStrings?: boolean;\n        exportApprovedOnly?: boolean;\n        qaCheckIsActive?: boolean;\n        qaCheckCategories?: CheckCategories;\n        qaChecksIgnorableCategories?: CheckCategories;\n        languageMapping?: LanguageMapping;\n        glossaryAccess?: boolean;\n        glossaryAccessOption?: GlossaryAccessOption;\n        normalizePlaceholder?: boolean;\n        notificationSettings?: NotificationSettings;\n        tmPreTranslate?: ProjectSettings['tmPreTranslate'];\n        mtPreTranslate?: ProjectSettings['mtPreTranslate'];\n        aiPreTranslate?: ProjectSettings['aiPreTranslate'];\n        assistActionAiPromptId?: number;\n        editorSuggestionAiPromptId?: number;\n        savingsReportSettingsTemplateId?: number;\n        defaultTmId?: number;\n        defaultGlossaryId?: number;\n        inContext?: boolean;\n        inContextProcessHiddenStrings?: boolean;\n        inContextPseudoLanguageId?: string;\n        saveMetaInfoInSource?: boolean;\n        type?: BooleanInt;\n        skipUntranslatedFiles?: boolean;\n        tmContextType?: TmContextType;\n    }\n    interface CreateProjectEnterpriseRequest {\n        name: string;\n        sourceLanguageId: string;\n        templateId?: number;\n        steps?: WorkflowTemplateStepConfig[];\n        groupId?: number;\n        targetLanguageIds?: string[];\n        vendorId?: number;\n        mtEngineId?: number;\n        description?: string;\n        translateDuplicates?: TranslateDuplicates;\n        tagsDetection?: TagDetection;\n        isMtAllowed?: boolean;\n        taskBasedAccessControl?: boolean;\n        taskReviewerIds?: number[];\n        autoSubstitution?: boolean;\n        showTmSuggestionsDialects?: boolean;\n        tmApprovedSuggestionsOnly?: boolean;\n        autoTranslateDialects?: boolean;\n        publicDownloads?: boolean;\n        hiddenStringsProofreadersAccess?: boolean;\n        delayedWorkflowStart?: boolean;\n        skipUntranslatedStrings?: boolean;\n        exportWithMinApprovalsCount?: number;\n        exportStringsThatPassedWorkflow?: number;\n        normalizePlaceholder?: boolean;\n        qaCheckIsActive?: boolean;\n        qaApprovalsCount?: number;\n        qaCheckCategories?: CheckCategories;\n        qaChecksIgnorableCategories?: CheckCategories;\n        customQaCheckIds?: number[];\n        languageMapping?: LanguageMapping;\n        glossaryAccess?: boolean;\n        glossaryAccessOption?: GlossaryAccessOption;\n        notificationSettings?: NotificationSettings;\n        savingsReportSettingsTemplateId?: number;\n        fields?: Record<string, any>;\n        assistActionAiPromptId?: number;\n        editorSuggestionAiPromptId?: number;\n        alignmentActionAiPromptId?: number;\n        defaultTmId?: number;\n        defaultGlossaryId?: number;\n        inContext?: boolean;\n        inContextProcessHiddenStrings?: boolean;\n        inContextPseudoLanguageId?: string;\n        saveMetaInfoInSource?: boolean;\n        type?: BooleanInt;\n        skipUntranslatedFiles?: boolean;\n        tmContextType?: TmContextType;\n    }\n    type GlossaryAccessOption = 'readOnly' | 'fullAccess' | 'manageDrafts';\n    interface ProjectSettings extends Project {\n        translateDuplicates: TranslateDuplicates;\n        tagsDetection: TagDetection;\n        glossaryAccess: boolean;\n        glossaryAccessOption: GlossaryAccessOption;\n        isMtAllowed: boolean;\n        taskBasedAccessControl: boolean;\n        hiddenStringsProofreadersAccess: boolean;\n        autoSubstitution: boolean;\n        exportTranslatedOnly: boolean;\n        skipUntranslatedStrings: boolean;\n        exportApprovedOnly: boolean;\n        autoTranslateDialects: boolean;\n        useGlobalTm: boolean;\n        showTmSuggestionsDialects: boolean;\n        tmApprovedSuggestionsOnly: boolean;\n        isSuspended: boolean;\n        qaCheckIsActive: boolean;\n        qaCheckCategories: CheckCategories;\n        qaChecksIgnorableCategories: CheckCategories;\n        languageMapping: LanguageMapping;\n        notificationSettings: NotificationSettings;\n        defaultTmId: number;\n        defaultGlossaryId: number;\n        assignedTms: {\n            [id: string]: {\n                priority: number;\n            };\n        };\n        assignedGlossaries: number[];\n        tmPenalties: {\n            autoSubstitution: number;\n            tmPriority: {\n                priority: number;\n                penalty: number;\n            };\n            multipleTranslations: number;\n            timeSinceLastUsage: {\n                months: number;\n                penalty: number;\n            };\n            timeSinceLastModified: {\n                months: number;\n                penalty: number;\n            };\n        };\n        normalizePlaceholder: boolean;\n        tmPreTranslate: {\n            enabled: boolean;\n            autoApproveOption: 'all' | 'perfectMatchOnly' | 'exceptAutoSubstituted' | 'perfectMatchApprovedOnly' | 'none';\n            minimumMatchRatio: 'perfect' | '100';\n        };\n        mtPreTranslate: {\n            enabled: boolean;\n            mts: {\n                mtId: number;\n                languageIds: string[];\n            }[];\n        };\n        aiPreTranslate: {\n            enabled: boolean;\n            aiPrompts: {\n                aiPromptId: number;\n                languageIds: string[];\n            }[];\n        };\n        assistActionAiPromptId: number;\n        editorSuggestionAiPromptId: number;\n        inContext: boolean;\n        inContextProcessHiddenStrings: string;\n        inContextPseudoLanguageId: string;\n        inContextPseudoLanguage: LanguagesModel.Language;\n        saveMetaInfoInSource: boolean;\n        skipUntranslatedFiles: boolean;\n        tmContextType: TmContextType;\n        clientOrganizationId: number;\n        taskReviewerIds: number[];\n        exportWithMinApprovalsCount: number;\n        exportStringsThatPassedWorkflow: boolean;\n        qaApprovalsCount: number;\n        customQaCheckIds: number[];\n        externalQaCheckIds: number[];\n        delayedWorkflowStart: boolean;\n        alignmentActionAiPromptId: number;\n    }\n    enum Type {\n        FILES_BASED = 0,\n        STRINGS_BASED = 1\n    }\n    enum TagDetection {\n        AUTO = 0,\n        COUNT_TAGS = 1,\n        SKIP_TAGS = 2\n    }\n    type JoinPolicy = 'open' | 'private';\n    type LanguageAccessPolicy = 'open' | 'moderate';\n    interface CheckCategories {\n        empty: boolean;\n        size: boolean;\n        tags: boolean;\n        spaces: boolean;\n        variables: boolean;\n        punctuation: boolean;\n        symbolRegister: boolean;\n        specialSymbols: boolean;\n        wrongTranslation: boolean;\n        spellcheck: boolean;\n        icu: boolean;\n        terms: boolean;\n        duplicate: boolean;\n        ftl: boolean;\n        android: boolean;\n    }\n    interface LanguageMapping {\n        [key: string]: LanguageMappingEntity;\n    }\n    interface LanguageMappingEntity {\n        name: string;\n        two_letters_code: string;\n        three_letters_code: string;\n        locale: string;\n        locale_with_underscore: string;\n        android_code: string;\n        osx_code: string;\n        osx_locale: string;\n    }\n    enum TranslateDuplicates {\n        SHOW = 0,\n        HIDE_REGULAR_DETECTION = 1,\n        SHOW_AUTO_TRANSLATE = 2,\n        SHOW_WITHIN_VERION_BRANCH_REGULAR_DETECTION = 3,\n        HIDE_STRICT_DETECTION = 4,\n        SHOW_WITHIN_VERION_BRANCH_STRICT_DETECTION = 5\n    }\n    interface NotificationSettings {\n        translatorNewStrings?: boolean;\n        managerNewStrings?: boolean;\n        managerLanguageCompleted?: boolean;\n    }\n    interface ListGroupsOptions extends PaginationOptions {\n        parentId?: number;\n        userId?: number;\n        orderBy?: string;\n    }\n    interface ListProjectsOptions extends PaginationOptions {\n        groupId?: number;\n        hasManagerAccess?: BooleanInt;\n        orderBy?: string;\n        type?: BooleanInt;\n    }\n    type Settings = PropertyFileFormatSettings | CommonFileFormatSettings | XmlFileFormatSettings | MdxV2FormatSettings | FmHtmlFormatSettings | HtmlFormatSettings | JsonFormatSettings | MdxV1FormatSettings | JavaScriptFileFormatSettings | DocxFileFormatSettings;\n    interface ProjectFileFormatSettings {\n        id: number;\n        name: string;\n        format: string;\n        extensions: string[];\n        settings: Settings;\n        createdAt: string;\n        updatedAt: string;\n    }\n    interface AddProjectFileFormatSettingsRequest {\n        format: string;\n        settings: Settings;\n    }\n    interface PropertyFileFormatSettings {\n        escapeQuotes?: 0 | 1 | 2 | 3;\n        escapeSpecialCharacters?: 0 | 1;\n        exportPattern?: string;\n    }\n    interface JavaScriptFileFormatSettings {\n        exportPattern?: 'string';\n        exportQuotes?: 'single' | 'double';\n    }\n    interface CommonFileFormatSettings {\n        contentSegmentation?: boolean;\n        srxStorageId?: number;\n        exportPattern?: string;\n    }\n    interface XmlFileFormatSettings extends CommonFileFormatSettings {\n        translateContent?: boolean;\n        translateAttributes?: boolean;\n        translatableElements?: string[];\n    }\n    interface JsonFormatSettings extends CommonFileFormatSettings {\n        type?: 'i18next_json' | 'nestjs_i18n';\n    }\n    interface MdxV2FormatSettings extends CommonFileFormatSettings {\n        excludeCodeBlocks?: boolean;\n        excludedFrontMatterElements?: string[];\n    }\n    interface MdxV1FormatSettings extends CommonFileFormatSettings {\n        excludeCodeBlocks?: boolean;\n        excludedFrontMatterElements?: string[];\n        type?: 'mdx_v1' | 'mdx_v2';\n    }\n    interface FmHtmlFormatSettings extends CommonFileFormatSettings {\n        excludedElements?: boolean;\n        excludedFrontMatterElements?: string[];\n    }\n    interface HtmlFormatSettings extends CommonFileFormatSettings {\n        excludedElements?: boolean;\n    }\n    interface DocxFileFormatSettings extends CommonFileFormatSettings {\n        cleanTagsAggressively?: boolean;\n        translateHiddenText?: boolean;\n        translateHyperlinkUrls?: boolean;\n        translateHiddenRowsAndColumns?: boolean;\n        importNotes?: boolean;\n        importHiddenSlides?: boolean;\n    }\n    type TmContextType = 'segmentContext' | 'auto' | 'prevAndNextSegment';\n    type WorkflowTemplateStepConfig = WorkflowTemplateStepConfigTranslateProofread | WorkflowTemplateStepConfigVendor | WorkflowTemplateStepConfigTMPreTranslate | WorkflowTemplateStepConfigMTPreTranslate;\n    interface WorkflowTemplateStepConfigTranslateProofread {\n        id: number;\n        languages?: string[];\n        assignees?: number[];\n        config?: {\n            assignees: {\n                [key: string]: number[];\n            };\n        };\n    }\n    interface WorkflowTemplateStepConfigVendor {\n        id: number;\n        languages?: string[];\n        vendorId?: number;\n    }\n    interface WorkflowTemplateStepConfigTMPreTranslate {\n        id: number;\n        languages?: string[];\n        config?: {\n            minRelevant?: number;\n            autoSubstitution?: boolean;\n        };\n    }\n    interface WorkflowTemplateStepConfigMTPreTranslate {\n        id: number;\n        languages?: string[];\n        mtId?: number;\n    }\n    type StringsExporterSettings = AndroidStringsExporterSettings | MacOSXStringsExporterSettings | XliffStringsExporterSettings;\n    interface ProjectStringsExporterSettings {\n        id: number;\n        format: string;\n        settings: StringsExporterSettings;\n        createdAt: string;\n        updatedAt: string;\n    }\n    interface AndroidStringsExporterSettings {\n        convertPlaceholders?: boolean;\n        convertLineBreaks?: boolean;\n        useCdataForStringsWithTags?: boolean;\n    }\n    interface MacOSXStringsExporterSettings {\n        convertPlaceholders?: boolean;\n        convertLineBreaks?: boolean;\n    }\n    interface XliffStringsExporterSettings {\n        languagePairMapping?: {\n            [key: string]: {\n                sourceLanguageId: string;\n            };\n        };\n        copySourceToEmptyTarget?: boolean;\n        exportTranslatorsComment?: boolean;\n    }\n    interface AddProjectStringsExporterSettingsRequest {\n        format: string;\n        settings: StringsExporterSettings;\n    }\n}\n```\n\n##### reports/index.d.ts\n\n```typescript\nimport { CrowdinApi, DownloadLink, PaginationOptions, PatchRequest, ResponseList, ResponseObject, Status } from '../core';\nexport declare class Reports extends CrowdinApi {\n    listOrganizationReportArchives(options?: ReportsModel.ListReportArchiveParams): Promise<ResponseList<ReportsModel.ReportArchive>>;\n    getOrganizationReportArchive(archiveId: number): Promise<ResponseObject<ReportsModel.ReportArchive>>;\n    deleteOrganizationReportArchive(archiveId: number): Promise<void>;\n    exportOrganizationReportArchive(archiveId: number, request?: {\n        format?: ReportsModel.Format;\n    }): Promise<ResponseObject<Status<ReportsModel.ReportArchiveStatusAttribute>>>;\n    checkOrganizationReportArchiveStatus(archiveId: number, exportId: string): Promise<ResponseObject<Status<ReportsModel.ReportArchiveStatusAttribute>>>;\n    downloadOrganizationReportArchive(archiveId: number, exportId: string): Promise<ResponseObject<DownloadLink>>;\n    listUserReportArchives(userId: number, options?: ReportsModel.ListReportArchiveParams): Promise<ResponseList<ReportsModel.ReportArchive>>;\n    getUserReportArchive(userId: number, archiveId: number): Promise<ResponseObject<ReportsModel.ReportArchive>>;\n    deleteUserReportArchive(userId: number, archiveId: number): Promise<void>;\n    exportUserReportArchive(userId: number, archiveId: number, request?: {\n        format?: ReportsModel.Format;\n    }): Promise<ResponseObject<Status<ReportsModel.ReportArchiveStatusAttribute>>>;\n    checkUserReportArchiveStatus(userId: number, archiveId: number, exportId: string): Promise<ResponseObject<Status<ReportsModel.ReportArchiveStatusAttribute>>>;\n    downloadUserReportArchive(userId: number, archiveId: number, exportId: string): Promise<ResponseObject<DownloadLink>>;\n    generateGroupReport(groupId: number, request: ReportsModel.GenerateGroupReportRequest): Promise<ResponseObject<Status<ReportsModel.ReportStatusAttributes<ReportsModel.GroupReportSchema>>>>;\n    checkGroupReportStatus(groupId: number, reportId: string): Promise<ResponseObject<Status<ReportsModel.ReportStatusAttributes<ReportsModel.GroupReportSchema>>>>;\n    downloadGroupReport(groupId: number, reportId: string): Promise<ResponseObject<DownloadLink>>;\n    listOrganizationReportSettingsTemplates(options?: ReportsModel.ListOrganizationReportSettingsParams): Promise<ResponseList<ReportsModel.OrganizationReportSettings>>;\n    addOrganizationReportSettingsTemplate(request: ReportsModel.AddOrganizationReportSettingsRequest): Promise<ResponseObject<ReportsModel.OrganizationReportSettings>>;\n    getOrganizationReportSettingsTemplate(reportSettingsTemplateId: number): Promise<ResponseObject<ReportsModel.OrganizationReportSettings>>;\n    editOrganizationReportSettingsTemplate(reportSettingsTemplateId: number, request: PatchRequest[]): Promise<ResponseObject<ReportsModel.OrganizationReportSettings>>;\n    deleteOrganizationReportSettingsTemplate(reportSettingsTemplateId: number): Promise<void>;\n    generateOrganizationReport(request: ReportsModel.GenerateOrganizationReportRequest): Promise<ResponseObject<Status<ReportsModel.ReportStatusAttributes<ReportsModel.OrganizationReportSchema>>>>;\n    checkOrganizationReportStatus(reportId: string): Promise<ResponseObject<Status<ReportsModel.ReportStatusAttributes<ReportsModel.OrganizationReportSchema>>>>;\n    downloadOrganizationReport(reportId: string): Promise<ResponseObject<DownloadLink>>;\n    generateReport(projectId: number, request: ReportsModel.GenerateReportRequest): Promise<ResponseObject<Status<ReportsModel.ReportStatusAttributes<ReportsModel.ReportSchema>>>>;\n    checkReportStatus(projectId: number, reportId: string): Promise<ResponseObject<Status<ReportsModel.ReportStatusAttributes<ReportsModel.ReportSchema>>>>;\n    downloadReport(projectId: number, reportId: string): Promise<ResponseObject<DownloadLink>>;\n    listReportSettingsTemplates(projectId: number, options?: PaginationOptions): Promise<ResponseList<ReportsModel.ReportSettings>>;\n    addReportSettingsTemplate(projectId: number, request: ReportsModel.AddReportSettingsRequest): Promise<ResponseObject<ReportsModel.ReportSettings>>;\n    getReportSettingsTemplate(projectId: number, reportSettingsTemplateId: number): Promise<ResponseObject<ReportsModel.ReportSettings>>;\n    editReportSettingsTemplate(projectId: number, reportSettingsTemplateId: number, request: PatchRequest[]): Promise<ResponseObject<ReportsModel.ReportSettings>>;\n    deleteReportSettingsTemplate(projectId: number, reportSettingsTemplateId: number): Promise<void>;\n    listUserReportSettingsTemplates(userId: number, options?: PaginationOptions): Promise<ResponseList<ReportsModel.UserReportSettings>>;\n    addUserReportSettingsTemplate(userId: number, request: ReportsModel.AddUserReportSettingsRequest): Promise<ResponseObject<ReportsModel.UserReportSettings>>;\n    getUserReportSettingsTemplate(userId: number, reportSettingsTemplateId: number): Promise<ResponseObject<ReportsModel.UserReportSettings>>;\n    editUserReportSettingsTemplate(userId: number, reportSettingsTemplateId: number, request: PatchRequest[]): Promise<ResponseObject<ReportsModel.UserReportSettings>>;\n    deleteUserReportSettingsTemplate(userId: number, reportSettingsTemplateId: number): Promise<void>;\n}\nexport declare namespace ReportsModel {\n    interface ReportArchive {\n        id: number;\n        scopeType: string;\n        scopeId: number;\n        userId: number;\n        name: string;\n        webUrl: string;\n        scheme: any;\n        createdAt: string;\n    }\n    interface ListReportArchiveParams extends PaginationOptions {\n        scopeType: string;\n        scopeId: number;\n    }\n    interface ReportArchiveStatusAttribute {\n        format: Format;\n        reportName: string;\n        schema: any;\n    }\n    type GroupReportSchema = GroupTranslationCostsPostEditingSchema | GroupTopMembersSchema | GroupTaskUsageSchema | GroupQaCheckIssuesSchema | GroupTranslationActivitySchema;\n    type OrganizationReportSchema = GroupTranslationCostsPostEditingSchema | GroupTopMembersSchema | GroupTaskUsageSchema | GroupQaCheckIssuesSchema | GroupTranslationActivitySchema;\n    interface GenerateGroupReportRequest {\n        name: string;\n        schema: GroupReportSchema;\n    }\n    interface GenerateOrganizationReportRequest {\n        name: string;\n        schema: OrganizationReportSchema;\n    }\n    interface GroupTranslationCostsPostEditingSchema {\n        projectIds?: number[];\n        unit?: Unit;\n        currency?: Currency;\n        format?: Format;\n        baseRates: BaseRate;\n        individualRates: IndividualRate[];\n        netRateSchemes: NetRateSchemas;\n        excludeApprovalsForEditedTranslations?: boolean;\n        preTranslatedStringsCategorizationAdjustment?: boolean;\n        groupBy?: GroupBy;\n        dateFrom?: string;\n        dateTo?: string;\n        userIds?: number[];\n    }\n    interface GroupTranslationCostsPerEditingByTaskSchema {\n        unit?: Unit;\n        currency?: Currency;\n        format?: Format;\n        baseRates: BaseRate;\n        individualRates: IndividualRate[];\n        netRateSchemes: NetRateSchemas;\n        taskId?: number;\n    }\n    interface CostsEstimationSchema {\n        projectIds?: number[];\n        unit?: Unit;\n        currency?: Currency;\n        format?: Format;\n        baseRates: BaseRate;\n        individualRates: IndividualRate[];\n        netRateSchemes: NetRateSchemas;\n        calculateInternalMatches?: boolean;\n        includePreTranslatedStrings?: boolean;\n        languageId?: string;\n        branchIds?: number[];\n        dateFrom?: string;\n        dateTo?: string;\n        labelIds?: number[];\n        labelIncludeType?: LabelIncludeType;\n    }\n    interface CostsEstimationByTaskSchema {\n        unit?: Unit;\n        currency?: Currency;\n        format?: Format;\n        baseRates?: BaseRate;\n        individualRates?: IndividualRate[];\n        netRateSchemes?: NetRateSchemas;\n        calculateInternalMatches?: boolean;\n        includePreTranslatedStrings?: boolean;\n        taskId?: number;\n    }\n    interface GroupTopMembersSchema {\n        projectIds?: number[];\n        unit?: Unit;\n        languageId?: string;\n        format?: Format;\n        dateFrom?: string;\n        dateTo?: string;\n    }\n    interface RawDataSchema {\n        mode: ContributionMode;\n        unit?: Unit;\n        languageId?: string;\n        userId?: number;\n        dateFrom?: string;\n        dateTo?: string;\n    }\n    type GenerateReportRequest = PreTranslateEfficeincy | PreTranslateAccuracy | TranslateAccuracy | CostEstimationPostEnding | TranslationCostsPostEnding | TopMembers | ContributionRawData | SourceContentUpdates | ProjectMembers | EditorIssues | QaCheckIssues | SavingActivity | TranslationActivity;\n    type ReportSchema = Pick<GenerateReportRequest, 'schema'>;\n    interface PreTranslateEfficeincy {\n        name: 'pre-translate-efficiency';\n        schema: PreTranslateAccuracySchema | PreTranslateAccuracySchemaByTask;\n    }\n    interface PreTranslateAccuracy {\n        name: 'pre-translate-accuracy';\n        schema: PreTranslateAccuracySchema | PreTranslateAccuracySchemaByTask;\n    }\n    interface TranslateAccuracy {\n        name: 'translator-accuracy';\n        schema: TranslateAccuracySchema;\n    }\n    interface CostEstimationPostEnding {\n        name: 'costs-estimation-pe';\n        schema: CostEstimationPostEndingSchema | CostEstimationPostEndingSchemaByTask;\n    }\n    interface TranslationCostsPostEnding {\n        name: 'translation-costs-pe';\n        schema: TranslationCostsPostEndingSchema | TranslationCostsPostEndingSchemaByTask;\n    }\n    interface TopMembers {\n        name: 'top-members';\n        schema: TopMembersSchema;\n    }\n    interface ContributionRawData {\n        name: 'contribution-raw-data';\n        schema: ContributionRawDataSchema | ContributionRawDataSchemaByTask;\n    }\n    interface SourceContentUpdates {\n        name: 'source-content-updates';\n        schema: SourceContentUpdatesSchema;\n    }\n    interface ProjectMembers {\n        name: 'project-members';\n        schema: MembersSchema;\n    }\n    interface EditorIssues {\n        name: 'editor-issues';\n        schema: EditorIssuesSchema;\n    }\n    interface QaCheckIssues {\n        name: 'qa-check-issues';\n        schema: ProjectQaCheckIssuesSchema;\n    }\n    interface SavingActivity {\n        name: 'saving-activity';\n        schema: SavingActivitySchema;\n    }\n    interface TranslationActivity {\n        name: 'translation-activity';\n        schema: ProjectConsumptionSchema;\n    }\n    interface ReportStatusAttributes<S> {\n        format: Format;\n        reportName: string;\n        schema: S;\n    }\n    interface PreTranslateAccuracySchema {\n        unit?: Unit;\n        format?: Format;\n        postEditingCategories?: string[];\n        languageId?: string;\n        dateFrom?: string;\n        dateTo?: string;\n    }\n    interface PreTranslateAccuracySchemaByTask {\n        unit?: Unit;\n        format?: Format;\n        postEditingCategories?: string[];\n        taskId?: number;\n    }\n    interface TranslateAccuracySchema {\n        unit?: Unit;\n        format?: Format;\n        postEditingCategories?: string[];\n        languageId?: string;\n        userIds?: number[];\n        dateFrom?: string;\n        dateTo?: string;\n    }\n    interface CostEstimationPostEndingSchema {\n        unit?: Unit;\n        currency?: Currency;\n        format?: Format;\n        baseRates: BaseRate;\n        individualRates: IndividualRate[];\n        netRateSchemes: Omit<NetRateSchemas, 'mtMatch' | 'suggestionMatch'>;\n        calculateInternalMatches?: boolean;\n        includePreTranslatedStrings?: boolean;\n        languageId?: string;\n        fileIds?: number[];\n        directoryIds?: number[];\n        branchIds?: number[];\n        dateFrom?: string;\n        dateTo?: string;\n        labelIds?: number[];\n        labelIncludeType?: LabelIncludeType;\n        workflowStepId?: number;\n    }\n    interface CostEstimationPostEndingSchemaByTask {\n        unit?: Unit;\n        currency?: Currency;\n        format?: Format;\n        baseRates?: BaseRate;\n        individualRates?: IndividualRate[];\n        netRateSchemes?: Omit<NetRateSchemas, 'mtMatch' | 'suggestionMatch'>;\n        calculateInternalMatches?: boolean;\n        includePreTranslatedStrings?: boolean;\n        taskId?: number;\n    }\n    interface TranslationCostsPostEndingSchemaByTask {\n        unit?: Unit;\n        currency?: Currency;\n        format?: Format;\n        baseRates: BaseRate;\n        individualRates: IndividualRate[];\n        netRateSchemes: NetRateSchemas;\n        taskId?: number;\n        excludeApprovalsForEditedTranslations?: boolean;\n        preTranslatedStringsCategorizationAdjustment?: boolean;\n    }\n    interface TranslationCostsPostEndingSchema {\n        unit?: Unit;\n        currency?: Currency;\n        format?: Format;\n        baseRates: BaseRate;\n        individualRates: IndividualRate[];\n        netRateSchemes: NetRateSchemas;\n        excludeApprovalsForEditedTranslations?: boolean;\n        preTranslatedStringsCategorizationAdjustment?: boolean;\n        groupBy?: GroupBy;\n        dateFrom?: string;\n        dateTo?: string;\n        languageId?: string;\n        userIds?: number[];\n        fileIds?: number[];\n        directoryIds?: number[];\n        branchIds?: number[];\n        labelIds?: number;\n        labelIncludeType?: LabelIncludeType;\n        workflowStepId?: number;\n    }\n    interface TopMembersSchema {\n        unit?: Unit;\n        languageId?: string;\n        format?: Format;\n        dateFrom?: string;\n        dateTo?: string;\n    }\n    interface ContributionRawDataSchema {\n        mode: ContributionMode;\n        unit?: Unit;\n        languageId?: string;\n        userId?: string;\n        columns?: Column[];\n        fileIds?: number[];\n        directoryIds?: number[];\n        branchIds?: number[];\n        tmIds?: number[];\n        mtIds?: number[];\n        aiPromptIds?: number[];\n        dateFrom?: string;\n        dateTo?: string;\n    }\n    interface ContributionRawDataSchemaByTask {\n        mode: ContributionMode;\n        unit?: Unit;\n        taskId: number;\n        columns?: Column[];\n        tmIds?: number[];\n        mtIds?: number[];\n        aiPromptIds?: number[];\n        dateFrom?: string;\n        dateTo?: string;\n    }\n    interface PreTranslateEfficiencySchema {\n        unit?: Unit;\n        format?: Format;\n        postEditingCategories?: string[];\n        languageId?: string;\n        dateFrom?: string;\n        dateTo?: string;\n    }\n    interface ListOrganizationReportSettingsParams extends PaginationOptions {\n        projectId?: number;\n        groupId?: number;\n    }\n    interface ReportSettings {\n        id: number;\n        name: string;\n        currency: Currency;\n        unit: Unit;\n        config: ReportSettinsConfig;\n        isPublic: boolean;\n        isGlobal: boolean;\n        createdAt: string;\n        updatedAt: string;\n    }\n    interface AddReportSettingsRequest {\n        name: string;\n        currency: Currency;\n        unit: Unit;\n        config: ReportSettinsConfig;\n        isPublic?: boolean;\n        isGlobal?: boolean;\n    }\n    type UserReportSettings = Omit<ReportSettings, 'isPublic' | 'isGlobal'>;\n    type AddUserReportSettingsRequest = Omit<AddReportSettingsRequest, 'isPublic' | 'isGlobal'>;\n    type OrganizationReportSettings = Omit<ReportSettings, 'isGlobal'> & {\n        projectId: number;\n        groupId: number;\n    };\n    type AddOrganizationReportSettingsRequest = Omit<AddReportSettingsRequest, 'isGlobal'> & {\n        projectId?: number;\n        groupId?: number;\n    };\n    interface ReportSettinsConfig {\n        baseRates: BaseRate;\n        netRateSchemes: NetRateSchemas[];\n        individualRates: IndividualRate[];\n    }\n    type Unit = 'strings' | 'words' | 'chars' | 'chars_with_spaces';\n    type Currency = 'USD' | 'EUR' | 'JPY' | 'GBP' | 'AUD' | 'CAD' | 'CHF' | 'CNY' | 'SEK' | 'NZD' | 'MXN' | 'SGD' | 'HKD' | 'NOK' | 'KRW' | 'TRY' | 'RUB' | 'INR' | 'BRL' | 'ZAR' | 'GEL' | 'UAH';\n    type Format = 'xlsx' | 'csv' | 'json';\n    interface BaseRate {\n        fullTranslation: number;\n        proofread: number;\n    }\n    interface IndividualRate extends BaseRate {\n        languageIds: string[];\n        userIds: number[];\n        fullTranslation: number;\n        proofread: number;\n    }\n    interface NetRateSchemas {\n        tmMatch: {\n            matchType: Mode;\n            price: number;\n        }[];\n        mtMatch: {\n            matchType: Mode;\n            price: number;\n        }[];\n        suggestionMatch: {\n            matchType: Mode;\n            price: number;\n        }[];\n        aiMatch?: {\n            matchType: Mode;\n            price: number;\n        }[];\n    }\n    type Mode = 'no_match' | 'tm_match' | 'approval' | '99-95' | '94-90' | '89-80' | 'perfect' | '100';\n    type ContributionMode = 'translations' | 'approvals' | 'votes';\n    type GroupBy = 'user' | 'language';\n    type LabelIncludeType = 'strings_with_label' | 'strings_without_label';\n    type Column = 'userId' | 'languageId' | 'stringId' | 'translationId' | 'fileId' | 'filePath' | 'pluralForm' | 'sourceStringTextHash' | 'mtEngine' | 'mtId' | 'tmName' | 'tmId' | 'aiPromptName' | 'aiPromptId' | 'preTranslated' | 'tmMatch' | 'mtMatch' | 'aiMatch' | 'suggestionMatch' | 'sourceUnits' | 'targetUnits' | 'createdAt' | 'updatedAt' | 'mark';\n    interface SourceContentUpdatesSchema {\n        unit?: Unit;\n        format?: Format;\n        dateFrom?: string;\n        dateTo?: string;\n        languageId?: string;\n        userIds?: number[];\n        fileIds?: number[];\n        directoryIds?: number[];\n        branchIds?: number[];\n        labelIds?: number[];\n        labelIncludeType?: LabelIncludeType;\n    }\n    interface MembersSchema {\n        format?: Format;\n        dateFrom?: string;\n        dateTo?: string;\n    }\n    interface EditorIssuesSchema {\n        dateFrom?: string;\n        dateTo?: string;\n        format?: Format;\n        languageId?: string;\n        userId?: number;\n    }\n    interface ProjectQaCheckIssuesSchema {\n        format?: Format;\n        dateFrom?: string;\n        dateTo?: string;\n        languageId?: string;\n    }\n    interface SavingActivitySchema {\n        unit?: Unit;\n        languageId?: string;\n        format?: Format;\n        dateFrom?: string;\n        dateTo?: string;\n        userIds?: number[];\n        fileIds?: number[];\n        directoryIds?: number[];\n        branchIds?: number[];\n        labelIds?: number[];\n        labelIncludeType?: LabelIncludeType;\n    }\n    interface ProjectConsumptionSchema {\n        unit?: Unit;\n        languageId?: string;\n        format?: Format;\n        dateFrom?: string;\n        dateTo?: string;\n        userIds?: number[];\n        fileIds?: number[];\n        directoryIds?: number[];\n        branchIds?: number[];\n        labelIds?: number[];\n        labelIncludeType?: LabelIncludeType;\n    }\n    interface GroupTaskUsageSchema {\n        format: Format;\n        type: 'workload' | 'create-vs-resolve' | 'performance' | 'time' | 'cost';\n        projectIds?: number[];\n        assigneeId?: number;\n        creatorId?: number;\n        dateFrom?: string;\n        dateTo?: string;\n        wordsCountFrom?: number;\n        wordsCountTo?: number;\n        excludeApprovalsForEditedTranslations?: boolean;\n        currency?: Currency;\n        baseRates?: BaseRate;\n        individualRates?: IndividualRate[];\n        netRateSchemes?: NetRateSchemas;\n    }\n    interface GroupQaCheckIssuesSchema {\n        projectIds?: number[];\n        format?: Format;\n        dateFrom?: string;\n        dateTo?: string;\n        languageId?: string;\n    }\n    interface GroupTranslationActivitySchema {\n        projectIds?: number[];\n        unit?: Unit;\n        languageId?: string;\n        format?: Format;\n        dateFrom?: string;\n        dateTo?: string;\n        userIds?: number[];\n        fileIds?: number[];\n        directoryIds?: number[];\n        branchIds?: number[];\n        labelIds?: number[];\n        labelIncludeType?: LabelIncludeType;\n    }\n}\n```\n\n##### screenshots/index.d.ts\n\n```typescript\nimport { CrowdinApi, PaginationOptions, PatchRequest, ResponseList, ResponseObject } from '../core';\nexport declare class Screenshots extends CrowdinApi {\n    listScreenshots(projectId: number, options?: ScreenshotsModel.ListScreenshotParams): Promise<ResponseList<ScreenshotsModel.Screenshot>>;\n    listScreenshots(projectId: number, limit?: number, offset?: number): Promise<ResponseList<ScreenshotsModel.Screenshot>>;\n    addScreenshot(projectId: number, request: ScreenshotsModel.CreateScreenshotRequest): Promise<ResponseObject<ScreenshotsModel.Screenshot>>;\n    getScreenshot(projectId: number, screenshotId: number): Promise<ResponseObject<ScreenshotsModel.Screenshot>>;\n    updateScreenshot(projectId: number, screenshotId: number, request: ScreenshotsModel.UpdateScreenshotRequest): Promise<ResponseObject<ScreenshotsModel.Screenshot>>;\n    deleteScreenshot(projectId: number, screenshotId: number): Promise<void>;\n    editScreenshot(projectId: number, screenshotId: number, request: PatchRequest[]): Promise<ResponseObject<ScreenshotsModel.Screenshot>>;\n    listScreenshotTags(projectId: number, screenshotId: number, options?: PaginationOptions): Promise<ResponseList<ScreenshotsModel.Tag>>;\n    listScreenshotTags(projectId: number, screenshotId: number, limit?: number, offset?: number): Promise<ResponseList<ScreenshotsModel.Tag>>;\n    replaceTags(projectId: number, screenshotId: number, request: ScreenshotsModel.ReplaceTagRequest[] | ScreenshotsModel.AutoTagRequest): Promise<void>;\n    addTag(projectId: number, screenshotId: number, request: ScreenshotsModel.ReplaceTagRequest[]): Promise<ResponseObject<ScreenshotsModel.Tag>>;\n    clearTags(projectId: number, screenshotId: number): Promise<void>;\n    getTag(projectId: number, screenshotId: number, tagId: number): Promise<ResponseObject<ScreenshotsModel.Tag>>;\n    deleteTag(projectId: number, screenshotId: number, tagId: number): Promise<void>;\n    updateTag(projectId: number, screenshotId: number, tagId: number, request: PatchRequest[]): Promise<ResponseObject<ScreenshotsModel.Screenshot>>;\n}\nexport declare namespace ScreenshotsModel {\n    interface ListScreenshotParams extends PaginationOptions {\n        stringIds?: number[];\n        stringId?: number;\n        labelIds?: string;\n        excludeLabelIds?: string;\n        orderBy?: string;\n    }\n    interface Screenshot {\n        id: number;\n        userId: number;\n        url: string;\n        webUrl: string;\n        name: string;\n        size: Size;\n        tagsCount: number;\n        tags: Tag[];\n        labels: number[];\n        labelIds: number[];\n        createdAt: string;\n        updatedAt: string;\n    }\n    interface CreateScreenshotRequest {\n        storageId: number;\n        name: string;\n        autoTag?: boolean;\n        fileId?: number;\n        branchId?: number;\n        directoryId?: number;\n        labelIds?: number[];\n    }\n    interface UpdateScreenshotRequest {\n        storageId: number;\n        name: string;\n    }\n    interface Tag {\n        id: number;\n        screenshotId: number;\n        stringId: number;\n        position: Position;\n        createdAt: string;\n    }\n    interface ReplaceTagRequest {\n        stringId: number;\n        position?: Position;\n    }\n    interface AutoTagRequest {\n        autoTag: boolean;\n        fileId?: number;\n        branchId?: number;\n        directoryId?: number;\n    }\n    interface Size {\n        width: number;\n        height: number;\n    }\n    interface Position {\n        x: number;\n        y: number;\n        width: number;\n        height: number;\n    }\n}\n```\n\n##### securityLogs/index.d.ts\n\n```typescript\nimport { CrowdinApi, PaginationOptions, ResponseList, ResponseObject } from '../core';\nexport declare class SecurityLogs extends CrowdinApi {\n    listOrganizationSecurityLogs(options?: SecurityLogsModel.ListOrganizationSecurityLogsParams): Promise<ResponseList<SecurityLogsModel.SecurityLog>>;\n    getOrganizationSecurityLog(securityLogId: number): Promise<ResponseObject<SecurityLogsModel.SecurityLog>>;\n    listUserSecurityLogs(userId: number, options?: SecurityLogsModel.ListUserSecurityLogsParams): Promise<ResponseList<SecurityLogsModel.SecurityLog>>;\n    getUserSecurityLog(userId: number, securityLogId: number): Promise<ResponseObject<SecurityLogsModel.SecurityLog>>;\n}\nexport declare namespace SecurityLogsModel {\n    type Event = 'login' | 'password.set' | 'password.change' | 'email.change' | 'login.change' | 'personal_token.issued' | 'personal_token.revoked' | 'mfa.enabled' | 'mfa.disabled' | 'session.revoke' | 'session.revoke_all' | 'sso.connect' | 'sso.disconnect' | 'user.remove' | 'application.connected' | 'application.disconnected' | 'webauthn.created' | 'webauthn.deleted' | 'trusted_device.remove' | 'trusted_device.remove_all' | 'device_verification.enabled' | 'device_verification.disabled';\n    interface ListOrganizationSecurityLogsParams extends PaginationOptions {\n        event?: Event;\n        createdAfter?: string;\n        createdBefore?: string;\n        ipAddress?: string;\n        userId?: number;\n    }\n    type ListUserSecurityLogsParams = Omit<ListOrganizationSecurityLogsParams, 'userId'>;\n    interface SecurityLog {\n        id: number;\n        event: string;\n        info: string;\n        userId: number;\n        location: string;\n        ipAddress: string;\n        deviceName: string;\n        createdAt: string;\n    }\n}\n```\n\n##### sourceFiles/index.d.ts\n\n```typescript\nimport { CrowdinApi, DownloadLink, PaginationOptions, PatchRequest, ResponseList, ResponseObject, Status } from '../core';\nexport declare class SourceFiles extends CrowdinApi {\n    getClonedBranch(projectId: number, branchId: number, cloneId: string): Promise<ResponseObject<SourceFilesModel.Branch>>;\n    clonedBranch(projectId: number, branchId: number, request: SourceFilesModel.CloneBranchRequest): Promise<ResponseObject<Status<object>>>;\n    checkBranchClonedStatus(projectId: number, branchId: number, cloneId: string): Promise<ResponseObject<Status<object>>>;\n    listProjectBranches(projectId: number, options?: SourceFilesModel.ListProjectBranchesOptions): Promise<ResponseList<SourceFilesModel.Branch>>;\n    listProjectBranches(projectId: number, name?: string, limit?: number, offset?: number): Promise<ResponseList<SourceFilesModel.Branch>>;\n    createBranch(projectId: number, request: SourceFilesModel.CreateBranchRequest): Promise<ResponseObject<SourceFilesModel.Branch>>;\n    getBranch(projectId: number, branchId: number): Promise<ResponseObject<SourceFilesModel.Branch>>;\n    deleteBranch(projectId: number, branchId: number): Promise<void>;\n    editBranch(projectId: number, branchId: number, request: PatchRequest[]): Promise<ResponseObject<SourceFilesModel.Branch>>;\n    mergeBranch(projectId: number, branchId: number, request: SourceFilesModel.MergeBranchRequest): Promise<ResponseObject<Status<SourceFilesModel.MergeBranchAttributes>>>;\n    checkBranchMergeStatus(projectId: number, branchId: number, mergeId: string): Promise<ResponseObject<Status<SourceFilesModel.MergeBranchAttributes>>>;\n    getBranchMergeSummary(projectId: number, branchId: number, mergeId: string): Promise<ResponseObject<SourceFilesModel.MergeBranchSummary>>;\n    listProjectDirectories(projectId: number, options?: SourceFilesModel.ListProjectDirectoriesOptions): Promise<ResponseList<SourceFilesModel.Directory>>;\n    listProjectDirectories(projectId: number, branchId?: number, directoryId?: number, limit?: number, offset?: number, filter?: string, recursion?: string): Promise<ResponseList<SourceFilesModel.Directory>>;\n    createDirectory(projectId: number, request: SourceFilesModel.CreateDirectoryRequest): Promise<ResponseObject<SourceFilesModel.Directory>>;\n    getDirectory(projectId: number, directoryId: number): Promise<ResponseObject<SourceFilesModel.Directory>>;\n    deleteDirectory(projectId: number, directoryId: number): Promise<void>;\n    editDirectory(projectId: number, directoryId: number, request: PatchRequest[]): Promise<ResponseObject<SourceFilesModel.Directory>>;\n    listProjectFiles(projectId: number, options?: SourceFilesModel.ListProjectFilesOptions): Promise<ResponseList<SourceFilesModel.File>>;\n    listProjectFiles(projectId: number, branchId?: number, directoryId?: number, limit?: number, offset?: number, recursion?: any, filter?: string): Promise<ResponseList<SourceFilesModel.File>>;\n    createFile(projectId: number, request: SourceFilesModel.CreateFileRequest): Promise<ResponseObject<SourceFilesModel.File>>;\n    getFile(projectId: number, fileId: number): Promise<ResponseObject<SourceFilesModel.File>>;\n    updateOrRestoreFile(projectId: number, fileId: number, request: SourceFilesModel.ReplaceFileFromStorageRequest | SourceFilesModel.RestoreFile): Promise<ResponseObject<SourceFilesModel.File>>;\n    deleteFile(projectId: number, fileId: number): Promise<void>;\n    editFile(projectId: number, fileId: number, request: PatchRequest[]): Promise<ResponseObject<SourceFilesModel.File>>;\n    downloadFilePreview(projectId: number, fileId: number): Promise<ResponseObject<DownloadLink>>;\n    downloadFile(projectId: number, fileId: number): Promise<ResponseObject<DownloadLink>>;\n    listAssetReferences(projectId: number, fileId: number, options?: PaginationOptions): Promise<ResponseList<SourceFilesModel.AssetReference>>;\n    getAssetReference(projectId: number, fileId: number, referenceId: number): Promise<ResponseObject<SourceFilesModel.AssetReference>>;\n    addAssetReference(projectId: number, fileId: number, request: SourceFilesModel.AssetReferenceRequest): Promise<ResponseObject<SourceFilesModel.AssetReference>>;\n    deleteAssetReference(projectId: number, fileId: number, referenceId: number): Promise<void>;\n    listFileRevisions(projectId: number, fileId: number, options?: PaginationOptions): Promise<ResponseList<SourceFilesModel.FileRevision>>;\n    listFileRevisions(projectId: number, fileId: number, limit?: number, offset?: number): Promise<ResponseList<SourceFilesModel.FileRevision>>;\n    getFileRevision(projectId: number, fileId: number, revisionId: number): Promise<ResponseObject<SourceFilesModel.FileRevision>>;\n    listReviewedSourceFilesBuild(projectId: number, options?: SourceFilesModel.ListReviewedSourceFilesBuildOptions): Promise<ResponseList<SourceFilesModel.ReviewedSourceFilesBuild>>;\n    listReviewedSourceFilesBuild(projectId: number, branchId?: number, limit?: number, offset?: number): Promise<ResponseList<SourceFilesModel.ReviewedSourceFilesBuild>>;\n    buildReviewedSourceFiles(projectId: number, request?: SourceFilesModel.BuildReviewedSourceFilesRequest): Promise<ResponseObject<SourceFilesModel.ReviewedSourceFilesBuild>>;\n    checkReviewedSourceFilesBuildStatus(projectId: number, buildId: number): Promise<ResponseObject<SourceFilesModel.ReviewedSourceFilesBuild>>;\n    downloadReviewedSourceFiles(projectId: number, buildId: number): Promise<ResponseObject<DownloadLink>>;\n}\nexport declare namespace SourceFilesModel {\n    interface Branch {\n        id: number;\n        projectId: number;\n        name: string;\n        title: string;\n        exportPattern: string;\n        priority: Priority;\n        createdAt: string;\n        updatedAt: string;\n    }\n    interface CreateBranchRequest {\n        name: string;\n        title?: string;\n        exportPattern?: string;\n        priority?: Priority;\n    }\n    interface CloneBranchRequest {\n        name: string;\n        title?: string;\n    }\n    interface MergeBranchRequest {\n        deleteAfterMerge?: boolean;\n        sourceBranchId: number;\n        acceptSourceChanges?: boolean;\n        dryRun?: boolean;\n    }\n    interface MergeBranchAttributes {\n        sourceBranchId: number;\n        deleteAfterMerge: boolean;\n        acceptSourceChanges?: boolean;\n    }\n    interface MergeBranchSummary {\n        status: string;\n        sourceBranchId: number;\n        targetBranchId: number;\n        dryRun: boolean;\n        details: {\n            added: number;\n            deleted: number;\n            updated: number;\n            conflicted: number;\n        };\n    }\n    type Priority = 'low' | 'normal' | 'high';\n    interface ListProjectDirectoriesOptions extends PaginationOptions {\n        branchId?: number;\n        directoryId?: number;\n        filter?: string;\n        recursion?: string;\n        orderBy?: string;\n    }\n    interface Directory {\n        id: number;\n        projectId: number;\n        branchId: number;\n        directoryId: number;\n        name: string;\n        title: string;\n        exportPattern: string;\n        path: string;\n        priority: Priority;\n        createdAt: string;\n        updatedAt: string;\n    }\n    interface CreateDirectoryRequest {\n        name: string;\n        branchId?: number;\n        directoryId?: number;\n        title?: string;\n        exportPattern?: string;\n        priority?: Priority;\n    }\n    interface ListProjectFilesOptions extends PaginationOptions {\n        branchId?: number;\n        directoryId?: number;\n        recursion?: any;\n        filter?: string;\n        orderBy?: string;\n    }\n    interface File {\n        id: number;\n        projectId: number;\n        branchId: number;\n        directoryId: number;\n        name: string;\n        title: string;\n        context: string;\n        type: string;\n        path: string;\n        status: string;\n        revisionId: number;\n        priority: Priority;\n        importOptions: ImportOptions;\n        exportOptions: GeneralExportOptions | PropertyExportOptions;\n        excludedTargetLanguages: string[];\n        parserVersion: number;\n        createdAt: string;\n        updatedAt: string;\n        fields: Record<string, any>;\n    }\n    interface CreateFileRequest {\n        storageId: number;\n        name: string;\n        branchId?: number;\n        directoryId?: number;\n        title?: string;\n        context?: string;\n        type?: FileType;\n        parserVersion?: number;\n        importOptions?: ImportOptions;\n        exportOptions?: ExportOptions;\n        excludedTargetLanguages?: string[];\n        attachLabelIds?: number[];\n        fields?: Record<string, any>;\n    }\n    interface ReplaceFileFromStorageRequest {\n        storageId: number;\n        name?: string;\n        updateOption?: UpdateOption;\n        importOptions?: ImportOptions;\n        exportOptions?: ExportOptions;\n        attachLabelIds?: number[];\n        detachLabelIds?: number[];\n        replaceModifiedContext?: boolean;\n    }\n    type ExportOptions = GeneralExportOptions | PropertyExportOptions | JavaScriptExportOptions | MdExportOptions;\n    type ImportOptions = SpreadsheetImportOptions | XmlImportOptions | WebXmlImportOptions | DocxFileImportOptions | HtmlFileImportOptions | HtmlFrontMatterFileImportOptions | MdxFileImportOptions | MdFileImportOptions | StringCatalogFileImportOptions | AdocFileImportOptions | OtherImportOptions;\n    interface RestoreFile {\n        revisionId: number;\n    }\n    interface FileRevision {\n        id: number;\n        projectId: number;\n        fileId: number;\n        restoreToRevision: number;\n        info: FileRevisionInfo;\n        date: string;\n    }\n    interface FileRevisionInfo {\n        added: FileRevisionInfoAttribute;\n        deleted: FileRevisionInfoAttribute;\n        updated: FileRevisionInfoAttribute;\n    }\n    interface FileRevisionInfoAttribute {\n        strings: number;\n        words: number;\n    }\n    type FileType = 'auto' | 'android' | 'macosx' | 'resx' | 'properties' | 'gettext' | 'yaml' | 'php' | 'json' | 'xml' | 'ini' | 'rc' | 'resw' | 'resjson' | 'qtts' | 'joomla' | 'chrome' | 'dtd' | 'dklang' | 'flex' | 'nsh' | 'wxl' | 'xliff' | 'xliff_two' | 'html' | 'haml' | 'txt' | 'csv' | 'md' | 'flsnp' | 'fm_html' | 'fm_md' | 'mediawiki' | 'docx' | 'xlsx' | 'sbv' | 'properties_play' | 'properties_xml' | 'maxthon' | 'go_json' | 'dita' | 'mif' | 'idml' | 'stringsdict' | 'plist' | 'vtt' | 'vdf' | 'srt' | 'stf' | 'toml' | 'contentful_rt' | 'svg' | 'js' | 'coffee' | 'nestjs_i18n' | 'webxml';\n    interface SpreadsheetImportOptions {\n        firstLineContainsHeader?: boolean;\n        contentSegmentation?: boolean;\n        srxStorageId?: number;\n        importTranslations?: boolean;\n        scheme?: Scheme;\n    }\n    interface Scheme {\n        none: number;\n        identifier: number;\n        sourcePhrase: number;\n        sourceOrTranslation: number;\n        translation: number;\n        context: number;\n        maxLength: number;\n        labels: number;\n        [key: string]: number;\n    }\n    interface XmlImportOptions {\n        translateContent?: boolean;\n        translateAttributes?: boolean;\n        inlineTags?: string[];\n        contentSegmentation?: boolean;\n        translatableElements?: string[];\n        srxStorageId?: number;\n    }\n    interface WebXmlImportOptions {\n        inlineTags?: string[];\n        contentSegmentation?: boolean;\n        srxStorageId?: number;\n    }\n    interface DocxFileImportOptions {\n        cleanTagsAggressively?: boolean;\n        translateHiddenText?: boolean;\n        translateHyperlinkUrls?: boolean;\n        translateHiddenRowsAndColumns?: boolean;\n        importNotes?: boolean;\n        importHiddenSlides?: boolean;\n        contentSegmentation?: boolean;\n        srxStorageId?: number;\n    }\n    interface HtmlFileImportOptions {\n        excludedElements?: string[];\n        inlineTags?: string[];\n        contentSegmentation?: boolean;\n        srxStorageId?: number;\n    }\n    interface HtmlFrontMatterFileImportOptions extends HtmlFileImportOptions {\n        excludedFrontMatterElements?: string[];\n    }\n    interface MdxFileImportOptions {\n        excludedFrontMatterElements?: string[];\n        excludeCodeBlocks?: boolean;\n        contentSegmentation?: boolean;\n        srxStorageId?: number;\n    }\n    interface MdFileImportOptions {\n        excludedFrontMatterElements?: string[];\n        excludeCodeBlocks?: boolean;\n        inlineTags?: string[];\n        contentSegmentation?: boolean;\n        srxStorageId?: number;\n    }\n    interface StringCatalogFileImportOptions {\n        importKeyAsSource?: boolean;\n    }\n    interface AdocFileImportOptions {\n        excludeIncludeDirectives?: boolean;\n    }\n    interface OtherImportOptions {\n        contentSegmentation: boolean;\n        srxStorageId: number;\n    }\n    interface GeneralExportOptions {\n        exportPattern?: string;\n    }\n    interface PropertyExportOptions {\n        escapeQuotes?: EscapeQuotes;\n        exportPattern?: string;\n        escapeSpecialCharacters?: 0 | 1;\n    }\n    interface JavaScriptExportOptions {\n        exportPattern?: string;\n        exportQuotes?: ExportQuotes;\n    }\n    interface MdExportOptions {\n        exportPattern?: string;\n        strongMarker?: 'asterisk' | 'underscore';\n        emphasisMarker?: 'asterisk' | 'underscore';\n        unorderedListBullet?: 'asterisks' | 'plus' | 'plus';\n        tableColumnWidth?: 'consolidate' | 'evenly_distribute_cells';\n    }\n    enum EscapeQuotes {\n        ZERO = 0,\n        ONE = 1,\n        TWO = 2,\n        THREE = 3\n    }\n    enum ExportQuotes {\n        SINGLE = \"single\",\n        DOUBLE = \"double\"\n    }\n    type UpdateOption = 'clear_translations_and_approvals' | 'keep_translations' | 'keep_translations_and_approvals';\n    interface ReviewedSourceFilesBuild {\n        id: number;\n        projectId: number;\n        status: string;\n        progress: number;\n        attributes: ReviewedSourceFilesBuildAttributes;\n    }\n    interface ReviewedSourceFilesBuildAttributes {\n        branchId: number;\n        targetLanguageId: string;\n    }\n    interface BuildReviewedSourceFilesRequest {\n        branchId?: number;\n    }\n    interface ListProjectBranchesOptions extends PaginationOptions {\n        name?: string;\n        orderBy?: string;\n    }\n    interface ListReviewedSourceFilesBuildOptions extends PaginationOptions {\n        branchId?: number;\n    }\n    interface User {\n        id: number;\n        username: string;\n        fullName: string;\n        avatarUrl: string;\n    }\n    interface AssetReference {\n        id: number;\n        name: string;\n        user: User;\n        createdAt: string;\n        mimeType: string;\n    }\n    interface AssetReferenceRequest {\n        storageId: number;\n        name: string;\n    }\n}\n```\n\n##### sourceStrings/index.d.ts\n\n```typescript\nimport { BooleanInt, CrowdinApi, PaginationOptions, PatchRequest, ResponseList, ResponseObject, Status } from '../core';\nimport { SourceFilesModel } from '../sourceFiles';\nexport declare class SourceStrings extends CrowdinApi {\n    uploadStringsStatus(projectId: number, uploadId: string): Promise<ResponseObject<Status<SourceStringsModel.UploadStringsStatus>>>;\n    uploadStrings(projectId: number, request: SourceStringsModel.UploadStringsRequest): Promise<ResponseObject<Status<SourceStringsModel.UploadStringsStatus>>>;\n    listProjectStrings(projectId: number, options?: SourceStringsModel.ListProjectStringsOptions): Promise<ResponseList<SourceStringsModel.String>>;\n    listProjectStrings(projectId: number, fileId?: number, limit?: number, offset?: number, filter?: string, denormalizePlaceholders?: BooleanInt, labelIds?: string, scope?: SourceStringsModel.Scope, croql?: string, branchId?: number, directoryId?: number): Promise<ResponseList<SourceStringsModel.String>>;\n    addString(projectId: number, request: SourceStringsModel.CreateStringRequest | SourceStringsModel.CreateStringStringsBasedRequest): Promise<ResponseObject<SourceStringsModel.String>>;\n    stringBatchOperations(projectId: number, request: PatchRequest[]): Promise<ResponseList<SourceStringsModel.String>>;\n    getString(projectId: number, stringId: number, query?: {\n        denormalizePlaceholders: BooleanInt;\n    }): Promise<ResponseObject<SourceStringsModel.String>>;\n    deleteString(projectId: number, stringId: number): Promise<void>;\n    editString(projectId: number, stringId: number, request: PatchRequest[]): Promise<ResponseObject<SourceStringsModel.String>>;\n}\nexport declare namespace SourceStringsModel {\n    type UploadStringsType = 'auto' | 'android' | 'macosx' | 'arb' | 'csv' | 'json' | 'xliff' | 'xliff_two' | 'xlsx';\n    interface UploadStringsStatus {\n        branchId: number;\n        storageId: number;\n        fileType: UploadStringsType;\n        parserVersion: number;\n        labelIds: number[];\n        importOptions: {\n            firstLineContainsHeader: boolean;\n            importTranslations: boolean;\n            scheme: SourceFilesModel.Scheme;\n        };\n        updateStrings: boolean;\n        cleanupMode: boolean;\n        updateOption: UpdateOption;\n    }\n    interface UploadStringsRequest {\n        branchId: number;\n        storageId: number;\n        type?: UploadStringsType;\n        parserVersion?: number;\n        labelIds?: number[];\n        updateStrings?: boolean;\n        cleanupMode?: boolean;\n        importOptions?: {\n            firstLineContainsHeader: boolean;\n            importTranslations: boolean;\n            scheme: SourceFilesModel.Scheme;\n        };\n        updateOption?: UpdateOption;\n    }\n    interface ListProjectStringsOptions extends PaginationOptions {\n        orderBy?: string;\n        denormalizePlaceholders?: BooleanInt;\n        labelIds?: string;\n        fileId?: number;\n        branchId?: number;\n        directoryId?: number;\n        taskId?: number;\n        croql?: string;\n        filter?: string;\n        scope?: SourceStringsModel.Scope;\n    }\n    interface String {\n        id: number;\n        projectId: number;\n        branchId: number;\n        identifier: string;\n        text: string | PluralText;\n        type: Type;\n        context: string;\n        maxLength: number;\n        isHidden: boolean;\n        isDuplicate: boolean;\n        masterStringId: boolean;\n        hasPlurals: boolean;\n        isIcu: boolean;\n        labelIds: number[];\n        webUrl: string;\n        createdAt: string;\n        updatedAt: string;\n        fileId: number;\n        directoryId: number;\n        revision: number;\n        fields: Record<string, any>;\n    }\n    interface CreateStringRequest {\n        text: string | PluralText;\n        identifier?: string;\n        fileId: number;\n        context?: string;\n        isHidden?: boolean;\n        maxLength?: number;\n        labelIds?: number[];\n        fields?: Record<string, any>;\n    }\n    interface CreateStringStringsBasedRequest {\n        text: string | PluralText;\n        identifier: string;\n        branchId: number;\n        context?: string;\n        isHidden?: boolean;\n        maxLength?: number;\n        labelIds?: number[];\n        fields?: Record<string, any>;\n    }\n    interface PluralText {\n        zero?: string;\n        one?: string;\n        two?: string;\n        few?: string;\n        many?: string;\n        other?: string;\n    }\n    enum Type {\n        TEXT = 0,\n        ASSET = 1,\n        ICU = 2\n    }\n    type Scope = 'identifier' | 'text' | 'context';\n    type UpdateOption = 'clear_translations_and_approvals' | 'keep_translations' | 'keep_translations_and_approvals';\n}\n```\n\n##### stringComments/index.d.ts\n\n```typescript\nimport { CrowdinApi, PaginationOptions, PatchRequest, ResponseList, ResponseObject } from '../core';\nexport declare class StringComments extends CrowdinApi {\n    listStringComments(projectId: number, options?: StringCommentsModel.ListStringCommentsOptions): Promise<ResponseList<StringCommentsModel.StringComment>>;\n    listStringComments(projectId: number, stringId?: number, type?: StringCommentsModel.Type, targetLanguageId?: string, issueType?: StringCommentsModel.IssueType, issueStatus?: StringCommentsModel.IssueStatus): Promise<ResponseList<StringCommentsModel.StringComment>>;\n    addStringComment(projectId: number, request: StringCommentsModel.AddStringCommentRequest): Promise<ResponseObject<StringCommentsModel.StringComment>>;\n    getStringComment(projectId: number, stringCommentId: number): Promise<ResponseObject<StringCommentsModel.StringComment>>;\n    deleteStringComment(projectId: number, stringCommentId: number): Promise<void>;\n    editStringComment(projectId: number, stringCommentId: number, request: PatchRequest[]): Promise<ResponseObject<StringCommentsModel.StringComment>>;\n    stringCommentBatchOperations(projectId: number, request: PatchRequest[]): Promise<ResponseList<StringCommentsModel.StringComment>>;\n}\nexport declare namespace StringCommentsModel {\n    interface ListStringCommentsOptions extends PaginationOptions {\n        stringId?: number;\n        type?: Type;\n        targetLanguageId?: string;\n        issueType?: IssueType;\n        issueStatus?: IssueStatus;\n        orderBy?: string;\n    }\n    interface StringComment {\n        id: number;\n        isShared?: boolean;\n        text: string;\n        userId: number;\n        stringId: number;\n        user: User;\n        string: StringModel;\n        projectId: number;\n        languageId: string;\n        type: Type;\n        issueType: IssueType;\n        issueStatus: IssueStatus;\n        resolverId: number;\n        senderOrganization: {\n            id: number;\n            domain: string;\n        };\n        resolverOrganization: {\n            id: number;\n            domain: string;\n        };\n        resolver: User;\n        resolvedAt: string;\n        createdAt: string;\n    }\n    interface User {\n        id: number;\n        username: string;\n        fullName: string;\n        avatarUrl: string;\n    }\n    interface StringModel {\n        id: number;\n        text: string;\n        type: string;\n        hasPlurals: boolean;\n        isIcu: boolean;\n        context: string;\n        fileId: number;\n    }\n    interface AddStringCommentRequest {\n        stringId: number;\n        text: string;\n        targetLanguageId: string;\n        type: Type;\n        isShared?: boolean;\n        issueType?: IssueType;\n    }\n    type Type = 'comment' | 'issue';\n    type IssueType = 'general_question' | 'translation_mistake' | 'context_request' | 'source_mistake';\n    type IssueStatus = 'unresolved' | 'resolved';\n}\n```\n\n##### stringCorrections/index.d.ts\n\n```typescript\nimport { BooleanInt, CrowdinApi, PaginationOptions, ResponseList, ResponseObject } from '../core';\nexport declare class StringCorrections extends CrowdinApi {\n    listStringCorrections(projectId: number, options: StringCorrectionsModel.ListStringCorrectionsParams): Promise<ResponseList<StringCorrectionsModel.StringCorrection>>;\n    addStringCorrection(projectId: number, request: StringCorrectionsModel.AddStringCorrectionRequest): Promise<ResponseObject<StringCorrectionsModel.StringCorrection>>;\n    deleteStringCorrections(projectId: number, stringId: number): Promise<void>;\n    getStringCorrection(projectId: number, correctionId: number, params?: {\n        denormalizePlaceholders?: BooleanInt;\n    }): Promise<ResponseObject<StringCorrectionsModel.StringCorrection>>;\n    restoreStringCorrection(projectId: number, correctionId: number): Promise<ResponseObject<StringCorrectionsModel.StringCorrection>>;\n    deleteStringCorrection(projectId: number, correctionId: number): Promise<void>;\n}\nexport declare namespace StringCorrectionsModel {\n    interface ListStringCorrectionsParams extends PaginationOptions {\n        stringId: number;\n        orderBy?: string;\n        denormalizePlaceholders?: BooleanInt;\n    }\n    interface StringCorrection {\n        id: number;\n        text: string;\n        pluralCategoryName: PluralCategoryName;\n        user: {\n            id: number;\n            username: string;\n            fullName: string;\n            avatarUrl: string;\n        };\n        createdAt: string;\n    }\n    type PluralCategoryName = 'zero' | 'one' | 'two' | 'few' | 'many' | 'other';\n    interface AddStringCorrectionRequest {\n        stringId: number;\n        text: string;\n        pluralCategoryName?: PluralCategoryName;\n    }\n}\n```\n\n##### stringTranslations/index.d.ts\n\n```typescript\nimport { BooleanInt, CrowdinApi, PaginationOptions, PatchRequest, ResponseList, ResponseObject } from '../core';\nexport declare class StringTranslations extends CrowdinApi {\n    listTranslationApprovals(projectId: number, options?: StringTranslationsModel.ListTranslationApprovalsOptions): Promise<ResponseList<StringTranslationsModel.Approval>>;\n    listTranslationApprovals(projectId: number, stringId?: number, languageId?: string, translationId?: number, limit?: number, offset?: number, fileId?: number, labelIds?: string, excludeLabelIds?: string): Promise<ResponseList<StringTranslationsModel.Approval>>;\n    addApproval(projectId: number, request: StringTranslationsModel.AddApprovalRequest): Promise<ResponseObject<StringTranslationsModel.Approval>>;\n    removeStringApprovals(projectId: number, stringId: number): Promise<void>;\n    approvalInfo(projectId: number, approvalId: number): Promise<ResponseObject<StringTranslationsModel.Approval>>;\n    approvalBatchOperations(projectId: number, request: PatchRequest[]): Promise<ResponseList<StringTranslationsModel.Approval>>;\n    removeApproval(projectId: number, approvalId: number): Promise<void>;\n    listLanguageTranslations(projectId: number, languageId: string, options?: StringTranslationsModel.ListLanguageTranslationsOptions): Promise<ResponseList<StringTranslationsModel.PlainLanguageTranslation | StringTranslationsModel.PluralLanguageTranslation | StringTranslationsModel.IcuLanguageTranslation>>;\n    listLanguageTranslations(projectId: number, languageId: string, stringIds?: string, fileId?: number, limit?: number, offset?: number, labelIds?: string, denormalizePlaceholders?: BooleanInt, croql?: string): Promise<ResponseList<StringTranslationsModel.PlainLanguageTranslation | StringTranslationsModel.PluralLanguageTranslation | StringTranslationsModel.IcuLanguageTranslation>>;\n    translationAlignment(projectId: number, request: StringTranslationsModel.TranslationAlignmentRequest): Promise<ResponseObject<StringTranslationsModel.TranslationAlignmentResponse>>;\n    listStringTranslations(projectId: number, stringId: number, languageId: string, options?: StringTranslationsModel.ListStringTranslationsOptions): Promise<ResponseList<StringTranslationsModel.StringTranslation>>;\n    listStringTranslations(projectId: number, stringId: number, languageId: string, limit?: number, offset?: number, denormalizePlaceholders?: BooleanInt): Promise<ResponseList<StringTranslationsModel.StringTranslation>>;\n    addTranslation(projectId: number, request: StringTranslationsModel.AddStringTranslationRequest): Promise<ResponseObject<StringTranslationsModel.StringTranslation>>;\n    deleteAllTranslations(projectId: number, stringId: number, languageId?: string): Promise<void>;\n    translationInfo(projectId: number, translationId: number): Promise<ResponseObject<StringTranslationsModel.StringTranslation>>;\n    restoreTranslation(projectId: number, translationId: number): Promise<ResponseObject<StringTranslationsModel.StringTranslation>>;\n    translationBatchOperations(projectId: number, request: PatchRequest[]): Promise<ResponseList<StringTranslationsModel.StringTranslation>>;\n    deleteTranslation(projectId: number, translationId: number): Promise<void>;\n    listTranslationVotes(projectId: number, options?: StringTranslationsModel.ListTranslationVotesOptions): Promise<ResponseList<StringTranslationsModel.Vote>>;\n    listTranslationVotes(projectId: number, stringId?: number, languageId?: string, translationId?: number, labelIds?: string, excludeLabelIds?: string, limit?: number, offset?: number): Promise<ResponseList<StringTranslationsModel.Vote>>;\n    addVote(projectId: number, request: StringTranslationsModel.AddVoteRequest): Promise<ResponseObject<StringTranslationsModel.Vote>>;\n    voteInfo(projectId: number, voteId: number): Promise<ResponseObject<StringTranslationsModel.Vote>>;\n    cancelVote(projectId: number, voteId: number): Promise<void>;\n}\nexport declare namespace StringTranslationsModel {\n    interface ListTranslationApprovalsOptions extends PaginationOptions {\n        stringId?: number;\n        languageId?: string;\n        translationId?: number;\n        fileId?: number;\n        labelIds?: string;\n        excludeLabelIds?: string;\n        orderBy?: string;\n    }\n    interface Approval {\n        id: number;\n        user: User;\n        translationId: number;\n        stringId: number;\n        languageId: string;\n        createdAt: string;\n    }\n    interface AddApprovalRequest {\n        translationId: number;\n    }\n    interface StringTranslation {\n        id: number;\n        text: string;\n        pluralCategoryName: PluralCategoryName;\n        user: User;\n        rating: number;\n        provider: string;\n        isPreTranslated: boolean;\n        createdAt: string;\n    }\n    interface ListLanguageTranslationsOptions extends PaginationOptions {\n        stringIds?: string;\n        fileId?: number;\n        labelIds?: string;\n        denormalizePlaceholders?: BooleanInt;\n        croql?: string;\n        approvedOnly?: BooleanInt;\n        passedWorkflow?: BooleanInt;\n        orderBy?: string;\n        branchId?: number;\n        minApprovalCount?: number;\n        directoryId?: number;\n    }\n    interface PlainLanguageTranslation {\n        stringId: number;\n        contentType: string;\n        translationId: number;\n        text: string;\n        user: User;\n        createdAt: string;\n    }\n    interface PluralLanguageTranslation {\n        stringId: number;\n        contentType: string;\n        plurals: Plural[];\n    }\n    interface IcuLanguageTranslation {\n        stringId: number;\n        contentType: string;\n        translationId: number;\n        text: string;\n        user: User;\n        createdAt: string;\n    }\n    interface Plural {\n        translationId: number;\n        text: string;\n        pluralForm: string;\n        user: User;\n        createdAt: string;\n    }\n    interface TranslationAlignmentRequest {\n        sourceLanguageId: string;\n        targetLanguageId: string;\n        text: string;\n    }\n    interface TranslationAlignmentResponse {\n        words: {\n            text: string;\n            alignments: {\n                sourceWord: string;\n                sourceLemma: string;\n                targetWord: string;\n                targetLemma: string;\n                match: number;\n                probability: number;\n            }[];\n        }[];\n    }\n    interface AddStringTranslationRequest {\n        stringId: number;\n        languageId: string;\n        text: string;\n        pluralCategoryName?: PluralCategoryName;\n        addToTm?: boolean;\n    }\n    interface ListTranslationVotesOptions extends PaginationOptions {\n        stringId?: number;\n        languageId?: string;\n        translationId?: number;\n        fileId?: number;\n        labelIds?: string;\n        excludeLabelIds?: string;\n    }\n    interface Vote {\n        id: number;\n        user: User;\n        translationId: number;\n        votedAt: string;\n        mark: Mark;\n    }\n    interface AddVoteRequest {\n        mark: Mark;\n        translationId: number;\n    }\n    interface User {\n        id: number;\n        username: string;\n        fullName: string;\n        avatarUrl: string;\n    }\n    type Mark = 'up' | 'down';\n    interface ListStringTranslationsOptions extends PaginationOptions {\n        denormalizePlaceholders?: BooleanInt;\n        orderBy?: string;\n    }\n    type PluralCategoryName = 'zero' | 'one' | 'two' | 'few' | 'many' | 'other';\n}\n```\n\n##### tasks/index.d.ts\n\n```typescript\nimport { BooleanInt, CrowdinApi, DownloadLink, PaginationOptions, PatchRequest, ResponseList, ResponseObject } from '../core';\nimport { LanguagesModel } from '../languages';\nexport declare class Tasks extends CrowdinApi {\n    listTasks(projectId: number, options?: TasksModel.ListTasksOptions): Promise<ResponseList<TasksModel.Task>>;\n    listTasks(projectId: number, limit?: number, offset?: number, status?: TasksModel.Status): Promise<ResponseList<TasksModel.Task>>;\n    addTask(projectId: number, request: TasksModel.CreateTaskRequest): Promise<ResponseObject<TasksModel.Task>>;\n    exportTaskStrings(projectId: number, taskId: number): Promise<ResponseObject<DownloadLink>>;\n    getTask(projectId: number, taskId: number): Promise<ResponseObject<TasksModel.Task>>;\n    deleteTask(projectId: number, taskId: number): Promise<void>;\n    editTask(projectId: number, taskId: number, request: PatchRequest[]): Promise<ResponseObject<TasksModel.Task>>;\n    listTasksComments(projectId: number, taskId: number, options?: PaginationOptions): Promise<ResponseList<TasksModel.TaskComment>>;\n    addTaskComment(projectId: number, taskId: number, request: TasksModel.CreateTaskCommentRequest): Promise<ResponseObject<TasksModel.TaskComment>>;\n    getTaskComment(projectId: number, taskId: number, commentId: number): Promise<ResponseObject<TasksModel.TaskComment>>;\n    deleteTaskComment(projectId: number, taskId: number, commentId: number): Promise<void>;\n    editTaskComment(projectId: number, taskId: number, commentId: number, request: PatchRequest[]): Promise<ResponseObject<TasksModel.TaskComment>>;\n    listUserTasks(options?: TasksModel.ListUserTasksOptions): Promise<ResponseList<TasksModel.UserTask>>;\n    listUserTasks(limit?: number, offset?: number, status?: TasksModel.Status, isArchived?: BooleanInt): Promise<ResponseList<TasksModel.UserTask>>;\n    editTaskArchivedStatus(projectId: number, taskId: number, request: PatchRequest[]): Promise<ResponseObject<TasksModel.UserTask>>;\n    listTaskSettingsTemplates(projectId: number, options?: PaginationOptions): Promise<ResponseList<TasksModel.TaskSettingsTemplate>>;\n    addTaskSettingsTemplate(projectId: number, request: TasksModel.AddTaskSettingsTemplate): Promise<ResponseObject<TasksModel.TaskSettingsTemplate>>;\n    getTaskSettingsTemplate(projectId: number, taskSettingsId: number): Promise<ResponseObject<TasksModel.TaskSettingsTemplate>>;\n    deleteTaskSettingsTemplate(projectId: number, taskSettingsId: number): Promise<void>;\n    editTaskSettingsTemplate(projectId: number, taskSettingsId: number, request: PatchRequest[]): Promise<ResponseObject<TasksModel.TaskSettingsTemplate>>;\n}\nexport declare namespace TasksModel {\n    interface Task {\n        id: number;\n        projectId: number;\n        creatorId: number;\n        type: Type | TypeVendor;\n        status: Status;\n        title: string;\n        assignees: Assignee[];\n        assignedTeams: AssignedTeam[];\n        progress: Progress;\n        translateProgress: Progress;\n        sourceLanguageId: string;\n        targetLanguageId: string;\n        description: string;\n        translationUrl: string;\n        webUrl: string;\n        wordsCount: number;\n        commentsCount: number;\n        deadline: string;\n        startedAt: string;\n        resolvedAt: string;\n        timeRange: string;\n        workflowStepId: number;\n        buyUrl: string;\n        createdAt: string;\n        updatedAt: string;\n        sourceLanguage: LanguagesModel.Language;\n        targetLanguages: LanguagesModel.Language[];\n        labelIds: number[];\n        excludeLabelIds: number[];\n        precedingTaskId: number;\n        filesCount: number;\n        fileIds: number[];\n        branchIds: number[];\n        vendor: string;\n        fields: Record<string, any>;\n    }\n    interface ListUserTasksOptions extends PaginationOptions {\n        status?: Status;\n        isArchived?: BooleanInt;\n        orderBy?: string;\n    }\n    interface UserTask extends Task {\n        isArchived: boolean;\n    }\n    type CreateTaskRequest = CreateTaskEnterpriseByBranchIds | CreateTaskEnterpriseByFileIds | CreateTaskEnterpriseByStringIds | CreateTaskEnterpriseVendorByBranchIds | CreateTaskEnterpriseVendorByFileIds | CreateTaskEnterpriseVendorByStringIds | CreateTaskEnterprisePendingTask | CreateTaskByFileIds | CreateTaskByStringIds | CreateTaskByBranchIds | CreateTaskByFileIdsLanguageService | CreateTaskByStringIdsLanguageService | CreateTaskByBranchIdsLanguageService | CreateTaskVendorOhtByFileIds | CreateTaskVendorOhtByStringIds | CreateTaskVendorOhtByBranchIds | CreateTaskVendorGengoByFileIds | CreateTaskVendorGengoByStringIds | CreateTaskVendorGengoByBranchIds | CreateTaskVendorManualByFileIds | CreateTaskVendorManualByStringIds | CreateTaskVendorManualByBranchIds | CreateTaskPendingTask | CreateTaskPendingTaskLanguageService | CreateTaskPendingTaskVendorManual;\n    interface CreateTaskEnterpriseByBranchIds {\n        type: Type;\n        workflowStepId: number;\n        title: string;\n        languageId: string;\n        branchIds: number[];\n        labelIds?: number[];\n        excludeLabelIds?: number[];\n        status?: RequestStatus;\n        description?: string;\n        splitContent?: boolean;\n        skipAssignedStrings?: boolean;\n        assignees?: CreateTaskAssignee[];\n        assignedTeams?: AssignedTeam[];\n        includePreTranslatedStringsOnly?: boolean;\n        deadline?: string;\n        startedAt?: string;\n        dateFrom?: string;\n        dateTo?: string;\n        fields?: Record<string, any>;\n    }\n    interface CreateTaskEnterpriseByStringIds {\n        type: Type;\n        workflowStepId: number;\n        title: string;\n        languageId: string;\n        stringIds: number[];\n        status?: RequestStatus;\n        description?: string;\n        splitContent?: boolean;\n        skipAssignedStrings?: boolean;\n        assignees?: CreateTaskAssignee[];\n        assignedTeams?: AssignedTeam[];\n        includePreTranslatedStringsOnly?: boolean;\n        deadline?: string;\n        startedAt?: string;\n        dateFrom?: string;\n        dateTo?: string;\n        fields?: Record<string, any>;\n    }\n    type CreateTaskEnterpriseVendorByStringIds = Omit<CreateTaskEnterpriseByStringIds, 'type' | 'status' | 'splitContent' | 'assignees' | 'assignedTeams'>;\n    type CreateTaskEnterpriseVendorByBranchIds = Omit<CreateTaskEnterpriseByBranchIds, 'type' | 'status' | 'splitContent' | 'assignees' | 'assignedTeams'>;\n    type CreateTaskEnterpriseByFileIds = Omit<CreateTaskEnterpriseByBranchIds, 'branchIds'> & {\n        fileIds: number[];\n    };\n    type CreateTaskEnterpriseVendorByFileIds = Omit<CreateTaskEnterpriseByFileIds, 'type' | 'status' | 'splitContent' | 'assignees' | 'assignedTeams'>;\n    interface CreateTaskEnterprisePendingTask {\n        precedingTaskId: number;\n        type: Type.PROOFREAD;\n        title: string;\n        description?: string;\n        assignees?: CreateTaskAssignee[];\n        assignedTeams?: AssignedTeam[];\n        deadline?: string;\n    }\n    interface CreateTaskByFileIds {\n        title: string;\n        languageId: string;\n        type: Type;\n        fileIds: number[];\n        labelIds?: number[];\n        excludeLabelIds?: number[];\n        status?: RequestStatus;\n        description?: string;\n        splitContent?: boolean;\n        skipAssignedStrings?: boolean;\n        includePreTranslatedStringsOnly?: boolean;\n        assignees?: CreateTaskAssignee[];\n        deadline?: string;\n        startedAt?: string;\n        dateFrom?: string;\n        dateTo?: string;\n    }\n    type CreateTaskByStringIds = Omit<CreateTaskByFileIds, 'fileIds' | 'labelIds' | 'excludeLabelIds'> & {\n        stringIds: number;\n    };\n    type CreateTaskByBranchIds = Omit<CreateTaskByFileIds, 'fileIds'> & {\n        branchIds: number;\n    };\n    interface CreateTaskByFileIdsLanguageService {\n        title: string;\n        languageId: string;\n        type: TypeVendor;\n        vendor: 'crowdin_language_service';\n        fileIds: number[];\n        labelIds?: number[];\n        excludeLabelIds?: number[];\n        status?: RequestStatus;\n        description?: string;\n        includePreTranslatedStringsOnly?: boolean;\n        assignees?: CreateTaskAssignee[];\n        dateFrom?: string;\n        dateTo?: string;\n    }\n    type CreateTaskByStringIdsLanguageService = Omit<CreateTaskByFileIdsLanguageService, 'fileIds' | 'labelIds' | 'excludeLabelIds'> & {\n        stringIds: number[];\n    };\n    type CreateTaskByBranchIdsLanguageService = Omit<CreateTaskByFileIdsLanguageService, 'fileIds'> & {\n        branchIds: number[];\n    };\n    interface CreateTaskVendorOhtByFileIds {\n        title: string;\n        languageId: string;\n        type: TypeVendor;\n        vendor: 'oht';\n        fileIds: number[];\n        labelIds?: number[];\n        excludeLabelIds?: number[];\n        status?: RequestStatus;\n        description?: string;\n        expertise?: Expertise;\n        editService?: boolean;\n        includePreTranslatedStringsOnly?: boolean;\n        dateFrom?: string;\n        dateTo?: string;\n    }\n    type CreateTaskVendorOhtByStringIds = Omit<CreateTaskVendorOhtByFileIds, 'fileIds' | 'labelIds' | 'excludeLabelIds'> & {\n        stringIds: number[];\n    };\n    type CreateTaskVendorOhtByBranchIds = Omit<CreateTaskVendorOhtByFileIds, 'fileIds'> & {\n        branchIds: number[];\n    };\n    interface CreateTaskVendorGengoByFileIds {\n        title: string;\n        languageId: string;\n        type: TypeVendor.TRANSLATE_BY_VENDOR;\n        vendor: 'gengo';\n        fileIds: number[];\n        labelIds?: number[];\n        excludeLabelIds?: number[];\n        status?: RequestStatus;\n        description?: string;\n        expertise?: 'standard' | 'pro';\n        tone?: Tone;\n        purpose?: Purpose;\n        customerMessage?: string;\n        usePreferred?: boolean;\n        editService?: boolean;\n        dateFrom?: string;\n        dateTo?: string;\n    }\n    type CreateTaskVendorGengoByStringIds = Omit<CreateTaskVendorGengoByFileIds, 'fileIds' | 'labelIds' | 'excludeLabelIds'> & {\n        stringIds: number[];\n    };\n    type CreateTaskVendorGengoByBranchIds = Omit<CreateTaskVendorGengoByFileIds, 'fileIds'> & {\n        branchIds: number[];\n    };\n    interface CreateTaskVendorManualByFileIds {\n        title: string;\n        languageId: string;\n        type: TypeVendor;\n        vendor: 'alconost' | 'babbleon' | 'tomedes' | 'e2f' | 'write_path_admin' | 'inlingo' | 'acclaro' | 'translate_by_humans' | 'lingo24' | 'assertio_language_services' | 'gte_localize' | 'kettu_solutions' | 'languageline_solutions';\n        fileIds: number[];\n        labelIds?: number[];\n        excludeLabelIds?: number[];\n        status?: RequestStatus;\n        description?: string;\n        skipAssignedStrings?: boolean;\n        includePreTranslatedStringsOnly?: boolean;\n        assignees?: CreateTaskAssignee[];\n        deadline?: string;\n        startedAt?: string;\n        dateFrom?: string;\n        dateTo?: string;\n    }\n    type CreateTaskVendorManualByStringIds = Omit<CreateTaskVendorManualByFileIds, 'fileIds' | 'labelIds' | 'excludeLabelIds'> & {\n        stringIds: number[];\n    };\n    type CreateTaskVendorManualByBranchIds = Omit<CreateTaskVendorManualByFileIds, 'fileIds'> & {\n        branchIds: number[];\n    };\n    interface CreateTaskPendingTask {\n        precedingTaskId: number;\n        type: Type.PROOFREAD;\n        title: string;\n        description?: string;\n        assignees?: CreateTaskAssignee[];\n        deadline?: string;\n    }\n    interface CreateTaskPendingTaskLanguageService {\n        precedingTaskId: number;\n        type: TypeVendor.PROOFREAD_BY_VENDOR;\n        vendor: 'crowdin_language_service';\n        title: string;\n        description?: string;\n        deadline?: string;\n    }\n    interface CreateTaskPendingTaskVendorManual {\n        precedingTaskId: number;\n        type: TypeVendor.PROOFREAD_BY_VENDOR;\n        vendor: CreateTaskVendorManualByFileIds['vendor'];\n        title: string;\n        description?: string;\n        deadline?: string;\n    }\n    interface CreateTaskAssignee {\n        id: number;\n        wordsCount?: number;\n    }\n    type Status = 'todo' | 'in_progress' | 'done' | 'closed';\n    type RequestStatus = Extract<Status, 'todo' | 'in_progress'>;\n    enum Type {\n        TRANSLATE = 0,\n        PROOFREAD = 1\n    }\n    enum TypeVendor {\n        TRANSLATE_BY_VENDOR = 2,\n        PROOFREAD_BY_VENDOR = 3\n    }\n    interface Assignee {\n        id: number;\n        username: string;\n        fullName: string;\n        avatarUrl: string;\n        wordsCount: number;\n        wordsLeft: number;\n    }\n    interface AssignedTeam {\n        id: number;\n        wordsCount: number;\n    }\n    interface Progress {\n        total: number;\n        done: number;\n        percent: number;\n    }\n    type Expertise = 'standard' | 'mobile-applications' | 'software-it' | 'gaming-video-games' | 'technical-engineering' | 'marketing-consumer-media' | 'business-finance' | 'legal-certificate' | 'medical' | 'ad-words-banners' | 'automotive-aerospace' | 'scientific' | 'scientific-academic' | 'tourism' | 'training-employee-handbooks' | 'forex-crypto';\n    enum TranslatedExpertise {\n        ECONOMY = \"P\",\n        PROFESSIONAL = \"T\",\n        PREMIUM = \"R\"\n    }\n    type Tone = '' | 'Informal' | 'Friendly' | 'Business' | 'Formal' | 'other';\n    type Purpose = 'standard' | 'Personal use' | 'Business' | 'Online content' | 'App/Web localization' | 'Media content' | 'Semi-technical' | 'other';\n    type Subject = 'general' | 'accounting_finance' | 'aerospace_defence' | 'architecture' | 'art' | 'automotive' | 'certificates_diplomas_licences_cv_etc' | 'chemical' | 'civil_engineering_construction' | 'corporate_social_responsibility' | 'cosmetics' | 'culinary' | 'electronics_electrical_engineering' | 'energy_power_generation_oil_gas' | 'environment' | 'fashion' | 'games_viseogames_casino' | 'general_business_commerce' | 'history_archaeology' | 'information_technology' | 'insurance' | 'internet_e-commerce' | 'legal_documents_contracts' | 'literary_translations' | 'marketing_advertising_material_public_relations' | 'matematics_and_physics' | 'mechanical_manufacturing' | 'media_journalism_publishing' | 'medical_pharmaceutical' | 'music' | 'private_correspondence_letters' | 'religion' | 'science' | 'shipping_sailing_maritime' | 'social_science' | 'telecommunications' | 'travel_tourism';\n    interface ListTasksOptions extends PaginationOptions {\n        status?: TasksModel.Status;\n        assigneeId?: number;\n        orderBy?: string;\n    }\n    interface TaskSettingsTemplate {\n        id: number;\n        name: string;\n        config: TaskSettingsTemplateConfig;\n        createdAt: string;\n        updatedAt: string;\n    }\n    interface AddTaskSettingsTemplate {\n        name: string;\n        config: TaskSettingsTemplateConfig;\n    }\n    interface TaskSettingsTemplateConfig {\n        languages: {\n            languageId?: string;\n            userIds?: number[];\n            teamIds?: number[];\n        }[];\n    }\n    interface TaskComment {\n        id: number;\n        userId: number;\n        taskId: number;\n        text: string;\n        timeSpent: number;\n        createdAt: string;\n        updatedAt: string;\n    }\n    interface CreateTaskCommentRequest {\n        text?: string;\n        timeSpent?: number;\n    }\n}\n```\n\n##### teams/index.d.ts\n\n```typescript\nimport { CrowdinApi, Pagination, PaginationOptions, PatchRequest, ProjectRole, ProjectRoles, ResponseList, ResponseObject } from '../core';\nimport { ProjectsGroupsModel } from '../projectsGroups';\nexport declare class Teams extends CrowdinApi {\n    listGroupTeams(groupId: number, options?: TeamsModel.ListGroupTeamsOptions): Promise<ResponseList<TeamsModel.TeamGroup>>;\n    updateGroupTeams(groupId: number, request: PatchRequest[]): Promise<ResponseList<TeamsModel.TeamGroup>>;\n    getGroupTeam(groupId: number, teamId: number): Promise<ResponseObject<TeamsModel.TeamGroup>>;\n    listTeamProjectPermissions(teamId: number, options?: PaginationOptions): Promise<ResponseList<TeamsModel.ProjectPermissions>>;\n    editTeamProjectPermissions(teamId: number, request: PatchRequest[]): Promise<ResponseList<TeamsModel.ProjectPermissions>>;\n    addTeamToProject(projectId: number, request: TeamsModel.AddTeamToProjectRequest): Promise<TeamsModel.ProjectTeamResources>;\n    listTeams(options?: TeamsModel.ListTeamsOptions): Promise<ResponseList<TeamsModel.Team>>;\n    listTeams(limit?: number, offset?: number): Promise<ResponseList<TeamsModel.Team>>;\n    addTeam(request: TeamsModel.AddTeamRequest): Promise<ResponseObject<TeamsModel.Team>>;\n    getTeam(teamId: number): Promise<ResponseObject<TeamsModel.Team>>;\n    deleteTeam(teamId: number): Promise<void>;\n    editTeam(teamId: number, request: PatchRequest[]): Promise<ResponseObject<TeamsModel.Team>>;\n    teamMembersList(teamId: number, options?: PaginationOptions): Promise<ResponseList<TeamsModel.TeamMember>>;\n    teamMembersList(teamId: number, limit?: number, offset?: number): Promise<ResponseList<TeamsModel.TeamMember>>;\n    addTeamMembers(teamId: number, request: TeamsModel.AddTeamMembersRequest): Promise<TeamsModel.AddTeamMembersResponse>;\n    deleteAllTeamMembers(teamId: number): Promise<void>;\n    deleteTeamMember(teamId: number, memberId: number): Promise<void>;\n}\nexport declare namespace TeamsModel {\n    interface ListGroupTeamsOptions extends PaginationOptions {\n        orderBy?: string;\n    }\n    interface ProjectPermissions {\n        id: number;\n        roles: ProjectRole[];\n        project: ProjectsGroupsModel.Project | ProjectsGroupsModel.ProjectSettings;\n    }\n    interface AddTeamToProjectRequest {\n        teamId: number;\n        managerAccess?: boolean;\n        developerAccess?: boolean;\n        roles?: ProjectRole[];\n        accessToAllWorkflowSteps?: boolean;\n        permissions?: Permissions;\n    }\n    interface ListTeamsOptions extends PaginationOptions {\n        search?: string;\n        projectIds?: string;\n        projectRoles?: ProjectRoles[];\n        languageIds?: string;\n        groupIds?: string;\n        orderBy?: string;\n    }\n    interface ProjectTeamResources {\n        skipped: ProjectTeamResource;\n        added: ProjectTeamResource;\n    }\n    interface ProjectTeamResource {\n        id: number;\n        hasManagerAccess: boolean;\n        hasDeveloperAccess: boolean;\n        hasAccessToAllWorkflowSteps: boolean;\n        permissions: Permissions;\n        roles: ProjectRole[];\n    }\n    interface Permissions {\n        [lang: string]: {\n            workflowStepIds: number[] | 'all';\n        };\n    }\n    interface Team {\n        id: number;\n        name: string;\n        totalMembers: number;\n        webUrl: string;\n        createdAt: string;\n        updatedAt: string;\n    }\n    interface TeamGroup {\n        id: number;\n        team: Team;\n    }\n    interface AddTeamRequest {\n        name: string;\n    }\n    interface TeamMember {\n        id: number;\n        username: string;\n        firstName: string;\n        lastName: string;\n        avatarUrl: string;\n        addedAt: string;\n    }\n    interface AddTeamMembersRequest {\n        userIds: number[];\n    }\n    interface AddTeamMembersResponse {\n        skipped: ResponseObject<TeamMember>[];\n        added: ResponseObject<TeamMember>[];\n        pagination: Pagination;\n    }\n}\n```\n\n##### translationMemory/index.d.ts\n\n```typescript\nimport { CrowdinApi, DownloadLink, PaginationOptions, PatchRequest, ResponseList, ResponseObject, Status } from '../core';\nexport declare class TranslationMemory extends CrowdinApi {\n    listTm(options?: TranslationMemoryModel.ListTMsOptions): Promise<ResponseList<TranslationMemoryModel.TranslationMemory>>;\n    listTm(groupId?: number, limit?: number, offset?: number): Promise<ResponseList<TranslationMemoryModel.TranslationMemory>>;\n    addTm(request: TranslationMemoryModel.AddTranslationMemoryRequest): Promise<ResponseObject<TranslationMemoryModel.TranslationMemory>>;\n    getTm(tmId: number): Promise<ResponseObject<TranslationMemoryModel.TranslationMemory>>;\n    deleteTm(tmId: number): Promise<void>;\n    editTm(tmId: number, request: PatchRequest[]): Promise<ResponseObject<TranslationMemoryModel.TranslationMemory>>;\n    listTmSegments(tmId: number, options?: TranslationMemoryModel.ListSegmentsOptions): Promise<ResponseList<TranslationMemoryModel.TMSegment>>;\n    addTmSegment(tmId: number, request: TranslationMemoryModel.AddTMSegment): Promise<ResponseObject<TranslationMemoryModel.TMSegment>>;\n    clearTm(tmId: number): Promise<void>;\n    exportTm(tmId: number, request?: TranslationMemoryModel.ExportTranslationMemoryRequest): Promise<ResponseObject<Status<TranslationMemoryModel.ExportTranslationMemoryAttribute>>>;\n    checkExportStatus(tmId: number, exportId: string): Promise<ResponseObject<Status<TranslationMemoryModel.ExportTranslationMemoryAttribute>>>;\n    downloadTm(tmId: number, exportId: string): Promise<ResponseObject<DownloadLink>>;\n    concordanceSearch(projectId: number, request: TranslationMemoryModel.ConcordanceSearchRequest): Promise<ResponseList<TranslationMemoryModel.ConcordanceSearchResponse>>;\n    importTm(tmId: number, request: TranslationMemoryModel.ImportTranslationMemoryRequest): Promise<ResponseObject<Status<TranslationMemoryModel.ImportTranslationMemoryAttribute>>>;\n    checkImportStatus(tmId: number, importId: string): Promise<ResponseObject<Status<TranslationMemoryModel.ImportTranslationMemoryAttribute>>>;\n    getTmSegment(tmId: number, segmentId: number): Promise<ResponseObject<TranslationMemoryModel.TMSegment>>;\n    deleteTmSegment(tmId: number, segmentId: number): Promise<void>;\n    editTmSegment(tmId: number, segmentId: number, request: PatchRequest[]): Promise<ResponseObject<TranslationMemoryModel.TMSegment>>;\n    deleteTmSegmentRecord(tmId: number, segmentId: number, recordId: number): Promise<void>;\n    editTmSegmentRecord(tmId: number, segmentId: number, recordId: number, request: PatchRequest[]): Promise<ResponseObject<TranslationMemoryModel.TMSegment>>;\n    addTmSegmentRecords(tmId: number, segmentId: number, request: TranslationMemoryModel.AddTMSegment): Promise<ResponseObject<TranslationMemoryModel.TMSegment>>;\n}\nexport declare namespace TranslationMemoryModel {\n    interface TranslationMemory {\n        id: number;\n        groupId: number;\n        userId: number;\n        name: string;\n        languageId: string;\n        languageIds: string[];\n        segmentsCount: number;\n        defaultProjectIds: number[];\n        projectIds: number[];\n        createdAt: string;\n        webUrl: string;\n    }\n    interface AddTranslationMemoryRequest {\n        name: string;\n        languageId: string;\n        groupId?: number;\n    }\n    interface ConcordanceSearchRequest {\n        sourceLanguageId: string;\n        targetLanguageId: string;\n        autoSubstitution: boolean;\n        minRelevant: number;\n        expressions: string[];\n        expression?: string;\n    }\n    interface ConcordanceSearchResponse {\n        tm: TranslationMemory;\n        recordId: number;\n        source: string;\n        target: string;\n        relevant: number;\n        substituted: string;\n        updatedAt: string;\n    }\n    interface ExportTranslationMemoryRequest {\n        sourceLanguageId?: number;\n        targetLanguageId?: number;\n        format?: Format;\n    }\n    interface ImportTranslationMemoryRequest {\n        storageId: number;\n        firstLineContainsHeader?: boolean;\n        scheme?: Scheme;\n    }\n    interface ExportTranslationMemoryAttribute {\n        sourceLanguageId: string;\n        targetLanguageId: string;\n        format: string;\n    }\n    interface ImportTranslationMemoryAttribute {\n        tmId: number;\n        storageId: number;\n        firstLineContainsHeader: number;\n        scheme: Scheme;\n    }\n    type Format = 'tmx' | 'csv' | 'xlsx';\n    interface Scheme {\n        [key: string]: number;\n    }\n    interface ListTMsOptions extends PaginationOptions {\n        groupId?: number;\n        userId?: number;\n        orderBy?: string;\n    }\n    interface ListSegmentsOptions extends PaginationOptions {\n        croql?: string;\n        orderBy?: string;\n    }\n    interface TMSegment {\n        id: number;\n        records: TMSegmentRecord[];\n    }\n    interface TMSegmentRecord {\n        id: number;\n        languageId: string;\n        text: string;\n        usageCount: number;\n        createdBy: number;\n        updatedBy: number;\n        createdAt: string;\n        updatedAt: string;\n    }\n    interface AddTMSegment {\n        records: AddTMSegmentRecord[];\n    }\n    interface AddTMSegmentRecord {\n        languageId: string;\n        text: string;\n    }\n}\n```\n\n##### translationStatus/index.d.ts\n\n```typescript\nimport { CrowdinApi, PaginationOptions, ResponseList } from '../core';\nimport { LanguagesModel } from '../languages';\nexport declare class TranslationStatus extends CrowdinApi {\n    getBranchProgress(projectId: number, branchId: number, options?: PaginationOptions): Promise<ResponseList<TranslationStatusModel.LanguageProgress>>;\n    getBranchProgress(projectId: number, branchId: number, limit?: number, offset?: number): Promise<ResponseList<TranslationStatusModel.LanguageProgress>>;\n    getDirectoryProgress(projectId: number, directoryId: number, options?: PaginationOptions): Promise<ResponseList<TranslationStatusModel.LanguageProgress>>;\n    getDirectoryProgress(projectId: number, directoryId: number, limit?: number, offset?: number): Promise<ResponseList<TranslationStatusModel.LanguageProgress>>;\n    getFileProgress(projectId: number, fileId: number, options?: PaginationOptions): Promise<ResponseList<TranslationStatusModel.LanguageProgress>>;\n    getFileProgress(projectId: number, fileId: number, limit?: number, offset?: number): Promise<ResponseList<TranslationStatusModel.LanguageProgress>>;\n    getLanguageProgress(projectId: number, languageId: string, options?: PaginationOptions): Promise<ResponseList<TranslationStatusModel.FileProgress>>;\n    getLanguageProgress(projectId: number, languageId: string, limit?: number, offset?: number): Promise<ResponseList<TranslationStatusModel.FileProgress>>;\n    getProjectProgress(projectId: number, options?: PaginationOptions): Promise<ResponseList<TranslationStatusModel.LanguageProgress>>;\n    getProjectProgress(projectId: number, limit?: number, offset?: number, languageIds?: string): Promise<ResponseList<TranslationStatusModel.LanguageProgress>>;\n    listQaCheckIssues(projectId: number, options?: TranslationStatusModel.ListQaCheckIssuesOptions): Promise<ResponseList<TranslationStatusModel.QaCheck>>;\n    listQaCheckIssues(projectId: number, limit?: number, offset?: number, category?: TranslationStatusModel.Category, validation?: TranslationStatusModel.Validation, languageIds?: string): Promise<ResponseList<TranslationStatusModel.QaCheck>>;\n}\nexport declare namespace TranslationStatusModel {\n    interface LanguageProgress {\n        words: Words;\n        phrases: Words;\n        translationProgress: number;\n        approvalProgress: number;\n        eTag: string;\n        languageId: string;\n        language: LanguagesModel.Language;\n    }\n    interface FileProgress {\n        words: Words;\n        phrases: Words;\n        translationProgress: number;\n        approvalProgress: number;\n        branchId: number;\n        fileId: number;\n        eTag: string;\n    }\n    interface Words {\n        total: number;\n        translated: number;\n        approved: number;\n        preTranslateAppliedTo: number;\n    }\n    type Category = 'empty' | 'variables' | 'tags' | 'punctuation' | 'symbol_register' | 'spaces' | 'size' | 'special_symbols' | 'wrong_translation' | 'spellcheck' | 'icu';\n    type Validation = 'empty_string_check' | 'empty_suggestion_check' | 'max_length_check' | 'tags_check' | 'mismatch_ids_check' | 'cdata_check' | 'specials_symbols_check' | 'leading_newlines_check' | 'trailing_newlines_check' | 'leading_spaces_check' | 'trailing_spaces_check' | 'multiple_spaces_check' | 'custom_blocked_variables_check' | 'highest_priority_custom_variables_check' | 'highest_priority_variables_check' | 'c_variables_check' | 'python_variables_check' | 'rails_variables_check' | 'java_variables_check' | 'dot_net_variables_check' | 'twig_variables_check' | 'php_variables_check' | 'freemarker_variables_check' | 'lowest_priority_variable_check' | 'lowest_priority_custom_variables_check' | 'punctuation_check' | 'spaces_before_punctuation_check' | 'spaces_after_punctuation_check' | 'non_breaking_spaces_check' | 'capitalize_check' | 'multiple_uppercase_check' | 'parentheses_check' | 'entities_check' | 'escaped_quotes_check' | 'wrong_translation_issue_check' | 'spellcheck' | 'icu_check';\n    interface ListQaCheckIssuesOptions extends PaginationOptions {\n        category?: Category | Category[];\n        validation?: Validation | Validation[];\n        languageIds?: string;\n    }\n    interface QaCheck {\n        stringId: number;\n        languageId: string;\n        category: Category;\n        categoryDescription: string;\n        validation: Validation;\n        validationDescription: string;\n        pluralId: number;\n        text: string;\n    }\n    interface GetProjectProgressOptions extends PaginationOptions {\n        languageIds?: string;\n    }\n}\n```\n\n##### translations/index.d.ts\n\n```typescript\nimport { CrowdinApi, DownloadLink, PaginationOptions, PatchRequest, ResponseList, ResponseObject, Status } from '../core';\nimport { ProjectsGroupsModel } from '../projectsGroups';\nexport declare class Translations extends CrowdinApi {\n    listPreTranslations(projectId: number, options?: PaginationOptions): Promise<ResponseList<Status<TranslationsModel.PreTranslationStatusAttributes>>>;\n    preTranslationStatus(projectId: number, preTranslationId: string): Promise<ResponseObject<Status<TranslationsModel.PreTranslationStatusAttributes>>>;\n    applyPreTranslation(projectId: number, request: TranslationsModel.PreTranslateRequest | TranslationsModel.PreTranslateStringsRequest): Promise<ResponseObject<Status<TranslationsModel.PreTranslationStatusAttributes>>>;\n    editPreTranslation(projectId: number, preTranslationId: string, request: PatchRequest[]): Promise<ResponseObject<Status<TranslationsModel.PreTranslationStatusAttributes>>>;\n    getPreTranslationReport(projectId: number, preTranslationId: string): Promise<ResponseObject<TranslationsModel.PreTranslationReport>>;\n    buildProjectDirectoryTranslation(projectId: number, directoryId: number, request?: TranslationsModel.BuildProjectDirectoryTranslationRequest): Promise<ResponseObject<TranslationsModel.BuildProjectDirectoryTranslationResponse>>;\n    buildProjectFileTranslation(projectId: number, fileId: number, request: TranslationsModel.BuildProjectFileTranslationRequest, eTag?: string): Promise<ResponseObject<TranslationsModel.BuildProjectFileTranslationResponse>>;\n    listProjectBuilds(projectId: number, options?: TranslationsModel.ListProjectBuildsOptions): Promise<ResponseList<TranslationsModel.Build>>;\n    listProjectBuilds(projectId: number, branchId?: number, limit?: number, offset?: number): Promise<ResponseList<TranslationsModel.Build>>;\n    buildProject(projectId: number, request?: TranslationsModel.BuildRequest | TranslationsModel.PseudoBuildRequest): Promise<ResponseObject<TranslationsModel.Build>>;\n    uploadTranslation(projectId: number, languageId: string, request: TranslationsModel.UploadTranslationRequest): Promise<ResponseObject<TranslationsModel.UploadTranslationResponse>>;\n    uploadTranslationStrings(projectId: number, languageId: string, request: TranslationsModel.UploadTranslationStringsRequest): Promise<ResponseObject<TranslationsModel.UploadTranslationStringsResponse>>;\n    downloadTranslations(projectId: number, buildId: number): Promise<ResponseObject<DownloadLink>>;\n    checkBuildStatus(projectId: number, buildId: number): Promise<ResponseObject<TranslationsModel.Build>>;\n    cancelBuild(projectId: number, buildId: number): Promise<void>;\n    exportProjectTranslation(projectId: number, request: TranslationsModel.ExportProjectTranslationRequest): Promise<ResponseObject<DownloadLink>>;\n}\nexport declare namespace TranslationsModel {\n    interface PreTranslateRequest {\n        languageIds: string[];\n        fileIds: number[];\n        method?: Method;\n        engineId?: number;\n        aiPromptId?: number;\n        autoApproveOption?: AutoApproveOption;\n        duplicateTranslations?: boolean;\n        skipApprovedTranslations?: boolean;\n        translateUntranslatedOnly?: boolean;\n        translateWithPerfectMatchOnly?: boolean;\n        fallbackLanguages?: {\n            languageId?: string[];\n        };\n        labelIds?: number[];\n        excludeLabelIds?: number[];\n    }\n    interface PreTranslateStringsRequest {\n        languageIds: string[];\n        branchIds?: number[];\n        method?: Method;\n        engineId?: number;\n        aiPromptId?: number;\n        autoApproveOption?: AutoApproveOption;\n        duplicateTranslations?: boolean;\n        skipApprovedTranslations?: boolean;\n        translateUntranslatedOnly?: boolean;\n        translateWithPerfectMatchOnly?: boolean;\n        fallbackLanguages?: {\n            languageId: string[];\n        };\n        labelIds?: number[];\n        excludeLabelIds?: number[];\n    }\n    interface BuildProjectDirectoryTranslationRequest {\n        targetLanguageIds?: string[];\n        skipUntranslatedStrings?: boolean;\n        skipUntranslatedFiles?: boolean;\n        preserveFolderHierarchy?: boolean;\n        exportStringsThatPassedWorkflow?: boolean;\n        exportWithMinApprovalsCount?: number;\n        exportApprovedOnly?: boolean;\n    }\n    interface BuildProjectDirectoryTranslationResponse {\n        id: number;\n        projectId: number;\n        status: BuildStatus;\n        progress: number;\n        createdAt: string;\n        updatedAt: string;\n        finishedAt: string;\n    }\n    type BuildStatus = 'created' | 'inProgress' | 'canceled' | 'failed' | 'finished';\n    interface BuildProjectFileTranslationRequest {\n        targetLanguageId: string;\n        exportAsXliff?: boolean;\n        skipUntranslatedStrings?: boolean;\n        skipUntranslatedFiles?: boolean;\n        exportApprovedOnly?: boolean;\n        exportWithMinApprovalsCount?: number;\n        exportStringsThatPassedWorkflow?: boolean;\n    }\n    interface BuildProjectFileTranslationResponse extends DownloadLink {\n        etag: string;\n    }\n    interface PreTranslationStatusAttributes {\n        languageIds: string[];\n        fileIds: number[];\n        branchIds: number[];\n        method: Method;\n        autoApproveOption: AutoApproveOption;\n        duplicateTranslations: boolean;\n        skipApprovedTranslations: boolean;\n        translateUntranslatedOnly: boolean;\n        translateWithPerfectMatchOnly: boolean;\n    }\n    type Method = 'tm' | 'mt' | 'ai';\n    type AutoApproveOption = 'all' | 'exceptAutoSubstituted' | 'perfectMatchOnly' | 'none';\n    type CharTransformation = 'asian' | 'european' | 'arabic' | 'cyrillic';\n    interface Build {\n        id: number;\n        projectId: number;\n        status: BuildStatus;\n        progress: number;\n        attributes: Attribute;\n        createdAt: string;\n        updatedAt: string;\n        finishedAt: string;\n    }\n    interface Attribute {\n        branchId: number;\n        directoryId: number;\n        targetLanguageIds: string[];\n        skipUntranslatedStrings: boolean;\n        skipUntranslatedFiles: boolean;\n        exportApprovedOnly: boolean;\n        exportWithMinApprovalsCount: number;\n        exportStringsThatPassedWorkflow: boolean;\n    }\n    interface BuildRequest {\n        branchId?: number;\n        targetLanguageIds?: string[];\n        skipUntranslatedStrings?: boolean;\n        skipUntranslatedFiles?: boolean;\n        exportApprovedOnly?: boolean;\n        exportWithMinApprovalsCount?: number;\n        exportStringsThatPassedWorkflow?: boolean;\n    }\n    interface PseudoBuildRequest {\n        pseudo: boolean;\n        branchId?: number;\n        prefix?: string;\n        suffix?: string;\n        lengthTransformation?: number;\n        charTransformation?: CharTransformation;\n    }\n    interface UploadTranslationRequest {\n        storageId: number;\n        fileId?: number;\n        importEqSuggestions?: boolean;\n        autoApproveImported?: boolean;\n        translateHidden?: boolean;\n        addToTm?: boolean;\n    }\n    interface UploadTranslationStringsRequest {\n        storageId: number;\n        branchId?: number;\n        importEqSuggestions?: boolean;\n        autoApproveImported?: boolean;\n        translateHidden?: boolean;\n        addToTm?: boolean;\n    }\n    interface UploadTranslationResponse {\n        projectId: number;\n        storageId: number;\n        languageId: string;\n        fileId: number;\n    }\n    interface UploadTranslationStringsResponse {\n        projectId: number;\n        storageId: number;\n        languageId: string;\n        branchId: number;\n    }\n    interface ExportProjectTranslationRequest {\n        targetLanguageId: string;\n        format?: string;\n        labelIds?: number[];\n        branchIds?: number[];\n        directoryIds?: number[];\n        fileIds?: number[];\n        skipUntranslatedStrings?: boolean;\n        skipUntranslatedFiles?: boolean;\n        exportApprovedOnly?: boolean;\n        exportWithMinApprovalsCount?: number;\n        exportStringsThatPassedWorkflow?: boolean;\n    }\n    interface ListProjectBuildsOptions extends PaginationOptions {\n        branchId?: number;\n    }\n    interface PreTranslationReport {\n        languages: TargetLanguage[];\n        preTranslateType: Method;\n    }\n    interface TargetLanguage {\n        id: string;\n        files: TargetLanguageFile[];\n        skipped: SkippedInfo;\n        skippedQaCheckCategories: ProjectsGroupsModel.CheckCategories;\n    }\n    interface TargetLanguageFile {\n        id: string;\n        statistics: TargetLanguageFileStatistics;\n    }\n    interface TargetLanguageFileStatistics {\n        phrases: number;\n        words: number;\n    }\n    interface SkippedInfo {\n        [key: string]: any;\n    }\n}\n```\n\n##### uploadStorage/index.d.ts\n\n```typescript\nimport { CrowdinApi, PaginationOptions, ResponseList, ResponseObject } from '../core';\nexport declare class UploadStorage extends CrowdinApi {\n    listStorages(options?: PaginationOptions): Promise<ResponseList<UploadStorageModel.Storage>>;\n    listStorages(limit?: number, offset?: number): Promise<ResponseList<UploadStorageModel.Storage>>;\n    addStorage(fileName: string, request: any, contentType?: string): Promise<ResponseObject<UploadStorageModel.Storage>>;\n    getStorage(storageId: number): Promise<ResponseObject<UploadStorageModel.Storage>>;\n    deleteStorage(storageId: number): Promise<void>;\n}\nexport declare namespace UploadStorageModel {\n    interface Storage {\n        id: number;\n        fileName: string;\n    }\n}\n```\n\n##### users/index.d.ts\n\n```typescript\nimport { CrowdinApi, Pagination, PaginationOptions, PatchRequest, ProjectRole, ProjectRoles, ResponseList, ResponseObject } from '../core';\nimport { ProjectsGroupsModel } from '../projectsGroups';\nimport { TeamsModel } from '../teams';\nexport declare class Users extends CrowdinApi {\n    listGroupManagers(groupId: number, options?: UsersModel.ListGroupManagersOptions): Promise<ResponseList<UsersModel.GroupManager>>;\n    updateGroupManagers(groupId: number, request: PatchRequest[]): Promise<ResponseList<UsersModel.GroupManager>>;\n    getGroupManager(groupId: number, userId: number): Promise<ResponseObject<UsersModel.GroupManager>>;\n    listProjectMembers(projectId: number, options?: UsersModel.ListProjectMembersOptions): Promise<ResponseList<UsersModel.ProjectMember | UsersModel.EnterpriseProjectMember>>;\n    listProjectMembers(projectId: number, search?: string, role?: UsersModel.Role, languageId?: string, limit?: number, offset?: number): Promise<ResponseList<UsersModel.ProjectMember | UsersModel.EnterpriseProjectMember>>;\n    addProjectMember(projectId: number, request: UsersModel.AddProjectMemberRequest): Promise<UsersModel.AddProjectMemberResponse>;\n    getProjectMemberPermissions(projectId: number, memberId: number): Promise<ResponseObject<UsersModel.ProjectMember | UsersModel.EnterpriseProjectMember>>;\n    replaceProjectMemberPermissions(projectId: number, memberId: number, request?: UsersModel.ReplaceProjectMemberRequest): Promise<ResponseObject<UsersModel.ProjectMember | UsersModel.EnterpriseProjectMember>>;\n    deleteMemberFromProject(projectId: number, memberId: number): Promise<void>;\n    listUsers(options?: UsersModel.ListUsersOptions): Promise<ResponseList<UsersModel.User>>;\n    listUsers(status?: UsersModel.Status, search?: string, twoFactor?: UsersModel.TwoFactor, limit?: number, offset?: number): Promise<ResponseList<UsersModel.User>>;\n    inviteUser(request: UsersModel.InviteUserRequest): Promise<ResponseObject<UsersModel.User>>;\n    getUserInfo(userId: number): Promise<ResponseObject<UsersModel.User>>;\n    deleteUser(userId: number): Promise<void>;\n    editUser(userId: number, request: PatchRequest[]): Promise<ResponseObject<UsersModel.User>>;\n    getAuthenticatedUser(): Promise<ResponseObject<UsersModel.User>>;\n    editAuthenticatedUser(request: PatchRequest[]): Promise<ResponseObject<UsersModel.User>>;\n    listUserProjectPermissions(userId: number, options?: PaginationOptions): Promise<ResponseList<UsersModel.ProjectPermissions>>;\n    editUserProjectPermissions(userId: number, request: PatchRequest[]): Promise<ResponseList<UsersModel.ProjectPermissions>>;\n    listUserProjectContributions(userId: number, options?: PaginationOptions): Promise<ResponseList<UsersModel.ProjectPermissions>>;\n}\nexport declare namespace UsersModel {\n    interface ListGroupManagersOptions extends PaginationOptions {\n        teamIds?: number[];\n        orderBy?: string;\n    }\n    interface ListProjectMembersOptions extends PaginationOptions {\n        search?: string;\n        role?: Role;\n        languageId?: string;\n        workflowStepId?: number;\n        orderBy?: string;\n    }\n    interface ListUsersOptions extends PaginationOptions {\n        status?: Status;\n        search?: string;\n        twoFactor?: TwoFactor;\n        orderBy?: string;\n        organizationRoles?: OrganizationRoles[];\n        teamId?: number;\n        projectIds?: string;\n        projectRoles?: ProjectRoles[];\n        languageIds?: string;\n        groupIds?: string;\n        lastSeenFrom?: string;\n        lastSeenTo?: string;\n    }\n    interface InviteUserRequest {\n        email: string;\n        firstName?: string;\n        lastName?: string;\n        timezone?: string;\n        adminAccess?: boolean;\n    }\n    interface User {\n        id: number;\n        username: string;\n        email: string;\n        firstName: string;\n        lastName: string;\n        status: Status;\n        avatarUrl: string;\n        fields: Record<string, any>;\n        createdAt: string;\n        lastSeen: string;\n        twoFactor: TwoFactor;\n        isAdmin: boolean;\n        timezone: string;\n        emailVerified: string;\n    }\n    type Status = 'active' | 'pending' | 'blocked';\n    type TwoFactor = 'enabled' | 'disabled';\n    type OrganizationRoles = 'admin' | 'manager' | 'vendor' | 'client';\n    interface GroupManager {\n        id: number;\n        user: User;\n        teams: TeamsModel.Team[];\n    }\n    interface ProjectMember {\n        id: number;\n        username: string;\n        fullName: string;\n        role: Role;\n        permissions: Permissions;\n        avatarUrl: string;\n        joinedAt: string;\n        timezone: string;\n        roles: ProjectRole[];\n    }\n    interface EnterpriseProjectMember {\n        id: number;\n        username: string;\n        firstName: string;\n        lastName: string;\n        isManager: boolean;\n        isDeveloperr: boolean;\n        managerOfGroup: Group;\n        accessToAllWorkflowSteps: boolean;\n        permissions: Permissions;\n        givenAccessAt: string;\n        roles: ProjectRole[];\n    }\n    interface Group {\n        id: number;\n        name: string;\n    }\n    type Role = 'all' | 'owner' | 'manager' | 'proofreader' | 'translator' | 'blocked';\n    type LanguageRole = 'proofreader' | 'translator' | 'denied';\n    interface AddProjectMemberRequest {\n        userIds?: number[];\n        usernames?: string[];\n        emails?: string[];\n        managerAccess?: boolean;\n        roles?: ProjectRole[];\n        developerAccess?: boolean;\n        accessToAllWorkflowSteps?: boolean;\n        permissions?: Permissions;\n    }\n    interface AddProjectMemberResponse {\n        skipped: ResponseObject<ProjectMember | EnterpriseProjectMember>[];\n        added: ResponseObject<ProjectMember | EnterpriseProjectMember>[];\n        pagination: Pagination;\n    }\n    interface ReplaceProjectMemberRequest {\n        managerAccess?: boolean;\n        developerAccess?: boolean;\n        roles?: ProjectRole[];\n        accessToAllWorkflowSteps?: boolean;\n        permissions?: Permissions;\n    }\n    interface ProjectPermissions {\n        id: number;\n        roles: ProjectRole[];\n        project: ProjectsGroupsModel.Project | ProjectsGroupsModel.ProjectSettings;\n        teams: TeamsModel.Team[];\n    }\n    interface Contributions {\n        id: number;\n        translated: Contribution;\n        approved: Contribution;\n        voted: Contribution;\n        commented: Contribution;\n        project: ProjectsGroupsModel.Project | ProjectsGroupsModel.ProjectSettings;\n    }\n    interface Contribution {\n        strings: number;\n        words?: number;\n    }\n    interface Permissions {\n        [lang: string]: string | {\n            workflowStepIds: number[] | 'all';\n        };\n    }\n}\n```\n\n##### vendors/index.d.ts\n\n```typescript\nimport { CrowdinApi, PaginationOptions, ResponseList } from '../core';\nexport declare class Vendors extends CrowdinApi {\n    listVendors(options?: PaginationOptions): Promise<ResponseList<VendorsModel.Vendor>>;\n    listVendors(limit?: number, offset?: number): Promise<ResponseList<VendorsModel.Vendor>>;\n}\nexport declare namespace VendorsModel {\n    interface Vendor {\n        id: number;\n        name: string;\n        description: string;\n        status: 'pending' | 'confirmed' | 'rejected';\n        webUrl: string;\n    }\n}\n```\n\n##### webhooks/index.d.ts\n\n```typescript\nimport { CrowdinApi, PaginationOptions, PatchRequest, ResponseList, ResponseObject } from '../core';\nexport declare class Webhooks extends CrowdinApi {\n    listWebhooks(projectId: number, options?: PaginationOptions): Promise<ResponseList<WebhooksModel.Webhook>>;\n    listWebhooks(projectId: number, limit?: number, offset?: number): Promise<ResponseList<WebhooksModel.Webhook>>;\n    addWebhook(projectId: number, request: WebhooksModel.AddWebhookRequest): Promise<ResponseObject<WebhooksModel.Webhook>>;\n    getWebhook(projectId: number, webhookId: number): Promise<ResponseObject<WebhooksModel.Webhook>>;\n    deleteWebhook(projectId: number, webhookId: number): Promise<void>;\n    editWebhook(projectId: number, webhookId: number, request: PatchRequest[]): Promise<ResponseObject<WebhooksModel.Webhook>>;\n}\nexport declare namespace WebhooksModel {\n    interface Webhook {\n        id: number;\n        projectId: number;\n        name: string;\n        url: string;\n        events: Event[];\n        headers: Record<string, string>;\n        payload: Record<string, any>;\n        isActive: boolean;\n        batchingEnabled: boolean;\n        requestType: RequestType;\n        contentType: ContentType;\n        createdAt: string;\n        updatedAt: string;\n    }\n    interface AddWebhookRequest {\n        name: string;\n        url: string;\n        events: Event[];\n        requestType: RequestType;\n        isActive?: boolean;\n        batchingEnabled?: boolean;\n        contentType?: ContentType;\n        headers?: Record<string, string>;\n        payload?: Record<string, any>;\n    }\n    type ContentType = 'multipart/form-data' | 'application/json' | 'application/x-www-form-urlencoded';\n    type Event = 'file.added' | 'file.updated' | 'file.reverted' | 'file.deleted' | 'file.translated' | 'file.approved' | 'project.translated' | 'project.approved' | 'project.built' | 'translation.updated' | 'string.added' | 'string.updated' | 'string.deleted' | 'stringComment.created' | 'stringComment.updated' | 'stringComment.deleted' | 'stringComment.restored' | 'suggestion.added' | 'suggestion.updated' | 'suggestion.deleted' | 'suggestion.approved' | 'suggestion.disapproved' | 'task.added' | 'task.statusChanged' | 'task.deleted';\n    type RequestType = 'POST' | 'GET';\n}\n```\n\n##### workflows/index.d.ts\n\n```typescript\nimport { CrowdinApi, PaginationOptions, PatchRequest, ResponseList, ResponseObject } from '../core';\nimport { SourceStringsModel } from '../sourceStrings';\nexport declare class Workflows extends CrowdinApi {\n    listWorkflowSteps(projectId: number, options?: PaginationOptions): Promise<ResponseList<WorkflowModel.WorkflowStep>>;\n    listWorkflowSteps(projectId: number, limit?: number, offset?: number): Promise<ResponseList<WorkflowModel.WorkflowStep>>;\n    getWorkflowStep(projectId: number, stepId: number): Promise<ResponseObject<WorkflowModel.WorkflowStep>>;\n    listStringsOnTheWorkflowStep(projectId: number, stepId: number, options?: WorkflowModel.ListStringsOntheWorkflowStepOptions): Promise<ResponseList<SourceStringsModel.String>>;\n    listWorkflowTemplates(options?: WorkflowModel.ListWorkflowTemplatesOptions): Promise<ResponseList<WorkflowModel.Workflow>>;\n    listWorkflowTemplates(groupId?: number, limit?: number, offset?: number): Promise<ResponseList<WorkflowModel.Workflow>>;\n    getWorkflowTemplateInfo(templateId: number): Promise<ResponseObject<WorkflowModel.Workflow>>;\n    updateWorkflowStepStringStatus(projectId: number, stepId: number, languageId: string, request: PatchRequest[]): Promise<ResponseList<WorkflowModel.WorkflowStepStringStatus>>;\n    getWorkflowStepStringStatus(projectId: number, stepId: number, languageId: string, options?: PaginationOptions): Promise<ResponseList<WorkflowModel.WorkflowStepStringStatus>>;\n}\nexport declare namespace WorkflowModel {\n    interface WorkflowStep {\n        id: number;\n        title: string;\n        type: string;\n        languages: string[];\n        config: {\n            assignees: {\n                [language: string]: number[];\n            };\n        };\n    }\n    interface ListWorkflowTemplatesOptions extends PaginationOptions {\n        groupId?: number;\n    }\n    interface ListStringsOntheWorkflowStepOptions extends PaginationOptions {\n        languageIds?: string;\n        orderBy?: string;\n        status?: 'todo' | 'done' | 'pending' | 'incomplete' | 'need_review';\n    }\n    interface Workflow {\n        id: number;\n        title: string;\n        description: string;\n        groupId: number;\n        isDefault: boolean;\n        webUrl: string;\n        steps: {\n            id: number;\n            languages: string[];\n            assignees: number[];\n            vendorId: number;\n            config: {\n                minRelevant: number;\n                autoSubstitution: boolean;\n            };\n            mtId: number;\n        }[];\n    }\n    interface WorkflowStepStringStatus {\n        stringId: number;\n        languageId: string;\n        stepId: number;\n        status: string;\n        output: string;\n    }\n}\n```\n\n<!-- CROWDIN_API_CLIENT_TYPES_END -->\n\n### App Metadata Storage\n\n#### Overview\n\nApp Metadata Storage is a built-in key-value storage system provided by the Crowdin Apps SDK. It allows your app to persist data across sessions without needing external databases or storage services.\n\n**Available Methods:**\n- `crowdinApp.saveMetadata(key, data, crowdinId)` - Save or update metadata (recommended)\n- `crowdinApp.getMetadata(key)` - Retrieve metadata\n- `crowdinApp.deleteMetadata(key)` - Delete metadata\n\n**Alternative approach:**\n- `crowdinModule.metadataStore.saveMetadata(key, data, crowdinId)`\n- `crowdinModule.metadataStore.getMetadata(key)`\n- `crowdinModule.metadataStore.deleteMetadata(key)`\n\n#### Official Documentation\n\n**üìö Complete Documentation:** Refer to Crowdin Apps SDK documentation for metadata storage\n\n**‚ö†Ô∏è CRITICAL**: Metadata is stored at the organization level. Always include `organizationId` in your keys to properly scope data.\n\n#### Common Examples\n\n**Save Metadata:**\n```typescript\napp.post('/api/save-data', async (req: Request, res: Response) => {\n    try {\n        const jwt = req.query.jwt as string;\n        const { data } = req.body;\n\n        if (!jwt) {\n            return res.status(400).json({ success: false, error: 'JWT token is required' });\n        }\n        \n        if (!crowdinApp.establishCrowdinConnection) {\n            return res.status(500).json({ success: false, error: 'Crowdin connection method not available' });\n        }\n\n        const connection = await crowdinApp.establishCrowdinConnection(jwt, undefined);\n\n        if (!connection.client) {\n            return res.status(500).json({ success: false, error: 'Crowdin API client not available' });\n        }\n\n        const userId = connection.context.jwtPayload.context.user_id;\n        const organizationId = connection.context.jwtPayload.context.organization_id;\n        \n        // Create a namespaced key\n        const key = `org_${organizationId}_user_${userId}_preferences`;\n        \n        // Save data to metadata storage\n        await crowdinApp.saveMetadata(key, data, connection.context.crowdinId);\n        res.json({ success: true, message: 'Data saved successfully' });\n    } catch (error) {\n        console.error('Save error:', error);\n        res.status(500).json({ success: false, error: 'Failed to save data' });\n    }\n});\n```\n\n**Get Metadata:**\n```typescript\napp.get('/api/get-data', async (req: Request, res: Response) => {\n    try {\n        const jwt = req.query.jwt as string;\n        \n        if (!jwt) {\n            return res.status(400).json({ success: false, error: 'JWT token is required' });\n        }\n        \n        if (!crowdinApp.establishCrowdinConnection) {\n            return res.status(500).json({ success: false, error: 'Crowdin connection method not available' });\n        }\n\n        const connection = await crowdinApp.establishCrowdinConnection(jwt, undefined);\n\n        if (!connection.client) {\n            return res.status(500).json({ success: false, error: 'Crowdin API client not available' });\n        }\n\n        const userId = connection.context.jwtPayload.context.user_id;\n        const organizationId = connection.context.jwtPayload.context.organization_id;\n        \n        const key = `org_${organizationId}_user_${userId}_preferences`;\n        \n        // Retrieve data from metadata storage\n        const data = await crowdinApp.getMetadata(key);\n            \n        // Handle case when no data exists\n        if (!data) {\n            return res.json({ \n                success: true, \n                data: null, \n                message: 'No data found' \n            });\n        }\n        \n        res.json({ success: true, data });\n    } catch (error) {\n        console.error('Get error:', error);\n        res.status(500).json({ success: false, error: 'Failed to retrieve data' });\n    }\n});\n```\n\n**Delete Metadata:**\n```typescript\napp.delete('/api/delete-data', async (req: Request, res: Response) => {\n    try {\n        const jwt = req.query.jwt as string;\n        \n        if (!jwt) {\n            return res.status(400).json({ success: false, error: 'JWT token is required' });\n        }\n        \n        if (!crowdinApp.establishCrowdinConnection) {\n            return res.status(500).json({ success: false, error: 'Crowdin connection method not available' });\n        }\n\n        const connection = await crowdinApp.establishCrowdinConnection(jwt, undefined);\n\n        if (!connection.client) {\n            return res.status(500).json({ success: false, error: 'Crowdin API client not available' });\n        }\n\n        const userId = connection.context.jwtPayload.context.user_id;\n        const organizationId = connection.context.jwtPayload.context.organization_id;\n        \n        const key = `org_${organizationId}_user_${userId}_preferences`;\n        \n        // Delete data from metadata storage\n        await crowdinApp.deleteMetadata(key);\n        res.json({ success: true, message: 'Data deleted successfully' });\n    } catch (error) {\n        console.error('Delete error:', error);\n        res.status(500).json({ success: false, error: 'Failed to delete data' });\n    }\n});\n```\n\n**Get All Metadata:**\n```typescript\napp.get('/api/all-metadata', async (req: Request, res: Response) => {\n    try {\n        const jwt = req.query.jwt as string;\n        \n        if (!jwt) {\n            return res.status(400).json({ success: false, error: 'JWT token is required' });\n        }\n        \n        if (!crowdinApp.establishCrowdinConnection) {\n            return res.status(500).json({ success: false, error: 'Crowdin connection method not available' });\n        }\n\n        const connection = await crowdinApp.establishCrowdinConnection(jwt, undefined);\n\n        if (!connection.client) {\n            return res.status(500).json({ success: false, error: 'Crowdin API client not available' });\n        }\n\n        // Retrieve all metadata records from storage\n        const allMetadata = await crowdinApp.storage.getAllMetadata();\n        \n        // allMetadata structure:\n        // [\n        //   {\n        //     id: \"org_123_user_456_preferences\",  // key\n        //     data: \"{\"theme\":\"dark\",\"lang\":\"en\"}\", // JSON stringified value\n        //     crowdin_id: \"domain\"     // crowdin identifier (from connection.context.crowdinId during save)\n        //   },\n        //   ...\n        // ]\n        \n        // Parse and format data\n        const formattedData = allMetadata.map(record => ({\n            key: record.id,\n            value: JSON.parse(record.data || '{}'),\n            crowdinId: record.crowdin_id\n        }));\n        \n        res.json({ success: true, metadata: formattedData, count: formattedData.length });\n    } catch (error) {\n        console.error('Error retrieving all metadata:', error);\n        res.status(500).json({ success: false, error: 'Failed to retrieve metadata' });\n    }\n});\n```\n\n**Store Complex Objects:**\n```typescript\n// Save complex user preferences\nconst preferences = {\n    theme: 'dark',\n    language: 'en',\n    notifications: {\n        email: true,\n        push: false,\n        digest: 'weekly'\n    },\n    lastUpdated: new Date().toISOString(),\n    settings: {\n        autoSave: true,\n        confirmActions: true\n    }\n};\n\nconst key = `org_${organizationId}_user_${userId}_preferences`;\nawait crowdinApp.saveMetadata(key, preferences, connection.context.crowdinId);\n\n// Retrieve and update\nconst currentPrefs = await crowdinApp.getMetadata(key) || {};\nconst updatedPrefs = {\n    ...currentPrefs,\n    theme: 'light',\n    lastUpdated: new Date().toISOString()\n};\nawait crowdinApp.saveMetadata(key, updatedPrefs, connection.context.crowdinId);\n```\n\n#### Best Practices\n\n1. **Always use namespaced keys**\n   ```typescript\n   // ‚úÖ CORRECT - includes organization and entity identifiers\n   const key = `org_${organizationId}_user_${userId}_preferences`;\n   const key = `org_${organizationId}_project_${projectId}_cache`;\n   \n   // ‚ùå WRONG - no organization scope, may cause conflicts\n   const key = `user_preferences`;\n   const key = `${userId}_data`;\n   ```\n\n2. **Handle missing data gracefully**\n   ```typescript\n   // ‚úÖ CORRECT - provide defaults for missing data\n   const data = await crowdinApp.getMetadata(key) || { \n       theme: 'auto', \n       language: 'en' \n   };\n   \n   // ‚úÖ CORRECT - check for null/undefined\n   const data = await crowdinApp.getMetadata(key);\n   if (!data) {\n       return defaultSettings;\n   }\n   \n   // ‚ùå WRONG - may cause errors if data is null\n   const theme = data.theme; // Error if data is null\n   ```\n\n3. **Always use the correct identifier for the third parameter**\n   ```typescript\n   // ‚úÖ CORRECT - when connection object is available\n   await crowdinApp.saveMetadata(key, data, connection.context.crowdinId);\n   \n   // ‚úÖ CORRECT - when using webhookContext (no connection object, crowdinApp not available)\n   await crowdinModule.metadataStore.saveMetadata(key, data, `${webhookContext.domain || webhookContext.organizationId}`);\n   \n   // ‚ùå WRONG - don't use organizationId directly\n   await crowdinApp.saveMetadata(key, data, String(organizationId));\n   ```\n\n4. **Use descriptive key patterns**\n   ```typescript\n   // ‚úÖ CORRECT - clear, hierarchical structure\n   `org_${orgId}_user_${userId}_preferences`\n   `org_${orgId}_project_${projectId}_settings`\n   `org_${orgId}_cache_${cacheType}_${identifier}`\n   \n   // ‚ùå WRONG - unclear, hard to maintain\n   `data_${id}`\n   `temp_storage`\n   ```\n\n5. **Handle errors properly**\n   ```typescript\n   // ‚úÖ CORRECT - comprehensive error handling\n   try {\n       await crowdinApp.saveMetadata(key, data, connection.context.crowdinId);\n       return { success: true };\n   } catch (error: any) {\n       console.error('Metadata save failed:', error);\n       return { \n           success: false, \n           error: 'Failed to save data'\n       };\n   }\n   ```\n\n7. **Store only JSON-serializable data**\n   ```typescript\n   // ‚úÖ CORRECT - simple JSON-serializable objects\n   const data = {\n       name: 'John',\n       age: 30,\n       preferences: ['option1', 'option2'],\n       metadata: { key: 'value' }\n   };\n   \n   // ‚ùå WRONG - functions, dates, circular references\n   const data = {\n       name: 'John',\n       callback: () => {},           // Functions don't serialize\n       created: new Date(),           // Dates become strings\n       circular: data                 // Circular reference\n   };\n   \n   // ‚úÖ CORRECT - convert dates to ISO strings\n   const data = {\n       name: 'John',\n       created: new Date().toISOString()\n   };\n   ```\n\n8. **NEVER use KVStore for configurations - use metadata storage instead**\n   ```typescript\n   // ‚úÖ CORRECT - use metadata storage for ALL configuration storage\n   const config = {\n       apiKey: userApiKey,\n       apiEndpoint: 'https://api.example.com',\n       languageMapping: { 'en': 'en-US' }\n   };\n   await crowdinApp.saveMetadata(\n       `config_org_${organizationId}`, \n       config, \n       connection.context.crowdinId\n   );\n   \n   // ‚úÖ CORRECT - read configuration from metadata storage\n   const config = await crowdinApp.getMetadata(`config_org_${organizationId}`) || {};\n   \n   // ‚ùå WRONG - using KVStore for configuration storage\n   const config = {\n       apiKey: userApiKey,\n       apiEndpoint: 'https://api.example.com',\n       languageMapping: { 'en': 'en-US' }\n   };\n   await env.KVStore.put(\n       `config_org_${organizationId}`, \n       JSON.stringify(config)\n   );\n   \n   // ‚ùå WRONG - reading configuration from KVStore\n   const configData = await env.KVStore.get(`config_org_${organizationId}`);\n   const config = JSON.parse(configData || '{}');\n   ```\n\n9. **Use crowdinApp.saveMetadata or crowdinModule.metadataStore.saveMetadata - both implement upsert**\n   ```typescript\n   // ‚úÖ CORRECT - implements upsert (insert or update)\n   await crowdinApp.saveMetadata(\n       key, \n       data, \n       connection.context.crowdinId\n   );\n   \n   // ‚úÖ CORRECT - also implements upsert (insert or update)\n   await crowdinModule.metadataStore.saveMetadata(\n       key, \n       data, \n       connection.context.crowdinId\n   );\n   \n   // ‚ùå WRONG - only insert, NOT upsert (will fail if key already exists)\n   await crowdinApp.storage.saveMetadata(\n       key, \n       data, \n       connection.context.crowdinId\n   );\n   ```\n\n### Cron Scheduling\n\n#### Overview\n\nCron Scheduling allows your app to execute background tasks at specified time intervals.\n\n#### Official Documentation\n\n**üìö Complete Documentation:** Refer to Crowdin Apps SDK documentation for cron scheduling\n\n**‚ö†Ô∏è CRITICAL**: Only specific cron intervals are supported. Using unsupported intervals will result in an error.\n\n#### Supported Intervals\n\nThe following cron expressions are supported:\n\n| Cron Expression | Description | Frequency |\n|----------------|-------------|-----------|\n| `0 * * * *` | Every hour | Runs at minute 0 of every hour |\n| `0 */3 * * *` | Every 3 hours | Runs at minute 0 every 3 hours |\n| `0 */6 * * *` | Every 6 hours | Runs at minute 0 every 6 hours |\n| `0 */12 * * *` | Every 12 hours | Runs at minute 0 every 12 hours |\n| `0 0 * * *` | Daily | Runs at midnight (00:00) every day |\n| `0 0 * * SUN` | Weekly | Runs at midnight (00:00) every Sunday |\n| `0 0 1 * *` | Monthly | Runs at midnight (00:00) on the 1st of each month |\n\n#### Common Examples\n\n**Simple Hourly Task:**\n```typescript\n// In worker/app.ts, after initializing crowdinApp\nconst crowdinApp = crowdinModule.addCrowdinEndpoints(app, configuration) as CrowdinAppUtilities;\n\n// Register cron job - runs every hour\ncrowdinApp.cron.schedule('0 * * * *', async () => {\n    try {\n        console.log('Hourly task started at', new Date().toISOString());\n        \n        // Perform your scheduled task\n        // Example: Check status, update cache, etc.\n        \n        console.log('Task completed');\n    } catch (error) {\n        console.error('Cron job error:', error);\n    }\n});\n```\n\n**Multiple Tasks for Same Schedule:**\n```typescript\n// In worker/app.ts, after initializing crowdinApp\nconst crowdinApp = crowdinModule.addCrowdinEndpoints(app, configuration) as CrowdinAppUtilities;\n\n// Both tasks will run daily at midnight\ncrowdinApp.cron.schedule('0 0 * * *', async () => {\n    try {\n        console.log('Daily cleanup started');\n        // Cleanup old data\n    } catch (error) {\n        console.error('Cleanup error:', error);\n    }\n});\n\ncrowdinApp.cron.schedule('0 0 * * *', async () => {\n    try {\n        console.log('Daily report started');\n        // Generate reports\n    } catch (error) {\n        console.error('Report error:', error);\n    }\n});\n```\n\n**Using Crowdin API Client in Cron Jobs:**\n```typescript\n// In worker/app.ts, after initializing crowdinApp\nconst crowdinApp = crowdinModule.addCrowdinEndpoints(app, configuration) as CrowdinAppUtilities;\n\n// Register cron job that processes data for multiple organizations\ncrowdinApp.cron.schedule('0 0 * * *', async () => {\n    try {\n        console.log('Daily sync started');\n        \n        // Get all metadata records\n        const allMetadata = await crowdinApp.storage.getAllMetadata();\n        \n        if (!allMetadata || allMetadata.length === 0) {\n            console.log('No metadata found, skipping sync');\n            return;\n        }\n        \n        // Filter metadata by pattern using regex (e.g., find all organization configs)\n        const configPattern = /^org_(\\d+)_config$/;\n        const orgConfigs = allMetadata.filter(record => \n            configPattern.test(record.id)\n        );\n        \n        console.log(`Found ${orgConfigs.length} organization configs to process`);\n        \n        // Process each organization separately\n        for (const configRecord of orgConfigs) {\n            try {\n                const match = configRecord.id.match(configPattern);\n                const organizationId = match?.[1];\n                const crowdinId = configRecord.crowdin_id; // domain or organizationId\n                const configData = JSON.parse(configRecord.data || '{}');\n                \n                console.log(`Processing organization ${organizationId}`);\n                \n                // Create individual Crowdin API client for this organization\n                const encryptedData = crowdinApp.encryptCrowdinConnection({\n                    crowdinId,\n                    extra: {}, // Always pass empty object\n                });\n                \n                const { client } = await crowdinApp.dencryptCrowdinConnection(encryptedData, true);\n                \n                // Use client to make API calls for this specific organization\n                const projects = await client.projectsGroupsApi.withFetchAll().listProjects();\n                console.log(`Organization ${organizationId}: Found ${projects.data.length} projects`);\n                \n                // Process organization-specific configuration\n                if (configData.autoSync) {\n                    console.log(`Organization ${organizationId}: Auto-sync enabled, processing...`);\n                    // Perform sync operations\n                }\n                \n            } catch (error) {\n                console.error(`Error processing organization ${organizationId}:`, error);\n                // Continue with next organization\n            }\n        }\n        \n        console.log('Daily sync completed');\n    } catch (error) {\n        console.error('Cron job error:', error);\n    }\n});\n```\n\n#### Best Practices\n\n1. **Use appropriate intervals for your task**\n   ```typescript\n   // ‚úÖ CORRECT - frequent checks for time-sensitive tasks\n   crowdinApp.cron.schedule('0 * * * *', async () => {\n       // Hourly notification checks\n   });\n   \n   // ‚úÖ CORRECT - less frequent for resource-intensive tasks\n   crowdinApp.cron.schedule('0 0 * * *', async () => {\n       // Daily cleanup or report generation\n   });\n   \n   // ‚ùå WRONG - using unsupported interval\n   crowdinApp.cron.schedule('*/5 * * * *', async () => {\n       // Every 5 minutes - NOT SUPPORTED\n   });\n   ```\n\n2. **Handle errors gracefully**\n   ```typescript\n   // ‚úÖ CORRECT - catch and log errors\n   crowdinApp.cron.schedule('0 * * * *', async () => {\n       try {\n           await performTask();\n       } catch (error) {\n           console.error('Cron job failed:', error);\n           // Log error but don't throw - let job complete\n       }\n   });\n   \n   // ‚ùå WRONG - unhandled errors\n   crowdinApp.cron.schedule('0 * * * *', async () => {\n       await performTask(); // May crash if it throws\n   });\n   ```\n\n3. **Keep cron jobs lightweight**\n   ```typescript\n   // ‚úÖ CORRECT - efficient processing\n   crowdinApp.cron.schedule('0 0 * * *', async () => {\n       const startTime = Date.now();\n       console.log('Task started');\n       \n       // Perform lightweight operations\n       await quickCleanup();\n       \n       console.log(`Completed in ${Date.now() - startTime}ms`);\n   });\n   \n   // ‚ùå WRONG - heavy processing that may timeout\n   crowdinApp.cron.schedule('0 * * * *', async () => {\n       // Processing millions of records - may timeout\n       const allData = await fetchAllData();\n       await processAll(allData);\n   });\n   ```\n\n4. **Always await async operations**\n   ```typescript\n   // ‚úÖ CORRECT - await all async operations\n   crowdinApp.cron.schedule('0 * * * *', async () => {\n       await saveData();\n       await processQueue();\n       console.log('All tasks completed');\n   });\n   \n   // ‚úÖ CORRECT - setTimeout with proper promise wrapper\n   crowdinApp.cron.schedule('0 * * * *', async () => {\n       await new Promise((resolve) => {\n           setTimeout(async () => {\n               await processData();\n               resolve();\n           }, 1000);\n       });\n   });\n   \n   // ‚ùå WRONG - promise without await (will not complete)\n   crowdinApp.cron.schedule('0 * * * *', async () => {\n       saveData(); // This will NOT complete before cron job ends\n       console.log('Done'); // Logs immediately, but saveData is not finished\n   });\n   \n   // ‚ùå WRONG - setTimeout without proper promise wrapper\n   crowdinApp.cron.schedule('0 * * * *', async () => {\n       setTimeout(async () => {\n           await processData(); // This will NOT execute\n       }, 1000);\n   });\n   ```\n\n5. **Log execution for debugging**\n   ```typescript\n   // ‚úÖ CORRECT - comprehensive logging\n   crowdinApp.cron.schedule('0 */6 * * *', async () => {\n       const startTime = Date.now();\n       console.log(`Cron job started at ${new Date().toISOString()}`);\n       \n       try {\n           await performTask();\n           console.log(`Completed in ${Date.now() - startTime}ms`);\n       } catch (error) {\n           console.error(`Failed after ${Date.now() - startTime}ms:`, error);\n       }\n   });\n   ```\n\n### Webhooks\n\n#### Overview\n\nWebhooks allow your app to subscribe to events that occur in Crowdin projects or organizations. When a subscribed event happens, Crowdin automatically sends the event data to your app's callback function.\n\n#### Official Documentation\n\n**üìö Complete Documentation:** [Crowdin Webhooks](https://crowdin.github.io/app-project-module/tools/webhook/)\n\n**üìö Available Events:** [Webhook Events List](https://support.crowdin.com/developer/webhooks/)\n\n**‚ö†Ô∏è CRITICAL**: Only use event names from the official events list. Invalid event names will be ignored.\n\n#### Configuration\n\nConfigure webhooks in your app configuration in `worker/app.ts`:\n\n```typescript\nconst configuration: ClientConfig = {\n    // ... other configuration ...\n    \n    // Webhook subscriptions\n    webhooks: [\n        {\n            // List of events to subscribe to\n            events: ['file.added', 'file.updated', 'file.deleted'],\n            \n            // Callback function that handles events\n            callback({ client, events, webhookContext }) {\n                console.log('Received events:', events);\n                console.log('Organization:', webhookContext.organizationId);\n                console.log('User:', webhookContext.userId);\n                \n                // Process events here\n                events.forEach(event => {\n                    console.log('Event:', event.event, 'Project:', event.file.project.id);\n                });\n            },\n            \n            deferResponse: true\n        },\n        {\n            // You can have multiple webhook subscriptions\n            events: ['suggestion.updated', 'string.added'],\n            callback({ client, events, webhookContext }) {\n                // Handle translation events\n            },\n            \n            deferResponse: true\n        }\n    ]\n};\n```\n\n#### Common Examples\n\n**File Events:**\n```typescript\nwebhooks: [\n    {\n        events: ['file.added', 'file.updated', 'file.deleted', 'file.reverted'],\n        async callback({ client, events, webhookContext }) {\n            for (const event of events) {\n                console.log(`File ${event.event} in project ${event.file.project.id}`);\n                console.log('File details:', event.file);\n                \n                // Example: Get project details when file is added\n                if (event.event === 'file.added') {\n                    const project = await client.projectsGroupsApi.getProject(event.file.project.id);\n                    console.log('Project name:', project.data.name);\n                }\n            }\n        },\n        deferResponse: true\n    }\n]\n```\n\n#### Callback Parameters\n\nThe callback function receives an object with three properties:\n\n```typescript\ninterface WebhookCallback {\n    /**\n     * Crowdin API client - use to make API calls\n     * Same client as connection.client in endpoints\n     */\n    client: CrowdinApi;\n    \n    /**\n     * Array of webhook event objects\n     * Multiple events may be batched together\n     */\n    events: WebhookEvent[];\n    \n    /**\n     * Context information about the webhook\n     */\n    webhookContext: {\n        /** Crowdin domain (e.g., \"crowdin.com\") */\n        domain: string;\n        \n        /** Organization ID where event occurred */\n        organizationId: number;\n        \n        /** User ID who installed the application */\n        userId: number;\n        \n        /** Agent ID (if authenticationType is \"crowdin_agent\") */\n        agentId?: number;\n    };\n}\n```\n\n#### Common Event Types\n\n**Project Events:**\n- `project.created` - New project added\n- `project.deleted` - Project deleted\n- `project.translated` - Project fully translated\n- `project.approved` - Project reviewed\n- `project.built` - Project built\n\n**Group Events:**\n- `group.created` - New group added\n- `group.deleted` - Group deleted\n\n**File Events:**\n- `file.added` - New file added to project\n- `file.updated` - File updated\n- `file.deleted` - File deleted from project\n- `file.reverted` - File reverted to previous version\n- `file.translated` - File fully translated\n- `file.approved` - File reviewed\n\n**String Events:**\n- `string.added` - New source string added\n- `string.updated` - Source string updated\n- `string.deleted` - Source string deleted\n\n**Translation Events:**\n- `suggestion.added` - String translation added\n- `suggestion.updated` - String translation updated\n- `suggestion.deleted` - String translation deleted\n- `suggestion.approved` - String translation approved\n- `suggestion.disapproved` - String translation disapproved\n\n**Comment Events:**\n- `stringComment.created` - String comment added\n- `stringComment.updated` - String comment updated\n- `stringComment.deleted` - String comment deleted\n- `stringComment.restored` - String comment restored\n\n**Task Events:**\n- `task.added` - New task added\n- `task.statusChanged` - Task status changed\n- `task.updated` - Task updated\n- `task.deleted` - Task deleted\n\n#### Best Practices\n\n1. **Always set deferResponse to true**\n   ```typescript\n   // ‚úÖ CORRECT - deferResponse is set to true\n   webhooks: [\n       {\n           events: ['file.added'],\n           callback({ client, events, webhookContext }) {\n               console.log('Processing events');\n           },\n           deferResponse: true  // REQUIRED!\n       }\n   ]\n   \n   // ‚ùå WRONG - missing deferResponse\n   webhooks: [\n       {\n           events: ['file.added'],\n           callback({ client, events, webhookContext }) {\n               console.log('Processing events');\n           }\n           // Missing deferResponse: true - this will cause issues!\n       }\n   ]\n   ```\n\n2. **Handle multiple events in batch**\n   ```typescript\n   // ‚úÖ CORRECT - process all events\n   callback({ client, events, webhookContext }) {\n       events.forEach(event => {\n           console.log('Processing event:', event.event);\n       });\n   }\n   \n   // ‚ùå WRONG - only processes first event\n   callback({ client, events, webhookContext }) {\n       const event = events[0];\n       console.log('Processing event:', event.event);\n   }\n   ```\n\n3. **Handle errors gracefully**\n   ```typescript\n   // ‚úÖ CORRECT - catches and logs errors\n   async callback({ client, events, webhookContext }) {\n       for (const event of events) {\n           try {\n               await processEvent(event);\n           } catch (error) {\n               console.error('Failed to process event:', event.event, error);\n               // Continue processing other events\n           }\n       }\n   }\n   ```\n\n4. **Check event type before processing**\n   ```typescript\n   // ‚úÖ CORRECT - checks event type\n   callback({ client, events, webhookContext }) {\n       events.forEach(event => {\n           if (event.event === 'file.added') {\n               console.log('New file:', event.file?.name);\n           } else if (event.event === 'file.updated') {\n               console.log('Updated file:', event.file?.name);\n           }\n       });\n   }\n   ```\n\n5. **Use webhookContext for scoping**\n   ```typescript\n   // ‚úÖ CORRECT - uses context for organization-specific logic\n   async callback({ client, events, webhookContext }) {\n       const orgId = webhookContext.organizationId;\n       const userId = webhookContext.userId;\n       \n       // Store event in metadata\n       const key = `org_${orgId}_events_${Date.now()}`;\n       // await crowdinModule.metadataStore.saveMetadata(key, events, `${webhookContext.domain || webhookContext.organizationId}`);\n   }\n   ```\n\n6. **Don't perform long-running operations**\n   ```typescript\n   // ‚úÖ CORRECT - quick processing, delegate heavy work\n   async callback({ client, events, webhookContext }) {\n       // Quick logging\n       console.log('Received', events.length, 'events');\n       \n       // Store for later processing\n       const key = `org_${webhookContext.organizationId}_queue`;\n       // await crowdinModule.metadataStore.saveMetadata(key, events, `${webhookContext.domain || webhookContext.organizationId}`);\n   }\n   \n   // ‚ö†Ô∏è PROBLEMATIC - long-running operation blocks webhook\n   async callback({ client, events, webhookContext }) {\n       // This might timeout\n       for (const event of events) {\n           await processLargeFile(event.file?.id);\n           await sendMultipleNotifications(event);\n           await updateExternalDatabase(event);\n       }\n   }\n   ```\n\n#### Event Object Structure\n\nEach event type has its own interface with specific fields. Use these interfaces to understand which data is available for each event:\n\n```typescript\n// ============================================================================\n// SHARED MODELS - Reusable data structures\n// ============================================================================\n\ninterface ProjectModel {\n    id: number;\n    name: string;\n    identifier: string;\n    sourceLanguageId: string;\n    targetLanguageIds: string[];\n}\n\ninterface UserModel {\n    id: number;\n    username: string;\n}\n\ninterface LanguageModel {\n    id: string;\n    name: string;\n}\n\ninterface FileModelBase {\n    id: number;\n    name: string;\n    title: string;\n    type: string;\n    path: string;\n    branchId: number | null;\n    directoryId: number | null;\n}\n\ninterface FileModel extends FileModelBase {\n    project: ProjectModel;\n}\n\ninterface GroupModel {\n    id: number;\n    name: string;\n    parentId: number | null;\n}\n\ninterface StringModelBase {\n    id: number;\n    identifier: string;\n    text: string;\n    context: string | null;\n    isHidden: boolean;\n}\n\ninterface StringModel extends StringModelBase {\n    file: FileModelBase;\n    project: ProjectModel;\n}\n\ninterface TranslationModelBase {\n    id: number;\n    text: string;\n}\n\ninterface TranslationModel extends TranslationModelBase {\n    user: UserModel;\n    targetLanguage: LanguageModel;\n    string: StringModel;\n}\n\ninterface TaskModel {\n    id: number;\n    type: 0 | 1; // 0 - Translate, 1 - Proofread\n    title: string;\n    status: 'todo' | 'in_progress' | 'done' | 'closed' | 'pending' | 'review';\n    sourceLanguage: LanguageModel;\n    targetLanguage: LanguageModel;\n    project: ProjectModel;\n    taskCreator: UserModel;\n}\n\ninterface CommentModelBase {\n    id: number;\n    text: string;\n    type: 'issue' | 'comment';\n    issueType: 'general_question' | 'translation_mistake' |  'context_request' |  'source_mistake';\n    issueStatus: 'resolved' | 'unresolved';\n}\n\ninterface CommentModel extends CommentModelBase {\n    string: StringModel;\n    targetLanguage: LanguageModel;\n    user: UserModel;\n    commentResolver: UserModel | null;\n}\n\ninterface BuildModel {\n    id: number;\n    downloadUrl: string;\n    project: ProjectModel;\n}\n\n// ============================================================================\n// BASE EVENT INTERFACES\n// ============================================================================\n\ninterface BaseEventWithUser {\n    user: UserModel;\n}\n\ninterface BaseProjectEvent {\n    project: ProjectModel;\n}\n\ninterface BaseGroupEvent {\n    group: GroupModel;\n}\n\ninterface BaseFileEvent {\n    file: FileModel;\n}\n\ninterface BaseStringEvent {\n    string: StringModel;\n}\n\ninterface BaseTranslationEvent {\n    translation: TranslationModel;\n}\n\ninterface BaseTaskEvent {\n    task: TaskModel;\n}\n\ninterface BaseCommentEvent {\n    comment: CommentModel;\n}\n\n// ============================================================================\n// PROJECT EVENTS\n// ============================================================================\n\ninterface ProjectCreatedEvent extends BaseProjectEvent, BaseEventWithUser {\n    event: 'project.created';\n}\n\ninterface ProjectDeletedEvent extends BaseProjectEvent, BaseEventWithUser {\n    event: 'project.deleted';\n}\n\ninterface ProjectTranslatedEvent extends BaseProjectEvent {\n    event: 'project.translated';\n    targetLanguage: LanguageModel;\n}\n\ninterface ProjectApprovedEvent extends BaseProjectEvent {\n    event: 'project.approved';\n    targetLanguage: LanguageModel;\n}\n\ninterface ProjectBuiltEvent {\n    event: 'project.built';\n    build: BuildModel;\n}\n\n// ============================================================================\n// GROUP EVENTS\n// ============================================================================\n\ninterface GroupCreatedEvent extends BaseGroupEvent, BaseEventWithUser {\n    event: 'group.created';\n}\n\ninterface GroupDeletedEvent extends BaseGroupEvent, BaseEventWithUser {\n    event: 'group.deleted';\n}\n\n// ============================================================================\n// FILE EVENTS\n// ============================================================================\n\ninterface FileAddedEvent extends BaseFileEvent, BaseEventWithUser {\n    event: 'file.added';\n}\n\ninterface FileUpdatedEvent extends BaseFileEvent, BaseEventWithUser {\n    event: 'file.updated';\n}\n\ninterface FileDeletedEvent extends BaseFileEvent, BaseEventWithUser {\n    event: 'file.deleted';\n}\n\ninterface FileRevertedEvent extends BaseFileEvent, BaseEventWithUser {\n    event: 'file.reverted';\n}\n\ninterface FileTranslatedEvent extends BaseFileEvent {\n    event: 'file.translated';\n    targetLanguage: LanguageModel;\n}\n\ninterface FileApprovedEvent extends BaseFileEvent {\n    event: 'file.approved';\n    targetLanguage: LanguageModel;\n}\n\n// ============================================================================\n// STRING EVENTS\n// ============================================================================\n\ninterface StringAddedEvent extends BaseStringEvent, BaseEventWithUser {\n    event: 'string.added';\n}\n\ninterface StringUpdatedEvent extends BaseStringEvent, BaseEventWithUser {\n    event: 'string.updated';\n}\n\ninterface StringDeletedEvent extends BaseStringEvent, BaseEventWithUser {\n    event: 'string.deleted';\n}\n\n// ============================================================================\n// TRANSLATION/SUGGESTION EVENTS\n// ============================================================================\n\ninterface SuggestionAddedEvent extends BaseTranslationEvent {\n    event: 'suggestion.added';\n}\n\ninterface SuggestionUpdatedEvent extends BaseTranslationEvent {\n    event: 'suggestion.updated';\n}\n\ninterface SuggestionDeletedEvent extends BaseTranslationEvent {\n    event: 'suggestion.deleted';\n}\n\ninterface SuggestionApprovedEvent extends BaseTranslationEvent {\n    event: 'suggestion.approved';\n}\n\ninterface SuggestionDisapprovedEvent extends BaseTranslationEvent {\n    event: 'suggestion.disapproved';\n}\n\ninterface TranslationUpdatedEvent {\n    event: 'translation.updated';\n    newTranslation: TranslationModel;\n}\n\n// ============================================================================\n// COMMENT EVENTS\n// ============================================================================\n\ninterface StringCommentCreatedEvent extends BaseCommentEvent {\n    event: 'stringComment.created';\n}\n\ninterface StringCommentUpdatedEvent extends BaseCommentEvent {\n    event: 'stringComment.updated';\n}\n\ninterface StringCommentDeletedEvent extends BaseCommentEvent {\n    event: 'stringComment.deleted';\n}\n\ninterface StringCommentRestoredEvent extends BaseCommentEvent {\n    event: 'stringComment.restored';\n}\n\n// ============================================================================\n// TASK EVENTS\n// ============================================================================\n\ninterface TaskAddedEvent extends BaseTaskEvent {\n    event: 'task.added';\n}\n\ninterface TaskStatusChangedEvent extends BaseTaskEvent {\n    event: 'task.statusChanged';\n}\n\ninterface TaskUpdatedEvent extends BaseTaskEvent {\n    event: 'task.updated';\n}\n\ninterface TaskDeletedEvent extends BaseTaskEvent {\n    event: 'task.deleted';\n}\n\n// ============================================================================\n// UNION TYPE - All possible webhook events\n// ============================================================================\n\ntype WebhookEvent = \n    // Project events\n    | ProjectCreatedEvent\n    | ProjectDeletedEvent\n    | ProjectTranslatedEvent\n    | ProjectApprovedEvent\n    | ProjectBuiltEvent\n    // Group events\n    | GroupCreatedEvent\n    | GroupDeletedEvent\n    // File events\n    | FileAddedEvent\n    | FileUpdatedEvent\n    | FileDeletedEvent\n    | FileRevertedEvent\n    | FileTranslatedEvent\n    | FileApprovedEvent\n    // String events\n    | StringAddedEvent\n    | StringUpdatedEvent\n    | StringDeletedEvent\n    // Translation/Suggestion events\n    | SuggestionAddedEvent\n    | SuggestionUpdatedEvent\n    | SuggestionDeletedEvent\n    | SuggestionApprovedEvent\n    | SuggestionDisapprovedEvent\n    | TranslationUpdatedEvent\n    // Comment events\n    | StringCommentCreatedEvent\n    | StringCommentUpdatedEvent\n    | StringCommentDeletedEvent\n    | StringCommentRestoredEvent\n    // Task events\n    | TaskAddedEvent\n    | TaskStatusChangedEvent\n    | TaskUpdatedEvent\n    | TaskDeletedEvent;\n```\n\n## Frontend Development\n\n### Crowdin Apps JS API\n\n#### Official Documentation\n\nThe `AP` object provides the Crowdin Apps JS API for interacting with the Crowdin application context.\n\n**üìö Complete API Reference:** https://support.crowdin.com/developer/crowdin-apps-js/\n\n**‚ö†Ô∏è CRITICAL**: Only use methods and types from the Crowdin Apps JS API definitions below.\n\n**Do NOT invent methods or properties that are not listed here.**\n\n#### Common Examples\n\n**Get Context (Promise-based):**\n```typescript\n// Promisified helper\nconst getContext = (): Promise<any> => {\n    return new Promise(resolve => window.AP.getContext(resolve));\n};\n\n// Usage\nconst context = await getContext();\nconsole.log('Project ID:', context.project_id);\n```\n\n**Get JWT Token (Promise-based):**\n```typescript\n// Promisified helper\nconst getJwtToken = (): Promise<string> => {\n    return new Promise(resolve => window.AP.getJwtToken(resolve));\n};\n\n// Usage with fetch\nconst token = await getJwtToken();\nconst response = await fetch(`/api/endpoint?jwt=${token}`);\nconst data = await response.json();\n```\n\n#### Best Practices\n\n1. **Handle errors gracefully**\n   ```typescript\n   try {\n       const context = await getContext();\n       if (!context.organization_id) {\n           throw new Error('Organization ID not found');\n       }\n       // Your code\n   } catch (error) {\n       console.error('Failed to get context:', error);\n   }\n   ```\n\n#### Complete Type Definitions\n\n##### Global AP Object Structure\n\n```typescript\ndeclare namespace AP {\n    // Global Actions\n    function getContext(callback: (context: Context) => void): void;\n    function getJwtToken(callback: (token: string) => void): void;\n    function getTheme(): 'light' | 'dark';\n    function redirect(path: string): void;\n}\n```\n\n##### Type Definitions\n\n```typescript\n// Context Information\ninterface Context {\n    project_id: number;\n    organization_id: number;\n}\n```\n\n## Development Workflow\n\n### 1. Configure Your App Identity\n\n**‚ö†Ô∏è Important**: You MUST update the configuration in `worker/app.ts` before deployment:\n\n```typescript\nconst configuration: ClientConfig = {\n    name: \"Your App Name\",           // Change this to your app's display name\n    identifier: \"your-app-id\",       // Change to unique identifier (lowercase, hyphens)\n    description: \"Your app description\", // Change to describe your app's purpose\n    // ... rest of configuration\n}\n```\n\n**Note**: The `identifier` must be unique across all Crowdin apps. Use format like: `company-profile-menu`\n\n### 2. Key Files to Modify\n\n- `worker/app.ts` - Add new API endpoints here\n- `src/pages/HomePage.tsx` - Main page component (customize for your app logic)\n- `src/components/app-sidebar.tsx` - Sidebar navigation (customize menu items)\n- `src/components/layout/AppLayout.tsx` - Application layout (customize layout structure)\n- `src/index.css` - Customize global styles and Tailwind theme\n- `tailwind.config.js` - Add custom colors and extend theme"
    }
  },
  {
    "name": "crowdin-project-tools",
    "language": "typescript",
    "frameworks": [
      "@dnd-kit",
      "@hookform/resolvers",
      "autoprefixer",
      "class-variance-authority",
      "cloudflare",
      "clsx",
      "cmdk",
      "date-fns",
      "express",
      "framer-motion",
      "immer",
      "input-otp",
      "next",
      "postcss",
      "react",
      "recharts",
      "sonner",
      "tailwind",
      "tw-animate-css",
      "typescript",
      "vaul",
      "vite",
      "wrangler",
      "zod",
      "zustand"
    ],
    "description": {
      "selection": "# Template Selection\n\nCrowdin app with Project Tools module.\n\nUse when:\n- Building project-specific tools and utilities\n- Creating project management extensions\n- Developing project analysis and reporting tools\n- Building project-level integrations with external APIs\n- Creating custom project workflows and automation\n\nAvoid when:\n- Integrating custom AI providers (use AI Provider instead)\n- Building machine translation integrations (use Custom MT instead)\n- Building editor extensions (use Editor Right Panel instead)\n- Transforming files during import/export (use File Processing instead)\n- Building organization-wide tools (use Organization Menu instead)\n- Building user profile tools (use Profile Resources Menu instead)\n\nBuilt with:\n- Crowdin Apps JS API\n- Crowdin Apps SDK (@crowdin/app-project-module)\n- React\n- ShadCN UI\n- Tailwind\n- Lucide Icons\n- ESLint\n- Vite\n- TypeScript\n- Express.js\n- Cloudflare Workers",
      "usage": "# Usage\n\n## Overview\nCrowdin app with Project Tools module for project-specific functionality.\n- Backend: TypeScript with Express.js and Crowdin Apps SDK\n- Frontend: React + TypeScript + ShadCN UI + Crowdin Apps JS API\n\n## Tech Stack\n- Crowdin Apps JS API\n- Crowdin Apps SDK (@crowdin/app-project-module)\n- React\n- ShadCN UI\n- Tailwind\n- Lucide Icons\n- ESLint\n- Vite\n- TypeScript\n- Express.js\n- Cloudflare Workers\n\n## Development Restrictions\n- **Tailwind Colors**: Hardcode custom colors in `tailwind.config.js`, NOT in `index.css`\n- **Components**: Use existing ShadCN components instead of writing custom ones\n- **Icons**: Import from `lucide-react` directly\n- **Error Handling**: ErrorBoundary components are pre-implemented\n- **Authentication**: Always use JWT tokens from Crowdin for API requests\n- **Project Tools Configuration**: Don't modify the projectTools configuration structure\n- **Scopes**: Ensure your app has appropriate API scopes\n- **Storage Keys**: Always include organizationId in metadata keys to isolate data per organization\n\n## Styling\n- Responsive, accessible\n- Prefer ShadCN components; Tailwind for layout/spacing/typography\n- Use framer-motion sparingly for micro-interactions\n\n## Project Structure\n\n### Backend Structure\n- `worker/app.ts` - Express app factory with Project Tools module configuration\n- `worker/index.ts` - Cloudflare Worker entry point (HTTP handler, cron scheduler, middleware)\n- `worker/types/` - Backend TypeScript type definitions\n  - `cloudflare-env.d.ts` - Cloudflare environment types (KV storage, secrets)\n\n### Frontend Structure\n- `index.html` - HTML entry point with Crowdin Apps JS API script\n- `src/main.tsx` - React entry point with ErrorBoundary wrapper\n- `src/index.css` - Global styles and Tailwind CSS customizations\n- `src/components/` - React components\n  - `app-sidebar.tsx` - Application sidebar navigation\n  - `ErrorBoundary.tsx` - React error boundary with backend error reporting\n  - `ErrorFallback.tsx` - Fallback UI component for error states\n  - `RouteErrorBoundary.tsx` - Error boundary for routing errors\n  - `layout/` - Layout components\n    - `AppLayout.tsx` - Main application layout wrapper\n  - `ui/` - ShadCN UI components (button, card, sonner, etc.)\n- `src/pages/` - Page components\n  - `HomePage.tsx` - Home page component (main entry point for your app logic)\n- `src/hooks/` - Custom React hooks\n  - `use-mobile.tsx` - Hook for detecting mobile breakpoints\n- `src/lib/` - Utility modules\n  - `utils.ts` - Tailwind utility functions (`cn` for class merging)\n  - `errorReporter.ts` - Client-side error reporting to backend\n  - `apiClient.ts` - Generic API call wrapper with JWT token handling\n- `src/types/` - TypeScript type definitions\n  - `global.d.ts` - Global type declarations\n  - `vite-env.d.ts` - Vite environment types\n\n## Backend Development\n\n### App Configuration\n\nConfigure your app identity in `worker/app.ts`:\n\n```typescript\nconst configuration: ClientConfig = {\n    name: \"Your App Name\",                    // Display name shown in Crowdin UI\n    identifier: \"your-unique-app-identifier\", // Unique ID (lowercase, hyphens)\n    description: \"Your app description\",      // Brief description of functionality\n    // ... rest of configuration\n}\n```\n\n**Guidelines:**\n- **identifier**: Must be unique across all Crowdin apps. Format: `company-project-tools`\n- **name**: User-friendly display name (e.g., \"Project Analyzer\")\n- **description**: Brief explanation of what your app does\n\n#### Required Scopes\n\nAdd scopes to configuration in `worker/app.ts` based on your app's functionality.\n\n**‚ö†Ô∏è IMPORTANT**: Only use scopes from the list below. Do not invent or use non-existent scopes!\n\n```typescript\nconst configuration: ClientConfig = {\n    // ... other configuration ...\n    scopes: [\n        // Choose from the following valid scopes:\n        \n        // General scopes\n        crowdinModule.Scope.NOTIFICATIONS,               // 'notification' - Notifications management\n        \n        // Project-level scopes\n        crowdinModule.Scope.PROJECTS,                    // 'project' - Project management\n        crowdinModule.Scope.TASKS,                       // 'project.task' - Project tasks\n        crowdinModule.Scope.REPORTS,                     // 'project.report' - Project reports\n        crowdinModule.Scope.TRANSLATION_STATUS,          // 'project.status' - Translation status\n        crowdinModule.Scope.SOURCE_FILES_AND_STRINGS,    // 'project.source' - Source files and strings\n        crowdinModule.Scope.WEBHOOKS,                    // 'project.webhook' - Project webhooks\n        crowdinModule.Scope.TRANSLATIONS,                // 'project.translation' - Translations\n        crowdinModule.Scope.SCREENSHOTS,                 // 'project.screenshot' - Screenshots\n        \n        // Organization-level scopes\n        crowdinModule.Scope.USERS,                       // 'user' - User management\n        crowdinModule.Scope.TEAMS,                       // 'team' - Team management\n        crowdinModule.Scope.GROUPS,                      // 'group' - Group management\n        crowdinModule.Scope.ORGANIZATION_WEBHOOKS,       // 'webhook' - Organization webhooks\n        crowdinModule.Scope.VENDORS,                     // 'vendor' - Vendor management\n        crowdinModule.Scope.FIELDS,                      // 'field' - Custom fields\n        crowdinModule.Scope.SECURITY_LOGS,               // 'security-log' - Security logs\n        crowdinModule.Scope.APPLICATIONS,                // 'application' - Applications management\n        \n        // Resources\n        crowdinModule.Scope.TRANSLATION_MEMORIES,        // 'tm' - Translation memories\n        crowdinModule.Scope.MACHINE_TRANSLATION_ENGINES, // 'mt' - Machine translation engines\n        crowdinModule.Scope.GLOSSARIES,                  // 'glossary' - Glossaries\n        \n        // AI-related scopes\n        crowdinModule.Scope.AI,                          // 'ai' - AI features\n        crowdinModule.Scope.AI_PROVIDERS,                // 'ai.provider' - AI providers\n        crowdinModule.Scope.AI_PROMPTS,                  // 'ai.prompt' - AI prompts\n        crowdinModule.Scope.AI_PROXIES,                  // 'ai.proxy' - AI proxies\n    ]\n}\n```\n\n### Project Tools Module Configuration\n\nConfigure the Project Tools module in `worker/app.ts`:\n\n```typescript\nconst configuration: ClientConfig = {\n    // ... other configuration ...\n\n    projectTools: {\n      fileName: 'index.html',\n      uiPath: '/'\n    }\n}\n```\n\n### API Endpoints Best Practices\n\n#### Common Examples\n\n**Standard Endpoint:**\n```typescript\napp.post('/api/process-data', async (req: Request, res: Response) => {\n    try {\n        const jwt = req.query.jwt as string;\n        const { data } = req.body;\n        \n        if (!jwt) {\n            return res.status(400).json({ success: false, error: 'JWT token is required' });\n        }\n        if (!data) {\n            return res.status(400).json({ success: false, error: 'Data is required' });\n        }\n\n        const connection = await crowdinApp.establishCrowdinConnection(jwt, undefined);\n        \n        // Your async logic here\n        const result = await processData(data);\n        \n        res.json({ \n            success: true, \n            result\n        });\n    } catch (error) {\n        console.error('Error:', error);\n        res.status(500).json({ success: false, error: 'Operation failed' });\n    }\n});\n```\n\n#### Best Practices\n\n1. **Always await async operations**\n   ```typescript\n   // ‚úÖ CORRECT - all operations are awaited\n   app.post('/api/save-config', async (req: Request, res: Response) => {\n       const jwt = req.query.jwt as string;\n       const connection = await crowdinApp.establishCrowdinConnection(jwt, undefined);\n       \n       await crowdinApp.saveMetadata(key, data, connection.context.crowdinId);\n       \n       res.json({ success: true });\n   });\n   \n   // ‚ùå WRONG - missing await, operation will NOT complete\n   app.post('/api/save-config', async (req: Request, res: Response) => {\n       const jwt = req.query.jwt as string;\n       const connection = await crowdinApp.establishCrowdinConnection(jwt, undefined);\n       \n       // This will NOT save! Response is sent before operation completes\n       crowdinApp.saveMetadata(key, data, connection.context.crowdinId);\n       \n       res.json({ success: true });\n   });\n   ```\n\n2. **Always return response after all operations complete**\n   ```typescript\n   // ‚úÖ CORRECT - response sent after all operations\n   app.post('/api/update', async (req: Request, res: Response) => {\n       const connection = await crowdinApp.establishCrowdinConnection(jwt, undefined);\n       \n       await operation1();\n       await operation2();\n       await operation3();\n       \n       res.json({ success: true }); // All operations completed\n   });\n   \n   // ‚ùå WRONG - response sent too early\n   app.post('/api/update', async (req: Request, res: Response) => {\n       const connection = await crowdinApp.establishCrowdinConnection(jwt, undefined);\n       \n       res.json({ success: true }); // Sent immediately\n       \n       await operation1(); // These will NOT execute\n       await operation2();\n       await operation3();\n   });\n   ```\n\n3. **Use Promise.all for independent parallel operations**\n   ```typescript\n   // ‚úÖ CORRECT - parallel operations (faster)\n   const [result1, result2, result3] = await Promise.all([\n       connection.client.projectsGroupsApi.getProject(id1),\n       connection.client.projectsGroupsApi.getProject(id2),\n       connection.client.projectsGroupsApi.getProject(id3)\n   ]);\n   \n   // ‚ùå WRONG - sequential operations (slower)\n   const result1 = await connection.client.projectsGroupsApi.getProject(id1);\n   const result2 = await connection.client.projectsGroupsApi.getProject(id2);\n   const result3 = await connection.client.projectsGroupsApi.getProject(id3);\n   ```\n\n4. **Wrap all async code in try-catch**\n   ```typescript\n   // ‚úÖ CORRECT - comprehensive error handling\n   app.get('/api/data', async (req: Request, res: Response) => {\n       try {\n           const connection = await crowdinApp.establishCrowdinConnection(jwt, undefined);\n           const data = await fetchData();\n           res.json({ success: true, data });\n       } catch (error) {\n           console.error('Error:', error);\n           res.status(500).json({ success: false, error: 'Operation failed' });\n       }\n   });\n   \n   // ‚ùå WRONG - no error handling\n   app.get('/api/data', async (req: Request, res: Response) => {\n       const connection = await crowdinApp.establishCrowdinConnection(jwt, undefined);\n       const data = await fetchData(); // May throw unhandled error\n       res.json({ success: true, data });\n   });\n   ```\n\n5. **Never use setTimeout without proper promise wrapper**\n   ```typescript\n   // ‚úÖ CORRECT - setTimeout with promise wrapper\n   app.get('/api/delayed', async (req: Request, res: Response) => {\n       await new Promise((resolve) => {\n           setTimeout(async () => {\n               await saveData();\n               resolve(undefined);\n           }, 1000);\n       });\n       \n       res.json({ success: true });\n   });\n   \n   // ‚ùå WRONG - setTimeout without await (will NOT execute)\n   app.get('/api/delayed', async (req: Request, res: Response) => {\n       setTimeout(async () => {\n           await saveData(); // This will NOT execute\n       }, 1000);\n       \n       res.json({ success: true }); // Sent immediately\n   });\n   ```\n\n6. **Always check for required parameters early**\n   ```typescript\n   // ‚úÖ CORRECT - validate parameters first\n   app.post('/api/process', async (req: Request, res: Response) => {\n       const jwt = req.query.jwt as string;\n       const { projectId, data } = req.body;\n       \n       // Validate early\n       if (!jwt) {\n           return res.status(400).json({ error: 'JWT token is required' });\n       }\n       if (!projectId) {\n           return res.status(400).json({ error: 'Project ID is required' });\n       }\n       if (!data) {\n           return res.status(400).json({ error: 'Data is required' });\n       }\n       \n       // Continue with processing\n       const connection = await crowdinApp.establishCrowdinConnection(jwt, undefined);\n       // ... rest of the logic\n   });\n   ```\n\n### Crowdin API Client\n\n#### Official Documentation\n\nThe `connection.client` object is an instance of `@crowdin/crowdin-api-client`.\n\n**üìö Complete API Reference:** https://crowdin.github.io/crowdin-api-client-js/modules.html\n\n**‚ö†Ô∏è CRITICAL**: Only use methods documented in the official API reference. Do NOT invent or assume methods exist.\n\n#### Common Examples\n\n**Standard Endpoint Template:**\n```typescript\napp.get('/api/your-endpoint', async (req: Request, res: Response) => {\n    try {\n        const jwt = req.query.jwt as string;\n        if (!jwt) {\n            return res.status(400).json({ success: false, error: 'JWT token is required' });\n        }\n\n        if (!crowdinApp.establishCrowdinConnection) {\n            return res.status(500).json({ success: false, error: 'Crowdin connection method not available' });\n        }\n\n        const connection = await crowdinApp.establishCrowdinConnection(jwt, undefined);\n\n        if (!connection.client) {\n            return res.status(500).json({ success: false, error: 'Crowdin API client not available' });\n        }\n\n        const userId = connection.context.jwtPayload.context.user_id;\n        const organizationId = connection.context.jwtPayload.context.organization_id;\n\n        // Your logic here using connection.client API\n        \n        res.status(200).json({ success: true, data: result });\n    } catch (error) {\n        console.error('Error:', error);\n        res.status(500).json({ success: false, error: 'Operation failed' });\n    }\n});\n```\n\n**Get Project Details:**\n```typescript\nconst response = await connection.client.projectsGroupsApi.getProject(projectId);\n\n// Access project properties\nconst project = response.data;\nconst projectName = project.name;                    // string\nconst sourceLanguageId = project.sourceLanguageId;   // string\nconst targetLanguageIds = project.targetLanguageIds; // string[]\nconst description = project.description;             // string | null\n```\n\n**List All Projects (with pagination):**\n```typescript\nconst response = await connection.client.projectsGroupsApi.withFetchAll().listProjects();\n\n// Iterate through all projects\nresponse.data.forEach((projectItem: ResponseObject<ProjectsGroupsModel.Project>) => {\n  const projectId = projectItem.data.id;\n  const projectName = projectItem.data.name;\n  const groupId = projectItem.data.groupId; // number | null\n});\n```\n\n**Get Supported Languages:**\n```typescript\nconst response = await connection.client.languagesApi.withFetchAll().listSupportedLanguages();\n\n// Filter languages\nconst targetLanguageIds = ['uk', 'pl', 'de'];\nconst projectLanguages = response.data.filter(\n  (lang: ResponseObject<LanguagesModel.Language>) => targetLanguageIds.includes(lang.data.id)\n);\n\n// Map to simpler structure\nconst languages = projectLanguages.map((lang: ResponseObject<LanguagesModel.Language>) => ({\n  id: lang.data.id,           // string: \"uk\"\n  name: lang.data.name,       // string: \"Ukrainian\"\n  locale: lang.data.locale,   // string: \"uk-UA\"\n  osxLocale: lang.data.osxLocale // string\n}));\n```\n\n**List Source Files:**\n```typescript\nconst response = await connection.client.sourceFilesApi.withFetchAll().listProjectFiles(projectId);\n\nresponse.data.forEach((fileItem: ResponseObject<SourceFilesModel.File>) => {\n  const file = fileItem.data;\n  const fileId = file.id;             // number\n  const fileName = file.name;         // string\n  const branchId = file.branchId;     // number | null\n  const directoryId = file.directoryId; // number | null\n});\n```\n\n#### Best Practices\n\n1. **Always access data via `.data` property**\n   ```typescript\n   // ‚úÖ CORRECT\n   const project = response.data;\n   const projectName = response.data.name;\n   \n   // ‚ùå WRONG - will be undefined\n   const projectName = response.name;\n   ```\n\n2. **Use withFetchAll() for complete data**\n   ```typescript\n   // ‚úÖ CORRECT - gets all items\n   const response = await connection.client.languagesApi.withFetchAll().listSupportedLanguages();\n   \n   // ‚ö†Ô∏è PARTIAL - only first page (25 items)\n   const response = await connection.client.languagesApi.listSupportedLanguages();\n   ```\n\n3. **Handle nullable properties**\n   ```typescript\n   const description = response.data.description || 'No description';\n   const groupId = response.data.groupId ?? null;\n   ```\n\n4. **Handle errors properly**\n   ```typescript\n   try {\n     const response = await connection.client.projectsGroupsApi.getProject(projectId);\n     const project = response.data;\n     // Use project data\n   } catch (error: any) {\n     console.error('Crowdin API Error:', error);\n\n     // API errors have specific structure\n     if (error.code === 404) {\n       return res.status(404).json({ error: 'Project not found' });\n     }\n     \n     return res.status(500).json({\n       error: 'API request failed',\n       details: error.message\n     });\n   }\n   ```\n\n5. **Use TypeScript types**\n   ```typescript\n   import type { ResponseObject, ProjectsGroupsModel } from '@crowdin/crowdin-api-client';\n   \n   // Use in your code\n   const response: ResponseObject<ProjectsGroupsModel.Project> = await connection.client.projectsGroupsApi.getProject(projectId);\n   const project: ProjectsGroupsModel.Project = response.data;\n   ```\n\n6. **Always sort data explicitly when order matters**\n   ```typescript\n   // ‚úÖ CORRECT - sort projects by creation date (newest first)\n   const response = await connection.client.projectsGroupsApi.withFetchAll().listProjects();\n   const sortedByDate = response.data.sort(\n     (a: ResponseObject<ProjectsGroupsModel.Project>, b: ResponseObject<ProjectsGroupsModel.Project>) => {\n       const dateA = new Date(a.data.createdAt).getTime();\n       const dateB = new Date(b.data.createdAt).getTime();\n       return dateB - dateA; // Descending order (newest first)\n     }\n   );\n   \n   // ‚ùå WRONG - assuming data is already sorted by date\n   const response = await connection.client.projectsGroupsApi.withFetchAll().listProjects();\n   // Directly using response.data without sorting - order is not guaranteed!\n   ```\n\n7. **Never use CroQL - fetch all data and filter manually**\n   ```typescript\n   // ‚úÖ CORRECT - fetch all strings and filter manually\n   const allStrings = await connection.client.sourceStringsApi.withFetchAll().listProjectStrings(projectId);\n   \n   // Filter for specific criteria\n   const filteredStrings = allStrings.data.filter(\n     (item: ResponseObject<SourceStringsModel.String>) => {\n       const str = item.data;\n       return str.text.includes('welcome') && !str.isHidden;\n     }\n   );\n   \n   // ‚ùå WRONG - using CroQL queries\n   const response = await connection.client.sourceStringsApi.listProjectStrings(projectId, {\n     croql: 'text contains \"welcome\" AND isHidden = false'\n   });\n   // CroQL should be avoided - fetch all data and filter in your code instead\n   ```\n\n#### Complete Type Definitions\n\n**‚ö†Ô∏è CRITICAL**: Only use methods and types from `@crowdin/crowdin-api-client` definitions below.\n\n**Do NOT invent methods or properties that are not listed here.**\n\n<!-- CROWDIN_API_CLIENT_TYPES_START -->\n\n##### ai/index.d.ts\n\n```typescript\nimport { CrowdinApi, DownloadLink, PaginationOptions, PatchRequest, PlainObject, ResponseList, ResponseObject, Status } from '../core';\nexport declare class Ai extends CrowdinApi {\n    listAiOrganizationCustomPlaceholders(options?: PaginationOptions): Promise<ResponseList<AiModel.CustomPlaceholder>>;\n    addAiOrganizationCustomPlaceholder(request: AiModel.AddCustomPlaceholderRequest): Promise<ResponseObject<AiModel.CustomPlaceholder>>;\n    getAiOrganizationCustomPlaceholder(aiCustomPlaceholderId: number): Promise<ResponseObject<AiModel.CustomPlaceholder>>;\n    deleteAiOrganizationCustomPlaceholder(aiCustomPlaceholderId: number): Promise<void>;\n    editAiOrganizationCustomPlaceholder(aiCustomPlaceholderId: number, request: PatchRequest[]): Promise<ResponseObject<AiModel.CustomPlaceholder>>;\n    generateAiOrganizationPromptFineTuningDataset(aiPromptId: number, request: AiModel.GenerateFineTuningDataset): Promise<ResponseObject<Status<AiModel.FineTuningDataset>>>;\n    getAiOrganizationPromptFineTuningDatasetStatus(aiPromptId: number, jobIdentifier: string): Promise<ResponseObject<Status<AiModel.FineTuningDataset>>>;\n    listAiOrganizationPromptFineTuningEvents(aiPromptId: number, jobIdentifier: string, options?: PaginationOptions): Promise<ResponseList<AiModel.PromptFineTuningEvent>>;\n    listAiOrganizationPromptFineTuningJobs(options?: AiModel.ListPromptFineTuningJobsOptions): Promise<ResponseList<Status<AiModel.FineTuningJob>>>;\n    createAiOrganizationPromptFineTuningJob(aiPromptId: number, request: AiModel.GenerateFineTuningJob): Promise<ResponseObject<Status<AiModel.FineTuningJob>>>;\n    getAiOrganizationPromptFineTuningJobStatus(aiPromptId: number, jobIdentifier: string): Promise<ResponseObject<Status<AiModel.FineTuningJob>>>;\n    downloadAiOrganizationPromptFineTuningDataset(aiPromptId: number, jobIdentifier: string): Promise<ResponseObject<DownloadLink>>;\n    cloneAiOrganizationPrompt(aiPromptId: number, request?: {\n        name?: string;\n    }): Promise<ResponseObject<AiModel.AiPromptResponse>>;\n    listAiOrganizationPrompts(options?: AiModel.ListAiPromptsOptions): Promise<ResponseList<AiModel.AiPromptResponse>>;\n    addAiOrganizationPrompt(request: AiModel.AddAiPromptRequest): Promise<ResponseObject<AiModel.AiPromptResponse>>;\n    generateAiOrganizationPromptCompletion(aiPromptId: number, request: AiModel.GenerateAiPromptCompletionRequest): Promise<ResponseObject<Status<AiModel.AiPromptCompletionAttribute>>>;\n    getAiOrganizationPromptCompletionStatus(aiPromptId: number, completionId: string): Promise<ResponseObject<Status<AiModel.AiPromptCompletionAttribute>>>;\n    cancelAiOrganizationPromptCompletion(aiPromptId: number, completionId: string): Promise<void>;\n    downloadAiOrganizationPromptCompletion(aiPromptId: number, completionId: string): Promise<ResponseObject<DownloadLink>>;\n    getAiOrganizationPrompt(aiPromptId: number): Promise<ResponseObject<AiModel.AiPromptResponse>>;\n    deleteAiOrganizationPrompt(aiPromptId: number): Promise<void>;\n    editAiOrganizationPrompt(aiPromptId: number, request: PatchRequest[]): Promise<ResponseObject<AiModel.AiPromptResponse>>;\n    listAiOrganizationProviders(options?: PaginationOptions): Promise<ResponseList<AiModel.AiProviderResponse>>;\n    addAiOrganizationProvider(request: AiModel.AddAiProviderRequest): Promise<ResponseObject<AiModel.AiProviderResponse>>;\n    getAiOrganizationProvider(aiProviderId: number): Promise<ResponseObject<AiModel.AiProviderResponse>>;\n    deleteAiOrganizationProvider(aiProviderId: number): Promise<void>;\n    editAiOrganizationProvider(aiProviderId: number, request: PatchRequest[]): Promise<ResponseObject<AiModel.AiProviderResponse>>;\n    listAiOrganizationProviderModels(aiProviderId: number, options?: PaginationOptions): Promise<ResponseList<AiModel.AiProviderModelResponse>>;\n    listAiOrganizationAllProviderModels(options?: PaginationOptions): Promise<ResponseList<AiModel.AiProviderModelResponse>>;\n    createAiOrganizationProxyChatCompletion(aiProviderId: number, request?: AiModel.OtherChatCompletionRequest | AiModel.GoogleGeminiChatCompletionRequest): Promise<ResponseObject<AiModel.AiProviderProxyResponseData>>;\n    generateAiOrganizationReport(request: AiModel.AiReport): Promise<ResponseObject<Status<AiModel.AiReport>>>;\n    checkAiOrganizationReportStatus(aiReportId: string): Promise<ResponseObject<Status<AiModel.AiReport>>>;\n    downloadAiOrganizationReport(aiReportId: string): Promise<ResponseObject<DownloadLink>>;\n    getAiOrganizationSettings(): Promise<ResponseObject<AiModel.AiSettings>>;\n    editAiOrganizationSettings(request: PatchRequest[]): Promise<ResponseObject<AiModel.AiSettings>>;\n    listAiUserCustomPlaceholders(userId: number, options?: PaginationOptions): Promise<ResponseList<AiModel.CustomPlaceholder>>;\n    addAiUserCustomPlaceholder(userId: number, request: AiModel.AddCustomPlaceholderRequest): Promise<ResponseObject<AiModel.CustomPlaceholder>>;\n    getAiUserCustomPlaceholder(userId: number, aiCustomPlaceholderId: number): Promise<ResponseObject<AiModel.CustomPlaceholder>>;\n    deleteAiUserCustomPlaceholder(userId: number, aiCustomPlaceholderId: number): Promise<void>;\n    editAiUserCustomPlaceholder(userId: number, aiCustomPlaceholderId: number, request: PatchRequest[]): Promise<ResponseObject<AiModel.CustomPlaceholder>>;\n    generateAiUserPromptFineTuningDataset(userId: number, aiPromptId: number, request: AiModel.GenerateFineTuningDataset): Promise<ResponseObject<Status<AiModel.FineTuningDataset>>>;\n    getAiUserPromptFineTuningDatasetStatus(userId: number, aiPromptId: number, jobIdentifier: string): Promise<ResponseObject<Status<AiModel.FineTuningDataset>>>;\n    listAiUserPromptFineTuningEvents(userId: number, aiPromptId: number, jobIdentifier: string, options?: PaginationOptions): Promise<ResponseList<AiModel.PromptFineTuningEvent>>;\n    listAiUserPromptFineTuningJobs(userId: number, options?: AiModel.ListPromptFineTuningJobsOptions): Promise<ResponseList<Status<AiModel.FineTuningJob>>>;\n    createAiUserPromptFineTuningJob(userId: number, aiPromptId: number, request: AiModel.GenerateFineTuningJob): Promise<ResponseObject<Status<AiModel.FineTuningJob>>>;\n    getAiUserPromptFineTuningJobStatus(userId: number, aiPromptId: number, jobIdentifier: string): Promise<ResponseObject<Status<AiModel.FineTuningJob>>>;\n    downloadAiUserPromptFineTuningDataset(userId: number, aiPromptId: number, jobIdentifier: string): Promise<ResponseObject<DownloadLink>>;\n    cloneAiUserPrompt(userId: number, aiPromptId: number, request?: {\n        name?: string;\n    }): Promise<ResponseObject<AiModel.AiPromptResponse>>;\n    listAiUserPrompts(userId: number, options?: AiModel.ListAiPromptsOptions): Promise<ResponseList<AiModel.AiPromptResponse>>;\n    addAiUserPrompt(userId: number, request: AiModel.AddAiPromptRequest): Promise<ResponseObject<AiModel.AiPromptResponse>>;\n    generateAiUserPromptCompletion(userId: number, aiPromptId: number, request: AiModel.GenerateAiPromptCompletionRequest): Promise<ResponseObject<Status<AiModel.AiPromptCompletionAttribute>>>;\n    getAiUserPromptCompletionStatus(userId: number, aiPromptId: number, completionId: string): Promise<ResponseObject<Status<AiModel.AiPromptCompletionAttribute>>>;\n    cancelAiUserPromptCompletion(userId: number, aiPromptId: number, completionId: string): Promise<void>;\n    downloadAiUserPromptCompletion(userId: number, aiPromptId: number, completionId: string): Promise<ResponseObject<DownloadLink>>;\n    getAiUserPrompt(userId: number, aiPromptId: number): Promise<ResponseObject<AiModel.AiPromptResponse>>;\n    deleteAiUserPrompt(userId: number, aiPromptId: number): Promise<void>;\n    editAiUserPrompt(userId: number, aiPromptId: number, request: PatchRequest[]): Promise<ResponseObject<AiModel.AiPromptResponse>>;\n    listAiUserProviders(userId: number, options?: PaginationOptions): Promise<ResponseList<AiModel.AiProviderResponse>>;\n    addAiUserProvider(userId: number, request: AiModel.AddAiProviderRequest): Promise<ResponseObject<AiModel.AiProviderResponse>>;\n    getAiUserProvider(userId: number, aiProviderId: number): Promise<ResponseObject<AiModel.AiProviderResponse>>;\n    deleteAiUserProvider(userId: number, aiProviderId: number): Promise<void>;\n    editAiUserProvider(userId: number, aiProviderId: number, request: PatchRequest[]): Promise<ResponseObject<AiModel.AiProviderResponse>>;\n    listAiUserProviderModels(userId: number, aiProviderId: number, options?: PaginationOptions): Promise<ResponseList<AiModel.AiProviderModelResponse>>;\n    listAiUserAllProviderModels(userId: number, options?: PaginationOptions): Promise<ResponseList<AiModel.AiProviderModelResponse>>;\n    createAiUserProxyChatCompletion(userId: number, aiProviderId: number, request?: AiModel.OtherChatCompletionRequest | AiModel.GoogleGeminiChatCompletionRequest): Promise<ResponseObject<AiModel.AiProviderProxyResponseData>>;\n    generateAiUserReport(userId: number, request: AiModel.AiReport): Promise<ResponseObject<Status<AiModel.AiReport>>>;\n    checkAiUserReportStatus(userId: number, aiReportId: string): Promise<ResponseObject<Status<AiModel.AiReport>>>;\n    downloadAiUserReport(userId: number, aiReportId: string): Promise<ResponseObject<DownloadLink>>;\n    getAiUsertSettings(userId: number): Promise<ResponseObject<AiModel.AiSettings>>;\n    editAiUserSettings(userId: number, request: PatchRequest[]): Promise<ResponseObject<AiModel.AiSettings>>;\n}\nexport declare namespace AiModel {\n    interface CustomPlaceholder {\n        id: number;\n        description: string;\n        placeholder: string;\n        value: string;\n        createdAt: string;\n        updatedAt: string;\n    }\n    interface AddCustomPlaceholderRequest {\n        description: string;\n        placeholder: string;\n        value: string;\n    }\n    interface FineTuningDataset {\n        projectIds: number[];\n        tmIds: number[];\n        purpose: 'training' | 'validation';\n        dateFrom: string;\n        dateTo: string;\n        maxFileSize: number;\n        minExamplesCount: number;\n        maxExamplesCount: number;\n    }\n    interface GenerateFineTuningDataset {\n        projectIds?: number[];\n        tmIds?: number[];\n        purpose?: 'training' | 'validation';\n        dateFrom?: string;\n        dateTo?: string;\n        maxFileSize?: number;\n        minExamplesCount?: number;\n        maxExamplesCount?: number;\n    }\n    interface GenerateFineTuningJob {\n        dryRun?: boolean;\n        hyperparameters?: {\n            batchSize: number;\n            learningRateMultiplier: number;\n            nEpochs: number;\n        };\n        trainingOptions: Omit<GenerateFineTuningDataset, 'purpose'>;\n        validationOptions?: Omit<GenerateFineTuningDataset, 'purpose'>;\n    }\n    interface FineTuningJob {\n        dryRun: boolean;\n        aiPromptId: number;\n        hyperparameters: {\n            batchSize: number;\n            learningRateMultiplier: number;\n            nEpochs: number;\n        };\n        trainingOptions: Omit<GenerateFineTuningDataset, 'purpose'>;\n        validationOptions: Omit<GenerateFineTuningDataset, 'purpose'>;\n        baseModel: string;\n        fineTunedModel: string;\n        trainedTokensCount: number;\n        trainingDatasetUrl: string;\n        validationDatasetUrl: string;\n        metadata: PlainObject;\n    }\n    interface PromptFineTuningEvent {\n        id: string;\n        type: string;\n        message: string;\n        data: {\n            step: number;\n            totalSteps: number;\n            trainingLoss: number;\n            validationLoss: number;\n            fullValidationLoss: number;\n        };\n        createdAt: string;\n    }\n    interface ListPromptFineTuningJobsOptions extends PaginationOptions {\n        statuses: string;\n        orderBy: string;\n    }\n    interface ListAiPromptsOptions extends PaginationOptions {\n        projectId?: number;\n        action?: Action;\n    }\n    interface AiPromptResponse {\n        id: number;\n        name: string;\n        action: Action;\n        aiProviderId: number;\n        aiModelId: string;\n        isEnabled: boolean;\n        enabledProjectIds: number[];\n        config: AiModel.AiPromptConfigBasicPreTranslate | AiModel.AiPromptConfigBasicAssistAction | AiModel.AiPromptConfigBasicAligmentAction | AiModel.AiPromptConfigAdvanced | AiModel.AiPromptConfigExternal;\n        promptPreview: string;\n        isFineTuningAvailable: boolean;\n        createdAt: string;\n        updatedAt: string;\n    }\n    interface AiPromptConfigBasicOtherLanguageTranslations {\n        isEnabled?: boolean;\n        languageIds?: string[];\n    }\n    interface AiPromptConfigBasicPreTranslate {\n        mode: 'basic';\n        companyDescription?: string;\n        projectDescription?: string;\n        audienceDescription?: string;\n        customPlaceholders?: string[];\n        otherLanguageTranslations?: AiModel.AiPromptConfigBasicOtherLanguageTranslations;\n        glossaryTerms?: boolean;\n        tmSuggestions?: boolean;\n        fileContent?: boolean;\n        fileContext?: boolean;\n        screenshots?: boolean;\n        publicProjectDescription?: boolean;\n        siblingsStrings?: boolean;\n    }\n    interface AiPromptConfigBasicAssistAction {\n        mode: 'basic';\n        companyDescription?: string;\n        projectDescription?: string;\n        audienceDescription?: string;\n        otherLanguageTranslations?: AiModel.AiPromptConfigBasicOtherLanguageTranslations;\n        glossaryTerms?: boolean;\n        tmSuggestions?: boolean;\n        fileContext?: boolean;\n        screenshots?: boolean;\n        publicProjectDescription?: boolean;\n        siblingsStrings?: boolean;\n        filteredStrings?: boolean;\n    }\n    interface AiPromptConfigBasicAligmentAction {\n        mode: 'basic';\n        customPlaceholders?: string[];\n        publicProjectDescription?: boolean;\n    }\n    interface AiPromptConfigAdvanced {\n        mode: 'advanced';\n        screenshots?: boolean;\n        prompt: string;\n        otherLanguageTranslations?: AiModel.AiPromptConfigBasicOtherLanguageTranslations;\n    }\n    interface AiPromptConfigExternal {\n        mode: 'external';\n        identifier: string;\n        key: string;\n        options?: any;\n    }\n    interface AddAiPromptRequest {\n        name: string;\n        action: Action;\n        aiProviderId?: number;\n        aiModelId?: string;\n        isEnabled?: boolean;\n        enabledProjectIds?: number[];\n        config: AiModel.AiPromptConfigBasicPreTranslate | AiModel.AiPromptConfigBasicAssistAction | AiModel.AiPromptConfigBasicAligmentAction | AiModel.AiPromptConfigAdvanced | AiPromptConfigExternal;\n    }\n    interface GenerateAiPromptCompletionRequest {\n        resources: AiModel.AiPromptResourceWithPreTranslate | AiModel.AiPromptResourceWithAssist | AiModel.AiPromptResourceWithAlignment | AiModel.AiPromptResourceWithCustom;\n        tools?: {\n            tool: {\n                type: 'function';\n                function: {\n                    description?: string;\n                    name: string;\n                    parameters?: PlainObject;\n                };\n            };\n        }[];\n        tool_choice?: string | PlainObject;\n    }\n    interface AiPromptCompletionAttribute {\n        aiPromptId: number;\n    }\n    interface AiPromptResourceWithPreTranslate {\n        projectId: number;\n        sourceLanguageId?: string;\n        targetLanguageId?: string;\n        stringIds?: number[];\n        overridePromptValues?: OverridePromptValues;\n    }\n    interface AiPromptResourceWithAlignment {\n        projectId: number;\n        sourceLanguageId?: string;\n        targetLanguageId?: string;\n        stringIds?: number[];\n        overridePromptValues?: OverridePromptValues;\n    }\n    interface AiPromptResourceWithAssist {\n        projectId: number;\n        sourceLanguageId?: string;\n        targetLanguageId?: string;\n        stringIds?: number[];\n        filteredStringsIds?: number[];\n        overridePromptValues?: OverridePromptValues;\n    }\n    interface AiPromptResourceWithCustom {\n        projectId: number;\n        sourceLanguageId?: string;\n        targetLanguageId?: string;\n        stringIds?: number[];\n        overridePromptValues?: OverridePromptValues;\n        customInstruction?: string;\n    }\n    interface OverridePromptValues {\n        [key: string]: any;\n    }\n    interface AiProviderResponse {\n        id: number;\n        name: string;\n        type: ProviderType;\n        credentials: AiModel.AiProviderCredentialsBasic | AiModel.AiProviderCredentialsAzureOpenAi | AiProviderCredentialsGoogleGemini | AiProviderCredentialsCustom;\n        config: AiModel.AiProviderConfig;\n        isEnabled: boolean;\n        useSystemCredentials: boolean;\n        createdAt: string;\n        updatedAt: string;\n        promptsCount: string;\n    }\n    interface AiProviderCredentialsBasic {\n        apiKey: string;\n    }\n    interface AiProviderCredentialsAzureOpenAi extends AiProviderCredentialsBasic {\n        resourceName: string;\n        deploymentName: string;\n        apiVersion: string;\n    }\n    interface AiProviderCredentialsGoogleGemini {\n        project: string;\n        region: string;\n        serviceAccountKey: string;\n    }\n    interface AiProviderCredentialsWatsonx {\n        apiKey: string;\n        projectId: string;\n        region: string;\n    }\n    interface AiProviderCredentialsCustom {\n        identifier: string;\n        key: string;\n    }\n    interface AiProviderConfig {\n        actionRules?: AiModel.AiProviderConfigActionRule[];\n    }\n    interface AiProviderConfigActionRule {\n        action?: 'pre_translate' | 'assist';\n        availableAiModelIds?: string[];\n    }\n    interface AddAiProviderRequest {\n        name: string;\n        type: ProviderType;\n        credentials?: AiModel.AiProviderCredentialsBasic | AiModel.AiProviderCredentialsAzureOpenAi | AiProviderCredentialsGoogleGemini | AiProviderCredentialsWatsonx | AiProviderCredentialsCustom;\n        config?: AiModel.AiProviderConfig;\n        isEnabled?: boolean;\n        useSystemCredentials?: boolean;\n    }\n    interface AiProviderModelResponse {\n        id: string;\n    }\n    interface AiProviderProxyResponseData {\n        data: object;\n    }\n    interface OtherChatCompletionRequest {\n        stream?: boolean;\n        [key: string]: any;\n    }\n    interface GoogleGeminiChatCompletionRequest extends OtherChatCompletionRequest {\n        model: string;\n    }\n    type AiReport = AiReportTokenUsage;\n    interface AiReportTokenUsage {\n        type: 'tokens-usage-raw-data';\n        schema: AiReportGeneralSchema;\n    }\n    interface AiReportGeneralSchema {\n        dateFrom: string;\n        dateTo: string;\n        format?: 'json' | 'csv';\n        projectIds?: number[];\n        promptIds?: number[];\n        userIds?: number[];\n    }\n    interface AiSettings {\n        assistActionAiPromptId: number;\n        showSuggestion: boolean;\n        shortcuts: {\n            name: string;\n            prompt: string;\n            enabled: boolean;\n        }[];\n    }\n    type Action = 'pre_translate' | 'assist';\n    type ProviderType = 'open_ai' | 'azure_open_ai' | 'google_gemini' | 'mistral_ai' | 'anthropic' | 'custom_ai' | 'x_ai' | 'deepseek' | 'watsonx';\n}\n```\n\n##### applications/index.d.ts\n\n```typescript\nimport { CrowdinApi, ResponseObject, PatchRequest, Pagination, ResponseList } from '../core';\nexport declare class Applications extends CrowdinApi {\n    listApplicationInstallations(options?: Pagination): Promise<ResponseList<ApplicationsModel.Application>>;\n    installApplication(request: ApplicationsModel.InstallApplication): Promise<ResponseObject<ApplicationsModel.Application>>;\n    getApplicationInstallation(applicationId: string): Promise<ResponseObject<ApplicationsModel.Application>>;\n    deleteApplicationInstallation(applicationId: string, force?: boolean): Promise<ResponseObject<ApplicationsModel.Application>>;\n    editApplicationInstallation(applicationId: string, request: PatchRequest[]): Promise<ResponseObject<ApplicationsModel.Application>>;\n    getApplicationData(applicationId: string, path: string): Promise<ResponseObject<any>>;\n    updateOrRestoreApplicationData(applicationId: string, path: string, request: any): Promise<ResponseObject<any>>;\n    addApplicationData(applicationId: string, path: string, request: any): Promise<ResponseObject<any>>;\n    deleteApplicationData(applicationId: string, path: string): Promise<void>;\n    editApplicationData(applicationId: string, path: string, request: any): Promise<ResponseObject<any>>;\n}\nexport declare namespace ApplicationsModel {\n    interface Application {\n        identifier: string;\n        name: string;\n        description: string;\n        logo: string;\n        baseUrl: string;\n        manifestUrl: string;\n        createdAt: string;\n        modules: ApplicationModule[];\n        scopes: string[];\n        permissions: ApplicationPermissions;\n        defaultPermissions: any;\n        limitReached: boolean;\n    }\n    interface InstallApplication {\n        url: string;\n        permissions?: ApplicationPermissions;\n        modules?: ApplicationModule[];\n    }\n    interface ApplicationPermissions {\n        user: {\n            value: 'all' | 'owner' | 'managers' | 'guests' | 'restricted';\n            ids: number[];\n        };\n        project: {\n            value: 'own' | 'restricted';\n            ids: number[];\n        };\n    }\n    interface ApplicationModule {\n        key: string;\n        type?: string;\n        data?: any;\n        authenticationType?: string;\n        permissions: Omit<ApplicationPermissions, 'project'>;\n    }\n}\n```\n\n##### bundles/index.d.ts\n\n```typescript\nimport { CrowdinApi, DownloadLink, PaginationOptions, PatchRequest, ResponseList, ResponseObject, Status } from '../core';\nimport { SourceFilesModel } from '../sourceFiles';\nexport declare class Bundles extends CrowdinApi {\n    listBundles(projectId: number, options?: PaginationOptions): Promise<ResponseList<BundlesModel.Bundle>>;\n    addBundle(projectId: number, request: BundlesModel.CreateBundleRequest): Promise<ResponseObject<BundlesModel.Bundle>>;\n    getBundle(projectId: number, bundleId: number): Promise<ResponseObject<BundlesModel.Bundle>>;\n    deleteBundle(projectId: number, bundleId: number): Promise<void>;\n    editBundle(projectId: number, bundleId: number, request: PatchRequest[]): Promise<ResponseObject<BundlesModel.Bundle>>;\n    downloadBundle(projectId: number, bundleId: number, exportId: string): Promise<ResponseObject<DownloadLink>>;\n    exportBundle(projectId: number, bundleId: number): Promise<ResponseObject<Status<BundlesModel.ExportAttributes>>>;\n    checkBundleExportStatus(projectId: number, bundleId: number, exportId: string): Promise<ResponseObject<Status<BundlesModel.ExportAttributes>>>;\n    listBundleFiles(projectId: number, bundleId: number, options?: PaginationOptions): Promise<ResponseList<SourceFilesModel.File>>;\n    listBundleBranches(projectId: number, bundleId: number, options?: PaginationOptions): Promise<ResponseList<SourceFilesModel.Branch>>;\n}\nexport declare namespace BundlesModel {\n    interface Bundle {\n        id: number;\n        name: string;\n        format: string;\n        sourcePatterns: string[];\n        ignorePatterns: string[];\n        exportPattern: string;\n        isMultilingual: boolean;\n        includeProjectSourceLanguage: boolean;\n        labelIds: number[];\n        excludeLabelIds: number[];\n        createdAt: string;\n        webUrl: string;\n        updatedAt: string;\n    }\n    interface CreateBundleRequest {\n        name: string;\n        format: string;\n        sourcePatterns: string[];\n        ignorePatterns?: string[];\n        exportPattern: string;\n        isMultilingual?: boolean;\n        includeProjectSourceLanguage?: boolean;\n        includeInContextPseudoLanguage?: boolean;\n        labelIds?: number[];\n        excludeLabelIds?: number[];\n    }\n    interface ExportAttributes {\n        bundleId: number;\n    }\n}\n```\n\n##### clients/index.d.ts\n\n```typescript\nimport { CrowdinApi, PaginationOptions, ResponseList } from '../core';\nexport declare class Clients extends CrowdinApi {\n    listClients(options?: PaginationOptions): Promise<ResponseList<ClientsModel.Client>>;\n}\nexport declare namespace ClientsModel {\n    interface Client {\n        id: number;\n        name: string;\n        description: string;\n        status: 'pending' | 'confirmed' | 'rejected';\n        webUrl: string;\n    }\n}\n```\n\n##### core/http-client-error.d.ts\n\n```typescript\nimport { AxiosError } from 'axios';\nimport { FetchClientJsonPayloadError } from './internal/fetch/fetchClientError';\nexport type HttpClientError = AxiosError | FetchClientJsonPayloadError | Error;\nexport declare const toHttpClientError: (error?: unknown) => HttpClientError;\n```\n\n##### core/index.d.ts\n\n```typescript\nimport { HttpClientError } from './http-client-error';\nimport { RetryConfig, RetryService } from './internal/retry';\nexport interface HttpClient {\n    get<T>(url: string, config?: {\n        headers: Record<string, string>;\n    }): Promise<T>;\n    delete<T>(url: string, config?: {\n        headers: Record<string, string>;\n    }): Promise<T>;\n    head<T>(url: string, config?: {\n        headers: Record<string, string>;\n    }): Promise<T>;\n    post<T>(url: string, data?: unknown, config?: {\n        headers: Record<string, string>;\n    }): Promise<T>;\n    put<T>(url: string, data?: unknown, config?: {\n        headers: Record<string, string>;\n    }): Promise<T>;\n    patch<T>(url: string, data?: unknown, config?: {\n        headers: Record<string, string>;\n    }): Promise<T>;\n}\nexport type HttpClientType = 'axios' | 'fetch';\nexport interface Credentials {\n    token: string;\n    organization?: string;\n    baseUrl?: string;\n}\nexport interface ClientConfig {\n    httpClientType?: HttpClientType;\n    httpClient?: HttpClient;\n    userAgent?: string;\n    integrationUserAgent?: string;\n    retryConfig?: RetryConfig;\n    httpRequestTimeout?: number;\n}\nexport interface ResponseList<T> {\n    data: ResponseObject<T>[];\n    pagination: Pagination;\n}\nexport interface ResponseObject<T> {\n    data: T;\n}\nexport interface Pagination {\n    offset: number;\n    limit: number;\n}\nexport type PaginationOptions = Partial<Pagination>;\nexport interface PatchRequest {\n    value?: any;\n    op: PatchOperation;\n    path: string;\n}\nexport type PatchOperation = 'add' | 'remove' | 'replace' | 'move' | 'copy' | 'test';\nexport type ProjectRoles = 'manager' | 'developer' | 'translator' | 'proofreader' | 'language_coordinator' | 'member';\nexport interface DownloadLink {\n    url: string;\n    expireIn: string;\n}\nexport declare enum BooleanInt {\n    TRUE = 1,\n    FALSE = 0\n}\nexport interface Status<T> {\n    identifier: string;\n    status: string;\n    progress: number;\n    attributes: T;\n    createdAt: string;\n    updatedAt: string;\n    startedAt: string;\n    finishedAt: string;\n    eta: string;\n}\nexport interface Attribute {\n    [key: string]: string;\n}\nexport type PlainObject = Record<string, any>;\nexport declare class CrowdinError extends Error {\n    apiError: any;\n    code: number;\n    constructor(message: string, code: number, apiError: any);\n}\nexport declare class CrowdinValidationError extends CrowdinError {\n    validationCodes: {\n        key: string;\n        codes: string[];\n    }[];\n    constructor(message: string, validationCodes: {\n        key: string;\n        codes: string[];\n    }[], apiError: any);\n}\nexport declare function handleHttpClientError(error: HttpClientError): never;\nexport declare abstract class CrowdinApi {\n    private static readonly CROWDIN_URL_SUFFIX;\n    private static readonly AXIOS_INSTANCE;\n    private static readonly FETCH_INSTANCE;\n    readonly token: string;\n    readonly organization?: string;\n    readonly url: string;\n    readonly config: ClientConfig | undefined;\n    readonly retryService: RetryService;\n    protected fetchAllFlag: boolean;\n    protected maxLimit: number | undefined;\n    constructor(credentials: Credentials, config?: ClientConfig);\n    graphql<T>(req: {\n        query: string;\n        operationName?: string;\n        variables?: any;\n    }, config?: {\n        url?: string;\n    }): Promise<ResponseObject<T>>;\n    protected addQueryParam(url: string, name: string, value?: string | number): string;\n    protected defaultConfig(): {\n        headers: Record<string, string>;\n    };\n    get httpClient(): HttpClient;\n    withFetchAll(maxLimit?: number): this;\n    protected getList<T = any>(url: string, limit?: number, offset?: number, config?: {\n        headers: Record<string, string>;\n    }): Promise<ResponseList<T>>;\n    protected fetchAll<T>(url: string, config: {\n        headers: Record<string, string>;\n    }, maxAmount?: number): Promise<ResponseList<T>>;\n    protected encodeUrlParam(param: string | number | boolean): string;\n    protected get<T>(url: string, config?: {\n        headers: Record<string, string>;\n    }): Promise<T>;\n    protected delete<T>(url: string, config?: {\n        headers: Record<string, string>;\n    }): Promise<T>;\n    protected head<T>(url: string, config?: {\n        headers: Record<string, string>;\n    }): Promise<T>;\n    protected post<T>(url: string, data?: unknown, config?: {\n        headers: Record<string, string>;\n    }): Promise<T>;\n    protected put<T>(url: string, data?: unknown, config?: {\n        headers: Record<string, string>;\n    }): Promise<T>;\n    protected patch<T>(url: string, data?: unknown, config?: {\n        headers: Record<string, string>;\n    }): Promise<T>;\n}\nexport declare function isOptionalString(parameter: string | unknown, parameterInArgs: boolean): parameter is string | undefined;\nexport declare function isOptionalNumber(parameter: number | unknown, parameterInArgs: boolean): parameter is number | undefined;\nexport interface ProjectRole {\n    name: string;\n    permissions: ProjectRolePermissions;\n}\nexport interface ProjectRolePermissions {\n    allLanguages: boolean;\n    languagesAccess: {\n        [lang: string]: {\n            allContent: boolean;\n            workflowStepIds: number[];\n        };\n    };\n}\n```\n\n##### dictionaries/index.d.ts\n\n```typescript\nimport { CrowdinApi, PatchRequest, ResponseList, ResponseObject } from '../core';\nexport declare class Dictionaries extends CrowdinApi {\n    listDictionaries(projectId: number, options?: DictionariesModel.ListDictionariesOptions): Promise<ResponseList<DictionariesModel.Dictionary>>;\n    listDictionaries(projectId: number, languageIds?: string): Promise<ResponseList<DictionariesModel.Dictionary>>;\n    editDictionary(projectId: number, languageId: string, request: PatchRequest[]): Promise<ResponseObject<DictionariesModel.Dictionary>>;\n}\nexport declare namespace DictionariesModel {\n    interface Dictionary {\n        languageId: string;\n        words: string[];\n    }\n    interface ListDictionariesOptions {\n        languageIds?: string;\n    }\n}\n```\n\n##### distributions/index.d.ts\n\n```typescript\nimport { CrowdinApi, PaginationOptions, PatchRequest, ResponseList, ResponseObject } from '../core';\nexport declare class Distributions extends CrowdinApi {\n    listDistributions(projectId: number, options?: PaginationOptions): Promise<ResponseList<DistributionsModel.Distribution>>;\n    listDistributions(projectId: number, limit?: number, offset?: number): Promise<ResponseList<DistributionsModel.Distribution>>;\n    createDistribution(projectId: number, request: DistributionsModel.CreateDistributionRequest | DistributionsModel.CreateDistributionStringsBasedRequest): Promise<ResponseObject<DistributionsModel.Distribution>>;\n    getDistribution(projectId: number, hash: string): Promise<ResponseObject<DistributionsModel.Distribution>>;\n    deleteDistribution(projectId: number, hash: string): Promise<void>;\n    editDistribution(projectId: number, hash: string, request: PatchRequest[]): Promise<ResponseObject<DistributionsModel.Distribution>>;\n    getDistributionRelease(projectId: number, hash: string): Promise<ResponseObject<DistributionsModel.DistributionRelease | DistributionsModel.DistributionStringsBasedRelease>>;\n    createDistributionRelease(projectId: number, hash: string): Promise<ResponseObject<DistributionsModel.DistributionRelease | DistributionsModel.DistributionStringsBasedRelease>>;\n}\nexport declare namespace DistributionsModel {\n    interface Distribution {\n        hash: string;\n        manifestUrl: string;\n        name: string;\n        bundleIds: number[];\n        createdAt: string;\n        updatedAt: string;\n        exportMode: ExportMode;\n        fileIds: number[];\n    }\n    interface CreateDistributionRequest {\n        exportMode?: ExportMode;\n        name: string;\n        fileIds?: number[];\n        bundleIds?: number[];\n    }\n    interface CreateDistributionStringsBasedRequest {\n        name: string;\n        bundleIds: number[];\n    }\n    interface DistributionRelease {\n        status: string;\n        progress: number;\n        currentLanguageId: string;\n        currentFileId: number;\n        date: string;\n    }\n    interface DistributionStringsBasedRelease {\n        status: string;\n        progress: number;\n        currentLanguageId: string;\n        currentBranchId: number;\n        date: string;\n    }\n    type ExportMode = 'default' | 'bundle';\n}\n```\n\n##### fields/index.d.ts\n\n```typescript\nimport { CrowdinApi, PaginationOptions, PatchRequest, ResponseList, ResponseObject } from '../core';\nexport declare class Fields extends CrowdinApi {\n    listFields(options?: FieldsModel.ListFieldsParams): Promise<ResponseList<FieldsModel.Field>>;\n    addField(request: FieldsModel.AddFieldRequest): Promise<ResponseObject<FieldsModel.Field>>;\n    getField(fieldId: number): Promise<ResponseObject<FieldsModel.Field>>;\n    deleteField(fieldId: number): Promise<void>;\n    editField(fieldId: number, request: PatchRequest[]): Promise<ResponseObject<FieldsModel.Field>>;\n}\nexport declare namespace FieldsModel {\n    type Entity = 'project' | 'user' | 'task' | 'file' | 'translation' | 'string';\n    type Type = 'checkbox' | 'radiobuttons' | 'date' | 'datetime' | 'number' | 'labels' | 'select' | 'multiselect' | 'text' | 'textarea' | 'url';\n    type Place = 'projectCreateModal' | 'projectHeader' | 'projectDetails' | 'projectCrowdsourceDetails' | 'projectSettings' | 'projectTaskEditCreate' | 'projectTaskDetails' | 'projectTaskBoardCard' | 'fileDetails' | 'fileSettings' | 'userEditModal' | 'userDetails' | 'userPopover' | 'stringEditModal' | 'stringDetails' | 'translationUnderContent';\n    interface Location {\n        place: Place;\n    }\n    interface Option {\n        label: string;\n        value: string;\n    }\n    interface OtherFieldConfig {\n        locations: Location[];\n    }\n    interface ListFieldConfig extends OtherFieldConfig {\n        options: Option[];\n    }\n    interface NumberFieldConfig extends OtherFieldConfig {\n        min: number;\n        max: number;\n        units: string;\n    }\n    type Config = ListFieldConfig | NumberFieldConfig | OtherFieldConfig;\n    interface ListFieldsParams extends PaginationOptions {\n        search?: string;\n        entity?: Entity;\n        type?: Type;\n    }\n    interface Field {\n        id: number;\n        name: string;\n        slug: string;\n        type: Type;\n        description: string;\n        entities: Entity[];\n        config: Config;\n        createdAt: string;\n        updatedAt: string;\n    }\n    interface AddFieldRequest {\n        name: string;\n        slug: string;\n        type: Type;\n        description?: string;\n        entities: Entity[];\n        config?: Config;\n    }\n}\n```\n\n##### glossaries/index.d.ts\n\n```typescript\nimport { CrowdinApi, DownloadLink, PaginationOptions, PatchRequest, ResponseList, ResponseObject, Status } from '../core';\nexport declare class Glossaries extends CrowdinApi {\n    listGlossaries(options?: GlossariesModel.ListGlossariesOptions): Promise<ResponseList<GlossariesModel.Glossary>>;\n    listGlossaries(groupId?: number, limit?: number, offset?: number): Promise<ResponseList<GlossariesModel.Glossary>>;\n    addGlossary(request: GlossariesModel.CreateGlossaryRequest): Promise<ResponseObject<GlossariesModel.Glossary>>;\n    getGlossary(glossaryId: number): Promise<ResponseObject<GlossariesModel.Glossary>>;\n    deleteGlossary(glossaryId: number): Promise<void>;\n    editGlossary(glossaryId: number, request: PatchRequest[]): Promise<ResponseObject<GlossariesModel.Glossary>>;\n    exportGlossary(glossaryId: number, request: GlossariesModel.ExportGlossaryRequest): Promise<ResponseObject<Status<GlossariesModel.GlossaryExportStatusAttribute>>>;\n    checkGlossaryExportStatus(glossaryId: number, exportId: string): Promise<ResponseObject<Status<GlossariesModel.GlossaryExportStatusAttribute>>>;\n    downloadGlossary(glossaryId: number, exportId: string): Promise<ResponseObject<DownloadLink>>;\n    importGlossaryFile(glossaryId: number, request: GlossariesModel.GlossaryFile): Promise<ResponseObject<Status<GlossariesModel.GlossaryImportStatusAttribute>>>;\n    checkGlossaryImportStatus(glossaryId: number, importId: string): Promise<ResponseObject<Status<GlossariesModel.GlossaryImportStatusAttribute>>>;\n    listTerms(glossaryId: number, options?: GlossariesModel.ListTermsOptions): Promise<ResponseList<GlossariesModel.Term>>;\n    listTerms(glossaryId: number, userId?: number, limit?: number, offset?: number, languageId?: string, translationOfTermId?: number, conceptId?: number): Promise<ResponseList<GlossariesModel.Term>>;\n    addTerm(glossaryId: number, request: GlossariesModel.CreateTermRequest): Promise<ResponseObject<GlossariesModel.Term>>;\n    clearGlossary(glossaryId: number, options?: GlossariesModel.ClearGlossaryOptions): Promise<ResponseObject<GlossariesModel.Term>>;\n    clearGlossary(glossaryId: number, languageId?: number, translationOfTermId?: number, conceptId?: number): Promise<ResponseObject<GlossariesModel.Term>>;\n    getTerm(glossaryId: number, termId: number): Promise<ResponseObject<GlossariesModel.Term>>;\n    deleteTerm(glossaryId: number, termId: number): Promise<void>;\n    editTerm(glossaryId: number, termId: number, request: PatchRequest[]): Promise<ResponseObject<GlossariesModel.Term>>;\n    listConcepts(glossaryId: number, options?: {\n        orderBy?: string;\n    } & PaginationOptions): Promise<ResponseList<GlossariesModel.Concept>>;\n    getConcept(glossaryId: number, conceptId: number): Promise<ResponseObject<GlossariesModel.Concept>>;\n    updateConcept(glossaryId: number, conceptId: number, request: GlossariesModel.UpdateConceptRequest): Promise<ResponseObject<GlossariesModel.Concept>>;\n    deleteConcept(glossaryId: number, conceptId: number): Promise<void>;\n    concordanceSearch(projectId: number, request: GlossariesModel.ConcordanceSearchRequest): Promise<ResponseList<GlossariesModel.ConcordanceSearchResponse>>;\n}\nexport declare namespace GlossariesModel {\n    interface Glossary {\n        id: number;\n        name: string;\n        groupId: number;\n        userId: number;\n        terms: number;\n        languageId: string;\n        languageIds: string[];\n        defaultProjectIds: number[];\n        projectIds: number[];\n        webUrl: string;\n        createdAt: string;\n    }\n    interface CreateGlossaryRequest {\n        name: string;\n        languageId: string;\n        groupId?: number;\n    }\n    type ExportField = 'term' | 'description' | 'partOfSpeech' | 'type' | 'status' | 'gender' | 'note' | 'url' | 'conceptDefinition' | 'conceptSubject' | 'conceptNote' | 'conceptUrl' | 'conceptFigure';\n    interface ExportGlossaryRequest {\n        format?: GlossaryFormat;\n        exportFields?: ExportField[];\n    }\n    interface GlossaryExportStatusAttribute {\n        format: string;\n        exportFields: ExportField[];\n    }\n    interface GlossaryImportStatusAttribute {\n        storageId: number;\n        scheme: unknown;\n        firstLineContainsHeader: boolean;\n    }\n    interface GlossaryFile {\n        storageId: number;\n        scheme?: GlossaryFileScheme;\n        firstLineContainsHeader?: boolean;\n    }\n    interface ListTermsOptions extends PaginationOptions {\n        userId?: number;\n        languageId?: string;\n        conceptId?: number;\n        orderBy?: string;\n        croql?: string;\n        translationOfTermId?: number;\n    }\n    interface Term {\n        id: number;\n        userId: number;\n        glossaryId: number;\n        languageId: string;\n        text: string;\n        description: string;\n        partOfSpeech: PartOfSpeech;\n        status: Status;\n        type: Type;\n        gender: Gender;\n        note: string;\n        url: string;\n        conceptId: number;\n        lemma: string;\n        createdAt: string;\n        updatedAt: string;\n    }\n    interface CreateTermRequest {\n        languageId: string;\n        text: string;\n        description?: string;\n        partOfSpeech?: PartOfSpeech;\n        status?: Status;\n        type?: Type;\n        gender?: Gender;\n        note?: string;\n        url?: string;\n        conceptId?: number;\n        translationOfTermId?: number;\n    }\n    interface ConcordanceSearchRequest extends PaginationOptions {\n        sourceLanguageId: string;\n        targetLanguageId: string;\n        expressions: string[];\n        expression?: string;\n    }\n    interface ConcordanceSearchResponse {\n        glossary: Glossary;\n        concept: Concept;\n        sourceTerms: Term[];\n        targetTerms: Term[];\n    }\n    type Status = 'preferred' | 'admitted' | 'not recommended' | 'obsolete';\n    type Type = 'full form' | 'acronym' | 'abbreviation' | 'short form' | 'phrase' | 'variant';\n    type Gender = 'masculine' | 'feminine' | 'neuter' | 'other';\n    type GlossaryFormat = 'tbx' | 'tbx_v3' | 'csv' | 'xlsx';\n    interface GlossaryFileScheme {\n        [key: string]: number;\n    }\n    type PartOfSpeech = 'adjective' | 'adposition' | 'adverb' | 'auxiliary' | 'coordinating conjunction' | 'determiner' | 'interjection' | 'noun' | 'numeral' | 'particle' | 'pronoun' | 'proper noun' | 'subordinating conjunction' | 'verb' | 'other';\n    interface ListGlossariesOptions extends PaginationOptions {\n        groupId?: number;\n        userId?: number;\n        orderBy?: string;\n    }\n    interface ClearGlossaryOptions {\n        languageId?: number;\n        translationOfTermId?: number;\n        conceptId?: number;\n    }\n    interface Concept {\n        id: number;\n        userId: number;\n        glossaryId: number;\n        subject: string;\n        definition: string;\n        translatable: boolean;\n        note: string;\n        url: string;\n        figure: string;\n        languagesDetails: LanguageDetails[];\n        createdAt: string;\n        updatedAt: string;\n    }\n    interface LanguageDetails {\n        languageId: string;\n        userId: number;\n        definition: string;\n        note: string;\n        createdAt: string;\n        updatedAt: string;\n    }\n    interface UpdateConceptRequest {\n        subject?: string;\n        definition?: string;\n        translatable?: boolean;\n        note?: string;\n        url?: string;\n        figure?: string;\n        languagesDetails?: {\n            languageId: string;\n            definition: string;\n            note?: string;\n        }[];\n    }\n}\n```\n\n##### index.d.ts\n\n```typescript\nimport { Ai } from './ai';\nimport { Applications } from './applications';\nimport { Bundles } from './bundles';\nimport { Clients } from './clients';\nimport { ClientConfig, Credentials, CrowdinApi } from './core';\nimport { Dictionaries } from './dictionaries';\nimport { Distributions } from './distributions';\nimport { Fields } from './fields';\nimport { Glossaries } from './glossaries';\nimport { Issues } from './issues';\nimport { Labels } from './labels';\nimport { Languages } from './languages';\nimport { MachineTranslation } from './machineTranslation';\nimport { Notifications } from './notifications';\nimport { OrganizationWebhooks } from './organizationWebhooks';\nimport { ProjectsGroups } from './projectsGroups';\nimport { Reports } from './reports';\nimport { Screenshots } from './screenshots';\nimport { SecurityLogs } from './securityLogs';\nimport { SourceFiles } from './sourceFiles';\nimport { SourceStrings } from './sourceStrings';\nimport { StringComments } from './stringComments';\nimport { StringCorrections } from './stringCorrections';\nimport { StringTranslations } from './stringTranslations';\nimport { Tasks } from './tasks';\nimport { Teams } from './teams';\nimport { TranslationMemory } from './translationMemory';\nimport { TranslationStatus } from './translationStatus';\nimport { Translations } from './translations';\nimport { UploadStorage } from './uploadStorage';\nimport { Users } from './users';\nimport { Vendors } from './vendors';\nimport { Webhooks } from './webhooks';\nimport { Workflows } from './workflows';\nexport * from './ai';\nexport * from './applications';\nexport * from './bundles';\nexport * from './clients';\nexport * from './core';\nexport * from './dictionaries';\nexport * from './distributions';\nexport * from './fields';\nexport * from './glossaries';\nexport * from './issues';\nexport * from './labels';\nexport * from './languages';\nexport * from './machineTranslation';\nexport * from './notifications';\nexport * from './organizationWebhooks';\nexport * from './projectsGroups';\nexport * from './reports';\nexport * from './screenshots';\nexport * from './securityLogs';\nexport * from './sourceFiles';\nexport * from './sourceStrings';\nexport * from './stringComments';\nexport * from './stringCorrections';\nexport * from './stringTranslations';\nexport * from './tasks';\nexport * from './teams';\nexport * from './translationMemory';\nexport * from './translationStatus';\nexport * from './translations';\nexport * from './uploadStorage';\nexport * from './users';\nexport * from './vendors';\nexport * from './webhooks';\nexport * from './workflows';\nexport default class Client extends CrowdinApi {\n    readonly aiApi: Ai;\n    readonly applicationsApi: Applications;\n    readonly sourceFilesApi: SourceFiles;\n    readonly glossariesApi: Glossaries;\n    readonly languagesApi: Languages;\n    readonly translationsApi: Translations;\n    readonly translationStatusApi: TranslationStatus;\n    readonly projectsGroupsApi: ProjectsGroups;\n    readonly reportsApi: Reports;\n    readonly screenshotsApi: Screenshots;\n    readonly sourceStringsApi: SourceStrings;\n    readonly uploadStorageApi: UploadStorage;\n    readonly tasksApi: Tasks;\n    readonly translationMemoryApi: TranslationMemory;\n    readonly webhooksApi: Webhooks;\n    readonly organizationWebhooksApi: OrganizationWebhooks;\n    readonly machineTranslationApi: MachineTranslation;\n    readonly stringTranslationsApi: StringTranslations;\n    readonly workflowsApi: Workflows;\n    readonly usersApi: Users;\n    readonly vendorsApi: Vendors;\n    readonly issuesApi: Issues;\n    readonly teamsApi: Teams;\n    readonly distributionsApi: Distributions;\n    readonly dictionariesApi: Dictionaries;\n    readonly labelsApi: Labels;\n    readonly stringCommentsApi: StringComments;\n    readonly bundlesApi: Bundles;\n    readonly notificationsApi: Notifications;\n    readonly clientsApi: Clients;\n    readonly securityLogsApi: SecurityLogs;\n    readonly fieldsApi: Fields;\n    readonly stringCorrectionsApi: StringCorrections;\n    constructor(credentials: Credentials, config?: ClientConfig);\n}\nexport { Client };\n```\n\n##### issues/index.d.ts\n\n```typescript\nimport { CrowdinApi, PaginationOptions, PatchRequest, ResponseList, ResponseObject } from '../core';\nexport declare class Issues extends CrowdinApi {\n    listReportedIssues(projectId: number, options?: IssuesModel.ListReportedIssuesOptions): Promise<ResponseList<IssuesModel.Issue>>;\n    listReportedIssues(projectId: number, limit?: number, offset?: number, type?: IssuesModel.Type, status?: IssuesModel.Status): Promise<ResponseList<IssuesModel.Issue>>;\n    editIssue(projectId: number, issueId: number, request: PatchRequest[]): Promise<ResponseObject<IssuesModel.Issue>>;\n}\nexport declare namespace IssuesModel {\n    type Type = 'all' | 'general_question' | 'translation_mistake' | 'context_request' | 'source_mistake';\n    type Status = 'all' | 'resolved' | 'unresolved';\n    interface Issue {\n        id: number;\n        text: string;\n        userId: number;\n        stringId: number;\n        user: User;\n        string: string;\n        languageId: string;\n        type: Type;\n        status: Status;\n        createdAt: string;\n    }\n    interface User {\n        id: number;\n        username: string;\n        fullName: string;\n        avatarUrl: string;\n    }\n    interface String {\n        id: number;\n        text: string;\n        type: string;\n        hasPlurals: boolean;\n        isIcu: boolean;\n        context: string;\n        fileId: number;\n    }\n    interface ListReportedIssuesOptions extends PaginationOptions {\n        type?: IssuesModel.Type;\n        status?: IssuesModel.Status;\n    }\n}\n```\n\n##### labels/index.d.ts\n\n```typescript\nimport { CrowdinApi, PaginationOptions, PatchRequest, ResponseList, ResponseObject } from '../core';\nimport { ScreenshotsModel } from '../screenshots';\nimport { SourceStringsModel } from '../sourceStrings';\nexport declare class Labels extends CrowdinApi {\n    listLabels(projectId: number, options?: LabelsModel.ListLabelsParams): Promise<ResponseList<LabelsModel.Label>>;\n    listLabels(projectId: number, limit?: number, offset?: number): Promise<ResponseList<LabelsModel.Label>>;\n    addLabel(projectId: number, request: LabelsModel.AddLabelRequest): Promise<ResponseObject<LabelsModel.Label>>;\n    getLabel(projectId: number, labelId: number): Promise<ResponseObject<LabelsModel.Label>>;\n    deleteLabel(projectId: number, labelId: number): Promise<void>;\n    editLabel(projectId: number, labelId: number, request: PatchRequest[]): Promise<ResponseObject<LabelsModel.Label>>;\n    assignLabelToScreenshots(projectId: number, labelId: number, request: LabelsModel.AssignLabelToScreenshotsRequet): Promise<ResponseList<ScreenshotsModel.Screenshot>>;\n    unassignLabelFromScreenshots(projectId: number, labelId: number, screenshotIds: string): Promise<ResponseList<ScreenshotsModel.Screenshot>>;\n    assignLabelToString(projectId: number, labelId: number, request: LabelsModel.AssignLabelToStringsRequet): Promise<ResponseList<SourceStringsModel.String>>;\n    unassignLabelFromString(projectId: number, labelId: number, stringIds: string): Promise<ResponseList<SourceStringsModel.String>>;\n}\nexport declare namespace LabelsModel {\n    interface ListLabelsParams extends PaginationOptions {\n        orderBy?: string;\n    }\n    interface Label {\n        id: number;\n        title: string;\n        isSystem?: boolean;\n    }\n    interface AddLabelRequest {\n        title: string;\n    }\n    interface AssignLabelToStringsRequet {\n        stringIds: number[];\n    }\n    interface AssignLabelToScreenshotsRequet {\n        screenshotIds: number[];\n    }\n}\n```\n\n##### languages/index.d.ts\n\n```typescript\nimport { CrowdinApi, PaginationOptions, PatchRequest, ResponseList, ResponseObject } from '../core';\nexport declare class Languages extends CrowdinApi {\n    listSupportedLanguages(options?: PaginationOptions): Promise<ResponseList<LanguagesModel.Language>>;\n    listSupportedLanguages(limit?: number, offset?: number): Promise<ResponseList<LanguagesModel.Language>>;\n    addCustomLanguage(request: LanguagesModel.AddLanguageRequest): Promise<ResponseObject<LanguagesModel.Language>>;\n    getLanguage(languageId: string): Promise<ResponseObject<LanguagesModel.Language>>;\n    deleteCustomLanguage(languageId: string): Promise<void>;\n    editCustomLanguage(languageId: string, request: PatchRequest[]): Promise<ResponseObject<LanguagesModel.Language>>;\n}\nexport declare namespace LanguagesModel {\n    interface Language {\n        id: string;\n        name: string;\n        editorCode: string;\n        twoLettersCode: string;\n        threeLettersCode: string;\n        locale: string;\n        androidCode: string;\n        osxCode: string;\n        osxLocale: string;\n        pluralCategoryNames: string[];\n        pluralRules: string;\n        pluralExamples: string[];\n        textDirection: TextDirection;\n        dialectOf: string;\n    }\n    interface AddLanguageRequest {\n        name: string;\n        code: string;\n        localeCode: string;\n        textDirection: TextDirection;\n        pluralCategoryNames: string[];\n        threeLettersCode: string;\n        twoLettersCode?: string;\n        dialectOf?: string;\n    }\n    type TextDirection = 'ltr' | 'rtl';\n}\n```\n\n##### machineTranslation/index.d.ts\n\n```typescript\nimport { CrowdinApi, PaginationOptions, PatchRequest, ResponseList, ResponseObject } from '../core';\nexport declare class MachineTranslation extends CrowdinApi {\n    listMts(options?: MachineTranslationModel.ListMTsOptions): Promise<ResponseList<MachineTranslationModel.MachineTranslation>>;\n    listMts(groupId?: number, limit?: number, offset?: number): Promise<ResponseList<MachineTranslationModel.MachineTranslation>>;\n    createMt(request: MachineTranslationModel.CreateMachineTranslationRequest): Promise<ResponseObject<MachineTranslationModel.MachineTranslation>>;\n    getMt(mtId: number): Promise<ResponseObject<MachineTranslationModel.MachineTranslation>>;\n    deleteMt(mtId: number): Promise<void>;\n    updateMt(mtId: number, request: PatchRequest[]): Promise<ResponseObject<MachineTranslationModel.MachineTranslation>>;\n    translate(mtId: number, request: MachineTranslationModel.TranslateRequest): Promise<ResponseObject<MachineTranslationModel.TranslateResponse>>;\n}\nexport declare namespace MachineTranslationModel {\n    interface MachineTranslation {\n        id: number;\n        groupId: number;\n        name: string;\n        type: number;\n        credentials: Credentials;\n        projectIds: number[];\n        supportedLanguageIds: string[];\n        supportedLanguagePairs: Record<string, string[]>;\n        enabledLanguageIds: string[];\n        enabledProjectIds: number[];\n        isEnabled: boolean;\n    }\n    type Credentials = {\n        apiKey: string;\n    } | {\n        credentials: string;\n    } | {\n        model: string;\n        apiKey: string;\n    } | {\n        isSystemCredentials: boolean;\n        apiKey: string;\n    } | {\n        endpoint: string;\n        apiKey: string;\n    } | {\n        url: string;\n    } | {\n        accessKey: string;\n        secretKey: string;\n    };\n    interface CreateMachineTranslationRequest {\n        name: string;\n        type: string;\n        credentials: Credentials;\n        groupId?: number;\n        enabledLanguageIds?: string[];\n        enabledProjectIds?: number[];\n        isEnabled?: boolean;\n    }\n    interface TranslateRequest {\n        languageRecognitionProvider?: LanguageRecognitionProvider;\n        sourceLanguageId?: string;\n        targetLanguageId: string;\n        strings?: string[];\n    }\n    interface TranslateResponse {\n        sourceLanguageId: string;\n        targetLanguageId: string;\n        strings: string[];\n        translations: string[];\n    }\n    type LanguageRecognitionProvider = 'crowdin' | 'engine';\n    interface ListMTsOptions extends PaginationOptions {\n        groupId?: number;\n    }\n}\n```\n\n##### notifications/index.d.ts\n\n```typescript\nimport { CrowdinApi } from '../core';\nexport declare class Notifications extends CrowdinApi {\n    sendNotificationToAuthenticatedUser(request: NotificationsModel.Notification): Promise<void>;\n    sendNotificationToProjectMembers(projectId: number, request: NotificationsModel.NotificationByUsers | NotificationsModel.NotificationByRole): Promise<void>;\n    sendNotificationToOrganizationMembers(request: NotificationsModel.Notification | NotificationsModel.NotificationByUsers | NotificationsModel.NotificationByRole): Promise<void>;\n}\nexport declare namespace NotificationsModel {\n    interface Notification {\n        message: string;\n    }\n    interface NotificationByUsers extends Notification {\n        userIds: number[];\n    }\n    interface NotificationByRole extends Notification {\n        role: 'owner' | 'admin';\n    }\n}\n```\n\n##### organizationWebhooks/index.d.ts\n\n```typescript\nimport { CrowdinApi, PaginationOptions, PatchRequest, ResponseList, ResponseObject } from '../core';\nimport { WebhooksModel } from '../webhooks';\nexport declare class OrganizationWebhooks extends CrowdinApi {\n    listWebhooks(options?: PaginationOptions): Promise<ResponseList<OrganizationWebhooksModel.OrganizationWebhook>>;\n    addWebhook(request: OrganizationWebhooksModel.AddOrganizationWebhookRequest): Promise<ResponseObject<OrganizationWebhooksModel.OrganizationWebhook>>;\n    getWebhook(webhookId: number): Promise<ResponseObject<OrganizationWebhooksModel.OrganizationWebhook>>;\n    deleteWebhook(webhookId: number): Promise<void>;\n    editWebhook(webhookId: number, request: PatchRequest[]): Promise<ResponseObject<OrganizationWebhooksModel.OrganizationWebhook>>;\n}\nexport declare namespace OrganizationWebhooksModel {\n    type OrganizationWebhook = Omit<WebhooksModel.Webhook, 'projectId' | 'events'> & {\n        events: Event[];\n    };\n    type AddOrganizationWebhookRequest = Omit<WebhooksModel.AddWebhookRequest, 'events'> & {\n        events: Event[];\n    };\n    type Event = 'group.created' | 'group.deleted' | 'project.created' | 'project.deleted';\n}\n```\n\n##### projectsGroups/index.d.ts\n\n```typescript\nimport { BooleanInt, CrowdinApi, DownloadLink, PaginationOptions, PatchRequest, ResponseList, ResponseObject } from '../core';\nimport { LanguagesModel } from '../languages';\nexport declare class ProjectsGroups extends CrowdinApi {\n    listGroups(options?: ProjectsGroupsModel.ListGroupsOptions): Promise<ResponseList<ProjectsGroupsModel.Group>>;\n    listGroups(parentId?: number, offset?: number, userId?: number, limit?: number): Promise<ResponseList<ProjectsGroupsModel.Group>>;\n    addGroup(request: ProjectsGroupsModel.AddGroupRequest): Promise<ResponseObject<ProjectsGroupsModel.Group>>;\n    getGroup(groupId: number): Promise<ResponseObject<ProjectsGroupsModel.Group>>;\n    deleteGroup(groupId: number): Promise<void>;\n    editGroup(groupId: number, request: PatchRequest[]): Promise<ResponseObject<ProjectsGroupsModel.Group>>;\n    listProjects(options?: ProjectsGroupsModel.ListProjectsOptions): Promise<ResponseList<ProjectsGroupsModel.Project | ProjectsGroupsModel.ProjectSettings>>;\n    listProjects(groupId?: number, hasManagerAccess?: BooleanInt, limit?: number, offset?: number): Promise<ResponseList<ProjectsGroupsModel.Project | ProjectsGroupsModel.ProjectSettings>>;\n    addProject(request: ProjectsGroupsModel.CreateProjectEnterpriseRequest | ProjectsGroupsModel.CreateProjectRequest): Promise<ResponseObject<ProjectsGroupsModel.Project | ProjectsGroupsModel.ProjectSettings>>;\n    getProject(projectId: number): Promise<ResponseObject<ProjectsGroupsModel.Project | ProjectsGroupsModel.ProjectSettings>>;\n    deleteProject(projectId: number): Promise<void>;\n    editProject(projectId: number, request: PatchRequest[]): Promise<ResponseObject<ProjectsGroupsModel.Project | ProjectsGroupsModel.ProjectSettings>>;\n    downloadProjectFileFormatSettingsCustomSegmentation(projectId: number, fileFormatSettingsId: number): Promise<ResponseObject<DownloadLink>>;\n    resetProjectFileFormatSettingsCustomSegmentation(projectId: number, fileFormatSettingsId: number): Promise<ResponseObject<DownloadLink>>;\n    listProjectFileFormatSettings(projectId: number, options?: PaginationOptions): Promise<ResponseList<ProjectsGroupsModel.ProjectFileFormatSettings>>;\n    addProjectFileFormatSettings(projectId: number, request: ProjectsGroupsModel.AddProjectFileFormatSettingsRequest): Promise<ResponseObject<ProjectsGroupsModel.ProjectFileFormatSettings>>;\n    getProjectFileFormatSettings(projectId: number, fileFormatSettingsId: number): Promise<ResponseObject<ProjectsGroupsModel.ProjectFileFormatSettings>>;\n    deleteProjectFileFormatSettings(projectId: number, fileFormatSettingsId: number): Promise<void>;\n    editProjectFileFormatSettings(projectId: number, fileFormatSettingsId: number, request: PatchRequest[]): Promise<ResponseObject<ProjectsGroupsModel.ProjectFileFormatSettings>>;\n    listProjectStringsExporterSettings(projectId: number, options?: PaginationOptions): Promise<ResponseList<ProjectsGroupsModel.ProjectStringsExporterSettings>>;\n    addProjectStringsExporterSettings(projectId: number, request: ProjectsGroupsModel.AddProjectStringsExporterSettingsRequest): Promise<ResponseObject<ProjectsGroupsModel.ProjectStringsExporterSettings>>;\n    getProjectStringsExporterSettings(projectId: number, systemStringsExporterSettingsId: number): Promise<ResponseObject<ProjectsGroupsModel.ProjectStringsExporterSettings>>;\n    deleteProjectStringsExporterSettings(projectId: number, systemStringsExporterSettingsId: number): Promise<void>;\n    editProjectStringsExporterSettings(projectId: number, systemStringsExporterSettingsId: number, request: ProjectsGroupsModel.AddProjectStringsExporterSettingsRequest): Promise<ResponseObject<ProjectsGroupsModel.ProjectStringsExporterSettings>>;\n}\nexport declare namespace ProjectsGroupsModel {\n    interface Group {\n        id: number;\n        name: string;\n        description: string;\n        parentId: number;\n        organizationId: number;\n        userId: number;\n        subgroupsCount: number;\n        projectsCount: number;\n        webUrl: string;\n        createdAt: string;\n        updatedAt: string;\n    }\n    interface AddGroupRequest {\n        name: string;\n        parentId?: number;\n        description?: string;\n    }\n    interface Project {\n        id: number;\n        type: Type;\n        userId: number;\n        sourceLanguageId: string;\n        targetLanguageIds: string[];\n        languageAccessPolicy: LanguageAccessPolicy;\n        name: string;\n        identifier: string;\n        description: string;\n        visibility: string;\n        logo: string;\n        publicDownloads: boolean;\n        createdAt: string;\n        updatedAt: string;\n        lastActivity: string;\n        sourceLanguage: LanguagesModel.Language;\n        targetLanguages: LanguagesModel.Language[];\n        webUrl: string;\n        savingsReportSettingsTemplateId: number;\n        fields: Record<string, any>;\n        cname: string;\n        groupId: number;\n        background: string;\n        isExternal: boolean;\n        externalType: string;\n        externalProjectId: number;\n        externalOrganizationId: number;\n        workflowId: number;\n        hasCrowdsourcing: boolean;\n        publicUrl: string;\n    }\n    interface CreateProjectRequest {\n        name: string;\n        identifier: string;\n        sourceLanguageId: string;\n        targetLanguageIds?: string[];\n        visibility?: JoinPolicy;\n        languageAccessPolicy?: LanguageAccessPolicy;\n        cname?: string;\n        description?: string;\n        tagDetection?: TagDetection;\n        isMtAllowed?: boolean;\n        taskBasedAccessControl?: boolean;\n        autoSubstitution?: boolean;\n        autoTranslateDialects?: boolean;\n        publicDownloads?: boolean;\n        hiddenStringsProofreadersAccess?: boolean;\n        useGlobalTm?: boolean;\n        showTmSuggestionsDialects?: boolean;\n        tmApprovedSuggestionsOnly?: boolean;\n        skipUntranslatedStrings?: boolean;\n        exportApprovedOnly?: boolean;\n        qaCheckIsActive?: boolean;\n        qaCheckCategories?: CheckCategories;\n        qaChecksIgnorableCategories?: CheckCategories;\n        languageMapping?: LanguageMapping;\n        glossaryAccess?: boolean;\n        glossaryAccessOption?: GlossaryAccessOption;\n        normalizePlaceholder?: boolean;\n        notificationSettings?: NotificationSettings;\n        tmPreTranslate?: ProjectSettings['tmPreTranslate'];\n        mtPreTranslate?: ProjectSettings['mtPreTranslate'];\n        aiPreTranslate?: ProjectSettings['aiPreTranslate'];\n        assistActionAiPromptId?: number;\n        editorSuggestionAiPromptId?: number;\n        savingsReportSettingsTemplateId?: number;\n        defaultTmId?: number;\n        defaultGlossaryId?: number;\n        inContext?: boolean;\n        inContextProcessHiddenStrings?: boolean;\n        inContextPseudoLanguageId?: string;\n        saveMetaInfoInSource?: boolean;\n        type?: BooleanInt;\n        skipUntranslatedFiles?: boolean;\n        tmContextType?: TmContextType;\n    }\n    interface CreateProjectEnterpriseRequest {\n        name: string;\n        sourceLanguageId: string;\n        templateId?: number;\n        steps?: WorkflowTemplateStepConfig[];\n        groupId?: number;\n        targetLanguageIds?: string[];\n        vendorId?: number;\n        mtEngineId?: number;\n        description?: string;\n        translateDuplicates?: TranslateDuplicates;\n        tagsDetection?: TagDetection;\n        isMtAllowed?: boolean;\n        taskBasedAccessControl?: boolean;\n        taskReviewerIds?: number[];\n        autoSubstitution?: boolean;\n        showTmSuggestionsDialects?: boolean;\n        tmApprovedSuggestionsOnly?: boolean;\n        autoTranslateDialects?: boolean;\n        publicDownloads?: boolean;\n        hiddenStringsProofreadersAccess?: boolean;\n        delayedWorkflowStart?: boolean;\n        skipUntranslatedStrings?: boolean;\n        exportWithMinApprovalsCount?: number;\n        exportStringsThatPassedWorkflow?: number;\n        normalizePlaceholder?: boolean;\n        qaCheckIsActive?: boolean;\n        qaApprovalsCount?: number;\n        qaCheckCategories?: CheckCategories;\n        qaChecksIgnorableCategories?: CheckCategories;\n        customQaCheckIds?: number[];\n        languageMapping?: LanguageMapping;\n        glossaryAccess?: boolean;\n        glossaryAccessOption?: GlossaryAccessOption;\n        notificationSettings?: NotificationSettings;\n        savingsReportSettingsTemplateId?: number;\n        fields?: Record<string, any>;\n        assistActionAiPromptId?: number;\n        editorSuggestionAiPromptId?: number;\n        alignmentActionAiPromptId?: number;\n        defaultTmId?: number;\n        defaultGlossaryId?: number;\n        inContext?: boolean;\n        inContextProcessHiddenStrings?: boolean;\n        inContextPseudoLanguageId?: string;\n        saveMetaInfoInSource?: boolean;\n        type?: BooleanInt;\n        skipUntranslatedFiles?: boolean;\n        tmContextType?: TmContextType;\n    }\n    type GlossaryAccessOption = 'readOnly' | 'fullAccess' | 'manageDrafts';\n    interface ProjectSettings extends Project {\n        translateDuplicates: TranslateDuplicates;\n        tagsDetection: TagDetection;\n        glossaryAccess: boolean;\n        glossaryAccessOption: GlossaryAccessOption;\n        isMtAllowed: boolean;\n        taskBasedAccessControl: boolean;\n        hiddenStringsProofreadersAccess: boolean;\n        autoSubstitution: boolean;\n        exportTranslatedOnly: boolean;\n        skipUntranslatedStrings: boolean;\n        exportApprovedOnly: boolean;\n        autoTranslateDialects: boolean;\n        useGlobalTm: boolean;\n        showTmSuggestionsDialects: boolean;\n        tmApprovedSuggestionsOnly: boolean;\n        isSuspended: boolean;\n        qaCheckIsActive: boolean;\n        qaCheckCategories: CheckCategories;\n        qaChecksIgnorableCategories: CheckCategories;\n        languageMapping: LanguageMapping;\n        notificationSettings: NotificationSettings;\n        defaultTmId: number;\n        defaultGlossaryId: number;\n        assignedTms: {\n            [id: string]: {\n                priority: number;\n            };\n        };\n        assignedGlossaries: number[];\n        tmPenalties: {\n            autoSubstitution: number;\n            tmPriority: {\n                priority: number;\n                penalty: number;\n            };\n            multipleTranslations: number;\n            timeSinceLastUsage: {\n                months: number;\n                penalty: number;\n            };\n            timeSinceLastModified: {\n                months: number;\n                penalty: number;\n            };\n        };\n        normalizePlaceholder: boolean;\n        tmPreTranslate: {\n            enabled: boolean;\n            autoApproveOption: 'all' | 'perfectMatchOnly' | 'exceptAutoSubstituted' | 'perfectMatchApprovedOnly' | 'none';\n            minimumMatchRatio: 'perfect' | '100';\n        };\n        mtPreTranslate: {\n            enabled: boolean;\n            mts: {\n                mtId: number;\n                languageIds: string[];\n            }[];\n        };\n        aiPreTranslate: {\n            enabled: boolean;\n            aiPrompts: {\n                aiPromptId: number;\n                languageIds: string[];\n            }[];\n        };\n        assistActionAiPromptId: number;\n        editorSuggestionAiPromptId: number;\n        inContext: boolean;\n        inContextProcessHiddenStrings: string;\n        inContextPseudoLanguageId: string;\n        inContextPseudoLanguage: LanguagesModel.Language;\n        saveMetaInfoInSource: boolean;\n        skipUntranslatedFiles: boolean;\n        tmContextType: TmContextType;\n        clientOrganizationId: number;\n        taskReviewerIds: number[];\n        exportWithMinApprovalsCount: number;\n        exportStringsThatPassedWorkflow: boolean;\n        qaApprovalsCount: number;\n        customQaCheckIds: number[];\n        externalQaCheckIds: number[];\n        delayedWorkflowStart: boolean;\n        alignmentActionAiPromptId: number;\n    }\n    enum Type {\n        FILES_BASED = 0,\n        STRINGS_BASED = 1\n    }\n    enum TagDetection {\n        AUTO = 0,\n        COUNT_TAGS = 1,\n        SKIP_TAGS = 2\n    }\n    type JoinPolicy = 'open' | 'private';\n    type LanguageAccessPolicy = 'open' | 'moderate';\n    interface CheckCategories {\n        empty: boolean;\n        size: boolean;\n        tags: boolean;\n        spaces: boolean;\n        variables: boolean;\n        punctuation: boolean;\n        symbolRegister: boolean;\n        specialSymbols: boolean;\n        wrongTranslation: boolean;\n        spellcheck: boolean;\n        icu: boolean;\n        terms: boolean;\n        duplicate: boolean;\n        ftl: boolean;\n        android: boolean;\n    }\n    interface LanguageMapping {\n        [key: string]: LanguageMappingEntity;\n    }\n    interface LanguageMappingEntity {\n        name: string;\n        two_letters_code: string;\n        three_letters_code: string;\n        locale: string;\n        locale_with_underscore: string;\n        android_code: string;\n        osx_code: string;\n        osx_locale: string;\n    }\n    enum TranslateDuplicates {\n        SHOW = 0,\n        HIDE_REGULAR_DETECTION = 1,\n        SHOW_AUTO_TRANSLATE = 2,\n        SHOW_WITHIN_VERION_BRANCH_REGULAR_DETECTION = 3,\n        HIDE_STRICT_DETECTION = 4,\n        SHOW_WITHIN_VERION_BRANCH_STRICT_DETECTION = 5\n    }\n    interface NotificationSettings {\n        translatorNewStrings?: boolean;\n        managerNewStrings?: boolean;\n        managerLanguageCompleted?: boolean;\n    }\n    interface ListGroupsOptions extends PaginationOptions {\n        parentId?: number;\n        userId?: number;\n        orderBy?: string;\n    }\n    interface ListProjectsOptions extends PaginationOptions {\n        groupId?: number;\n        hasManagerAccess?: BooleanInt;\n        orderBy?: string;\n        type?: BooleanInt;\n    }\n    type Settings = PropertyFileFormatSettings | CommonFileFormatSettings | XmlFileFormatSettings | MdxV2FormatSettings | FmHtmlFormatSettings | HtmlFormatSettings | JsonFormatSettings | MdxV1FormatSettings | JavaScriptFileFormatSettings | DocxFileFormatSettings;\n    interface ProjectFileFormatSettings {\n        id: number;\n        name: string;\n        format: string;\n        extensions: string[];\n        settings: Settings;\n        createdAt: string;\n        updatedAt: string;\n    }\n    interface AddProjectFileFormatSettingsRequest {\n        format: string;\n        settings: Settings;\n    }\n    interface PropertyFileFormatSettings {\n        escapeQuotes?: 0 | 1 | 2 | 3;\n        escapeSpecialCharacters?: 0 | 1;\n        exportPattern?: string;\n    }\n    interface JavaScriptFileFormatSettings {\n        exportPattern?: 'string';\n        exportQuotes?: 'single' | 'double';\n    }\n    interface CommonFileFormatSettings {\n        contentSegmentation?: boolean;\n        srxStorageId?: number;\n        exportPattern?: string;\n    }\n    interface XmlFileFormatSettings extends CommonFileFormatSettings {\n        translateContent?: boolean;\n        translateAttributes?: boolean;\n        translatableElements?: string[];\n    }\n    interface JsonFormatSettings extends CommonFileFormatSettings {\n        type?: 'i18next_json' | 'nestjs_i18n';\n    }\n    interface MdxV2FormatSettings extends CommonFileFormatSettings {\n        excludeCodeBlocks?: boolean;\n        excludedFrontMatterElements?: string[];\n    }\n    interface MdxV1FormatSettings extends CommonFileFormatSettings {\n        excludeCodeBlocks?: boolean;\n        excludedFrontMatterElements?: string[];\n        type?: 'mdx_v1' | 'mdx_v2';\n    }\n    interface FmHtmlFormatSettings extends CommonFileFormatSettings {\n        excludedElements?: boolean;\n        excludedFrontMatterElements?: string[];\n    }\n    interface HtmlFormatSettings extends CommonFileFormatSettings {\n        excludedElements?: boolean;\n    }\n    interface DocxFileFormatSettings extends CommonFileFormatSettings {\n        cleanTagsAggressively?: boolean;\n        translateHiddenText?: boolean;\n        translateHyperlinkUrls?: boolean;\n        translateHiddenRowsAndColumns?: boolean;\n        importNotes?: boolean;\n        importHiddenSlides?: boolean;\n    }\n    type TmContextType = 'segmentContext' | 'auto' | 'prevAndNextSegment';\n    type WorkflowTemplateStepConfig = WorkflowTemplateStepConfigTranslateProofread | WorkflowTemplateStepConfigVendor | WorkflowTemplateStepConfigTMPreTranslate | WorkflowTemplateStepConfigMTPreTranslate;\n    interface WorkflowTemplateStepConfigTranslateProofread {\n        id: number;\n        languages?: string[];\n        assignees?: number[];\n        config?: {\n            assignees: {\n                [key: string]: number[];\n            };\n        };\n    }\n    interface WorkflowTemplateStepConfigVendor {\n        id: number;\n        languages?: string[];\n        vendorId?: number;\n    }\n    interface WorkflowTemplateStepConfigTMPreTranslate {\n        id: number;\n        languages?: string[];\n        config?: {\n            minRelevant?: number;\n            autoSubstitution?: boolean;\n        };\n    }\n    interface WorkflowTemplateStepConfigMTPreTranslate {\n        id: number;\n        languages?: string[];\n        mtId?: number;\n    }\n    type StringsExporterSettings = AndroidStringsExporterSettings | MacOSXStringsExporterSettings | XliffStringsExporterSettings;\n    interface ProjectStringsExporterSettings {\n        id: number;\n        format: string;\n        settings: StringsExporterSettings;\n        createdAt: string;\n        updatedAt: string;\n    }\n    interface AndroidStringsExporterSettings {\n        convertPlaceholders?: boolean;\n        convertLineBreaks?: boolean;\n        useCdataForStringsWithTags?: boolean;\n    }\n    interface MacOSXStringsExporterSettings {\n        convertPlaceholders?: boolean;\n        convertLineBreaks?: boolean;\n    }\n    interface XliffStringsExporterSettings {\n        languagePairMapping?: {\n            [key: string]: {\n                sourceLanguageId: string;\n            };\n        };\n        copySourceToEmptyTarget?: boolean;\n        exportTranslatorsComment?: boolean;\n    }\n    interface AddProjectStringsExporterSettingsRequest {\n        format: string;\n        settings: StringsExporterSettings;\n    }\n}\n```\n\n##### reports/index.d.ts\n\n```typescript\nimport { CrowdinApi, DownloadLink, PaginationOptions, PatchRequest, ResponseList, ResponseObject, Status } from '../core';\nexport declare class Reports extends CrowdinApi {\n    listOrganizationReportArchives(options?: ReportsModel.ListReportArchiveParams): Promise<ResponseList<ReportsModel.ReportArchive>>;\n    getOrganizationReportArchive(archiveId: number): Promise<ResponseObject<ReportsModel.ReportArchive>>;\n    deleteOrganizationReportArchive(archiveId: number): Promise<void>;\n    exportOrganizationReportArchive(archiveId: number, request?: {\n        format?: ReportsModel.Format;\n    }): Promise<ResponseObject<Status<ReportsModel.ReportArchiveStatusAttribute>>>;\n    checkOrganizationReportArchiveStatus(archiveId: number, exportId: string): Promise<ResponseObject<Status<ReportsModel.ReportArchiveStatusAttribute>>>;\n    downloadOrganizationReportArchive(archiveId: number, exportId: string): Promise<ResponseObject<DownloadLink>>;\n    listUserReportArchives(userId: number, options?: ReportsModel.ListReportArchiveParams): Promise<ResponseList<ReportsModel.ReportArchive>>;\n    getUserReportArchive(userId: number, archiveId: number): Promise<ResponseObject<ReportsModel.ReportArchive>>;\n    deleteUserReportArchive(userId: number, archiveId: number): Promise<void>;\n    exportUserReportArchive(userId: number, archiveId: number, request?: {\n        format?: ReportsModel.Format;\n    }): Promise<ResponseObject<Status<ReportsModel.ReportArchiveStatusAttribute>>>;\n    checkUserReportArchiveStatus(userId: number, archiveId: number, exportId: string): Promise<ResponseObject<Status<ReportsModel.ReportArchiveStatusAttribute>>>;\n    downloadUserReportArchive(userId: number, archiveId: number, exportId: string): Promise<ResponseObject<DownloadLink>>;\n    generateGroupReport(groupId: number, request: ReportsModel.GenerateGroupReportRequest): Promise<ResponseObject<Status<ReportsModel.ReportStatusAttributes<ReportsModel.GroupReportSchema>>>>;\n    checkGroupReportStatus(groupId: number, reportId: string): Promise<ResponseObject<Status<ReportsModel.ReportStatusAttributes<ReportsModel.GroupReportSchema>>>>;\n    downloadGroupReport(groupId: number, reportId: string): Promise<ResponseObject<DownloadLink>>;\n    listOrganizationReportSettingsTemplates(options?: ReportsModel.ListOrganizationReportSettingsParams): Promise<ResponseList<ReportsModel.OrganizationReportSettings>>;\n    addOrganizationReportSettingsTemplate(request: ReportsModel.AddOrganizationReportSettingsRequest): Promise<ResponseObject<ReportsModel.OrganizationReportSettings>>;\n    getOrganizationReportSettingsTemplate(reportSettingsTemplateId: number): Promise<ResponseObject<ReportsModel.OrganizationReportSettings>>;\n    editOrganizationReportSettingsTemplate(reportSettingsTemplateId: number, request: PatchRequest[]): Promise<ResponseObject<ReportsModel.OrganizationReportSettings>>;\n    deleteOrganizationReportSettingsTemplate(reportSettingsTemplateId: number): Promise<void>;\n    generateOrganizationReport(request: ReportsModel.GenerateOrganizationReportRequest): Promise<ResponseObject<Status<ReportsModel.ReportStatusAttributes<ReportsModel.OrganizationReportSchema>>>>;\n    checkOrganizationReportStatus(reportId: string): Promise<ResponseObject<Status<ReportsModel.ReportStatusAttributes<ReportsModel.OrganizationReportSchema>>>>;\n    downloadOrganizationReport(reportId: string): Promise<ResponseObject<DownloadLink>>;\n    generateReport(projectId: number, request: ReportsModel.GenerateReportRequest): Promise<ResponseObject<Status<ReportsModel.ReportStatusAttributes<ReportsModel.ReportSchema>>>>;\n    checkReportStatus(projectId: number, reportId: string): Promise<ResponseObject<Status<ReportsModel.ReportStatusAttributes<ReportsModel.ReportSchema>>>>;\n    downloadReport(projectId: number, reportId: string): Promise<ResponseObject<DownloadLink>>;\n    listReportSettingsTemplates(projectId: number, options?: PaginationOptions): Promise<ResponseList<ReportsModel.ReportSettings>>;\n    addReportSettingsTemplate(projectId: number, request: ReportsModel.AddReportSettingsRequest): Promise<ResponseObject<ReportsModel.ReportSettings>>;\n    getReportSettingsTemplate(projectId: number, reportSettingsTemplateId: number): Promise<ResponseObject<ReportsModel.ReportSettings>>;\n    editReportSettingsTemplate(projectId: number, reportSettingsTemplateId: number, request: PatchRequest[]): Promise<ResponseObject<ReportsModel.ReportSettings>>;\n    deleteReportSettingsTemplate(projectId: number, reportSettingsTemplateId: number): Promise<void>;\n    listUserReportSettingsTemplates(userId: number, options?: PaginationOptions): Promise<ResponseList<ReportsModel.UserReportSettings>>;\n    addUserReportSettingsTemplate(userId: number, request: ReportsModel.AddUserReportSettingsRequest): Promise<ResponseObject<ReportsModel.UserReportSettings>>;\n    getUserReportSettingsTemplate(userId: number, reportSettingsTemplateId: number): Promise<ResponseObject<ReportsModel.UserReportSettings>>;\n    editUserReportSettingsTemplate(userId: number, reportSettingsTemplateId: number, request: PatchRequest[]): Promise<ResponseObject<ReportsModel.UserReportSettings>>;\n    deleteUserReportSettingsTemplate(userId: number, reportSettingsTemplateId: number): Promise<void>;\n}\nexport declare namespace ReportsModel {\n    interface ReportArchive {\n        id: number;\n        scopeType: string;\n        scopeId: number;\n        userId: number;\n        name: string;\n        webUrl: string;\n        scheme: any;\n        createdAt: string;\n    }\n    interface ListReportArchiveParams extends PaginationOptions {\n        scopeType: string;\n        scopeId: number;\n    }\n    interface ReportArchiveStatusAttribute {\n        format: Format;\n        reportName: string;\n        schema: any;\n    }\n    type GroupReportSchema = GroupTranslationCostsPostEditingSchema | GroupTopMembersSchema | GroupTaskUsageSchema | GroupQaCheckIssuesSchema | GroupTranslationActivitySchema;\n    type OrganizationReportSchema = GroupTranslationCostsPostEditingSchema | GroupTopMembersSchema | GroupTaskUsageSchema | GroupQaCheckIssuesSchema | GroupTranslationActivitySchema;\n    interface GenerateGroupReportRequest {\n        name: string;\n        schema: GroupReportSchema;\n    }\n    interface GenerateOrganizationReportRequest {\n        name: string;\n        schema: OrganizationReportSchema;\n    }\n    interface GroupTranslationCostsPostEditingSchema {\n        projectIds?: number[];\n        unit?: Unit;\n        currency?: Currency;\n        format?: Format;\n        baseRates: BaseRate;\n        individualRates: IndividualRate[];\n        netRateSchemes: NetRateSchemas;\n        excludeApprovalsForEditedTranslations?: boolean;\n        preTranslatedStringsCategorizationAdjustment?: boolean;\n        groupBy?: GroupBy;\n        dateFrom?: string;\n        dateTo?: string;\n        userIds?: number[];\n    }\n    interface GroupTranslationCostsPerEditingByTaskSchema {\n        unit?: Unit;\n        currency?: Currency;\n        format?: Format;\n        baseRates: BaseRate;\n        individualRates: IndividualRate[];\n        netRateSchemes: NetRateSchemas;\n        taskId?: number;\n    }\n    interface CostsEstimationSchema {\n        projectIds?: number[];\n        unit?: Unit;\n        currency?: Currency;\n        format?: Format;\n        baseRates: BaseRate;\n        individualRates: IndividualRate[];\n        netRateSchemes: NetRateSchemas;\n        calculateInternalMatches?: boolean;\n        includePreTranslatedStrings?: boolean;\n        languageId?: string;\n        branchIds?: number[];\n        dateFrom?: string;\n        dateTo?: string;\n        labelIds?: number[];\n        labelIncludeType?: LabelIncludeType;\n    }\n    interface CostsEstimationByTaskSchema {\n        unit?: Unit;\n        currency?: Currency;\n        format?: Format;\n        baseRates?: BaseRate;\n        individualRates?: IndividualRate[];\n        netRateSchemes?: NetRateSchemas;\n        calculateInternalMatches?: boolean;\n        includePreTranslatedStrings?: boolean;\n        taskId?: number;\n    }\n    interface GroupTopMembersSchema {\n        projectIds?: number[];\n        unit?: Unit;\n        languageId?: string;\n        format?: Format;\n        dateFrom?: string;\n        dateTo?: string;\n    }\n    interface RawDataSchema {\n        mode: ContributionMode;\n        unit?: Unit;\n        languageId?: string;\n        userId?: number;\n        dateFrom?: string;\n        dateTo?: string;\n    }\n    type GenerateReportRequest = PreTranslateEfficeincy | PreTranslateAccuracy | TranslateAccuracy | CostEstimationPostEnding | TranslationCostsPostEnding | TopMembers | ContributionRawData | SourceContentUpdates | ProjectMembers | EditorIssues | QaCheckIssues | SavingActivity | TranslationActivity;\n    type ReportSchema = Pick<GenerateReportRequest, 'schema'>;\n    interface PreTranslateEfficeincy {\n        name: 'pre-translate-efficiency';\n        schema: PreTranslateAccuracySchema | PreTranslateAccuracySchemaByTask;\n    }\n    interface PreTranslateAccuracy {\n        name: 'pre-translate-accuracy';\n        schema: PreTranslateAccuracySchema | PreTranslateAccuracySchemaByTask;\n    }\n    interface TranslateAccuracy {\n        name: 'translator-accuracy';\n        schema: TranslateAccuracySchema;\n    }\n    interface CostEstimationPostEnding {\n        name: 'costs-estimation-pe';\n        schema: CostEstimationPostEndingSchema | CostEstimationPostEndingSchemaByTask;\n    }\n    interface TranslationCostsPostEnding {\n        name: 'translation-costs-pe';\n        schema: TranslationCostsPostEndingSchema | TranslationCostsPostEndingSchemaByTask;\n    }\n    interface TopMembers {\n        name: 'top-members';\n        schema: TopMembersSchema;\n    }\n    interface ContributionRawData {\n        name: 'contribution-raw-data';\n        schema: ContributionRawDataSchema | ContributionRawDataSchemaByTask;\n    }\n    interface SourceContentUpdates {\n        name: 'source-content-updates';\n        schema: SourceContentUpdatesSchema;\n    }\n    interface ProjectMembers {\n        name: 'project-members';\n        schema: MembersSchema;\n    }\n    interface EditorIssues {\n        name: 'editor-issues';\n        schema: EditorIssuesSchema;\n    }\n    interface QaCheckIssues {\n        name: 'qa-check-issues';\n        schema: ProjectQaCheckIssuesSchema;\n    }\n    interface SavingActivity {\n        name: 'saving-activity';\n        schema: SavingActivitySchema;\n    }\n    interface TranslationActivity {\n        name: 'translation-activity';\n        schema: ProjectConsumptionSchema;\n    }\n    interface ReportStatusAttributes<S> {\n        format: Format;\n        reportName: string;\n        schema: S;\n    }\n    interface PreTranslateAccuracySchema {\n        unit?: Unit;\n        format?: Format;\n        postEditingCategories?: string[];\n        languageId?: string;\n        dateFrom?: string;\n        dateTo?: string;\n    }\n    interface PreTranslateAccuracySchemaByTask {\n        unit?: Unit;\n        format?: Format;\n        postEditingCategories?: string[];\n        taskId?: number;\n    }\n    interface TranslateAccuracySchema {\n        unit?: Unit;\n        format?: Format;\n        postEditingCategories?: string[];\n        languageId?: string;\n        userIds?: number[];\n        dateFrom?: string;\n        dateTo?: string;\n    }\n    interface CostEstimationPostEndingSchema {\n        unit?: Unit;\n        currency?: Currency;\n        format?: Format;\n        baseRates: BaseRate;\n        individualRates: IndividualRate[];\n        netRateSchemes: Omit<NetRateSchemas, 'mtMatch' | 'suggestionMatch'>;\n        calculateInternalMatches?: boolean;\n        includePreTranslatedStrings?: boolean;\n        languageId?: string;\n        fileIds?: number[];\n        directoryIds?: number[];\n        branchIds?: number[];\n        dateFrom?: string;\n        dateTo?: string;\n        labelIds?: number[];\n        labelIncludeType?: LabelIncludeType;\n        workflowStepId?: number;\n    }\n    interface CostEstimationPostEndingSchemaByTask {\n        unit?: Unit;\n        currency?: Currency;\n        format?: Format;\n        baseRates?: BaseRate;\n        individualRates?: IndividualRate[];\n        netRateSchemes?: Omit<NetRateSchemas, 'mtMatch' | 'suggestionMatch'>;\n        calculateInternalMatches?: boolean;\n        includePreTranslatedStrings?: boolean;\n        taskId?: number;\n    }\n    interface TranslationCostsPostEndingSchemaByTask {\n        unit?: Unit;\n        currency?: Currency;\n        format?: Format;\n        baseRates: BaseRate;\n        individualRates: IndividualRate[];\n        netRateSchemes: NetRateSchemas;\n        taskId?: number;\n        excludeApprovalsForEditedTranslations?: boolean;\n        preTranslatedStringsCategorizationAdjustment?: boolean;\n    }\n    interface TranslationCostsPostEndingSchema {\n        unit?: Unit;\n        currency?: Currency;\n        format?: Format;\n        baseRates: BaseRate;\n        individualRates: IndividualRate[];\n        netRateSchemes: NetRateSchemas;\n        excludeApprovalsForEditedTranslations?: boolean;\n        preTranslatedStringsCategorizationAdjustment?: boolean;\n        groupBy?: GroupBy;\n        dateFrom?: string;\n        dateTo?: string;\n        languageId?: string;\n        userIds?: number[];\n        fileIds?: number[];\n        directoryIds?: number[];\n        branchIds?: number[];\n        labelIds?: number;\n        labelIncludeType?: LabelIncludeType;\n        workflowStepId?: number;\n    }\n    interface TopMembersSchema {\n        unit?: Unit;\n        languageId?: string;\n        format?: Format;\n        dateFrom?: string;\n        dateTo?: string;\n    }\n    interface ContributionRawDataSchema {\n        mode: ContributionMode;\n        unit?: Unit;\n        languageId?: string;\n        userId?: string;\n        columns?: Column[];\n        fileIds?: number[];\n        directoryIds?: number[];\n        branchIds?: number[];\n        tmIds?: number[];\n        mtIds?: number[];\n        aiPromptIds?: number[];\n        dateFrom?: string;\n        dateTo?: string;\n    }\n    interface ContributionRawDataSchemaByTask {\n        mode: ContributionMode;\n        unit?: Unit;\n        taskId: number;\n        columns?: Column[];\n        tmIds?: number[];\n        mtIds?: number[];\n        aiPromptIds?: number[];\n        dateFrom?: string;\n        dateTo?: string;\n    }\n    interface PreTranslateEfficiencySchema {\n        unit?: Unit;\n        format?: Format;\n        postEditingCategories?: string[];\n        languageId?: string;\n        dateFrom?: string;\n        dateTo?: string;\n    }\n    interface ListOrganizationReportSettingsParams extends PaginationOptions {\n        projectId?: number;\n        groupId?: number;\n    }\n    interface ReportSettings {\n        id: number;\n        name: string;\n        currency: Currency;\n        unit: Unit;\n        config: ReportSettinsConfig;\n        isPublic: boolean;\n        isGlobal: boolean;\n        createdAt: string;\n        updatedAt: string;\n    }\n    interface AddReportSettingsRequest {\n        name: string;\n        currency: Currency;\n        unit: Unit;\n        config: ReportSettinsConfig;\n        isPublic?: boolean;\n        isGlobal?: boolean;\n    }\n    type UserReportSettings = Omit<ReportSettings, 'isPublic' | 'isGlobal'>;\n    type AddUserReportSettingsRequest = Omit<AddReportSettingsRequest, 'isPublic' | 'isGlobal'>;\n    type OrganizationReportSettings = Omit<ReportSettings, 'isGlobal'> & {\n        projectId: number;\n        groupId: number;\n    };\n    type AddOrganizationReportSettingsRequest = Omit<AddReportSettingsRequest, 'isGlobal'> & {\n        projectId?: number;\n        groupId?: number;\n    };\n    interface ReportSettinsConfig {\n        baseRates: BaseRate;\n        netRateSchemes: NetRateSchemas[];\n        individualRates: IndividualRate[];\n    }\n    type Unit = 'strings' | 'words' | 'chars' | 'chars_with_spaces';\n    type Currency = 'USD' | 'EUR' | 'JPY' | 'GBP' | 'AUD' | 'CAD' | 'CHF' | 'CNY' | 'SEK' | 'NZD' | 'MXN' | 'SGD' | 'HKD' | 'NOK' | 'KRW' | 'TRY' | 'RUB' | 'INR' | 'BRL' | 'ZAR' | 'GEL' | 'UAH';\n    type Format = 'xlsx' | 'csv' | 'json';\n    interface BaseRate {\n        fullTranslation: number;\n        proofread: number;\n    }\n    interface IndividualRate extends BaseRate {\n        languageIds: string[];\n        userIds: number[];\n        fullTranslation: number;\n        proofread: number;\n    }\n    interface NetRateSchemas {\n        tmMatch: {\n            matchType: Mode;\n            price: number;\n        }[];\n        mtMatch: {\n            matchType: Mode;\n            price: number;\n        }[];\n        suggestionMatch: {\n            matchType: Mode;\n            price: number;\n        }[];\n        aiMatch?: {\n            matchType: Mode;\n            price: number;\n        }[];\n    }\n    type Mode = 'no_match' | 'tm_match' | 'approval' | '99-95' | '94-90' | '89-80' | 'perfect' | '100';\n    type ContributionMode = 'translations' | 'approvals' | 'votes';\n    type GroupBy = 'user' | 'language';\n    type LabelIncludeType = 'strings_with_label' | 'strings_without_label';\n    type Column = 'userId' | 'languageId' | 'stringId' | 'translationId' | 'fileId' | 'filePath' | 'pluralForm' | 'sourceStringTextHash' | 'mtEngine' | 'mtId' | 'tmName' | 'tmId' | 'aiPromptName' | 'aiPromptId' | 'preTranslated' | 'tmMatch' | 'mtMatch' | 'aiMatch' | 'suggestionMatch' | 'sourceUnits' | 'targetUnits' | 'createdAt' | 'updatedAt' | 'mark';\n    interface SourceContentUpdatesSchema {\n        unit?: Unit;\n        format?: Format;\n        dateFrom?: string;\n        dateTo?: string;\n        languageId?: string;\n        userIds?: number[];\n        fileIds?: number[];\n        directoryIds?: number[];\n        branchIds?: number[];\n        labelIds?: number[];\n        labelIncludeType?: LabelIncludeType;\n    }\n    interface MembersSchema {\n        format?: Format;\n        dateFrom?: string;\n        dateTo?: string;\n    }\n    interface EditorIssuesSchema {\n        dateFrom?: string;\n        dateTo?: string;\n        format?: Format;\n        languageId?: string;\n        userId?: number;\n    }\n    interface ProjectQaCheckIssuesSchema {\n        format?: Format;\n        dateFrom?: string;\n        dateTo?: string;\n        languageId?: string;\n    }\n    interface SavingActivitySchema {\n        unit?: Unit;\n        languageId?: string;\n        format?: Format;\n        dateFrom?: string;\n        dateTo?: string;\n        userIds?: number[];\n        fileIds?: number[];\n        directoryIds?: number[];\n        branchIds?: number[];\n        labelIds?: number[];\n        labelIncludeType?: LabelIncludeType;\n    }\n    interface ProjectConsumptionSchema {\n        unit?: Unit;\n        languageId?: string;\n        format?: Format;\n        dateFrom?: string;\n        dateTo?: string;\n        userIds?: number[];\n        fileIds?: number[];\n        directoryIds?: number[];\n        branchIds?: number[];\n        labelIds?: number[];\n        labelIncludeType?: LabelIncludeType;\n    }\n    interface GroupTaskUsageSchema {\n        format: Format;\n        type: 'workload' | 'create-vs-resolve' | 'performance' | 'time' | 'cost';\n        projectIds?: number[];\n        assigneeId?: number;\n        creatorId?: number;\n        dateFrom?: string;\n        dateTo?: string;\n        wordsCountFrom?: number;\n        wordsCountTo?: number;\n        excludeApprovalsForEditedTranslations?: boolean;\n        currency?: Currency;\n        baseRates?: BaseRate;\n        individualRates?: IndividualRate[];\n        netRateSchemes?: NetRateSchemas;\n    }\n    interface GroupQaCheckIssuesSchema {\n        projectIds?: number[];\n        format?: Format;\n        dateFrom?: string;\n        dateTo?: string;\n        languageId?: string;\n    }\n    interface GroupTranslationActivitySchema {\n        projectIds?: number[];\n        unit?: Unit;\n        languageId?: string;\n        format?: Format;\n        dateFrom?: string;\n        dateTo?: string;\n        userIds?: number[];\n        fileIds?: number[];\n        directoryIds?: number[];\n        branchIds?: number[];\n        labelIds?: number[];\n        labelIncludeType?: LabelIncludeType;\n    }\n}\n```\n\n##### screenshots/index.d.ts\n\n```typescript\nimport { CrowdinApi, PaginationOptions, PatchRequest, ResponseList, ResponseObject } from '../core';\nexport declare class Screenshots extends CrowdinApi {\n    listScreenshots(projectId: number, options?: ScreenshotsModel.ListScreenshotParams): Promise<ResponseList<ScreenshotsModel.Screenshot>>;\n    listScreenshots(projectId: number, limit?: number, offset?: number): Promise<ResponseList<ScreenshotsModel.Screenshot>>;\n    addScreenshot(projectId: number, request: ScreenshotsModel.CreateScreenshotRequest): Promise<ResponseObject<ScreenshotsModel.Screenshot>>;\n    getScreenshot(projectId: number, screenshotId: number): Promise<ResponseObject<ScreenshotsModel.Screenshot>>;\n    updateScreenshot(projectId: number, screenshotId: number, request: ScreenshotsModel.UpdateScreenshotRequest): Promise<ResponseObject<ScreenshotsModel.Screenshot>>;\n    deleteScreenshot(projectId: number, screenshotId: number): Promise<void>;\n    editScreenshot(projectId: number, screenshotId: number, request: PatchRequest[]): Promise<ResponseObject<ScreenshotsModel.Screenshot>>;\n    listScreenshotTags(projectId: number, screenshotId: number, options?: PaginationOptions): Promise<ResponseList<ScreenshotsModel.Tag>>;\n    listScreenshotTags(projectId: number, screenshotId: number, limit?: number, offset?: number): Promise<ResponseList<ScreenshotsModel.Tag>>;\n    replaceTags(projectId: number, screenshotId: number, request: ScreenshotsModel.ReplaceTagRequest[] | ScreenshotsModel.AutoTagRequest): Promise<void>;\n    addTag(projectId: number, screenshotId: number, request: ScreenshotsModel.ReplaceTagRequest[]): Promise<ResponseObject<ScreenshotsModel.Tag>>;\n    clearTags(projectId: number, screenshotId: number): Promise<void>;\n    getTag(projectId: number, screenshotId: number, tagId: number): Promise<ResponseObject<ScreenshotsModel.Tag>>;\n    deleteTag(projectId: number, screenshotId: number, tagId: number): Promise<void>;\n    updateTag(projectId: number, screenshotId: number, tagId: number, request: PatchRequest[]): Promise<ResponseObject<ScreenshotsModel.Screenshot>>;\n}\nexport declare namespace ScreenshotsModel {\n    interface ListScreenshotParams extends PaginationOptions {\n        stringIds?: number[];\n        stringId?: number;\n        labelIds?: string;\n        excludeLabelIds?: string;\n        orderBy?: string;\n    }\n    interface Screenshot {\n        id: number;\n        userId: number;\n        url: string;\n        webUrl: string;\n        name: string;\n        size: Size;\n        tagsCount: number;\n        tags: Tag[];\n        labels: number[];\n        labelIds: number[];\n        createdAt: string;\n        updatedAt: string;\n    }\n    interface CreateScreenshotRequest {\n        storageId: number;\n        name: string;\n        autoTag?: boolean;\n        fileId?: number;\n        branchId?: number;\n        directoryId?: number;\n        labelIds?: number[];\n    }\n    interface UpdateScreenshotRequest {\n        storageId: number;\n        name: string;\n    }\n    interface Tag {\n        id: number;\n        screenshotId: number;\n        stringId: number;\n        position: Position;\n        createdAt: string;\n    }\n    interface ReplaceTagRequest {\n        stringId: number;\n        position?: Position;\n    }\n    interface AutoTagRequest {\n        autoTag: boolean;\n        fileId?: number;\n        branchId?: number;\n        directoryId?: number;\n    }\n    interface Size {\n        width: number;\n        height: number;\n    }\n    interface Position {\n        x: number;\n        y: number;\n        width: number;\n        height: number;\n    }\n}\n```\n\n##### securityLogs/index.d.ts\n\n```typescript\nimport { CrowdinApi, PaginationOptions, ResponseList, ResponseObject } from '../core';\nexport declare class SecurityLogs extends CrowdinApi {\n    listOrganizationSecurityLogs(options?: SecurityLogsModel.ListOrganizationSecurityLogsParams): Promise<ResponseList<SecurityLogsModel.SecurityLog>>;\n    getOrganizationSecurityLog(securityLogId: number): Promise<ResponseObject<SecurityLogsModel.SecurityLog>>;\n    listUserSecurityLogs(userId: number, options?: SecurityLogsModel.ListUserSecurityLogsParams): Promise<ResponseList<SecurityLogsModel.SecurityLog>>;\n    getUserSecurityLog(userId: number, securityLogId: number): Promise<ResponseObject<SecurityLogsModel.SecurityLog>>;\n}\nexport declare namespace SecurityLogsModel {\n    type Event = 'login' | 'password.set' | 'password.change' | 'email.change' | 'login.change' | 'personal_token.issued' | 'personal_token.revoked' | 'mfa.enabled' | 'mfa.disabled' | 'session.revoke' | 'session.revoke_all' | 'sso.connect' | 'sso.disconnect' | 'user.remove' | 'application.connected' | 'application.disconnected' | 'webauthn.created' | 'webauthn.deleted' | 'trusted_device.remove' | 'trusted_device.remove_all' | 'device_verification.enabled' | 'device_verification.disabled';\n    interface ListOrganizationSecurityLogsParams extends PaginationOptions {\n        event?: Event;\n        createdAfter?: string;\n        createdBefore?: string;\n        ipAddress?: string;\n        userId?: number;\n    }\n    type ListUserSecurityLogsParams = Omit<ListOrganizationSecurityLogsParams, 'userId'>;\n    interface SecurityLog {\n        id: number;\n        event: string;\n        info: string;\n        userId: number;\n        location: string;\n        ipAddress: string;\n        deviceName: string;\n        createdAt: string;\n    }\n}\n```\n\n##### sourceFiles/index.d.ts\n\n```typescript\nimport { CrowdinApi, DownloadLink, PaginationOptions, PatchRequest, ResponseList, ResponseObject, Status } from '../core';\nexport declare class SourceFiles extends CrowdinApi {\n    getClonedBranch(projectId: number, branchId: number, cloneId: string): Promise<ResponseObject<SourceFilesModel.Branch>>;\n    clonedBranch(projectId: number, branchId: number, request: SourceFilesModel.CloneBranchRequest): Promise<ResponseObject<Status<object>>>;\n    checkBranchClonedStatus(projectId: number, branchId: number, cloneId: string): Promise<ResponseObject<Status<object>>>;\n    listProjectBranches(projectId: number, options?: SourceFilesModel.ListProjectBranchesOptions): Promise<ResponseList<SourceFilesModel.Branch>>;\n    listProjectBranches(projectId: number, name?: string, limit?: number, offset?: number): Promise<ResponseList<SourceFilesModel.Branch>>;\n    createBranch(projectId: number, request: SourceFilesModel.CreateBranchRequest): Promise<ResponseObject<SourceFilesModel.Branch>>;\n    getBranch(projectId: number, branchId: number): Promise<ResponseObject<SourceFilesModel.Branch>>;\n    deleteBranch(projectId: number, branchId: number): Promise<void>;\n    editBranch(projectId: number, branchId: number, request: PatchRequest[]): Promise<ResponseObject<SourceFilesModel.Branch>>;\n    mergeBranch(projectId: number, branchId: number, request: SourceFilesModel.MergeBranchRequest): Promise<ResponseObject<Status<SourceFilesModel.MergeBranchAttributes>>>;\n    checkBranchMergeStatus(projectId: number, branchId: number, mergeId: string): Promise<ResponseObject<Status<SourceFilesModel.MergeBranchAttributes>>>;\n    getBranchMergeSummary(projectId: number, branchId: number, mergeId: string): Promise<ResponseObject<SourceFilesModel.MergeBranchSummary>>;\n    listProjectDirectories(projectId: number, options?: SourceFilesModel.ListProjectDirectoriesOptions): Promise<ResponseList<SourceFilesModel.Directory>>;\n    listProjectDirectories(projectId: number, branchId?: number, directoryId?: number, limit?: number, offset?: number, filter?: string, recursion?: string): Promise<ResponseList<SourceFilesModel.Directory>>;\n    createDirectory(projectId: number, request: SourceFilesModel.CreateDirectoryRequest): Promise<ResponseObject<SourceFilesModel.Directory>>;\n    getDirectory(projectId: number, directoryId: number): Promise<ResponseObject<SourceFilesModel.Directory>>;\n    deleteDirectory(projectId: number, directoryId: number): Promise<void>;\n    editDirectory(projectId: number, directoryId: number, request: PatchRequest[]): Promise<ResponseObject<SourceFilesModel.Directory>>;\n    listProjectFiles(projectId: number, options?: SourceFilesModel.ListProjectFilesOptions): Promise<ResponseList<SourceFilesModel.File>>;\n    listProjectFiles(projectId: number, branchId?: number, directoryId?: number, limit?: number, offset?: number, recursion?: any, filter?: string): Promise<ResponseList<SourceFilesModel.File>>;\n    createFile(projectId: number, request: SourceFilesModel.CreateFileRequest): Promise<ResponseObject<SourceFilesModel.File>>;\n    getFile(projectId: number, fileId: number): Promise<ResponseObject<SourceFilesModel.File>>;\n    updateOrRestoreFile(projectId: number, fileId: number, request: SourceFilesModel.ReplaceFileFromStorageRequest | SourceFilesModel.RestoreFile): Promise<ResponseObject<SourceFilesModel.File>>;\n    deleteFile(projectId: number, fileId: number): Promise<void>;\n    editFile(projectId: number, fileId: number, request: PatchRequest[]): Promise<ResponseObject<SourceFilesModel.File>>;\n    downloadFilePreview(projectId: number, fileId: number): Promise<ResponseObject<DownloadLink>>;\n    downloadFile(projectId: number, fileId: number): Promise<ResponseObject<DownloadLink>>;\n    listAssetReferences(projectId: number, fileId: number, options?: PaginationOptions): Promise<ResponseList<SourceFilesModel.AssetReference>>;\n    getAssetReference(projectId: number, fileId: number, referenceId: number): Promise<ResponseObject<SourceFilesModel.AssetReference>>;\n    addAssetReference(projectId: number, fileId: number, request: SourceFilesModel.AssetReferenceRequest): Promise<ResponseObject<SourceFilesModel.AssetReference>>;\n    deleteAssetReference(projectId: number, fileId: number, referenceId: number): Promise<void>;\n    listFileRevisions(projectId: number, fileId: number, options?: PaginationOptions): Promise<ResponseList<SourceFilesModel.FileRevision>>;\n    listFileRevisions(projectId: number, fileId: number, limit?: number, offset?: number): Promise<ResponseList<SourceFilesModel.FileRevision>>;\n    getFileRevision(projectId: number, fileId: number, revisionId: number): Promise<ResponseObject<SourceFilesModel.FileRevision>>;\n    listReviewedSourceFilesBuild(projectId: number, options?: SourceFilesModel.ListReviewedSourceFilesBuildOptions): Promise<ResponseList<SourceFilesModel.ReviewedSourceFilesBuild>>;\n    listReviewedSourceFilesBuild(projectId: number, branchId?: number, limit?: number, offset?: number): Promise<ResponseList<SourceFilesModel.ReviewedSourceFilesBuild>>;\n    buildReviewedSourceFiles(projectId: number, request?: SourceFilesModel.BuildReviewedSourceFilesRequest): Promise<ResponseObject<SourceFilesModel.ReviewedSourceFilesBuild>>;\n    checkReviewedSourceFilesBuildStatus(projectId: number, buildId: number): Promise<ResponseObject<SourceFilesModel.ReviewedSourceFilesBuild>>;\n    downloadReviewedSourceFiles(projectId: number, buildId: number): Promise<ResponseObject<DownloadLink>>;\n}\nexport declare namespace SourceFilesModel {\n    interface Branch {\n        id: number;\n        projectId: number;\n        name: string;\n        title: string;\n        exportPattern: string;\n        priority: Priority;\n        createdAt: string;\n        updatedAt: string;\n    }\n    interface CreateBranchRequest {\n        name: string;\n        title?: string;\n        exportPattern?: string;\n        priority?: Priority;\n    }\n    interface CloneBranchRequest {\n        name: string;\n        title?: string;\n    }\n    interface MergeBranchRequest {\n        deleteAfterMerge?: boolean;\n        sourceBranchId: number;\n        acceptSourceChanges?: boolean;\n        dryRun?: boolean;\n    }\n    interface MergeBranchAttributes {\n        sourceBranchId: number;\n        deleteAfterMerge: boolean;\n        acceptSourceChanges?: boolean;\n    }\n    interface MergeBranchSummary {\n        status: string;\n        sourceBranchId: number;\n        targetBranchId: number;\n        dryRun: boolean;\n        details: {\n            added: number;\n            deleted: number;\n            updated: number;\n            conflicted: number;\n        };\n    }\n    type Priority = 'low' | 'normal' | 'high';\n    interface ListProjectDirectoriesOptions extends PaginationOptions {\n        branchId?: number;\n        directoryId?: number;\n        filter?: string;\n        recursion?: string;\n        orderBy?: string;\n    }\n    interface Directory {\n        id: number;\n        projectId: number;\n        branchId: number;\n        directoryId: number;\n        name: string;\n        title: string;\n        exportPattern: string;\n        path: string;\n        priority: Priority;\n        createdAt: string;\n        updatedAt: string;\n    }\n    interface CreateDirectoryRequest {\n        name: string;\n        branchId?: number;\n        directoryId?: number;\n        title?: string;\n        exportPattern?: string;\n        priority?: Priority;\n    }\n    interface ListProjectFilesOptions extends PaginationOptions {\n        branchId?: number;\n        directoryId?: number;\n        recursion?: any;\n        filter?: string;\n        orderBy?: string;\n    }\n    interface File {\n        id: number;\n        projectId: number;\n        branchId: number;\n        directoryId: number;\n        name: string;\n        title: string;\n        context: string;\n        type: string;\n        path: string;\n        status: string;\n        revisionId: number;\n        priority: Priority;\n        importOptions: ImportOptions;\n        exportOptions: GeneralExportOptions | PropertyExportOptions;\n        excludedTargetLanguages: string[];\n        parserVersion: number;\n        createdAt: string;\n        updatedAt: string;\n        fields: Record<string, any>;\n    }\n    interface CreateFileRequest {\n        storageId: number;\n        name: string;\n        branchId?: number;\n        directoryId?: number;\n        title?: string;\n        context?: string;\n        type?: FileType;\n        parserVersion?: number;\n        importOptions?: ImportOptions;\n        exportOptions?: ExportOptions;\n        excludedTargetLanguages?: string[];\n        attachLabelIds?: number[];\n        fields?: Record<string, any>;\n    }\n    interface ReplaceFileFromStorageRequest {\n        storageId: number;\n        name?: string;\n        updateOption?: UpdateOption;\n        importOptions?: ImportOptions;\n        exportOptions?: ExportOptions;\n        attachLabelIds?: number[];\n        detachLabelIds?: number[];\n        replaceModifiedContext?: boolean;\n    }\n    type ExportOptions = GeneralExportOptions | PropertyExportOptions | JavaScriptExportOptions | MdExportOptions;\n    type ImportOptions = SpreadsheetImportOptions | XmlImportOptions | WebXmlImportOptions | DocxFileImportOptions | HtmlFileImportOptions | HtmlFrontMatterFileImportOptions | MdxFileImportOptions | MdFileImportOptions | StringCatalogFileImportOptions | AdocFileImportOptions | OtherImportOptions;\n    interface RestoreFile {\n        revisionId: number;\n    }\n    interface FileRevision {\n        id: number;\n        projectId: number;\n        fileId: number;\n        restoreToRevision: number;\n        info: FileRevisionInfo;\n        date: string;\n    }\n    interface FileRevisionInfo {\n        added: FileRevisionInfoAttribute;\n        deleted: FileRevisionInfoAttribute;\n        updated: FileRevisionInfoAttribute;\n    }\n    interface FileRevisionInfoAttribute {\n        strings: number;\n        words: number;\n    }\n    type FileType = 'auto' | 'android' | 'macosx' | 'resx' | 'properties' | 'gettext' | 'yaml' | 'php' | 'json' | 'xml' | 'ini' | 'rc' | 'resw' | 'resjson' | 'qtts' | 'joomla' | 'chrome' | 'dtd' | 'dklang' | 'flex' | 'nsh' | 'wxl' | 'xliff' | 'xliff_two' | 'html' | 'haml' | 'txt' | 'csv' | 'md' | 'flsnp' | 'fm_html' | 'fm_md' | 'mediawiki' | 'docx' | 'xlsx' | 'sbv' | 'properties_play' | 'properties_xml' | 'maxthon' | 'go_json' | 'dita' | 'mif' | 'idml' | 'stringsdict' | 'plist' | 'vtt' | 'vdf' | 'srt' | 'stf' | 'toml' | 'contentful_rt' | 'svg' | 'js' | 'coffee' | 'nestjs_i18n' | 'webxml';\n    interface SpreadsheetImportOptions {\n        firstLineContainsHeader?: boolean;\n        contentSegmentation?: boolean;\n        srxStorageId?: number;\n        importTranslations?: boolean;\n        scheme?: Scheme;\n    }\n    interface Scheme {\n        none: number;\n        identifier: number;\n        sourcePhrase: number;\n        sourceOrTranslation: number;\n        translation: number;\n        context: number;\n        maxLength: number;\n        labels: number;\n        [key: string]: number;\n    }\n    interface XmlImportOptions {\n        translateContent?: boolean;\n        translateAttributes?: boolean;\n        inlineTags?: string[];\n        contentSegmentation?: boolean;\n        translatableElements?: string[];\n        srxStorageId?: number;\n    }\n    interface WebXmlImportOptions {\n        inlineTags?: string[];\n        contentSegmentation?: boolean;\n        srxStorageId?: number;\n    }\n    interface DocxFileImportOptions {\n        cleanTagsAggressively?: boolean;\n        translateHiddenText?: boolean;\n        translateHyperlinkUrls?: boolean;\n        translateHiddenRowsAndColumns?: boolean;\n        importNotes?: boolean;\n        importHiddenSlides?: boolean;\n        contentSegmentation?: boolean;\n        srxStorageId?: number;\n    }\n    interface HtmlFileImportOptions {\n        excludedElements?: string[];\n        inlineTags?: string[];\n        contentSegmentation?: boolean;\n        srxStorageId?: number;\n    }\n    interface HtmlFrontMatterFileImportOptions extends HtmlFileImportOptions {\n        excludedFrontMatterElements?: string[];\n    }\n    interface MdxFileImportOptions {\n        excludedFrontMatterElements?: string[];\n        excludeCodeBlocks?: boolean;\n        contentSegmentation?: boolean;\n        srxStorageId?: number;\n    }\n    interface MdFileImportOptions {\n        excludedFrontMatterElements?: string[];\n        excludeCodeBlocks?: boolean;\n        inlineTags?: string[];\n        contentSegmentation?: boolean;\n        srxStorageId?: number;\n    }\n    interface StringCatalogFileImportOptions {\n        importKeyAsSource?: boolean;\n    }\n    interface AdocFileImportOptions {\n        excludeIncludeDirectives?: boolean;\n    }\n    interface OtherImportOptions {\n        contentSegmentation: boolean;\n        srxStorageId: number;\n    }\n    interface GeneralExportOptions {\n        exportPattern?: string;\n    }\n    interface PropertyExportOptions {\n        escapeQuotes?: EscapeQuotes;\n        exportPattern?: string;\n        escapeSpecialCharacters?: 0 | 1;\n    }\n    interface JavaScriptExportOptions {\n        exportPattern?: string;\n        exportQuotes?: ExportQuotes;\n    }\n    interface MdExportOptions {\n        exportPattern?: string;\n        strongMarker?: 'asterisk' | 'underscore';\n        emphasisMarker?: 'asterisk' | 'underscore';\n        unorderedListBullet?: 'asterisks' | 'plus' | 'plus';\n        tableColumnWidth?: 'consolidate' | 'evenly_distribute_cells';\n    }\n    enum EscapeQuotes {\n        ZERO = 0,\n        ONE = 1,\n        TWO = 2,\n        THREE = 3\n    }\n    enum ExportQuotes {\n        SINGLE = \"single\",\n        DOUBLE = \"double\"\n    }\n    type UpdateOption = 'clear_translations_and_approvals' | 'keep_translations' | 'keep_translations_and_approvals';\n    interface ReviewedSourceFilesBuild {\n        id: number;\n        projectId: number;\n        status: string;\n        progress: number;\n        attributes: ReviewedSourceFilesBuildAttributes;\n    }\n    interface ReviewedSourceFilesBuildAttributes {\n        branchId: number;\n        targetLanguageId: string;\n    }\n    interface BuildReviewedSourceFilesRequest {\n        branchId?: number;\n    }\n    interface ListProjectBranchesOptions extends PaginationOptions {\n        name?: string;\n        orderBy?: string;\n    }\n    interface ListReviewedSourceFilesBuildOptions extends PaginationOptions {\n        branchId?: number;\n    }\n    interface User {\n        id: number;\n        username: string;\n        fullName: string;\n        avatarUrl: string;\n    }\n    interface AssetReference {\n        id: number;\n        name: string;\n        user: User;\n        createdAt: string;\n        mimeType: string;\n    }\n    interface AssetReferenceRequest {\n        storageId: number;\n        name: string;\n    }\n}\n```\n\n##### sourceStrings/index.d.ts\n\n```typescript\nimport { BooleanInt, CrowdinApi, PaginationOptions, PatchRequest, ResponseList, ResponseObject, Status } from '../core';\nimport { SourceFilesModel } from '../sourceFiles';\nexport declare class SourceStrings extends CrowdinApi {\n    uploadStringsStatus(projectId: number, uploadId: string): Promise<ResponseObject<Status<SourceStringsModel.UploadStringsStatus>>>;\n    uploadStrings(projectId: number, request: SourceStringsModel.UploadStringsRequest): Promise<ResponseObject<Status<SourceStringsModel.UploadStringsStatus>>>;\n    listProjectStrings(projectId: number, options?: SourceStringsModel.ListProjectStringsOptions): Promise<ResponseList<SourceStringsModel.String>>;\n    listProjectStrings(projectId: number, fileId?: number, limit?: number, offset?: number, filter?: string, denormalizePlaceholders?: BooleanInt, labelIds?: string, scope?: SourceStringsModel.Scope, croql?: string, branchId?: number, directoryId?: number): Promise<ResponseList<SourceStringsModel.String>>;\n    addString(projectId: number, request: SourceStringsModel.CreateStringRequest | SourceStringsModel.CreateStringStringsBasedRequest): Promise<ResponseObject<SourceStringsModel.String>>;\n    stringBatchOperations(projectId: number, request: PatchRequest[]): Promise<ResponseList<SourceStringsModel.String>>;\n    getString(projectId: number, stringId: number, query?: {\n        denormalizePlaceholders: BooleanInt;\n    }): Promise<ResponseObject<SourceStringsModel.String>>;\n    deleteString(projectId: number, stringId: number): Promise<void>;\n    editString(projectId: number, stringId: number, request: PatchRequest[]): Promise<ResponseObject<SourceStringsModel.String>>;\n}\nexport declare namespace SourceStringsModel {\n    type UploadStringsType = 'auto' | 'android' | 'macosx' | 'arb' | 'csv' | 'json' | 'xliff' | 'xliff_two' | 'xlsx';\n    interface UploadStringsStatus {\n        branchId: number;\n        storageId: number;\n        fileType: UploadStringsType;\n        parserVersion: number;\n        labelIds: number[];\n        importOptions: {\n            firstLineContainsHeader: boolean;\n            importTranslations: boolean;\n            scheme: SourceFilesModel.Scheme;\n        };\n        updateStrings: boolean;\n        cleanupMode: boolean;\n        updateOption: UpdateOption;\n    }\n    interface UploadStringsRequest {\n        branchId: number;\n        storageId: number;\n        type?: UploadStringsType;\n        parserVersion?: number;\n        labelIds?: number[];\n        updateStrings?: boolean;\n        cleanupMode?: boolean;\n        importOptions?: {\n            firstLineContainsHeader: boolean;\n            importTranslations: boolean;\n            scheme: SourceFilesModel.Scheme;\n        };\n        updateOption?: UpdateOption;\n    }\n    interface ListProjectStringsOptions extends PaginationOptions {\n        orderBy?: string;\n        denormalizePlaceholders?: BooleanInt;\n        labelIds?: string;\n        fileId?: number;\n        branchId?: number;\n        directoryId?: number;\n        taskId?: number;\n        croql?: string;\n        filter?: string;\n        scope?: SourceStringsModel.Scope;\n    }\n    interface String {\n        id: number;\n        projectId: number;\n        branchId: number;\n        identifier: string;\n        text: string | PluralText;\n        type: Type;\n        context: string;\n        maxLength: number;\n        isHidden: boolean;\n        isDuplicate: boolean;\n        masterStringId: boolean;\n        hasPlurals: boolean;\n        isIcu: boolean;\n        labelIds: number[];\n        webUrl: string;\n        createdAt: string;\n        updatedAt: string;\n        fileId: number;\n        directoryId: number;\n        revision: number;\n        fields: Record<string, any>;\n    }\n    interface CreateStringRequest {\n        text: string | PluralText;\n        identifier?: string;\n        fileId: number;\n        context?: string;\n        isHidden?: boolean;\n        maxLength?: number;\n        labelIds?: number[];\n        fields?: Record<string, any>;\n    }\n    interface CreateStringStringsBasedRequest {\n        text: string | PluralText;\n        identifier: string;\n        branchId: number;\n        context?: string;\n        isHidden?: boolean;\n        maxLength?: number;\n        labelIds?: number[];\n        fields?: Record<string, any>;\n    }\n    interface PluralText {\n        zero?: string;\n        one?: string;\n        two?: string;\n        few?: string;\n        many?: string;\n        other?: string;\n    }\n    enum Type {\n        TEXT = 0,\n        ASSET = 1,\n        ICU = 2\n    }\n    type Scope = 'identifier' | 'text' | 'context';\n    type UpdateOption = 'clear_translations_and_approvals' | 'keep_translations' | 'keep_translations_and_approvals';\n}\n```\n\n##### stringComments/index.d.ts\n\n```typescript\nimport { CrowdinApi, PaginationOptions, PatchRequest, ResponseList, ResponseObject } from '../core';\nexport declare class StringComments extends CrowdinApi {\n    listStringComments(projectId: number, options?: StringCommentsModel.ListStringCommentsOptions): Promise<ResponseList<StringCommentsModel.StringComment>>;\n    listStringComments(projectId: number, stringId?: number, type?: StringCommentsModel.Type, targetLanguageId?: string, issueType?: StringCommentsModel.IssueType, issueStatus?: StringCommentsModel.IssueStatus): Promise<ResponseList<StringCommentsModel.StringComment>>;\n    addStringComment(projectId: number, request: StringCommentsModel.AddStringCommentRequest): Promise<ResponseObject<StringCommentsModel.StringComment>>;\n    getStringComment(projectId: number, stringCommentId: number): Promise<ResponseObject<StringCommentsModel.StringComment>>;\n    deleteStringComment(projectId: number, stringCommentId: number): Promise<void>;\n    editStringComment(projectId: number, stringCommentId: number, request: PatchRequest[]): Promise<ResponseObject<StringCommentsModel.StringComment>>;\n    stringCommentBatchOperations(projectId: number, request: PatchRequest[]): Promise<ResponseList<StringCommentsModel.StringComment>>;\n}\nexport declare namespace StringCommentsModel {\n    interface ListStringCommentsOptions extends PaginationOptions {\n        stringId?: number;\n        type?: Type;\n        targetLanguageId?: string;\n        issueType?: IssueType;\n        issueStatus?: IssueStatus;\n        orderBy?: string;\n    }\n    interface StringComment {\n        id: number;\n        isShared?: boolean;\n        text: string;\n        userId: number;\n        stringId: number;\n        user: User;\n        string: StringModel;\n        projectId: number;\n        languageId: string;\n        type: Type;\n        issueType: IssueType;\n        issueStatus: IssueStatus;\n        resolverId: number;\n        senderOrganization: {\n            id: number;\n            domain: string;\n        };\n        resolverOrganization: {\n            id: number;\n            domain: string;\n        };\n        resolver: User;\n        resolvedAt: string;\n        createdAt: string;\n    }\n    interface User {\n        id: number;\n        username: string;\n        fullName: string;\n        avatarUrl: string;\n    }\n    interface StringModel {\n        id: number;\n        text: string;\n        type: string;\n        hasPlurals: boolean;\n        isIcu: boolean;\n        context: string;\n        fileId: number;\n    }\n    interface AddStringCommentRequest {\n        stringId: number;\n        text: string;\n        targetLanguageId: string;\n        type: Type;\n        isShared?: boolean;\n        issueType?: IssueType;\n    }\n    type Type = 'comment' | 'issue';\n    type IssueType = 'general_question' | 'translation_mistake' | 'context_request' | 'source_mistake';\n    type IssueStatus = 'unresolved' | 'resolved';\n}\n```\n\n##### stringCorrections/index.d.ts\n\n```typescript\nimport { BooleanInt, CrowdinApi, PaginationOptions, ResponseList, ResponseObject } from '../core';\nexport declare class StringCorrections extends CrowdinApi {\n    listStringCorrections(projectId: number, options: StringCorrectionsModel.ListStringCorrectionsParams): Promise<ResponseList<StringCorrectionsModel.StringCorrection>>;\n    addStringCorrection(projectId: number, request: StringCorrectionsModel.AddStringCorrectionRequest): Promise<ResponseObject<StringCorrectionsModel.StringCorrection>>;\n    deleteStringCorrections(projectId: number, stringId: number): Promise<void>;\n    getStringCorrection(projectId: number, correctionId: number, params?: {\n        denormalizePlaceholders?: BooleanInt;\n    }): Promise<ResponseObject<StringCorrectionsModel.StringCorrection>>;\n    restoreStringCorrection(projectId: number, correctionId: number): Promise<ResponseObject<StringCorrectionsModel.StringCorrection>>;\n    deleteStringCorrection(projectId: number, correctionId: number): Promise<void>;\n}\nexport declare namespace StringCorrectionsModel {\n    interface ListStringCorrectionsParams extends PaginationOptions {\n        stringId: number;\n        orderBy?: string;\n        denormalizePlaceholders?: BooleanInt;\n    }\n    interface StringCorrection {\n        id: number;\n        text: string;\n        pluralCategoryName: PluralCategoryName;\n        user: {\n            id: number;\n            username: string;\n            fullName: string;\n            avatarUrl: string;\n        };\n        createdAt: string;\n    }\n    type PluralCategoryName = 'zero' | 'one' | 'two' | 'few' | 'many' | 'other';\n    interface AddStringCorrectionRequest {\n        stringId: number;\n        text: string;\n        pluralCategoryName?: PluralCategoryName;\n    }\n}\n```\n\n##### stringTranslations/index.d.ts\n\n```typescript\nimport { BooleanInt, CrowdinApi, PaginationOptions, PatchRequest, ResponseList, ResponseObject } from '../core';\nexport declare class StringTranslations extends CrowdinApi {\n    listTranslationApprovals(projectId: number, options?: StringTranslationsModel.ListTranslationApprovalsOptions): Promise<ResponseList<StringTranslationsModel.Approval>>;\n    listTranslationApprovals(projectId: number, stringId?: number, languageId?: string, translationId?: number, limit?: number, offset?: number, fileId?: number, labelIds?: string, excludeLabelIds?: string): Promise<ResponseList<StringTranslationsModel.Approval>>;\n    addApproval(projectId: number, request: StringTranslationsModel.AddApprovalRequest): Promise<ResponseObject<StringTranslationsModel.Approval>>;\n    removeStringApprovals(projectId: number, stringId: number): Promise<void>;\n    approvalInfo(projectId: number, approvalId: number): Promise<ResponseObject<StringTranslationsModel.Approval>>;\n    approvalBatchOperations(projectId: number, request: PatchRequest[]): Promise<ResponseList<StringTranslationsModel.Approval>>;\n    removeApproval(projectId: number, approvalId: number): Promise<void>;\n    listLanguageTranslations(projectId: number, languageId: string, options?: StringTranslationsModel.ListLanguageTranslationsOptions): Promise<ResponseList<StringTranslationsModel.PlainLanguageTranslation | StringTranslationsModel.PluralLanguageTranslation | StringTranslationsModel.IcuLanguageTranslation>>;\n    listLanguageTranslations(projectId: number, languageId: string, stringIds?: string, fileId?: number, limit?: number, offset?: number, labelIds?: string, denormalizePlaceholders?: BooleanInt, croql?: string): Promise<ResponseList<StringTranslationsModel.PlainLanguageTranslation | StringTranslationsModel.PluralLanguageTranslation | StringTranslationsModel.IcuLanguageTranslation>>;\n    translationAlignment(projectId: number, request: StringTranslationsModel.TranslationAlignmentRequest): Promise<ResponseObject<StringTranslationsModel.TranslationAlignmentResponse>>;\n    listStringTranslations(projectId: number, stringId: number, languageId: string, options?: StringTranslationsModel.ListStringTranslationsOptions): Promise<ResponseList<StringTranslationsModel.StringTranslation>>;\n    listStringTranslations(projectId: number, stringId: number, languageId: string, limit?: number, offset?: number, denormalizePlaceholders?: BooleanInt): Promise<ResponseList<StringTranslationsModel.StringTranslation>>;\n    addTranslation(projectId: number, request: StringTranslationsModel.AddStringTranslationRequest): Promise<ResponseObject<StringTranslationsModel.StringTranslation>>;\n    deleteAllTranslations(projectId: number, stringId: number, languageId?: string): Promise<void>;\n    translationInfo(projectId: number, translationId: number): Promise<ResponseObject<StringTranslationsModel.StringTranslation>>;\n    restoreTranslation(projectId: number, translationId: number): Promise<ResponseObject<StringTranslationsModel.StringTranslation>>;\n    translationBatchOperations(projectId: number, request: PatchRequest[]): Promise<ResponseList<StringTranslationsModel.StringTranslation>>;\n    deleteTranslation(projectId: number, translationId: number): Promise<void>;\n    listTranslationVotes(projectId: number, options?: StringTranslationsModel.ListTranslationVotesOptions): Promise<ResponseList<StringTranslationsModel.Vote>>;\n    listTranslationVotes(projectId: number, stringId?: number, languageId?: string, translationId?: number, labelIds?: string, excludeLabelIds?: string, limit?: number, offset?: number): Promise<ResponseList<StringTranslationsModel.Vote>>;\n    addVote(projectId: number, request: StringTranslationsModel.AddVoteRequest): Promise<ResponseObject<StringTranslationsModel.Vote>>;\n    voteInfo(projectId: number, voteId: number): Promise<ResponseObject<StringTranslationsModel.Vote>>;\n    cancelVote(projectId: number, voteId: number): Promise<void>;\n}\nexport declare namespace StringTranslationsModel {\n    interface ListTranslationApprovalsOptions extends PaginationOptions {\n        stringId?: number;\n        languageId?: string;\n        translationId?: number;\n        fileId?: number;\n        labelIds?: string;\n        excludeLabelIds?: string;\n        orderBy?: string;\n    }\n    interface Approval {\n        id: number;\n        user: User;\n        translationId: number;\n        stringId: number;\n        languageId: string;\n        createdAt: string;\n    }\n    interface AddApprovalRequest {\n        translationId: number;\n    }\n    interface StringTranslation {\n        id: number;\n        text: string;\n        pluralCategoryName: PluralCategoryName;\n        user: User;\n        rating: number;\n        provider: string;\n        isPreTranslated: boolean;\n        createdAt: string;\n    }\n    interface ListLanguageTranslationsOptions extends PaginationOptions {\n        stringIds?: string;\n        fileId?: number;\n        labelIds?: string;\n        denormalizePlaceholders?: BooleanInt;\n        croql?: string;\n        approvedOnly?: BooleanInt;\n        passedWorkflow?: BooleanInt;\n        orderBy?: string;\n        branchId?: number;\n        minApprovalCount?: number;\n        directoryId?: number;\n    }\n    interface PlainLanguageTranslation {\n        stringId: number;\n        contentType: string;\n        translationId: number;\n        text: string;\n        user: User;\n        createdAt: string;\n    }\n    interface PluralLanguageTranslation {\n        stringId: number;\n        contentType: string;\n        plurals: Plural[];\n    }\n    interface IcuLanguageTranslation {\n        stringId: number;\n        contentType: string;\n        translationId: number;\n        text: string;\n        user: User;\n        createdAt: string;\n    }\n    interface Plural {\n        translationId: number;\n        text: string;\n        pluralForm: string;\n        user: User;\n        createdAt: string;\n    }\n    interface TranslationAlignmentRequest {\n        sourceLanguageId: string;\n        targetLanguageId: string;\n        text: string;\n    }\n    interface TranslationAlignmentResponse {\n        words: {\n            text: string;\n            alignments: {\n                sourceWord: string;\n                sourceLemma: string;\n                targetWord: string;\n                targetLemma: string;\n                match: number;\n                probability: number;\n            }[];\n        }[];\n    }\n    interface AddStringTranslationRequest {\n        stringId: number;\n        languageId: string;\n        text: string;\n        pluralCategoryName?: PluralCategoryName;\n        addToTm?: boolean;\n    }\n    interface ListTranslationVotesOptions extends PaginationOptions {\n        stringId?: number;\n        languageId?: string;\n        translationId?: number;\n        fileId?: number;\n        labelIds?: string;\n        excludeLabelIds?: string;\n    }\n    interface Vote {\n        id: number;\n        user: User;\n        translationId: number;\n        votedAt: string;\n        mark: Mark;\n    }\n    interface AddVoteRequest {\n        mark: Mark;\n        translationId: number;\n    }\n    interface User {\n        id: number;\n        username: string;\n        fullName: string;\n        avatarUrl: string;\n    }\n    type Mark = 'up' | 'down';\n    interface ListStringTranslationsOptions extends PaginationOptions {\n        denormalizePlaceholders?: BooleanInt;\n        orderBy?: string;\n    }\n    type PluralCategoryName = 'zero' | 'one' | 'two' | 'few' | 'many' | 'other';\n}\n```\n\n##### tasks/index.d.ts\n\n```typescript\nimport { BooleanInt, CrowdinApi, DownloadLink, PaginationOptions, PatchRequest, ResponseList, ResponseObject } from '../core';\nimport { LanguagesModel } from '../languages';\nexport declare class Tasks extends CrowdinApi {\n    listTasks(projectId: number, options?: TasksModel.ListTasksOptions): Promise<ResponseList<TasksModel.Task>>;\n    listTasks(projectId: number, limit?: number, offset?: number, status?: TasksModel.Status): Promise<ResponseList<TasksModel.Task>>;\n    addTask(projectId: number, request: TasksModel.CreateTaskRequest): Promise<ResponseObject<TasksModel.Task>>;\n    exportTaskStrings(projectId: number, taskId: number): Promise<ResponseObject<DownloadLink>>;\n    getTask(projectId: number, taskId: number): Promise<ResponseObject<TasksModel.Task>>;\n    deleteTask(projectId: number, taskId: number): Promise<void>;\n    editTask(projectId: number, taskId: number, request: PatchRequest[]): Promise<ResponseObject<TasksModel.Task>>;\n    listTasksComments(projectId: number, taskId: number, options?: PaginationOptions): Promise<ResponseList<TasksModel.TaskComment>>;\n    addTaskComment(projectId: number, taskId: number, request: TasksModel.CreateTaskCommentRequest): Promise<ResponseObject<TasksModel.TaskComment>>;\n    getTaskComment(projectId: number, taskId: number, commentId: number): Promise<ResponseObject<TasksModel.TaskComment>>;\n    deleteTaskComment(projectId: number, taskId: number, commentId: number): Promise<void>;\n    editTaskComment(projectId: number, taskId: number, commentId: number, request: PatchRequest[]): Promise<ResponseObject<TasksModel.TaskComment>>;\n    listUserTasks(options?: TasksModel.ListUserTasksOptions): Promise<ResponseList<TasksModel.UserTask>>;\n    listUserTasks(limit?: number, offset?: number, status?: TasksModel.Status, isArchived?: BooleanInt): Promise<ResponseList<TasksModel.UserTask>>;\n    editTaskArchivedStatus(projectId: number, taskId: number, request: PatchRequest[]): Promise<ResponseObject<TasksModel.UserTask>>;\n    listTaskSettingsTemplates(projectId: number, options?: PaginationOptions): Promise<ResponseList<TasksModel.TaskSettingsTemplate>>;\n    addTaskSettingsTemplate(projectId: number, request: TasksModel.AddTaskSettingsTemplate): Promise<ResponseObject<TasksModel.TaskSettingsTemplate>>;\n    getTaskSettingsTemplate(projectId: number, taskSettingsId: number): Promise<ResponseObject<TasksModel.TaskSettingsTemplate>>;\n    deleteTaskSettingsTemplate(projectId: number, taskSettingsId: number): Promise<void>;\n    editTaskSettingsTemplate(projectId: number, taskSettingsId: number, request: PatchRequest[]): Promise<ResponseObject<TasksModel.TaskSettingsTemplate>>;\n}\nexport declare namespace TasksModel {\n    interface Task {\n        id: number;\n        projectId: number;\n        creatorId: number;\n        type: Type | TypeVendor;\n        status: Status;\n        title: string;\n        assignees: Assignee[];\n        assignedTeams: AssignedTeam[];\n        progress: Progress;\n        translateProgress: Progress;\n        sourceLanguageId: string;\n        targetLanguageId: string;\n        description: string;\n        translationUrl: string;\n        webUrl: string;\n        wordsCount: number;\n        commentsCount: number;\n        deadline: string;\n        startedAt: string;\n        resolvedAt: string;\n        timeRange: string;\n        workflowStepId: number;\n        buyUrl: string;\n        createdAt: string;\n        updatedAt: string;\n        sourceLanguage: LanguagesModel.Language;\n        targetLanguages: LanguagesModel.Language[];\n        labelIds: number[];\n        excludeLabelIds: number[];\n        precedingTaskId: number;\n        filesCount: number;\n        fileIds: number[];\n        branchIds: number[];\n        vendor: string;\n        fields: Record<string, any>;\n    }\n    interface ListUserTasksOptions extends PaginationOptions {\n        status?: Status;\n        isArchived?: BooleanInt;\n        orderBy?: string;\n    }\n    interface UserTask extends Task {\n        isArchived: boolean;\n    }\n    type CreateTaskRequest = CreateTaskEnterpriseByBranchIds | CreateTaskEnterpriseByFileIds | CreateTaskEnterpriseByStringIds | CreateTaskEnterpriseVendorByBranchIds | CreateTaskEnterpriseVendorByFileIds | CreateTaskEnterpriseVendorByStringIds | CreateTaskEnterprisePendingTask | CreateTaskByFileIds | CreateTaskByStringIds | CreateTaskByBranchIds | CreateTaskByFileIdsLanguageService | CreateTaskByStringIdsLanguageService | CreateTaskByBranchIdsLanguageService | CreateTaskVendorOhtByFileIds | CreateTaskVendorOhtByStringIds | CreateTaskVendorOhtByBranchIds | CreateTaskVendorGengoByFileIds | CreateTaskVendorGengoByStringIds | CreateTaskVendorGengoByBranchIds | CreateTaskVendorManualByFileIds | CreateTaskVendorManualByStringIds | CreateTaskVendorManualByBranchIds | CreateTaskPendingTask | CreateTaskPendingTaskLanguageService | CreateTaskPendingTaskVendorManual;\n    interface CreateTaskEnterpriseByBranchIds {\n        type: Type;\n        workflowStepId: number;\n        title: string;\n        languageId: string;\n        branchIds: number[];\n        labelIds?: number[];\n        excludeLabelIds?: number[];\n        status?: RequestStatus;\n        description?: string;\n        splitContent?: boolean;\n        skipAssignedStrings?: boolean;\n        assignees?: CreateTaskAssignee[];\n        assignedTeams?: AssignedTeam[];\n        includePreTranslatedStringsOnly?: boolean;\n        deadline?: string;\n        startedAt?: string;\n        dateFrom?: string;\n        dateTo?: string;\n        fields?: Record<string, any>;\n    }\n    interface CreateTaskEnterpriseByStringIds {\n        type: Type;\n        workflowStepId: number;\n        title: string;\n        languageId: string;\n        stringIds: number[];\n        status?: RequestStatus;\n        description?: string;\n        splitContent?: boolean;\n        skipAssignedStrings?: boolean;\n        assignees?: CreateTaskAssignee[];\n        assignedTeams?: AssignedTeam[];\n        includePreTranslatedStringsOnly?: boolean;\n        deadline?: string;\n        startedAt?: string;\n        dateFrom?: string;\n        dateTo?: string;\n        fields?: Record<string, any>;\n    }\n    type CreateTaskEnterpriseVendorByStringIds = Omit<CreateTaskEnterpriseByStringIds, 'type' | 'status' | 'splitContent' | 'assignees' | 'assignedTeams'>;\n    type CreateTaskEnterpriseVendorByBranchIds = Omit<CreateTaskEnterpriseByBranchIds, 'type' | 'status' | 'splitContent' | 'assignees' | 'assignedTeams'>;\n    type CreateTaskEnterpriseByFileIds = Omit<CreateTaskEnterpriseByBranchIds, 'branchIds'> & {\n        fileIds: number[];\n    };\n    type CreateTaskEnterpriseVendorByFileIds = Omit<CreateTaskEnterpriseByFileIds, 'type' | 'status' | 'splitContent' | 'assignees' | 'assignedTeams'>;\n    interface CreateTaskEnterprisePendingTask {\n        precedingTaskId: number;\n        type: Type.PROOFREAD;\n        title: string;\n        description?: string;\n        assignees?: CreateTaskAssignee[];\n        assignedTeams?: AssignedTeam[];\n        deadline?: string;\n    }\n    interface CreateTaskByFileIds {\n        title: string;\n        languageId: string;\n        type: Type;\n        fileIds: number[];\n        labelIds?: number[];\n        excludeLabelIds?: number[];\n        status?: RequestStatus;\n        description?: string;\n        splitContent?: boolean;\n        skipAssignedStrings?: boolean;\n        includePreTranslatedStringsOnly?: boolean;\n        assignees?: CreateTaskAssignee[];\n        deadline?: string;\n        startedAt?: string;\n        dateFrom?: string;\n        dateTo?: string;\n    }\n    type CreateTaskByStringIds = Omit<CreateTaskByFileIds, 'fileIds' | 'labelIds' | 'excludeLabelIds'> & {\n        stringIds: number;\n    };\n    type CreateTaskByBranchIds = Omit<CreateTaskByFileIds, 'fileIds'> & {\n        branchIds: number;\n    };\n    interface CreateTaskByFileIdsLanguageService {\n        title: string;\n        languageId: string;\n        type: TypeVendor;\n        vendor: 'crowdin_language_service';\n        fileIds: number[];\n        labelIds?: number[];\n        excludeLabelIds?: number[];\n        status?: RequestStatus;\n        description?: string;\n        includePreTranslatedStringsOnly?: boolean;\n        assignees?: CreateTaskAssignee[];\n        dateFrom?: string;\n        dateTo?: string;\n    }\n    type CreateTaskByStringIdsLanguageService = Omit<CreateTaskByFileIdsLanguageService, 'fileIds' | 'labelIds' | 'excludeLabelIds'> & {\n        stringIds: number[];\n    };\n    type CreateTaskByBranchIdsLanguageService = Omit<CreateTaskByFileIdsLanguageService, 'fileIds'> & {\n        branchIds: number[];\n    };\n    interface CreateTaskVendorOhtByFileIds {\n        title: string;\n        languageId: string;\n        type: TypeVendor;\n        vendor: 'oht';\n        fileIds: number[];\n        labelIds?: number[];\n        excludeLabelIds?: number[];\n        status?: RequestStatus;\n        description?: string;\n        expertise?: Expertise;\n        editService?: boolean;\n        includePreTranslatedStringsOnly?: boolean;\n        dateFrom?: string;\n        dateTo?: string;\n    }\n    type CreateTaskVendorOhtByStringIds = Omit<CreateTaskVendorOhtByFileIds, 'fileIds' | 'labelIds' | 'excludeLabelIds'> & {\n        stringIds: number[];\n    };\n    type CreateTaskVendorOhtByBranchIds = Omit<CreateTaskVendorOhtByFileIds, 'fileIds'> & {\n        branchIds: number[];\n    };\n    interface CreateTaskVendorGengoByFileIds {\n        title: string;\n        languageId: string;\n        type: TypeVendor.TRANSLATE_BY_VENDOR;\n        vendor: 'gengo';\n        fileIds: number[];\n        labelIds?: number[];\n        excludeLabelIds?: number[];\n        status?: RequestStatus;\n        description?: string;\n        expertise?: 'standard' | 'pro';\n        tone?: Tone;\n        purpose?: Purpose;\n        customerMessage?: string;\n        usePreferred?: boolean;\n        editService?: boolean;\n        dateFrom?: string;\n        dateTo?: string;\n    }\n    type CreateTaskVendorGengoByStringIds = Omit<CreateTaskVendorGengoByFileIds, 'fileIds' | 'labelIds' | 'excludeLabelIds'> & {\n        stringIds: number[];\n    };\n    type CreateTaskVendorGengoByBranchIds = Omit<CreateTaskVendorGengoByFileIds, 'fileIds'> & {\n        branchIds: number[];\n    };\n    interface CreateTaskVendorManualByFileIds {\n        title: string;\n        languageId: string;\n        type: TypeVendor;\n        vendor: 'alconost' | 'babbleon' | 'tomedes' | 'e2f' | 'write_path_admin' | 'inlingo' | 'acclaro' | 'translate_by_humans' | 'lingo24' | 'assertio_language_services' | 'gte_localize' | 'kettu_solutions' | 'languageline_solutions';\n        fileIds: number[];\n        labelIds?: number[];\n        excludeLabelIds?: number[];\n        status?: RequestStatus;\n        description?: string;\n        skipAssignedStrings?: boolean;\n        includePreTranslatedStringsOnly?: boolean;\n        assignees?: CreateTaskAssignee[];\n        deadline?: string;\n        startedAt?: string;\n        dateFrom?: string;\n        dateTo?: string;\n    }\n    type CreateTaskVendorManualByStringIds = Omit<CreateTaskVendorManualByFileIds, 'fileIds' | 'labelIds' | 'excludeLabelIds'> & {\n        stringIds: number[];\n    };\n    type CreateTaskVendorManualByBranchIds = Omit<CreateTaskVendorManualByFileIds, 'fileIds'> & {\n        branchIds: number[];\n    };\n    interface CreateTaskPendingTask {\n        precedingTaskId: number;\n        type: Type.PROOFREAD;\n        title: string;\n        description?: string;\n        assignees?: CreateTaskAssignee[];\n        deadline?: string;\n    }\n    interface CreateTaskPendingTaskLanguageService {\n        precedingTaskId: number;\n        type: TypeVendor.PROOFREAD_BY_VENDOR;\n        vendor: 'crowdin_language_service';\n        title: string;\n        description?: string;\n        deadline?: string;\n    }\n    interface CreateTaskPendingTaskVendorManual {\n        precedingTaskId: number;\n        type: TypeVendor.PROOFREAD_BY_VENDOR;\n        vendor: CreateTaskVendorManualByFileIds['vendor'];\n        title: string;\n        description?: string;\n        deadline?: string;\n    }\n    interface CreateTaskAssignee {\n        id: number;\n        wordsCount?: number;\n    }\n    type Status = 'todo' | 'in_progress' | 'done' | 'closed';\n    type RequestStatus = Extract<Status, 'todo' | 'in_progress'>;\n    enum Type {\n        TRANSLATE = 0,\n        PROOFREAD = 1\n    }\n    enum TypeVendor {\n        TRANSLATE_BY_VENDOR = 2,\n        PROOFREAD_BY_VENDOR = 3\n    }\n    interface Assignee {\n        id: number;\n        username: string;\n        fullName: string;\n        avatarUrl: string;\n        wordsCount: number;\n        wordsLeft: number;\n    }\n    interface AssignedTeam {\n        id: number;\n        wordsCount: number;\n    }\n    interface Progress {\n        total: number;\n        done: number;\n        percent: number;\n    }\n    type Expertise = 'standard' | 'mobile-applications' | 'software-it' | 'gaming-video-games' | 'technical-engineering' | 'marketing-consumer-media' | 'business-finance' | 'legal-certificate' | 'medical' | 'ad-words-banners' | 'automotive-aerospace' | 'scientific' | 'scientific-academic' | 'tourism' | 'training-employee-handbooks' | 'forex-crypto';\n    enum TranslatedExpertise {\n        ECONOMY = \"P\",\n        PROFESSIONAL = \"T\",\n        PREMIUM = \"R\"\n    }\n    type Tone = '' | 'Informal' | 'Friendly' | 'Business' | 'Formal' | 'other';\n    type Purpose = 'standard' | 'Personal use' | 'Business' | 'Online content' | 'App/Web localization' | 'Media content' | 'Semi-technical' | 'other';\n    type Subject = 'general' | 'accounting_finance' | 'aerospace_defence' | 'architecture' | 'art' | 'automotive' | 'certificates_diplomas_licences_cv_etc' | 'chemical' | 'civil_engineering_construction' | 'corporate_social_responsibility' | 'cosmetics' | 'culinary' | 'electronics_electrical_engineering' | 'energy_power_generation_oil_gas' | 'environment' | 'fashion' | 'games_viseogames_casino' | 'general_business_commerce' | 'history_archaeology' | 'information_technology' | 'insurance' | 'internet_e-commerce' | 'legal_documents_contracts' | 'literary_translations' | 'marketing_advertising_material_public_relations' | 'matematics_and_physics' | 'mechanical_manufacturing' | 'media_journalism_publishing' | 'medical_pharmaceutical' | 'music' | 'private_correspondence_letters' | 'religion' | 'science' | 'shipping_sailing_maritime' | 'social_science' | 'telecommunications' | 'travel_tourism';\n    interface ListTasksOptions extends PaginationOptions {\n        status?: TasksModel.Status;\n        assigneeId?: number;\n        orderBy?: string;\n    }\n    interface TaskSettingsTemplate {\n        id: number;\n        name: string;\n        config: TaskSettingsTemplateConfig;\n        createdAt: string;\n        updatedAt: string;\n    }\n    interface AddTaskSettingsTemplate {\n        name: string;\n        config: TaskSettingsTemplateConfig;\n    }\n    interface TaskSettingsTemplateConfig {\n        languages: {\n            languageId?: string;\n            userIds?: number[];\n            teamIds?: number[];\n        }[];\n    }\n    interface TaskComment {\n        id: number;\n        userId: number;\n        taskId: number;\n        text: string;\n        timeSpent: number;\n        createdAt: string;\n        updatedAt: string;\n    }\n    interface CreateTaskCommentRequest {\n        text?: string;\n        timeSpent?: number;\n    }\n}\n```\n\n##### teams/index.d.ts\n\n```typescript\nimport { CrowdinApi, Pagination, PaginationOptions, PatchRequest, ProjectRole, ProjectRoles, ResponseList, ResponseObject } from '../core';\nimport { ProjectsGroupsModel } from '../projectsGroups';\nexport declare class Teams extends CrowdinApi {\n    listGroupTeams(groupId: number, options?: TeamsModel.ListGroupTeamsOptions): Promise<ResponseList<TeamsModel.TeamGroup>>;\n    updateGroupTeams(groupId: number, request: PatchRequest[]): Promise<ResponseList<TeamsModel.TeamGroup>>;\n    getGroupTeam(groupId: number, teamId: number): Promise<ResponseObject<TeamsModel.TeamGroup>>;\n    listTeamProjectPermissions(teamId: number, options?: PaginationOptions): Promise<ResponseList<TeamsModel.ProjectPermissions>>;\n    editTeamProjectPermissions(teamId: number, request: PatchRequest[]): Promise<ResponseList<TeamsModel.ProjectPermissions>>;\n    addTeamToProject(projectId: number, request: TeamsModel.AddTeamToProjectRequest): Promise<TeamsModel.ProjectTeamResources>;\n    listTeams(options?: TeamsModel.ListTeamsOptions): Promise<ResponseList<TeamsModel.Team>>;\n    listTeams(limit?: number, offset?: number): Promise<ResponseList<TeamsModel.Team>>;\n    addTeam(request: TeamsModel.AddTeamRequest): Promise<ResponseObject<TeamsModel.Team>>;\n    getTeam(teamId: number): Promise<ResponseObject<TeamsModel.Team>>;\n    deleteTeam(teamId: number): Promise<void>;\n    editTeam(teamId: number, request: PatchRequest[]): Promise<ResponseObject<TeamsModel.Team>>;\n    teamMembersList(teamId: number, options?: PaginationOptions): Promise<ResponseList<TeamsModel.TeamMember>>;\n    teamMembersList(teamId: number, limit?: number, offset?: number): Promise<ResponseList<TeamsModel.TeamMember>>;\n    addTeamMembers(teamId: number, request: TeamsModel.AddTeamMembersRequest): Promise<TeamsModel.AddTeamMembersResponse>;\n    deleteAllTeamMembers(teamId: number): Promise<void>;\n    deleteTeamMember(teamId: number, memberId: number): Promise<void>;\n}\nexport declare namespace TeamsModel {\n    interface ListGroupTeamsOptions extends PaginationOptions {\n        orderBy?: string;\n    }\n    interface ProjectPermissions {\n        id: number;\n        roles: ProjectRole[];\n        project: ProjectsGroupsModel.Project | ProjectsGroupsModel.ProjectSettings;\n    }\n    interface AddTeamToProjectRequest {\n        teamId: number;\n        managerAccess?: boolean;\n        developerAccess?: boolean;\n        roles?: ProjectRole[];\n        accessToAllWorkflowSteps?: boolean;\n        permissions?: Permissions;\n    }\n    interface ListTeamsOptions extends PaginationOptions {\n        search?: string;\n        projectIds?: string;\n        projectRoles?: ProjectRoles[];\n        languageIds?: string;\n        groupIds?: string;\n        orderBy?: string;\n    }\n    interface ProjectTeamResources {\n        skipped: ProjectTeamResource;\n        added: ProjectTeamResource;\n    }\n    interface ProjectTeamResource {\n        id: number;\n        hasManagerAccess: boolean;\n        hasDeveloperAccess: boolean;\n        hasAccessToAllWorkflowSteps: boolean;\n        permissions: Permissions;\n        roles: ProjectRole[];\n    }\n    interface Permissions {\n        [lang: string]: {\n            workflowStepIds: number[] | 'all';\n        };\n    }\n    interface Team {\n        id: number;\n        name: string;\n        totalMembers: number;\n        webUrl: string;\n        createdAt: string;\n        updatedAt: string;\n    }\n    interface TeamGroup {\n        id: number;\n        team: Team;\n    }\n    interface AddTeamRequest {\n        name: string;\n    }\n    interface TeamMember {\n        id: number;\n        username: string;\n        firstName: string;\n        lastName: string;\n        avatarUrl: string;\n        addedAt: string;\n    }\n    interface AddTeamMembersRequest {\n        userIds: number[];\n    }\n    interface AddTeamMembersResponse {\n        skipped: ResponseObject<TeamMember>[];\n        added: ResponseObject<TeamMember>[];\n        pagination: Pagination;\n    }\n}\n```\n\n##### translationMemory/index.d.ts\n\n```typescript\nimport { CrowdinApi, DownloadLink, PaginationOptions, PatchRequest, ResponseList, ResponseObject, Status } from '../core';\nexport declare class TranslationMemory extends CrowdinApi {\n    listTm(options?: TranslationMemoryModel.ListTMsOptions): Promise<ResponseList<TranslationMemoryModel.TranslationMemory>>;\n    listTm(groupId?: number, limit?: number, offset?: number): Promise<ResponseList<TranslationMemoryModel.TranslationMemory>>;\n    addTm(request: TranslationMemoryModel.AddTranslationMemoryRequest): Promise<ResponseObject<TranslationMemoryModel.TranslationMemory>>;\n    getTm(tmId: number): Promise<ResponseObject<TranslationMemoryModel.TranslationMemory>>;\n    deleteTm(tmId: number): Promise<void>;\n    editTm(tmId: number, request: PatchRequest[]): Promise<ResponseObject<TranslationMemoryModel.TranslationMemory>>;\n    listTmSegments(tmId: number, options?: TranslationMemoryModel.ListSegmentsOptions): Promise<ResponseList<TranslationMemoryModel.TMSegment>>;\n    addTmSegment(tmId: number, request: TranslationMemoryModel.AddTMSegment): Promise<ResponseObject<TranslationMemoryModel.TMSegment>>;\n    clearTm(tmId: number): Promise<void>;\n    exportTm(tmId: number, request?: TranslationMemoryModel.ExportTranslationMemoryRequest): Promise<ResponseObject<Status<TranslationMemoryModel.ExportTranslationMemoryAttribute>>>;\n    checkExportStatus(tmId: number, exportId: string): Promise<ResponseObject<Status<TranslationMemoryModel.ExportTranslationMemoryAttribute>>>;\n    downloadTm(tmId: number, exportId: string): Promise<ResponseObject<DownloadLink>>;\n    concordanceSearch(projectId: number, request: TranslationMemoryModel.ConcordanceSearchRequest): Promise<ResponseList<TranslationMemoryModel.ConcordanceSearchResponse>>;\n    importTm(tmId: number, request: TranslationMemoryModel.ImportTranslationMemoryRequest): Promise<ResponseObject<Status<TranslationMemoryModel.ImportTranslationMemoryAttribute>>>;\n    checkImportStatus(tmId: number, importId: string): Promise<ResponseObject<Status<TranslationMemoryModel.ImportTranslationMemoryAttribute>>>;\n    getTmSegment(tmId: number, segmentId: number): Promise<ResponseObject<TranslationMemoryModel.TMSegment>>;\n    deleteTmSegment(tmId: number, segmentId: number): Promise<void>;\n    editTmSegment(tmId: number, segmentId: number, request: PatchRequest[]): Promise<ResponseObject<TranslationMemoryModel.TMSegment>>;\n    deleteTmSegmentRecord(tmId: number, segmentId: number, recordId: number): Promise<void>;\n    editTmSegmentRecord(tmId: number, segmentId: number, recordId: number, request: PatchRequest[]): Promise<ResponseObject<TranslationMemoryModel.TMSegment>>;\n    addTmSegmentRecords(tmId: number, segmentId: number, request: TranslationMemoryModel.AddTMSegment): Promise<ResponseObject<TranslationMemoryModel.TMSegment>>;\n}\nexport declare namespace TranslationMemoryModel {\n    interface TranslationMemory {\n        id: number;\n        groupId: number;\n        userId: number;\n        name: string;\n        languageId: string;\n        languageIds: string[];\n        segmentsCount: number;\n        defaultProjectIds: number[];\n        projectIds: number[];\n        createdAt: string;\n        webUrl: string;\n    }\n    interface AddTranslationMemoryRequest {\n        name: string;\n        languageId: string;\n        groupId?: number;\n    }\n    interface ConcordanceSearchRequest {\n        sourceLanguageId: string;\n        targetLanguageId: string;\n        autoSubstitution: boolean;\n        minRelevant: number;\n        expressions: string[];\n        expression?: string;\n    }\n    interface ConcordanceSearchResponse {\n        tm: TranslationMemory;\n        recordId: number;\n        source: string;\n        target: string;\n        relevant: number;\n        substituted: string;\n        updatedAt: string;\n    }\n    interface ExportTranslationMemoryRequest {\n        sourceLanguageId?: number;\n        targetLanguageId?: number;\n        format?: Format;\n    }\n    interface ImportTranslationMemoryRequest {\n        storageId: number;\n        firstLineContainsHeader?: boolean;\n        scheme?: Scheme;\n    }\n    interface ExportTranslationMemoryAttribute {\n        sourceLanguageId: string;\n        targetLanguageId: string;\n        format: string;\n    }\n    interface ImportTranslationMemoryAttribute {\n        tmId: number;\n        storageId: number;\n        firstLineContainsHeader: number;\n        scheme: Scheme;\n    }\n    type Format = 'tmx' | 'csv' | 'xlsx';\n    interface Scheme {\n        [key: string]: number;\n    }\n    interface ListTMsOptions extends PaginationOptions {\n        groupId?: number;\n        userId?: number;\n        orderBy?: string;\n    }\n    interface ListSegmentsOptions extends PaginationOptions {\n        croql?: string;\n        orderBy?: string;\n    }\n    interface TMSegment {\n        id: number;\n        records: TMSegmentRecord[];\n    }\n    interface TMSegmentRecord {\n        id: number;\n        languageId: string;\n        text: string;\n        usageCount: number;\n        createdBy: number;\n        updatedBy: number;\n        createdAt: string;\n        updatedAt: string;\n    }\n    interface AddTMSegment {\n        records: AddTMSegmentRecord[];\n    }\n    interface AddTMSegmentRecord {\n        languageId: string;\n        text: string;\n    }\n}\n```\n\n##### translationStatus/index.d.ts\n\n```typescript\nimport { CrowdinApi, PaginationOptions, ResponseList } from '../core';\nimport { LanguagesModel } from '../languages';\nexport declare class TranslationStatus extends CrowdinApi {\n    getBranchProgress(projectId: number, branchId: number, options?: PaginationOptions): Promise<ResponseList<TranslationStatusModel.LanguageProgress>>;\n    getBranchProgress(projectId: number, branchId: number, limit?: number, offset?: number): Promise<ResponseList<TranslationStatusModel.LanguageProgress>>;\n    getDirectoryProgress(projectId: number, directoryId: number, options?: PaginationOptions): Promise<ResponseList<TranslationStatusModel.LanguageProgress>>;\n    getDirectoryProgress(projectId: number, directoryId: number, limit?: number, offset?: number): Promise<ResponseList<TranslationStatusModel.LanguageProgress>>;\n    getFileProgress(projectId: number, fileId: number, options?: PaginationOptions): Promise<ResponseList<TranslationStatusModel.LanguageProgress>>;\n    getFileProgress(projectId: number, fileId: number, limit?: number, offset?: number): Promise<ResponseList<TranslationStatusModel.LanguageProgress>>;\n    getLanguageProgress(projectId: number, languageId: string, options?: PaginationOptions): Promise<ResponseList<TranslationStatusModel.FileProgress>>;\n    getLanguageProgress(projectId: number, languageId: string, limit?: number, offset?: number): Promise<ResponseList<TranslationStatusModel.FileProgress>>;\n    getProjectProgress(projectId: number, options?: PaginationOptions): Promise<ResponseList<TranslationStatusModel.LanguageProgress>>;\n    getProjectProgress(projectId: number, limit?: number, offset?: number, languageIds?: string): Promise<ResponseList<TranslationStatusModel.LanguageProgress>>;\n    listQaCheckIssues(projectId: number, options?: TranslationStatusModel.ListQaCheckIssuesOptions): Promise<ResponseList<TranslationStatusModel.QaCheck>>;\n    listQaCheckIssues(projectId: number, limit?: number, offset?: number, category?: TranslationStatusModel.Category, validation?: TranslationStatusModel.Validation, languageIds?: string): Promise<ResponseList<TranslationStatusModel.QaCheck>>;\n}\nexport declare namespace TranslationStatusModel {\n    interface LanguageProgress {\n        words: Words;\n        phrases: Words;\n        translationProgress: number;\n        approvalProgress: number;\n        eTag: string;\n        languageId: string;\n        language: LanguagesModel.Language;\n    }\n    interface FileProgress {\n        words: Words;\n        phrases: Words;\n        translationProgress: number;\n        approvalProgress: number;\n        branchId: number;\n        fileId: number;\n        eTag: string;\n    }\n    interface Words {\n        total: number;\n        translated: number;\n        approved: number;\n        preTranslateAppliedTo: number;\n    }\n    type Category = 'empty' | 'variables' | 'tags' | 'punctuation' | 'symbol_register' | 'spaces' | 'size' | 'special_symbols' | 'wrong_translation' | 'spellcheck' | 'icu';\n    type Validation = 'empty_string_check' | 'empty_suggestion_check' | 'max_length_check' | 'tags_check' | 'mismatch_ids_check' | 'cdata_check' | 'specials_symbols_check' | 'leading_newlines_check' | 'trailing_newlines_check' | 'leading_spaces_check' | 'trailing_spaces_check' | 'multiple_spaces_check' | 'custom_blocked_variables_check' | 'highest_priority_custom_variables_check' | 'highest_priority_variables_check' | 'c_variables_check' | 'python_variables_check' | 'rails_variables_check' | 'java_variables_check' | 'dot_net_variables_check' | 'twig_variables_check' | 'php_variables_check' | 'freemarker_variables_check' | 'lowest_priority_variable_check' | 'lowest_priority_custom_variables_check' | 'punctuation_check' | 'spaces_before_punctuation_check' | 'spaces_after_punctuation_check' | 'non_breaking_spaces_check' | 'capitalize_check' | 'multiple_uppercase_check' | 'parentheses_check' | 'entities_check' | 'escaped_quotes_check' | 'wrong_translation_issue_check' | 'spellcheck' | 'icu_check';\n    interface ListQaCheckIssuesOptions extends PaginationOptions {\n        category?: Category | Category[];\n        validation?: Validation | Validation[];\n        languageIds?: string;\n    }\n    interface QaCheck {\n        stringId: number;\n        languageId: string;\n        category: Category;\n        categoryDescription: string;\n        validation: Validation;\n        validationDescription: string;\n        pluralId: number;\n        text: string;\n    }\n    interface GetProjectProgressOptions extends PaginationOptions {\n        languageIds?: string;\n    }\n}\n```\n\n##### translations/index.d.ts\n\n```typescript\nimport { CrowdinApi, DownloadLink, PaginationOptions, PatchRequest, ResponseList, ResponseObject, Status } from '../core';\nimport { ProjectsGroupsModel } from '../projectsGroups';\nexport declare class Translations extends CrowdinApi {\n    listPreTranslations(projectId: number, options?: PaginationOptions): Promise<ResponseList<Status<TranslationsModel.PreTranslationStatusAttributes>>>;\n    preTranslationStatus(projectId: number, preTranslationId: string): Promise<ResponseObject<Status<TranslationsModel.PreTranslationStatusAttributes>>>;\n    applyPreTranslation(projectId: number, request: TranslationsModel.PreTranslateRequest | TranslationsModel.PreTranslateStringsRequest): Promise<ResponseObject<Status<TranslationsModel.PreTranslationStatusAttributes>>>;\n    editPreTranslation(projectId: number, preTranslationId: string, request: PatchRequest[]): Promise<ResponseObject<Status<TranslationsModel.PreTranslationStatusAttributes>>>;\n    getPreTranslationReport(projectId: number, preTranslationId: string): Promise<ResponseObject<TranslationsModel.PreTranslationReport>>;\n    buildProjectDirectoryTranslation(projectId: number, directoryId: number, request?: TranslationsModel.BuildProjectDirectoryTranslationRequest): Promise<ResponseObject<TranslationsModel.BuildProjectDirectoryTranslationResponse>>;\n    buildProjectFileTranslation(projectId: number, fileId: number, request: TranslationsModel.BuildProjectFileTranslationRequest, eTag?: string): Promise<ResponseObject<TranslationsModel.BuildProjectFileTranslationResponse>>;\n    listProjectBuilds(projectId: number, options?: TranslationsModel.ListProjectBuildsOptions): Promise<ResponseList<TranslationsModel.Build>>;\n    listProjectBuilds(projectId: number, branchId?: number, limit?: number, offset?: number): Promise<ResponseList<TranslationsModel.Build>>;\n    buildProject(projectId: number, request?: TranslationsModel.BuildRequest | TranslationsModel.PseudoBuildRequest): Promise<ResponseObject<TranslationsModel.Build>>;\n    uploadTranslation(projectId: number, languageId: string, request: TranslationsModel.UploadTranslationRequest): Promise<ResponseObject<TranslationsModel.UploadTranslationResponse>>;\n    uploadTranslationStrings(projectId: number, languageId: string, request: TranslationsModel.UploadTranslationStringsRequest): Promise<ResponseObject<TranslationsModel.UploadTranslationStringsResponse>>;\n    downloadTranslations(projectId: number, buildId: number): Promise<ResponseObject<DownloadLink>>;\n    checkBuildStatus(projectId: number, buildId: number): Promise<ResponseObject<TranslationsModel.Build>>;\n    cancelBuild(projectId: number, buildId: number): Promise<void>;\n    exportProjectTranslation(projectId: number, request: TranslationsModel.ExportProjectTranslationRequest): Promise<ResponseObject<DownloadLink>>;\n}\nexport declare namespace TranslationsModel {\n    interface PreTranslateRequest {\n        languageIds: string[];\n        fileIds: number[];\n        method?: Method;\n        engineId?: number;\n        aiPromptId?: number;\n        autoApproveOption?: AutoApproveOption;\n        duplicateTranslations?: boolean;\n        skipApprovedTranslations?: boolean;\n        translateUntranslatedOnly?: boolean;\n        translateWithPerfectMatchOnly?: boolean;\n        fallbackLanguages?: {\n            languageId?: string[];\n        };\n        labelIds?: number[];\n        excludeLabelIds?: number[];\n    }\n    interface PreTranslateStringsRequest {\n        languageIds: string[];\n        branchIds?: number[];\n        method?: Method;\n        engineId?: number;\n        aiPromptId?: number;\n        autoApproveOption?: AutoApproveOption;\n        duplicateTranslations?: boolean;\n        skipApprovedTranslations?: boolean;\n        translateUntranslatedOnly?: boolean;\n        translateWithPerfectMatchOnly?: boolean;\n        fallbackLanguages?: {\n            languageId: string[];\n        };\n        labelIds?: number[];\n        excludeLabelIds?: number[];\n    }\n    interface BuildProjectDirectoryTranslationRequest {\n        targetLanguageIds?: string[];\n        skipUntranslatedStrings?: boolean;\n        skipUntranslatedFiles?: boolean;\n        preserveFolderHierarchy?: boolean;\n        exportStringsThatPassedWorkflow?: boolean;\n        exportWithMinApprovalsCount?: number;\n        exportApprovedOnly?: boolean;\n    }\n    interface BuildProjectDirectoryTranslationResponse {\n        id: number;\n        projectId: number;\n        status: BuildStatus;\n        progress: number;\n        createdAt: string;\n        updatedAt: string;\n        finishedAt: string;\n    }\n    type BuildStatus = 'created' | 'inProgress' | 'canceled' | 'failed' | 'finished';\n    interface BuildProjectFileTranslationRequest {\n        targetLanguageId: string;\n        exportAsXliff?: boolean;\n        skipUntranslatedStrings?: boolean;\n        skipUntranslatedFiles?: boolean;\n        exportApprovedOnly?: boolean;\n        exportWithMinApprovalsCount?: number;\n        exportStringsThatPassedWorkflow?: boolean;\n    }\n    interface BuildProjectFileTranslationResponse extends DownloadLink {\n        etag: string;\n    }\n    interface PreTranslationStatusAttributes {\n        languageIds: string[];\n        fileIds: number[];\n        branchIds: number[];\n        method: Method;\n        autoApproveOption: AutoApproveOption;\n        duplicateTranslations: boolean;\n        skipApprovedTranslations: boolean;\n        translateUntranslatedOnly: boolean;\n        translateWithPerfectMatchOnly: boolean;\n    }\n    type Method = 'tm' | 'mt' | 'ai';\n    type AutoApproveOption = 'all' | 'exceptAutoSubstituted' | 'perfectMatchOnly' | 'none';\n    type CharTransformation = 'asian' | 'european' | 'arabic' | 'cyrillic';\n    interface Build {\n        id: number;\n        projectId: number;\n        status: BuildStatus;\n        progress: number;\n        attributes: Attribute;\n        createdAt: string;\n        updatedAt: string;\n        finishedAt: string;\n    }\n    interface Attribute {\n        branchId: number;\n        directoryId: number;\n        targetLanguageIds: string[];\n        skipUntranslatedStrings: boolean;\n        skipUntranslatedFiles: boolean;\n        exportApprovedOnly: boolean;\n        exportWithMinApprovalsCount: number;\n        exportStringsThatPassedWorkflow: boolean;\n    }\n    interface BuildRequest {\n        branchId?: number;\n        targetLanguageIds?: string[];\n        skipUntranslatedStrings?: boolean;\n        skipUntranslatedFiles?: boolean;\n        exportApprovedOnly?: boolean;\n        exportWithMinApprovalsCount?: number;\n        exportStringsThatPassedWorkflow?: boolean;\n    }\n    interface PseudoBuildRequest {\n        pseudo: boolean;\n        branchId?: number;\n        prefix?: string;\n        suffix?: string;\n        lengthTransformation?: number;\n        charTransformation?: CharTransformation;\n    }\n    interface UploadTranslationRequest {\n        storageId: number;\n        fileId?: number;\n        importEqSuggestions?: boolean;\n        autoApproveImported?: boolean;\n        translateHidden?: boolean;\n        addToTm?: boolean;\n    }\n    interface UploadTranslationStringsRequest {\n        storageId: number;\n        branchId?: number;\n        importEqSuggestions?: boolean;\n        autoApproveImported?: boolean;\n        translateHidden?: boolean;\n        addToTm?: boolean;\n    }\n    interface UploadTranslationResponse {\n        projectId: number;\n        storageId: number;\n        languageId: string;\n        fileId: number;\n    }\n    interface UploadTranslationStringsResponse {\n        projectId: number;\n        storageId: number;\n        languageId: string;\n        branchId: number;\n    }\n    interface ExportProjectTranslationRequest {\n        targetLanguageId: string;\n        format?: string;\n        labelIds?: number[];\n        branchIds?: number[];\n        directoryIds?: number[];\n        fileIds?: number[];\n        skipUntranslatedStrings?: boolean;\n        skipUntranslatedFiles?: boolean;\n        exportApprovedOnly?: boolean;\n        exportWithMinApprovalsCount?: number;\n        exportStringsThatPassedWorkflow?: boolean;\n    }\n    interface ListProjectBuildsOptions extends PaginationOptions {\n        branchId?: number;\n    }\n    interface PreTranslationReport {\n        languages: TargetLanguage[];\n        preTranslateType: Method;\n    }\n    interface TargetLanguage {\n        id: string;\n        files: TargetLanguageFile[];\n        skipped: SkippedInfo;\n        skippedQaCheckCategories: ProjectsGroupsModel.CheckCategories;\n    }\n    interface TargetLanguageFile {\n        id: string;\n        statistics: TargetLanguageFileStatistics;\n    }\n    interface TargetLanguageFileStatistics {\n        phrases: number;\n        words: number;\n    }\n    interface SkippedInfo {\n        [key: string]: any;\n    }\n}\n```\n\n##### uploadStorage/index.d.ts\n\n```typescript\nimport { CrowdinApi, PaginationOptions, ResponseList, ResponseObject } from '../core';\nexport declare class UploadStorage extends CrowdinApi {\n    listStorages(options?: PaginationOptions): Promise<ResponseList<UploadStorageModel.Storage>>;\n    listStorages(limit?: number, offset?: number): Promise<ResponseList<UploadStorageModel.Storage>>;\n    addStorage(fileName: string, request: any, contentType?: string): Promise<ResponseObject<UploadStorageModel.Storage>>;\n    getStorage(storageId: number): Promise<ResponseObject<UploadStorageModel.Storage>>;\n    deleteStorage(storageId: number): Promise<void>;\n}\nexport declare namespace UploadStorageModel {\n    interface Storage {\n        id: number;\n        fileName: string;\n    }\n}\n```\n\n##### users/index.d.ts\n\n```typescript\nimport { CrowdinApi, Pagination, PaginationOptions, PatchRequest, ProjectRole, ProjectRoles, ResponseList, ResponseObject } from '../core';\nimport { ProjectsGroupsModel } from '../projectsGroups';\nimport { TeamsModel } from '../teams';\nexport declare class Users extends CrowdinApi {\n    listGroupManagers(groupId: number, options?: UsersModel.ListGroupManagersOptions): Promise<ResponseList<UsersModel.GroupManager>>;\n    updateGroupManagers(groupId: number, request: PatchRequest[]): Promise<ResponseList<UsersModel.GroupManager>>;\n    getGroupManager(groupId: number, userId: number): Promise<ResponseObject<UsersModel.GroupManager>>;\n    listProjectMembers(projectId: number, options?: UsersModel.ListProjectMembersOptions): Promise<ResponseList<UsersModel.ProjectMember | UsersModel.EnterpriseProjectMember>>;\n    listProjectMembers(projectId: number, search?: string, role?: UsersModel.Role, languageId?: string, limit?: number, offset?: number): Promise<ResponseList<UsersModel.ProjectMember | UsersModel.EnterpriseProjectMember>>;\n    addProjectMember(projectId: number, request: UsersModel.AddProjectMemberRequest): Promise<UsersModel.AddProjectMemberResponse>;\n    getProjectMemberPermissions(projectId: number, memberId: number): Promise<ResponseObject<UsersModel.ProjectMember | UsersModel.EnterpriseProjectMember>>;\n    replaceProjectMemberPermissions(projectId: number, memberId: number, request?: UsersModel.ReplaceProjectMemberRequest): Promise<ResponseObject<UsersModel.ProjectMember | UsersModel.EnterpriseProjectMember>>;\n    deleteMemberFromProject(projectId: number, memberId: number): Promise<void>;\n    listUsers(options?: UsersModel.ListUsersOptions): Promise<ResponseList<UsersModel.User>>;\n    listUsers(status?: UsersModel.Status, search?: string, twoFactor?: UsersModel.TwoFactor, limit?: number, offset?: number): Promise<ResponseList<UsersModel.User>>;\n    inviteUser(request: UsersModel.InviteUserRequest): Promise<ResponseObject<UsersModel.User>>;\n    getUserInfo(userId: number): Promise<ResponseObject<UsersModel.User>>;\n    deleteUser(userId: number): Promise<void>;\n    editUser(userId: number, request: PatchRequest[]): Promise<ResponseObject<UsersModel.User>>;\n    getAuthenticatedUser(): Promise<ResponseObject<UsersModel.User>>;\n    editAuthenticatedUser(request: PatchRequest[]): Promise<ResponseObject<UsersModel.User>>;\n    listUserProjectPermissions(userId: number, options?: PaginationOptions): Promise<ResponseList<UsersModel.ProjectPermissions>>;\n    editUserProjectPermissions(userId: number, request: PatchRequest[]): Promise<ResponseList<UsersModel.ProjectPermissions>>;\n    listUserProjectContributions(userId: number, options?: PaginationOptions): Promise<ResponseList<UsersModel.ProjectPermissions>>;\n}\nexport declare namespace UsersModel {\n    interface ListGroupManagersOptions extends PaginationOptions {\n        teamIds?: number[];\n        orderBy?: string;\n    }\n    interface ListProjectMembersOptions extends PaginationOptions {\n        search?: string;\n        role?: Role;\n        languageId?: string;\n        workflowStepId?: number;\n        orderBy?: string;\n    }\n    interface ListUsersOptions extends PaginationOptions {\n        status?: Status;\n        search?: string;\n        twoFactor?: TwoFactor;\n        orderBy?: string;\n        organizationRoles?: OrganizationRoles[];\n        teamId?: number;\n        projectIds?: string;\n        projectRoles?: ProjectRoles[];\n        languageIds?: string;\n        groupIds?: string;\n        lastSeenFrom?: string;\n        lastSeenTo?: string;\n    }\n    interface InviteUserRequest {\n        email: string;\n        firstName?: string;\n        lastName?: string;\n        timezone?: string;\n        adminAccess?: boolean;\n    }\n    interface User {\n        id: number;\n        username: string;\n        email: string;\n        firstName: string;\n        lastName: string;\n        status: Status;\n        avatarUrl: string;\n        fields: Record<string, any>;\n        createdAt: string;\n        lastSeen: string;\n        twoFactor: TwoFactor;\n        isAdmin: boolean;\n        timezone: string;\n        emailVerified: string;\n    }\n    type Status = 'active' | 'pending' | 'blocked';\n    type TwoFactor = 'enabled' | 'disabled';\n    type OrganizationRoles = 'admin' | 'manager' | 'vendor' | 'client';\n    interface GroupManager {\n        id: number;\n        user: User;\n        teams: TeamsModel.Team[];\n    }\n    interface ProjectMember {\n        id: number;\n        username: string;\n        fullName: string;\n        role: Role;\n        permissions: Permissions;\n        avatarUrl: string;\n        joinedAt: string;\n        timezone: string;\n        roles: ProjectRole[];\n    }\n    interface EnterpriseProjectMember {\n        id: number;\n        username: string;\n        firstName: string;\n        lastName: string;\n        isManager: boolean;\n        isDeveloperr: boolean;\n        managerOfGroup: Group;\n        accessToAllWorkflowSteps: boolean;\n        permissions: Permissions;\n        givenAccessAt: string;\n        roles: ProjectRole[];\n    }\n    interface Group {\n        id: number;\n        name: string;\n    }\n    type Role = 'all' | 'owner' | 'manager' | 'proofreader' | 'translator' | 'blocked';\n    type LanguageRole = 'proofreader' | 'translator' | 'denied';\n    interface AddProjectMemberRequest {\n        userIds?: number[];\n        usernames?: string[];\n        emails?: string[];\n        managerAccess?: boolean;\n        roles?: ProjectRole[];\n        developerAccess?: boolean;\n        accessToAllWorkflowSteps?: boolean;\n        permissions?: Permissions;\n    }\n    interface AddProjectMemberResponse {\n        skipped: ResponseObject<ProjectMember | EnterpriseProjectMember>[];\n        added: ResponseObject<ProjectMember | EnterpriseProjectMember>[];\n        pagination: Pagination;\n    }\n    interface ReplaceProjectMemberRequest {\n        managerAccess?: boolean;\n        developerAccess?: boolean;\n        roles?: ProjectRole[];\n        accessToAllWorkflowSteps?: boolean;\n        permissions?: Permissions;\n    }\n    interface ProjectPermissions {\n        id: number;\n        roles: ProjectRole[];\n        project: ProjectsGroupsModel.Project | ProjectsGroupsModel.ProjectSettings;\n        teams: TeamsModel.Team[];\n    }\n    interface Contributions {\n        id: number;\n        translated: Contribution;\n        approved: Contribution;\n        voted: Contribution;\n        commented: Contribution;\n        project: ProjectsGroupsModel.Project | ProjectsGroupsModel.ProjectSettings;\n    }\n    interface Contribution {\n        strings: number;\n        words?: number;\n    }\n    interface Permissions {\n        [lang: string]: string | {\n            workflowStepIds: number[] | 'all';\n        };\n    }\n}\n```\n\n##### vendors/index.d.ts\n\n```typescript\nimport { CrowdinApi, PaginationOptions, ResponseList } from '../core';\nexport declare class Vendors extends CrowdinApi {\n    listVendors(options?: PaginationOptions): Promise<ResponseList<VendorsModel.Vendor>>;\n    listVendors(limit?: number, offset?: number): Promise<ResponseList<VendorsModel.Vendor>>;\n}\nexport declare namespace VendorsModel {\n    interface Vendor {\n        id: number;\n        name: string;\n        description: string;\n        status: 'pending' | 'confirmed' | 'rejected';\n        webUrl: string;\n    }\n}\n```\n\n##### webhooks/index.d.ts\n\n```typescript\nimport { CrowdinApi, PaginationOptions, PatchRequest, ResponseList, ResponseObject } from '../core';\nexport declare class Webhooks extends CrowdinApi {\n    listWebhooks(projectId: number, options?: PaginationOptions): Promise<ResponseList<WebhooksModel.Webhook>>;\n    listWebhooks(projectId: number, limit?: number, offset?: number): Promise<ResponseList<WebhooksModel.Webhook>>;\n    addWebhook(projectId: number, request: WebhooksModel.AddWebhookRequest): Promise<ResponseObject<WebhooksModel.Webhook>>;\n    getWebhook(projectId: number, webhookId: number): Promise<ResponseObject<WebhooksModel.Webhook>>;\n    deleteWebhook(projectId: number, webhookId: number): Promise<void>;\n    editWebhook(projectId: number, webhookId: number, request: PatchRequest[]): Promise<ResponseObject<WebhooksModel.Webhook>>;\n}\nexport declare namespace WebhooksModel {\n    interface Webhook {\n        id: number;\n        projectId: number;\n        name: string;\n        url: string;\n        events: Event[];\n        headers: Record<string, string>;\n        payload: Record<string, any>;\n        isActive: boolean;\n        batchingEnabled: boolean;\n        requestType: RequestType;\n        contentType: ContentType;\n        createdAt: string;\n        updatedAt: string;\n    }\n    interface AddWebhookRequest {\n        name: string;\n        url: string;\n        events: Event[];\n        requestType: RequestType;\n        isActive?: boolean;\n        batchingEnabled?: boolean;\n        contentType?: ContentType;\n        headers?: Record<string, string>;\n        payload?: Record<string, any>;\n    }\n    type ContentType = 'multipart/form-data' | 'application/json' | 'application/x-www-form-urlencoded';\n    type Event = 'file.added' | 'file.updated' | 'file.reverted' | 'file.deleted' | 'file.translated' | 'file.approved' | 'project.translated' | 'project.approved' | 'project.built' | 'translation.updated' | 'string.added' | 'string.updated' | 'string.deleted' | 'stringComment.created' | 'stringComment.updated' | 'stringComment.deleted' | 'stringComment.restored' | 'suggestion.added' | 'suggestion.updated' | 'suggestion.deleted' | 'suggestion.approved' | 'suggestion.disapproved' | 'task.added' | 'task.statusChanged' | 'task.deleted';\n    type RequestType = 'POST' | 'GET';\n}\n```\n\n##### workflows/index.d.ts\n\n```typescript\nimport { CrowdinApi, PaginationOptions, PatchRequest, ResponseList, ResponseObject } from '../core';\nimport { SourceStringsModel } from '../sourceStrings';\nexport declare class Workflows extends CrowdinApi {\n    listWorkflowSteps(projectId: number, options?: PaginationOptions): Promise<ResponseList<WorkflowModel.WorkflowStep>>;\n    listWorkflowSteps(projectId: number, limit?: number, offset?: number): Promise<ResponseList<WorkflowModel.WorkflowStep>>;\n    getWorkflowStep(projectId: number, stepId: number): Promise<ResponseObject<WorkflowModel.WorkflowStep>>;\n    listStringsOnTheWorkflowStep(projectId: number, stepId: number, options?: WorkflowModel.ListStringsOntheWorkflowStepOptions): Promise<ResponseList<SourceStringsModel.String>>;\n    listWorkflowTemplates(options?: WorkflowModel.ListWorkflowTemplatesOptions): Promise<ResponseList<WorkflowModel.Workflow>>;\n    listWorkflowTemplates(groupId?: number, limit?: number, offset?: number): Promise<ResponseList<WorkflowModel.Workflow>>;\n    getWorkflowTemplateInfo(templateId: number): Promise<ResponseObject<WorkflowModel.Workflow>>;\n    updateWorkflowStepStringStatus(projectId: number, stepId: number, languageId: string, request: PatchRequest[]): Promise<ResponseList<WorkflowModel.WorkflowStepStringStatus>>;\n    getWorkflowStepStringStatus(projectId: number, stepId: number, languageId: string, options?: PaginationOptions): Promise<ResponseList<WorkflowModel.WorkflowStepStringStatus>>;\n}\nexport declare namespace WorkflowModel {\n    interface WorkflowStep {\n        id: number;\n        title: string;\n        type: string;\n        languages: string[];\n        config: {\n            assignees: {\n                [language: string]: number[];\n            };\n        };\n    }\n    interface ListWorkflowTemplatesOptions extends PaginationOptions {\n        groupId?: number;\n    }\n    interface ListStringsOntheWorkflowStepOptions extends PaginationOptions {\n        languageIds?: string;\n        orderBy?: string;\n        status?: 'todo' | 'done' | 'pending' | 'incomplete' | 'need_review';\n    }\n    interface Workflow {\n        id: number;\n        title: string;\n        description: string;\n        groupId: number;\n        isDefault: boolean;\n        webUrl: string;\n        steps: {\n            id: number;\n            languages: string[];\n            assignees: number[];\n            vendorId: number;\n            config: {\n                minRelevant: number;\n                autoSubstitution: boolean;\n            };\n            mtId: number;\n        }[];\n    }\n    interface WorkflowStepStringStatus {\n        stringId: number;\n        languageId: string;\n        stepId: number;\n        status: string;\n        output: string;\n    }\n}\n```\n\n<!-- CROWDIN_API_CLIENT_TYPES_END -->\n\n### App Metadata Storage\n\n#### Overview\n\nApp Metadata Storage is a built-in key-value storage system provided by the Crowdin Apps SDK. It allows your app to persist data across sessions without needing external databases or storage services.\n\n**Available Methods:**\n- `crowdinApp.saveMetadata(key, data, crowdinId)` - Save or update metadata (recommended)\n- `crowdinApp.getMetadata(key)` - Retrieve metadata\n- `crowdinApp.deleteMetadata(key)` - Delete metadata\n\n**Alternative approach:**\n- `crowdinModule.metadataStore.saveMetadata(key, data, crowdinId)`\n- `crowdinModule.metadataStore.getMetadata(key)`\n- `crowdinModule.metadataStore.deleteMetadata(key)`\n\n#### Official Documentation\n\n**üìö Complete Documentation:** Refer to Crowdin Apps SDK documentation for metadata storage\n\n**‚ö†Ô∏è CRITICAL**: Metadata is stored at the organization level. Always include `organizationId` in your keys to properly scope data.\n\n#### Common Examples\n\n**Save Metadata:**\n```typescript\napp.post('/api/save-data', async (req: Request, res: Response) => {\n    try {\n        const jwt = req.query.jwt as string;\n        const { data } = req.body;\n\n        if (!jwt) {\n            return res.status(400).json({ success: false, error: 'JWT token is required' });\n        }\n        \n        if (!crowdinApp.establishCrowdinConnection) {\n            return res.status(500).json({ success: false, error: 'Crowdin connection method not available' });\n        }\n\n        const connection = await crowdinApp.establishCrowdinConnection(jwt, undefined);\n\n        if (!connection.client) {\n            return res.status(500).json({ success: false, error: 'Crowdin API client not available' });\n        }\n\n        const userId = connection.context.jwtPayload.context.user_id;\n        const organizationId = connection.context.jwtPayload.context.organization_id;\n        \n        // Create a namespaced key\n        const key = `org_${organizationId}_user_${userId}_preferences`;\n        \n        // Save data to metadata storage\n        await crowdinApp.saveMetadata(key, data, connection.context.crowdinId);\n        res.json({ success: true, message: 'Data saved successfully' });\n    } catch (error) {\n        console.error('Save error:', error);\n        res.status(500).json({ success: false, error: 'Failed to save data' });\n    }\n});\n```\n\n**Get Metadata:**\n```typescript\napp.get('/api/get-data', async (req: Request, res: Response) => {\n    try {\n        const jwt = req.query.jwt as string;\n        \n        if (!jwt) {\n            return res.status(400).json({ success: false, error: 'JWT token is required' });\n        }\n        \n        if (!crowdinApp.establishCrowdinConnection) {\n            return res.status(500).json({ success: false, error: 'Crowdin connection method not available' });\n        }\n\n        const connection = await crowdinApp.establishCrowdinConnection(jwt, undefined);\n\n        if (!connection.client) {\n            return res.status(500).json({ success: false, error: 'Crowdin API client not available' });\n        }\n\n        const userId = connection.context.jwtPayload.context.user_id;\n        const organizationId = connection.context.jwtPayload.context.organization_id;\n        \n        const key = `org_${organizationId}_user_${userId}_preferences`;\n        \n        // Retrieve data from metadata storage\n        const data = await crowdinApp.getMetadata(key);\n            \n        // Handle case when no data exists\n        if (!data) {\n            return res.json({ \n                success: true, \n                data: null, \n                message: 'No data found' \n            });\n        }\n        \n        res.json({ success: true, data });\n    } catch (error) {\n        console.error('Get error:', error);\n        res.status(500).json({ success: false, error: 'Failed to retrieve data' });\n    }\n});\n```\n\n**Delete Metadata:**\n```typescript\napp.delete('/api/delete-data', async (req: Request, res: Response) => {\n    try {\n        const jwt = req.query.jwt as string;\n        \n        if (!jwt) {\n            return res.status(400).json({ success: false, error: 'JWT token is required' });\n        }\n        \n        if (!crowdinApp.establishCrowdinConnection) {\n            return res.status(500).json({ success: false, error: 'Crowdin connection method not available' });\n        }\n\n        const connection = await crowdinApp.establishCrowdinConnection(jwt, undefined);\n\n        if (!connection.client) {\n            return res.status(500).json({ success: false, error: 'Crowdin API client not available' });\n        }\n\n        const userId = connection.context.jwtPayload.context.user_id;\n        const organizationId = connection.context.jwtPayload.context.organization_id;\n        \n        const key = `org_${organizationId}_user_${userId}_preferences`;\n        \n        // Delete data from metadata storage\n        await crowdinApp.deleteMetadata(key);\n        res.json({ success: true, message: 'Data deleted successfully' });\n    } catch (error) {\n        console.error('Delete error:', error);\n        res.status(500).json({ success: false, error: 'Failed to delete data' });\n    }\n});\n```\n\n**Get All Metadata:**\n```typescript\napp.get('/api/all-metadata', async (req: Request, res: Response) => {\n    try {\n        const jwt = req.query.jwt as string;\n        \n        if (!jwt) {\n            return res.status(400).json({ success: false, error: 'JWT token is required' });\n        }\n        \n        if (!crowdinApp.establishCrowdinConnection) {\n            return res.status(500).json({ success: false, error: 'Crowdin connection method not available' });\n        }\n\n        const connection = await crowdinApp.establishCrowdinConnection(jwt, undefined);\n\n        if (!connection.client) {\n            return res.status(500).json({ success: false, error: 'Crowdin API client not available' });\n        }\n\n        // Retrieve all metadata records from storage\n        const allMetadata = await crowdinApp.storage.getAllMetadata();\n        \n        // allMetadata structure:\n        // [\n        //   {\n        //     id: \"org_123_user_456_preferences\",  // key\n        //     data: \"{\"theme\":\"dark\",\"lang\":\"en\"}\", // JSON stringified value\n        //     crowdin_id: \"domain\"     // crowdin identifier (from connection.context.crowdinId during save)\n        //   },\n        //   ...\n        // ]\n        \n        // Parse and format data\n        const formattedData = allMetadata.map(record => ({\n            key: record.id,\n            value: JSON.parse(record.data || '{}'),\n            crowdinId: record.crowdin_id\n        }));\n        \n        res.json({ success: true, metadata: formattedData, count: formattedData.length });\n    } catch (error) {\n        console.error('Error retrieving all metadata:', error);\n        res.status(500).json({ success: false, error: 'Failed to retrieve metadata' });\n    }\n});\n```\n\n**Store Complex Objects:**\n```typescript\n// Save complex user preferences\nconst preferences = {\n    theme: 'dark',\n    language: 'en',\n    notifications: {\n        email: true,\n        push: false,\n        digest: 'weekly'\n    },\n    lastUpdated: new Date().toISOString(),\n    settings: {\n        autoSave: true,\n        confirmActions: true\n    }\n};\n\nconst key = `org_${organizationId}_user_${userId}_preferences`;\nawait crowdinApp.saveMetadata(key, preferences, connection.context.crowdinId);\n\n// Retrieve and update\nconst currentPrefs = await crowdinApp.getMetadata(key) || {};\nconst updatedPrefs = {\n    ...currentPrefs,\n    theme: 'light',\n    lastUpdated: new Date().toISOString()\n};\nawait crowdinApp.saveMetadata(key, updatedPrefs, connection.context.crowdinId);\n```\n\n#### Best Practices\n\n1. **Always use namespaced keys**\n   ```typescript\n   // ‚úÖ CORRECT - includes organization and entity identifiers\n   const key = `org_${organizationId}_user_${userId}_preferences`;\n   const key = `org_${organizationId}_project_${projectId}_cache`;\n   \n   // ‚ùå WRONG - no organization scope, may cause conflicts\n   const key = `user_preferences`;\n   const key = `${userId}_data`;\n   ```\n\n2. **Handle missing data gracefully**\n   ```typescript\n   // ‚úÖ CORRECT - provide defaults for missing data\n   const data = await crowdinApp.getMetadata(key) || { \n       theme: 'auto', \n       language: 'en' \n   };\n   \n   // ‚úÖ CORRECT - check for null/undefined\n   const data = await crowdinApp.getMetadata(key);\n   if (!data) {\n       return defaultSettings;\n   }\n   \n   // ‚ùå WRONG - may cause errors if data is null\n   const theme = data.theme; // Error if data is null\n   ```\n\n3. **Always use the correct identifier for the third parameter**\n   ```typescript\n   // ‚úÖ CORRECT - when connection object is available\n   await crowdinApp.saveMetadata(key, data, connection.context.crowdinId);\n   \n   // ‚úÖ CORRECT - when using webhookContext (no connection object, crowdinApp not available)\n   await crowdinModule.metadataStore.saveMetadata(key, data, `${webhookContext.domain || webhookContext.organizationId}`);\n   \n   // ‚ùå WRONG - don't use organizationId directly\n   await crowdinApp.saveMetadata(key, data, String(organizationId));\n   ```\n\n4. **Use descriptive key patterns**\n   ```typescript\n   // ‚úÖ CORRECT - clear, hierarchical structure\n   `org_${orgId}_user_${userId}_preferences`\n   `org_${orgId}_project_${projectId}_settings`\n   `org_${orgId}_cache_${cacheType}_${identifier}`\n   \n   // ‚ùå WRONG - unclear, hard to maintain\n   `data_${id}`\n   `temp_storage`\n   ```\n\n5. **Handle errors properly**\n   ```typescript\n   // ‚úÖ CORRECT - comprehensive error handling\n   try {\n       await crowdinApp.saveMetadata(key, data, connection.context.crowdinId);\n       return { success: true };\n   } catch (error: any) {\n       console.error('Metadata save failed:', error);\n       return { \n           success: false, \n           error: 'Failed to save data'\n       };\n   }\n   ```\n\n7. **Store only JSON-serializable data**\n   ```typescript\n   // ‚úÖ CORRECT - simple JSON-serializable objects\n   const data = {\n       name: 'John',\n       age: 30,\n       preferences: ['option1', 'option2'],\n       metadata: { key: 'value' }\n   };\n   \n   // ‚ùå WRONG - functions, dates, circular references\n   const data = {\n       name: 'John',\n       callback: () => {},           // Functions don't serialize\n       created: new Date(),           // Dates become strings\n       circular: data                 // Circular reference\n   };\n   \n   // ‚úÖ CORRECT - convert dates to ISO strings\n   const data = {\n       name: 'John',\n       created: new Date().toISOString()\n   };\n   ```\n\n8. **NEVER use KVStore for configurations - use metadata storage instead**\n   ```typescript\n   // ‚úÖ CORRECT - use metadata storage for ALL configuration storage\n   const config = {\n       apiKey: userApiKey,\n       apiEndpoint: 'https://api.example.com',\n       languageMapping: { 'en': 'en-US' }\n   };\n   await crowdinApp.saveMetadata(\n       `config_org_${organizationId}`, \n       config, \n       connection.context.crowdinId\n   );\n   \n   // ‚úÖ CORRECT - read configuration from metadata storage\n   const config = await crowdinApp.getMetadata(`config_org_${organizationId}`) || {};\n   \n   // ‚ùå WRONG - using KVStore for configuration storage\n   const config = {\n       apiKey: userApiKey,\n       apiEndpoint: 'https://api.example.com',\n       languageMapping: { 'en': 'en-US' }\n   };\n   await env.KVStore.put(\n       `config_org_${organizationId}`, \n       JSON.stringify(config)\n   );\n   \n   // ‚ùå WRONG - reading configuration from KVStore\n   const configData = await env.KVStore.get(`config_org_${organizationId}`);\n   const config = JSON.parse(configData || '{}');\n   ```\n\n9. **Use crowdinApp.saveMetadata or crowdinModule.metadataStore.saveMetadata - both implement upsert**\n   ```typescript\n   // ‚úÖ CORRECT - implements upsert (insert or update)\n   await crowdinApp.saveMetadata(\n       key, \n       data, \n       connection.context.crowdinId\n   );\n   \n   // ‚úÖ CORRECT - also implements upsert (insert or update)\n   await crowdinModule.metadataStore.saveMetadata(\n       key, \n       data, \n       connection.context.crowdinId\n   );\n   \n   // ‚ùå WRONG - only insert, NOT upsert (will fail if key already exists)\n   await crowdinApp.storage.saveMetadata(\n       key, \n       data, \n       connection.context.crowdinId\n   );\n   ```\n\n### Cron Scheduling\n\n#### Overview\n\nCron Scheduling allows your app to execute background tasks at specified time intervals.\n\n#### Official Documentation\n\n**üìö Complete Documentation:** Refer to Crowdin Apps SDK documentation for cron scheduling\n\n**‚ö†Ô∏è CRITICAL**: Only specific cron intervals are supported. Using unsupported intervals will result in an error.\n\n#### Supported Intervals\n\nThe following cron expressions are supported:\n\n| Cron Expression | Description | Frequency |\n|----------------|-------------|-----------|\n| `0 * * * *` | Every hour | Runs at minute 0 of every hour |\n| `0 */3 * * *` | Every 3 hours | Runs at minute 0 every 3 hours |\n| `0 */6 * * *` | Every 6 hours | Runs at minute 0 every 6 hours |\n| `0 */12 * * *` | Every 12 hours | Runs at minute 0 every 12 hours |\n| `0 0 * * *` | Daily | Runs at midnight (00:00) every day |\n| `0 0 * * SUN` | Weekly | Runs at midnight (00:00) every Sunday |\n| `0 0 1 * *` | Monthly | Runs at midnight (00:00) on the 1st of each month |\n\n#### Common Examples\n\n**Simple Hourly Task:**\n```typescript\n// In worker/app.ts, after initializing crowdinApp\nconst crowdinApp = crowdinModule.addCrowdinEndpoints(app, configuration) as CrowdinAppUtilities;\n\n// Register cron job - runs every hour\ncrowdinApp.cron.schedule('0 * * * *', async () => {\n    try {\n        console.log('Hourly task started at', new Date().toISOString());\n        \n        // Perform your scheduled task\n        // Example: Check status, update cache, etc.\n        \n        console.log('Task completed');\n    } catch (error) {\n        console.error('Cron job error:', error);\n    }\n});\n```\n\n**Multiple Tasks for Same Schedule:**\n```typescript\n// In worker/app.ts, after initializing crowdinApp\nconst crowdinApp = crowdinModule.addCrowdinEndpoints(app, configuration) as CrowdinAppUtilities;\n\n// Both tasks will run daily at midnight\ncrowdinApp.cron.schedule('0 0 * * *', async () => {\n    try {\n        console.log('Daily cleanup started');\n        // Cleanup old data\n    } catch (error) {\n        console.error('Cleanup error:', error);\n    }\n});\n\ncrowdinApp.cron.schedule('0 0 * * *', async () => {\n    try {\n        console.log('Daily report started');\n        // Generate reports\n    } catch (error) {\n        console.error('Report error:', error);\n    }\n});\n```\n\n**Using Crowdin API Client in Cron Jobs:**\n```typescript\n// In worker/app.ts, after initializing crowdinApp\nconst crowdinApp = crowdinModule.addCrowdinEndpoints(app, configuration) as CrowdinAppUtilities;\n\n// Register cron job that processes data for multiple organizations\ncrowdinApp.cron.schedule('0 0 * * *', async () => {\n    try {\n        console.log('Daily sync started');\n        \n        // Get all metadata records\n        const allMetadata = await crowdinApp.storage.getAllMetadata();\n        \n        if (!allMetadata || allMetadata.length === 0) {\n            console.log('No metadata found, skipping sync');\n            return;\n        }\n        \n        // Filter metadata by pattern using regex (e.g., find all organization configs)\n        const configPattern = /^org_(\\d+)_config$/;\n        const orgConfigs = allMetadata.filter(record => \n            configPattern.test(record.id)\n        );\n        \n        console.log(`Found ${orgConfigs.length} organization configs to process`);\n        \n        // Process each organization separately\n        for (const configRecord of orgConfigs) {\n            try {\n                const match = configRecord.id.match(configPattern);\n                const organizationId = match?.[1];\n                const crowdinId = configRecord.crowdin_id; // domain or organizationId\n                const configData = JSON.parse(configRecord.data || '{}');\n                \n                console.log(`Processing organization ${organizationId}`);\n                \n                // Create individual Crowdin API client for this organization\n                const encryptedData = crowdinApp.encryptCrowdinConnection({\n                    crowdinId,\n                    extra: {}, // Always pass empty object\n                });\n                \n                const { client } = await crowdinApp.dencryptCrowdinConnection(encryptedData, true);\n                \n                // Use client to make API calls for this specific organization\n                const projects = await client.projectsGroupsApi.withFetchAll().listProjects();\n                console.log(`Organization ${organizationId}: Found ${projects.data.length} projects`);\n                \n                // Process organization-specific configuration\n                if (configData.autoSync) {\n                    console.log(`Organization ${organizationId}: Auto-sync enabled, processing...`);\n                    // Perform sync operations\n                }\n                \n            } catch (error) {\n                console.error(`Error processing organization ${organizationId}:`, error);\n                // Continue with next organization\n            }\n        }\n        \n        console.log('Daily sync completed');\n    } catch (error) {\n        console.error('Cron job error:', error);\n    }\n});\n```\n\n#### Best Practices\n\n1. **Use appropriate intervals for your task**\n   ```typescript\n   // ‚úÖ CORRECT - frequent checks for time-sensitive tasks\n   crowdinApp.cron.schedule('0 * * * *', async () => {\n       // Hourly notification checks\n   });\n   \n   // ‚úÖ CORRECT - less frequent for resource-intensive tasks\n   crowdinApp.cron.schedule('0 0 * * *', async () => {\n       // Daily cleanup or report generation\n   });\n   \n   // ‚ùå WRONG - using unsupported interval\n   crowdinApp.cron.schedule('*/5 * * * *', async () => {\n       // Every 5 minutes - NOT SUPPORTED\n   });\n   ```\n\n2. **Handle errors gracefully**\n   ```typescript\n   // ‚úÖ CORRECT - catch and log errors\n   crowdinApp.cron.schedule('0 * * * *', async () => {\n       try {\n           await performTask();\n       } catch (error) {\n           console.error('Cron job failed:', error);\n           // Log error but don't throw - let job complete\n       }\n   });\n   \n   // ‚ùå WRONG - unhandled errors\n   crowdinApp.cron.schedule('0 * * * *', async () => {\n       await performTask(); // May crash if it throws\n   });\n   ```\n\n3. **Keep cron jobs lightweight**\n   ```typescript\n   // ‚úÖ CORRECT - efficient processing\n   crowdinApp.cron.schedule('0 0 * * *', async () => {\n       const startTime = Date.now();\n       console.log('Task started');\n       \n       // Perform lightweight operations\n       await quickCleanup();\n       \n       console.log(`Completed in ${Date.now() - startTime}ms`);\n   });\n   \n   // ‚ùå WRONG - heavy processing that may timeout\n   crowdinApp.cron.schedule('0 * * * *', async () => {\n       // Processing millions of records - may timeout\n       const allData = await fetchAllData();\n       await processAll(allData);\n   });\n   ```\n\n4. **Always await async operations**\n   ```typescript\n   // ‚úÖ CORRECT - await all async operations\n   crowdinApp.cron.schedule('0 * * * *', async () => {\n       await saveData();\n       await processQueue();\n       console.log('All tasks completed');\n   });\n   \n   // ‚úÖ CORRECT - setTimeout with proper promise wrapper\n   crowdinApp.cron.schedule('0 * * * *', async () => {\n       await new Promise((resolve) => {\n           setTimeout(async () => {\n               await processData();\n               resolve();\n           }, 1000);\n       });\n   });\n   \n   // ‚ùå WRONG - promise without await (will not complete)\n   crowdinApp.cron.schedule('0 * * * *', async () => {\n       saveData(); // This will NOT complete before cron job ends\n       console.log('Done'); // Logs immediately, but saveData is not finished\n   });\n   \n   // ‚ùå WRONG - setTimeout without proper promise wrapper\n   crowdinApp.cron.schedule('0 * * * *', async () => {\n       setTimeout(async () => {\n           await processData(); // This will NOT execute\n       }, 1000);\n   });\n   ```\n\n5. **Log execution for debugging**\n   ```typescript\n   // ‚úÖ CORRECT - comprehensive logging\n   crowdinApp.cron.schedule('0 */6 * * *', async () => {\n       const startTime = Date.now();\n       console.log(`Cron job started at ${new Date().toISOString()}`);\n       \n       try {\n           await performTask();\n           console.log(`Completed in ${Date.now() - startTime}ms`);\n       } catch (error) {\n           console.error(`Failed after ${Date.now() - startTime}ms:`, error);\n       }\n   });\n   ```\n\n### Webhooks\n\n#### Overview\n\nWebhooks allow your app to subscribe to events that occur in Crowdin projects or organizations. When a subscribed event happens, Crowdin automatically sends the event data to your app's callback function.\n\n#### Official Documentation\n\n**üìö Complete Documentation:** [Crowdin Webhooks](https://crowdin.github.io/app-project-module/tools/webhook/)\n\n**üìö Available Events:** [Webhook Events List](https://support.crowdin.com/developer/webhooks/)\n\n**‚ö†Ô∏è CRITICAL**: Only use event names from the official events list. Invalid event names will be ignored.\n\n#### Configuration\n\nConfigure webhooks in your app configuration in `worker/app.ts`:\n\n```typescript\nconst configuration: ClientConfig = {\n    // ... other configuration ...\n    \n    // Webhook subscriptions\n    webhooks: [\n        {\n            // List of events to subscribe to\n            events: ['file.added', 'file.updated', 'file.deleted'],\n            \n            // Callback function that handles events\n            callback({ client, events, webhookContext }) {\n                console.log('Received events:', events);\n                console.log('Organization:', webhookContext.organizationId);\n                console.log('User:', webhookContext.userId);\n                \n                // Process events here\n                events.forEach(event => {\n                    console.log('Event:', event.event, 'Project:', event.file.project.id);\n                });\n            },\n            \n            deferResponse: true\n        },\n        {\n            // You can have multiple webhook subscriptions\n            events: ['suggestion.updated', 'string.added'],\n            callback({ client, events, webhookContext }) {\n                // Handle translation events\n            },\n            \n            deferResponse: true\n        }\n    ]\n};\n```\n\n#### Common Examples\n\n**File Events:**\n```typescript\nwebhooks: [\n    {\n        events: ['file.added', 'file.updated', 'file.deleted', 'file.reverted'],\n        async callback({ client, events, webhookContext }) {\n            for (const event of events) {\n                console.log(`File ${event.event} in project ${event.file.project.id}`);\n                console.log('File details:', event.file);\n                \n                // Example: Get project details when file is added\n                if (event.event === 'file.added') {\n                    const project = await client.projectsGroupsApi.getProject(event.file.project.id);\n                    console.log('Project name:', project.data.name);\n                }\n            }\n        },\n        deferResponse: true\n    }\n]\n```\n\n#### Callback Parameters\n\nThe callback function receives an object with three properties:\n\n```typescript\ninterface WebhookCallback {\n    /**\n     * Crowdin API client - use to make API calls\n     * Same client as connection.client in endpoints\n     */\n    client: CrowdinApi;\n    \n    /**\n     * Array of webhook event objects\n     * Multiple events may be batched together\n     */\n    events: WebhookEvent[];\n    \n    /**\n     * Context information about the webhook\n     */\n    webhookContext: {\n        /** Crowdin domain (e.g., \"crowdin.com\") */\n        domain: string;\n        \n        /** Organization ID where event occurred */\n        organizationId: number;\n        \n        /** User ID who installed the application */\n        userId: number;\n        \n        /** Agent ID (if authenticationType is \"crowdin_agent\") */\n        agentId?: number;\n    };\n}\n```\n\n#### Common Event Types\n\n**Project Events:**\n- `project.created` - New project added\n- `project.deleted` - Project deleted\n- `project.translated` - Project fully translated\n- `project.approved` - Project reviewed\n- `project.built` - Project built\n\n**Group Events:**\n- `group.created` - New group added\n- `group.deleted` - Group deleted\n\n**File Events:**\n- `file.added` - New file added to project\n- `file.updated` - File updated\n- `file.deleted` - File deleted from project\n- `file.reverted` - File reverted to previous version\n- `file.translated` - File fully translated\n- `file.approved` - File reviewed\n\n**String Events:**\n- `string.added` - New source string added\n- `string.updated` - Source string updated\n- `string.deleted` - Source string deleted\n\n**Translation Events:**\n- `suggestion.added` - String translation added\n- `suggestion.updated` - String translation updated\n- `suggestion.deleted` - String translation deleted\n- `suggestion.approved` - String translation approved\n- `suggestion.disapproved` - String translation disapproved\n\n**Comment Events:**\n- `stringComment.created` - String comment added\n- `stringComment.updated` - String comment updated\n- `stringComment.deleted` - String comment deleted\n- `stringComment.restored` - String comment restored\n\n**Task Events:**\n- `task.added` - New task added\n- `task.statusChanged` - Task status changed\n- `task.updated` - Task updated\n- `task.deleted` - Task deleted\n\n#### Best Practices\n\n1. **Always set deferResponse to true**\n   ```typescript\n   // ‚úÖ CORRECT - deferResponse is set to true\n   webhooks: [\n       {\n           events: ['file.added'],\n           callback({ client, events, webhookContext }) {\n               console.log('Processing events');\n           },\n           deferResponse: true  // REQUIRED!\n       }\n   ]\n   \n   // ‚ùå WRONG - missing deferResponse\n   webhooks: [\n       {\n           events: ['file.added'],\n           callback({ client, events, webhookContext }) {\n               console.log('Processing events');\n           }\n           // Missing deferResponse: true - this will cause issues!\n       }\n   ]\n   ```\n\n2. **Handle multiple events in batch**\n   ```typescript\n   // ‚úÖ CORRECT - process all events\n   callback({ client, events, webhookContext }) {\n       events.forEach(event => {\n           console.log('Processing event:', event.event);\n       });\n   }\n   \n   // ‚ùå WRONG - only processes first event\n   callback({ client, events, webhookContext }) {\n       const event = events[0];\n       console.log('Processing event:', event.event);\n   }\n   ```\n\n3. **Handle errors gracefully**\n   ```typescript\n   // ‚úÖ CORRECT - catches and logs errors\n   async callback({ client, events, webhookContext }) {\n       for (const event of events) {\n           try {\n               await processEvent(event);\n           } catch (error) {\n               console.error('Failed to process event:', event.event, error);\n               // Continue processing other events\n           }\n       }\n   }\n   ```\n\n4. **Check event type before processing**\n   ```typescript\n   // ‚úÖ CORRECT - checks event type\n   callback({ client, events, webhookContext }) {\n       events.forEach(event => {\n           if (event.event === 'file.added') {\n               console.log('New file:', event.file?.name);\n           } else if (event.event === 'file.updated') {\n               console.log('Updated file:', event.file?.name);\n           }\n       });\n   }\n   ```\n\n5. **Use webhookContext for scoping**\n   ```typescript\n   // ‚úÖ CORRECT - uses context for organization-specific logic\n   async callback({ client, events, webhookContext }) {\n       const orgId = webhookContext.organizationId;\n       const userId = webhookContext.userId;\n       \n       // Store event in metadata\n       const key = `org_${orgId}_events_${Date.now()}`;\n       // await crowdinModule.metadataStore.saveMetadata(key, events, `${webhookContext.domain || webhookContext.organizationId}`);\n   }\n   ```\n\n6. **Don't perform long-running operations**\n   ```typescript\n   // ‚úÖ CORRECT - quick processing, delegate heavy work\n   async callback({ client, events, webhookContext }) {\n       // Quick logging\n       console.log('Received', events.length, 'events');\n       \n       // Store for later processing\n       const key = `org_${webhookContext.organizationId}_queue`;\n       // await crowdinModule.metadataStore.saveMetadata(key, events, `${webhookContext.domain || webhookContext.organizationId}`);\n   }\n   \n   // ‚ö†Ô∏è PROBLEMATIC - long-running operation blocks webhook\n   async callback({ client, events, webhookContext }) {\n       // This might timeout\n       for (const event of events) {\n           await processLargeFile(event.file?.id);\n           await sendMultipleNotifications(event);\n           await updateExternalDatabase(event);\n       }\n   }\n   ```\n\n#### Event Object Structure\n\nEach event type has its own interface with specific fields. Use these interfaces to understand which data is available for each event:\n\n```typescript\n// ============================================================================\n// SHARED MODELS - Reusable data structures\n// ============================================================================\n\ninterface ProjectModel {\n    id: number;\n    name: string;\n    identifier: string;\n    sourceLanguageId: string;\n    targetLanguageIds: string[];\n}\n\ninterface UserModel {\n    id: number;\n    username: string;\n}\n\ninterface LanguageModel {\n    id: string;\n    name: string;\n}\n\ninterface FileModelBase {\n    id: number;\n    name: string;\n    title: string;\n    type: string;\n    path: string;\n    branchId: number | null;\n    directoryId: number | null;\n}\n\ninterface FileModel extends FileModelBase {\n    project: ProjectModel;\n}\n\ninterface GroupModel {\n    id: number;\n    name: string;\n    parentId: number | null;\n}\n\ninterface StringModelBase {\n    id: number;\n    identifier: string;\n    text: string;\n    context: string | null;\n    isHidden: boolean;\n}\n\ninterface StringModel extends StringModelBase {\n    file: FileModelBase;\n    project: ProjectModel;\n}\n\ninterface TranslationModelBase {\n    id: number;\n    text: string;\n}\n\ninterface TranslationModel extends TranslationModelBase {\n    user: UserModel;\n    targetLanguage: LanguageModel;\n    string: StringModel;\n}\n\ninterface TaskModel {\n    id: number;\n    type: 0 | 1; // 0 - Translate, 1 - Proofread\n    title: string;\n    status: 'todo' | 'in_progress' | 'done' | 'closed' | 'pending' | 'review';\n    sourceLanguage: LanguageModel;\n    targetLanguage: LanguageModel;\n    project: ProjectModel;\n    taskCreator: UserModel;\n}\n\ninterface CommentModelBase {\n    id: number;\n    text: string;\n    type: 'issue' | 'comment';\n    issueType: 'general_question' | 'translation_mistake' |  'context_request' |  'source_mistake';\n    issueStatus: 'resolved' | 'unresolved';\n}\n\ninterface CommentModel extends CommentModelBase {\n    string: StringModel;\n    targetLanguage: LanguageModel;\n    user: UserModel;\n    commentResolver: UserModel | null;\n}\n\ninterface BuildModel {\n    id: number;\n    downloadUrl: string;\n    project: ProjectModel;\n}\n\n// ============================================================================\n// BASE EVENT INTERFACES\n// ============================================================================\n\ninterface BaseEventWithUser {\n    user: UserModel;\n}\n\ninterface BaseProjectEvent {\n    project: ProjectModel;\n}\n\ninterface BaseGroupEvent {\n    group: GroupModel;\n}\n\ninterface BaseFileEvent {\n    file: FileModel;\n}\n\ninterface BaseStringEvent {\n    string: StringModel;\n}\n\ninterface BaseTranslationEvent {\n    translation: TranslationModel;\n}\n\ninterface BaseTaskEvent {\n    task: TaskModel;\n}\n\ninterface BaseCommentEvent {\n    comment: CommentModel;\n}\n\n// ============================================================================\n// PROJECT EVENTS\n// ============================================================================\n\ninterface ProjectCreatedEvent extends BaseProjectEvent, BaseEventWithUser {\n    event: 'project.created';\n}\n\ninterface ProjectDeletedEvent extends BaseProjectEvent, BaseEventWithUser {\n    event: 'project.deleted';\n}\n\ninterface ProjectTranslatedEvent extends BaseProjectEvent {\n    event: 'project.translated';\n    targetLanguage: LanguageModel;\n}\n\ninterface ProjectApprovedEvent extends BaseProjectEvent {\n    event: 'project.approved';\n    targetLanguage: LanguageModel;\n}\n\ninterface ProjectBuiltEvent {\n    event: 'project.built';\n    build: BuildModel;\n}\n\n// ============================================================================\n// GROUP EVENTS\n// ============================================================================\n\ninterface GroupCreatedEvent extends BaseGroupEvent, BaseEventWithUser {\n    event: 'group.created';\n}\n\ninterface GroupDeletedEvent extends BaseGroupEvent, BaseEventWithUser {\n    event: 'group.deleted';\n}\n\n// ============================================================================\n// FILE EVENTS\n// ============================================================================\n\ninterface FileAddedEvent extends BaseFileEvent, BaseEventWithUser {\n    event: 'file.added';\n}\n\ninterface FileUpdatedEvent extends BaseFileEvent, BaseEventWithUser {\n    event: 'file.updated';\n}\n\ninterface FileDeletedEvent extends BaseFileEvent, BaseEventWithUser {\n    event: 'file.deleted';\n}\n\ninterface FileRevertedEvent extends BaseFileEvent, BaseEventWithUser {\n    event: 'file.reverted';\n}\n\ninterface FileTranslatedEvent extends BaseFileEvent {\n    event: 'file.translated';\n    targetLanguage: LanguageModel;\n}\n\ninterface FileApprovedEvent extends BaseFileEvent {\n    event: 'file.approved';\n    targetLanguage: LanguageModel;\n}\n\n// ============================================================================\n// STRING EVENTS\n// ============================================================================\n\ninterface StringAddedEvent extends BaseStringEvent, BaseEventWithUser {\n    event: 'string.added';\n}\n\ninterface StringUpdatedEvent extends BaseStringEvent, BaseEventWithUser {\n    event: 'string.updated';\n}\n\ninterface StringDeletedEvent extends BaseStringEvent, BaseEventWithUser {\n    event: 'string.deleted';\n}\n\n// ============================================================================\n// TRANSLATION/SUGGESTION EVENTS\n// ============================================================================\n\ninterface SuggestionAddedEvent extends BaseTranslationEvent {\n    event: 'suggestion.added';\n}\n\ninterface SuggestionUpdatedEvent extends BaseTranslationEvent {\n    event: 'suggestion.updated';\n}\n\ninterface SuggestionDeletedEvent extends BaseTranslationEvent {\n    event: 'suggestion.deleted';\n}\n\ninterface SuggestionApprovedEvent extends BaseTranslationEvent {\n    event: 'suggestion.approved';\n}\n\ninterface SuggestionDisapprovedEvent extends BaseTranslationEvent {\n    event: 'suggestion.disapproved';\n}\n\ninterface TranslationUpdatedEvent {\n    event: 'translation.updated';\n    newTranslation: TranslationModel;\n}\n\n// ============================================================================\n// COMMENT EVENTS\n// ============================================================================\n\ninterface StringCommentCreatedEvent extends BaseCommentEvent {\n    event: 'stringComment.created';\n}\n\ninterface StringCommentUpdatedEvent extends BaseCommentEvent {\n    event: 'stringComment.updated';\n}\n\ninterface StringCommentDeletedEvent extends BaseCommentEvent {\n    event: 'stringComment.deleted';\n}\n\ninterface StringCommentRestoredEvent extends BaseCommentEvent {\n    event: 'stringComment.restored';\n}\n\n// ============================================================================\n// TASK EVENTS\n// ============================================================================\n\ninterface TaskAddedEvent extends BaseTaskEvent {\n    event: 'task.added';\n}\n\ninterface TaskStatusChangedEvent extends BaseTaskEvent {\n    event: 'task.statusChanged';\n}\n\ninterface TaskUpdatedEvent extends BaseTaskEvent {\n    event: 'task.updated';\n}\n\ninterface TaskDeletedEvent extends BaseTaskEvent {\n    event: 'task.deleted';\n}\n\n// ============================================================================\n// UNION TYPE - All possible webhook events\n// ============================================================================\n\ntype WebhookEvent = \n    // Project events\n    | ProjectCreatedEvent\n    | ProjectDeletedEvent\n    | ProjectTranslatedEvent\n    | ProjectApprovedEvent\n    | ProjectBuiltEvent\n    // Group events\n    | GroupCreatedEvent\n    | GroupDeletedEvent\n    // File events\n    | FileAddedEvent\n    | FileUpdatedEvent\n    | FileDeletedEvent\n    | FileRevertedEvent\n    | FileTranslatedEvent\n    | FileApprovedEvent\n    // String events\n    | StringAddedEvent\n    | StringUpdatedEvent\n    | StringDeletedEvent\n    // Translation/Suggestion events\n    | SuggestionAddedEvent\n    | SuggestionUpdatedEvent\n    | SuggestionDeletedEvent\n    | SuggestionApprovedEvent\n    | SuggestionDisapprovedEvent\n    | TranslationUpdatedEvent\n    // Comment events\n    | StringCommentCreatedEvent\n    | StringCommentUpdatedEvent\n    | StringCommentDeletedEvent\n    | StringCommentRestoredEvent\n    // Task events\n    | TaskAddedEvent\n    | TaskStatusChangedEvent\n    | TaskUpdatedEvent\n    | TaskDeletedEvent;\n```\n\n## Frontend Development\n\n### Crowdin Apps JS API\n\n#### Official Documentation\n\nThe `AP` object provides the Crowdin Apps JS API for interacting with the Crowdin application context.\n\n**üìö Complete API Reference:** https://support.crowdin.com/developer/crowdin-apps-js/\n\n**‚ö†Ô∏è CRITICAL**: Only use methods and types from the Crowdin Apps JS API definitions below.\n\n**Do NOT invent methods or properties that are not listed here.**\n\n#### Common Examples\n\n**Get Context (Promise-based):**\n```typescript\n// Promisified helper\nconst getContext = (): Promise<any> => {\n    return new Promise(resolve => window.AP.getContext(resolve));\n};\n\n// Usage\nconst context = await getContext();\nconsole.log('Project ID:', context.project_id);\n```\n\n**Get JWT Token (Promise-based):**\n```typescript\n// Promisified helper\nconst getJwtToken = (): Promise<string> => {\n    return new Promise(resolve => window.AP.getJwtToken(resolve));\n};\n\n// Usage with fetch\nconst token = await getJwtToken();\nconst response = await fetch(`/api/endpoint?jwt=${token}`);\nconst data = await response.json();\n```\n\n#### Best Practices\n\n1. **Handle errors gracefully**\n   ```typescript\n   try {\n       const context = await getContext();\n       if (!context.organization_id) {\n           throw new Error('Organization ID not found');\n       }\n       // Your code\n   } catch (error) {\n       console.error('Failed to get context:', error);\n   }\n   ```\n\n#### Complete Type Definitions\n\n##### Global AP Object Structure\n\n```typescript\ndeclare namespace AP {\n    // Global Actions\n    function getContext(callback: (context: Context) => void): void;\n    function getJwtToken(callback: (token: string) => void): void;\n    function getTheme(): 'light' | 'dark';\n    function redirect(path: string): void;\n}\n```\n\n##### Type Definitions\n\n```typescript\n// Context Information\ninterface Context {\n    project_id: number;\n    organization_id: number;\n}\n```\n\n## Development Workflow\n\n### 1. Configure Your App Identity\n\n**‚ö†Ô∏è Important**: You MUST update the configuration in `worker/app.ts` before deployment:\n\n```typescript\nconst configuration: ClientConfig = {\n    name: \"Your App Name\",           // Change this to your app's display name\n    identifier: \"your-app-id\",       // Change to unique identifier (lowercase, hyphens)\n    description: \"Your app description\", // Change to describe your app's purpose\n    // ... rest of configuration\n}\n```\n\n**Note**: The `identifier` must be unique across all Crowdin apps. Use format like: `company-project-tools`\n\n### 2. Key Files to Modify\n\n- `worker/app.ts` - Add new API endpoints here\n- `src/pages/HomePage.tsx` - Main page component (customize for your app logic)\n- `src/components/app-sidebar.tsx` - Sidebar navigation (customize menu items)\n- `src/components/layout/AppLayout.tsx` - Application layout (customize layout structure)\n- `src/index.css` - Customize global styles and Tailwind theme\n- `tailwind.config.js` - Add custom colors and extend theme"
    }
  },
  {
    "name": "crowdin-file-processor",
    "language": "typescript",
    "frameworks": [
      "@dnd-kit",
      "@hookform/resolvers",
      "autoprefixer",
      "class-variance-authority",
      "cloudflare",
      "clsx",
      "cmdk",
      "date-fns",
      "express",
      "framer-motion",
      "immer",
      "input-otp",
      "next",
      "postcss",
      "react",
      "recharts",
      "sonner",
      "tailwind",
      "tw-animate-css",
      "typescript",
      "vaul",
      "vite",
      "wrangler",
      "zod",
      "zustand"
    ],
    "description": {
      "selection": "# Template Selection\n\nCrowdin app with File Processing modules (Pre-Import, Post-Import, Pre-Export, Post-Export).\n\nUse when:\n- Transforming file content before Crowdin parses it (Pre-Import)\n- Modifying source strings after parsing but before storage (Post-Import)\n- Transforming translations before file generation (Pre-Export)\n- Post-processing generated files before delivery (Post-Export)\n- Implementing custom text replacement rules with regex\n- Normalizing file formats or content during localization workflow\n- Adding/removing metadata, headers, or formatting in files\n\nAvoid when:\n- Integrating custom AI providers (use AI Provider instead)\n- Building machine translation integrations (use Custom MT instead)\n- Building editor extensions (use Editor Right Panel instead)\n- Building organization-wide tools (use Organization Menu instead)\n- Building user profile tools (use Profile Resources Menu instead)\n- Building project-specific tools (use Project Tools instead)\n\nBuilt with:\n- Crowdin Apps JS API\n- Crowdin Apps SDK (@crowdin/app-project-module)\n- React\n- ShadCN UI\n- Tailwind\n- Lucide Icons\n- ESLint\n- Vite\n- TypeScript\n- Express.js\n- Cloudflare Workers",
      "usage": "# Usage\n\n## Overview\nCrowdin app with File Processing modules (Pre-Import, Post-Import, Pre-Export, Post-Export), Profile Resources Menu and Organization Menu modules for transforming files and strings during localization workflows.\n- Backend: TypeScript with Express.js and Crowdin Apps SDK\n- Frontend: React + TypeScript + ShadCN UI + Crowdin Apps JS API\n\n## Tech Stack\n- Crowdin Apps JS API\n- Crowdin Apps SDK (@crowdin/app-project-module)\n- React\n- ShadCN UI\n- Tailwind\n- Lucide Icons\n- ESLint\n- Vite\n- TypeScript\n- Express.js\n- Cloudflare Workers\n\n## Development Restrictions\n- **Tailwind Colors**: Hardcode custom colors in `tailwind.config.js`, NOT in `index.css`\n- **Components**: Use existing ShadCN components instead of writing custom ones\n- **Icons**: Import from `lucide-react` directly\n- **Error Handling**: ErrorBoundary components are pre-implemented\n- **Authentication**: Always use JWT tokens from Crowdin for API requests\n- **File Processing Configuration**: Don't modify the filePreImport, filePostImport, filePreExport, filePostExport configuration structures\n- **Profile Resources Menu Configuration**: Don't modify the profileResourcesMenu configuration structure\n- **Organization Menu Configuration**: Don't modify the organizationMenu configuration structure\n- **Scopes**: Ensure your app has appropriate API scopes\n- **Storage Keys**: Always include organizationId in metadata keys to isolate data per organization\n- **Return Values**: fileProcess functions must return correct response types (ContentFileResponse or StringsFileResponse)\n- **Buffer Handling**: Always handle Buffer ‚Üî string conversions properly for file content\n- **Plural Forms**: Process all plural forms (zero, one, two, few, many, other) when transforming string text\n- **Error Handling**: Return error property instead of throwing to prevent file operation failures\n- **Type Safety**: Use ProcessFileString type for strings array and proper type assertions for content\n\n## Styling\n- Responsive, accessible\n- Prefer ShadCN components; Tailwind for layout/spacing/typography\n- Use framer-motion sparingly for micro-interactions\n\n## Project Structure\n\n### Backend Structure\n- `worker/app.ts` - Express app factory with File Processing module configuration\n- `worker/index.ts` - Cloudflare Worker entry point (HTTP handler, cron scheduler, middleware)\n- `worker/types/` - Backend TypeScript type definitions\n  - `cloudflare-env.d.ts` - Cloudflare environment types (KV storage, secrets)\n\n### Frontend Structure\n- `index.html` - HTML entry point with Crowdin Apps JS API script\n- `src/main.tsx` - React entry point with ErrorBoundary wrapper\n- `src/index.css` - Global styles and Tailwind CSS customizations\n- `src/components/` - React components\n  - `app-sidebar.tsx` - Application sidebar navigation\n  - `ErrorBoundary.tsx` - React error boundary with backend error reporting\n  - `ErrorFallback.tsx` - Fallback UI component for error states\n  - `RouteErrorBoundary.tsx` - Error boundary for routing errors\n  - `layout/` - Layout components\n    - `AppLayout.tsx` - Main application layout wrapper\n  - `ui/` - ShadCN UI components (button, card, sonner, etc.)\n- `src/pages/` - Page components\n  - `HomePage.tsx` - Home page component (main entry point for your app logic)\n- `src/hooks/` - Custom React hooks\n  - `use-mobile.tsx` - Hook for detecting mobile breakpoints\n- `src/lib/` - Utility modules\n  - `utils.ts` - Tailwind utility functions (`cn` for class merging)\n  - `errorReporter.ts` - Client-side error reporting to backend\n  - `apiClient.ts` - Generic API call wrapper with JWT token handling\n- `src/types/` - TypeScript type definitions\n  - `global.d.ts` - Global type declarations\n  - `vite-env.d.ts` - Vite environment types\n\n## Backend Development\n\n### App Configuration\n\nConfigure your app identity in `worker/app.ts`:\n\n```typescript\nconst configuration: ClientConfig = {\n    name: \"Your App Name\",                    // Display name shown in Crowdin UI\n    identifier: \"your-unique-app-identifier\", // Unique ID (lowercase, hyphens)\n    description: \"Your app description\",      // Brief description of functionality\n    // ... rest of configuration\n}\n```\n\n**Guidelines:**\n- **identifier**: Must be unique across all Crowdin apps. Format: `company-file-processor`\n- **name**: User-friendly display name (e.g., \"Company File Processor\")\n- **description**: Brief explanation of what your file processor does\n\n#### Required Scopes\n\nAdd scopes to configuration in `worker/app.ts` based on your app's functionality.\n\n**‚ö†Ô∏è IMPORTANT**: Only use scopes from the list below. Do not invent or use non-existent scopes!\n\n```typescript\nconst configuration: ClientConfig = {\n    // ... other configuration ...\n    scopes: [\n        // Choose from the following valid scopes:\n        \n        // General scopes\n        crowdinModule.Scope.NOTIFICATIONS,               // 'notification' - Notifications management\n        \n        // Project-level scopes\n        crowdinModule.Scope.PROJECTS,                    // 'project' - Project management\n        crowdinModule.Scope.TASKS,                       // 'project.task' - Project tasks\n        crowdinModule.Scope.REPORTS,                     // 'project.report' - Project reports\n        crowdinModule.Scope.TRANSLATION_STATUS,          // 'project.status' - Translation status\n        crowdinModule.Scope.SOURCE_FILES_AND_STRINGS,    // 'project.source' - Source files and strings\n        crowdinModule.Scope.WEBHOOKS,                    // 'project.webhook' - Project webhooks\n        crowdinModule.Scope.TRANSLATIONS,                // 'project.translation' - Translations\n        crowdinModule.Scope.SCREENSHOTS,                 // 'project.screenshot' - Screenshots\n        \n        // Organization-level scopes\n        crowdinModule.Scope.USERS,                       // 'user' - User management\n        crowdinModule.Scope.TEAMS,                       // 'team' - Team management\n        crowdinModule.Scope.GROUPS,                      // 'group' - Group management\n        crowdinModule.Scope.ORGANIZATION_WEBHOOKS,       // 'webhook' - Organization webhooks\n        crowdinModule.Scope.VENDORS,                     // 'vendor' - Vendor management\n        crowdinModule.Scope.FIELDS,                      // 'field' - Custom fields\n        crowdinModule.Scope.SECURITY_LOGS,               // 'security-log' - Security logs\n        crowdinModule.Scope.APPLICATIONS,                // 'application' - Applications management\n        \n        // Resources\n        crowdinModule.Scope.TRANSLATION_MEMORIES,        // 'tm' - Translation memories\n        crowdinModule.Scope.MACHINE_TRANSLATION_ENGINES, // 'mt' - Machine translation engines\n        crowdinModule.Scope.GLOSSARIES,                  // 'glossary' - Glossaries\n        \n        // AI-related scopes\n        crowdinModule.Scope.AI,                          // 'ai' - AI features\n        crowdinModule.Scope.AI_PROVIDERS,                // 'ai.provider' - AI providers\n        crowdinModule.Scope.AI_PROMPTS,                  // 'ai.prompt' - AI prompts\n        crowdinModule.Scope.AI_PROXIES,                  // 'ai.proxy' - AI proxies\n    ]\n}\n```\n\n### File Processing Modules Configuration\n\nConfigure the File Processing modules in `worker/app.ts`:\n\n```typescript\nimport type { Client, SourceStringsModel } from '@crowdin/crowdin-api-client';\nimport type { CrowdinContextInfo, ClientConfig } from '@crowdin/app-project-module/out/types';\nimport type { \n    ContentFileResponse, \n    FileImportExportContent, \n    ProcessFileRequest, \n    ProcessFileString, \n    StringsFileResponse \n} from '@crowdin/app-project-module/out/modules/file-processing/types';\n\nconst configuration: ClientConfig = {\n    // ... other configuration ...\n\n    // Pre-Import: Transform raw file content before parsing\n    filePreImport: {\n        signaturePatterns: {\n            fileName: \"^.+\\\\..+$\",      // Regex to match file names\n            fileContent: \".*\"            // Regex to match file content\n        },\n        fileProcess: async (\n            req: ProcessFileRequest,\n            content: FileImportExportContent,\n            client: Client,\n            context: CrowdinContextInfo,\n            projectId: number\n        ): Promise<ContentFileResponse> => {\n            const contentBuffer = content as Buffer;\n            let contentString = contentBuffer.toString('utf-8');\n            \n            // Your transformation logic here\n            contentString = contentString.replace(/pattern/g, 'replacement');\n            \n            return { \n                contentFile: Buffer.from(contentString, 'utf-8')\n            };\n        }\n    },\n\n    // Post-Import: Transform parsed strings before storage\n    filePostImport: {\n        signaturePatterns: {\n            fileName: \"^.+\\\\..+$\",\n            fileContent: \".*\"\n        },\n        fileProcess: async (\n            req: ProcessFileRequest,\n            content: FileImportExportContent,\n            client: Client,\n            context: CrowdinContextInfo,\n            projectId: number\n        ): Promise<StringsFileResponse> => {\n            const strings = content as ProcessFileString[];\n            \n            // Your transformation logic here\n            const modifiedStrings = strings.map(str => {\n                const modified: ProcessFileString = { ...str };\n                \n                // Early return if no text\n                if (!str.text) {\n                    return modified;\n                }\n                \n                // Simple string - apply rules\n                if (typeof str.text === 'string') {\n                    modified.text = str.text.replace(/pattern/g, 'replacement');\n                    return modified;\n                }\n                \n                // Plural text - apply rules to each plural form\n                const pluralText = { ...str.text };\n                for (const key in pluralText) {\n                    const pluralKey = key as keyof SourceStringsModel.PluralText;\n                    if (pluralText[pluralKey]) {\n                        pluralText[pluralKey] = pluralText[pluralKey]!.replace(/pattern/g, 'replacement');\n                    }\n                }\n                modified.text = pluralText;\n                \n                return modified;\n            });\n            \n            return { strings: modifiedStrings };\n        }\n    },\n\n    // Pre-Export: Transform translations before file generation\n    filePreExport: {\n        signaturePatterns: {\n            fileName: \"^.+\\\\..+$\",\n            fileContent: \".*\"\n        },\n        fileProcess: async (\n            req: ProcessFileRequest,\n            content: FileImportExportContent,\n            client: Client,\n            context: CrowdinContextInfo,\n            projectId: number\n        ): Promise<StringsFileResponse> => {\n            const strings = content as ProcessFileString[];\n            \n            // Transform translations for all languages\n            const modifiedStrings = strings.map(str => {\n                const modified: ProcessFileString = { ...str };\n                \n                // Early return if no translations\n                if (!str.translations) {\n                    return modified;\n                }\n                \n                const modifiedTranslations = { ...str.translations };\n                \n                // Process each language\n                for (const lang in modifiedTranslations) {\n                    const translation = modifiedTranslations[lang];\n                    \n                    // Skip if no text\n                    if (!translation.text) {\n                        continue;\n                    }\n                    \n                    // Simple string - apply rules\n                    if (typeof translation.text === 'string') {\n                        translation.text = translation.text.replace(/pattern/g, 'replacement');\n                        continue;\n                    }\n                    \n                    // Plural text - apply rules to each plural form\n                    const pluralText = { ...translation.text };\n                    for (const key in pluralText) {\n                        const pluralKey = key as keyof SourceStringsModel.PluralText;\n                        if (pluralText[pluralKey]) {\n                            pluralText[pluralKey] = pluralText[pluralKey]!.replace(/pattern/g, 'replacement');\n                        }\n                    }\n                    translation.text = pluralText;\n                }\n                \n                modified.translations = modifiedTranslations;\n                return modified;\n            });\n            \n            return { strings: modifiedStrings };\n        }\n    },\n\n    // Post-Export: Transform generated file before delivery\n    filePostExport: {\n        signaturePatterns: {\n            fileName: \"^.+\\\\..+$\",\n            fileContent: \".*\"\n        },\n        fileProcess: async (\n            req: ProcessFileRequest,\n            content: FileImportExportContent,\n            client: Client,\n            context: CrowdinContextInfo,\n            projectId: number\n        ): Promise<ContentFileResponse> => {\n            const contentBuffer = content as Buffer;\n            let contentString = contentBuffer.toString('utf-8');\n            \n            // Your transformation logic here\n            contentString = contentString.replace(/pattern/g, 'replacement');\n            \n            return { \n                contentFile: Buffer.from(contentString, 'utf-8')\n            };\n        }\n    }\n}\n```\n\n#### Common Examples\n\n**Using Configuration for Dynamic Rules**\n```typescript\nimport type { Client, SourceStringsModel } from '@crowdin/crowdin-api-client';\nimport type { CrowdinContextInfo, ClientConfig } from '@crowdin/app-project-module/out/types';\nimport type { \n    ContentFileResponse, \n    FileImportExportContent, \n    ProcessFileRequest, \n    ProcessFileString, \n    StringsFileResponse \n} from '@crowdin/app-project-module/out/modules/file-processing/types';\n\n// Helper function to apply replacement rules\nfunction applyReplaceRules(text: string, rules: Array<{ find: string; replace: string }>): string {\n    let result = text;\n    for (const rule of rules) {\n        if (rule.find && rule.replace !== undefined) {\n            try {\n                const regex = new RegExp(rule.find, 'g');\n                result = result.replace(regex, rule.replace);\n            } catch (e) {\n                console.error('Invalid regex pattern:', rule.find, e);\n            }\n        }\n    }\n    return result;\n}\n\n// Helper function to get configuration\nasync function getConfig(organizationId: number) {\n    const configKey = `file_processor_config_${organizationId}`;\n    const config = await crowdinModule.metadataStore.getMetadata(configKey);\n    return config || { modules: {}, preImport: { replaceRules: [] } };\n}\n\nconst configuration: ClientConfig = {\n    // ... other configuration ...\n\n    filePreImport: {\n        signaturePatterns: {\n            fileName: \"^.+\\\\..+$\",\n            fileContent: \".*\"\n        },\n        fileProcess: async (\n            req: ProcessFileRequest,\n            content: FileImportExportContent,\n            client: Client,\n            context: CrowdinContextInfo,\n            projectId: number\n        ): Promise<ContentFileResponse> => {\n            try {\n                // Get organization configuration\n                const organizationId = context.jwtPayload.context.organization_id;\n                const config = await getConfig(organizationId);\n                \n                // Early return if module disabled or no content\n                if (!content || !config.modules.preImport) {\n                    return { contentFile: content as Buffer, notModified: true };\n                }\n                \n                // Early return if no rules\n                if (!config.preImport.replaceRules?.length) {\n                    return { contentFile: content as Buffer, notModified: true };\n                }\n                \n                // Apply transformations\n                let contentString = (content as Buffer).toString('utf-8');\n                contentString = applyReplaceRules(contentString, config.preImport.replaceRules);\n                \n                return { contentFile: Buffer.from(contentString, 'utf-8') };\n            } catch (error) {\n                console.error('Pre-import processing error:', error);\n                return {\n                    contentFile: content as Buffer,\n                    error: 'Failed to process file during pre-import'\n                };\n            }\n        }\n    }\n}\n```\n\n**Processing Plural Forms in Post-Import**\n```typescript\nfilePostImport: {\n    signaturePatterns: {\n        fileName: \"^.+\\\\..+$\",\n        fileContent: \".*\"\n    },\n    fileProcess: async (\n        req: ProcessFileRequest,\n        content: FileImportExportContent,\n        client: Client,\n        context: CrowdinContextInfo,\n        projectId: number\n    ): Promise<StringsFileResponse> => {\n        const organizationId = context.jwtPayload.context.organization_id;\n        const config = await getConfig(organizationId);\n        \n        // Early returns\n        if (!config.modules.postImport || !config.postImport.replaceRules?.length) {\n            return { strings: content as ProcessFileString[], notModified: true };\n        }\n        \n        const strings = content as ProcessFileString[];\n        \n        // Apply rules to string text only\n        const modifiedStrings = strings.map(str => {\n            const modified: ProcessFileString = { ...str };\n            \n            // Early return if no text\n            if (!str.text) {\n                return modified;\n            }\n            \n            // Simple string - apply rules directly\n            if (typeof str.text === 'string') {\n                modified.text = applyReplaceRules(str.text, config.postImport.replaceRules);\n                return modified;\n            }\n            \n            // Plural text - apply rules to each plural form\n            const pluralText = { ...str.text };\n            for (const key in pluralText) {\n                const pluralKey = key as keyof SourceStringsModel.PluralText;\n                if (pluralText[pluralKey]) {\n                    pluralText[pluralKey] = applyReplaceRules(\n                        pluralText[pluralKey]!, \n                        config.postImport.replaceRules\n                    );\n                }\n            }\n            modified.text = pluralText;\n            \n            return modified;\n        });\n        \n        return { strings: modifiedStrings };\n    }\n}\n```\n\n**Processing Translations in Pre-Export**\n```typescript\nfilePreExport: {\n    signaturePatterns: {\n        fileName: \"^.+\\\\..+$\",\n        fileContent: \".*\"\n    },\n    fileProcess: async (\n        req: ProcessFileRequest,\n        content: FileImportExportContent,\n        client: Client,\n        context: CrowdinContextInfo,\n        projectId: number\n    ): Promise<StringsFileResponse> => {\n        const organizationId = context.jwtPayload.context.organization_id;\n        const config = await getConfig(organizationId);\n        \n        // Early returns\n        if (!config.modules.preExport || !config.preExport.replaceRules?.length) {\n            return { strings: content as ProcessFileString[], notModified: true };\n        }\n        \n        const strings = content as ProcessFileString[];\n        \n        // Apply rules to translations\n        const modifiedStrings = strings.map(str => {\n            const modified: ProcessFileString = { ...str };\n            \n            // Early return if no translations\n            if (!str.translations) {\n                return modified;\n            }\n            \n            const modifiedTranslations = { ...str.translations };\n            \n            // Process each language\n            for (const lang in modifiedTranslations) {\n                const translation = modifiedTranslations[lang];\n                \n                // Skip if no text\n                if (!translation.text) {\n                    continue;\n                }\n                \n                // Simple string - apply rules directly\n                if (typeof translation.text === 'string') {\n                    translation.text = applyReplaceRules(translation.text, config.preExport.replaceRules);\n                    continue;\n                }\n                \n                // Plural text - apply rules to each plural form\n                const pluralText = { ...translation.text };\n                for (const key in pluralText) {\n                    const pluralKey = key as keyof SourceStringsModel.PluralText;\n                    if (pluralText[pluralKey]) {\n                        pluralText[pluralKey] = applyReplaceRules(\n                            pluralText[pluralKey]!, \n                            config.preExport.replaceRules\n                        );\n                    }\n                }\n                translation.text = pluralText;\n            }\n            \n            modified.translations = modifiedTranslations;\n            return modified;\n        });\n        \n        return { strings: modifiedStrings };\n    }\n}\n```\n\n#### Best Practices\n\n1. **Use early returns to reduce nesting**\n   ```typescript\n   // ‚úÖ CORRECT - clear flow with early returns\n   fileProcess: async (\n        req: ProcessFileRequest,\n        content: FileImportExportContent,\n        client: Client,\n        context: CrowdinContextInfo,\n        projectId: number\n    ): Promise<StringsFileResponse> => {\n       const strings = content as ProcessFileString[];\n       \n       const modifiedStrings = strings.map(str => {\n           const modified: ProcessFileString = { ...str };\n           \n           // Early return if no text\n           if (!str.text) {\n               return modified;\n           }\n           \n           // Early return for simple string\n           if (typeof str.text === 'string') {\n               modified.text = transformText(str.text);\n               return modified;\n           }\n           \n           // Handle plurals\n           modified.text = transformPluralText(str.text);\n           return modified;\n       });\n       \n       return { strings: modifiedStrings };\n   }\n   \n   // ‚ùå WRONG - deep nesting\n   fileProcess: async (\n        req: ProcessFileRequest,\n        content: FileImportExportContent,\n        client: Client,\n        context: CrowdinContextInfo,\n        projectId: number\n    ): Promise<StringsFileResponse> => {\n       const strings = content as ProcessFileString[];\n       \n       const modifiedStrings = strings.map(str => {\n           const modified: ProcessFileString = { ...str };\n           \n           if (str.text) {\n               if (typeof str.text === 'string') {\n                   modified.text = transformText(str.text);\n               } else {\n                   // Deep nesting makes code hard to read\n                   modified.text = transformPluralText(str.text);\n               }\n           }\n           \n           return modified;\n       });\n       \n       return { strings: modifiedStrings };\n   }\n   ```\n\n2. **Handle plural forms correctly**\n   ```typescript\n   // ‚úÖ CORRECT - processes each plural form with proper typing\n   const modifiedStrings = strings.map(str => {\n       const modified: ProcessFileString = { ...str };\n       \n       if (!str.text) return modified;\n       \n       if (typeof str.text === 'string') {\n           modified.text = applyRules(str.text);\n           return modified;\n       }\n       \n       // Plural text - process each form\n       const pluralText = { ...str.text };\n       for (const key in pluralText) {\n           const pluralKey = key as keyof SourceStringsModel.PluralText;\n           if (pluralText[pluralKey]) {\n               pluralText[pluralKey] = applyRules(pluralText[pluralKey]!);\n           }\n       }\n       modified.text = pluralText;\n       \n       return modified;\n   });\n   \n   // ‚ùå WRONG - doesn't handle plurals, loses plural forms\n   const modifiedStrings = strings.map(str => {\n       const modified: ProcessFileString = { ...str };\n       \n       // BAD: Only processes simple strings, ignores plurals\n       if (typeof str.text === 'string') {\n           modified.text = applyRules(str.text);\n       }\n       // Plural forms are not processed!\n       \n       return modified;\n   });\n   ```\n\n3. **Return error property instead of throwing errors**\n   ```typescript\n   // ‚úÖ CORRECT - returns error property for file operation failures\n   fileProcess: async (\n       req: ProcessFileRequest,\n       content: FileImportExportContent,\n       client: Client,\n       context: CrowdinContextInfo,\n       projectId: number\n   ): Promise<ContentFileResponse> => {\n       try {\n           if (!content) {\n               return { contentFile: Buffer.from(''), error: 'No content provided' };\n           }\n           \n           const contentBuffer = content as Buffer;\n           let contentString = contentBuffer.toString('utf-8');\n           \n           // Apply transformations\n           contentString = applyTransformations(contentString);\n           \n           return { contentFile: Buffer.from(contentString, 'utf-8') };\n       } catch (error) {\n           console.error('Processing error:', error);\n           // Return error property instead of throwing\n           return {\n               contentFile: content as Buffer,\n               error: 'Failed to process file'\n           };\n       }\n   }\n   \n   // ‚ùå WRONG - throws error and fails entire file operation\n   fileProcess: async (\n       req: ProcessFileRequest,\n       content: FileImportExportContent,\n       client: Client,\n       context: CrowdinContextInfo,\n       projectId: number\n   ): Promise<ContentFileResponse> => {\n       const contentBuffer = content as Buffer;\n       let contentString = contentBuffer.toString('utf-8');\n       \n       // BAD: Throws error instead of returning error property\n       if (!contentString) {\n           throw new Error('Empty content');\n       }\n       \n       contentString = applyTransformations(contentString);\n       \n       return { contentFile: Buffer.from(contentString, 'utf-8') };\n   }\n   ```\n\n4. **Properly handle Buffer ‚Üî string conversions**\n   ```typescript\n   // ‚úÖ CORRECT - proper Buffer handling\n   fileProcess: async (\n       req: ProcessFileRequest,\n       content: FileImportExportContent,\n       client: Client,\n       context: CrowdinContextInfo,\n       projectId: number\n   ): Promise<ContentFileResponse> => {\n       // Type assertion for Buffer\n       const contentBuffer = content as Buffer;\n       \n       // Convert to string with explicit encoding\n       let contentString = contentBuffer.toString('utf-8');\n       \n       // Apply transformations\n       contentString = applyTransformations(contentString);\n       \n       // Convert back to Buffer with explicit encoding\n       return { \n           contentFile: Buffer.from(contentString, 'utf-8') \n       };\n   }\n   \n   // ‚ùå WRONG - unsafe type handling\n   fileProcess: async (\n       req: ProcessFileRequest,\n       content: FileImportExportContent,\n       client: Client,\n       context: CrowdinContextInfo,\n       projectId: number\n   ): Promise<ContentFileResponse> => {\n       // BAD: No type checking, may fail if content is undefined\n       let contentString = content.toString(); // Missing encoding!\n       \n       contentString = applyTransformations(contentString);\n       \n       // BAD: Missing encoding parameter\n       return { contentFile: Buffer.from(contentString) };\n   }\n   ```\n\n5. **Use signaturePatterns to control which files are processed**\n   ```typescript\n   // ‚úÖ CORRECT - specific patterns for targeted file types\n   filePreImport: {\n       signaturePatterns: {\n           fileName: \"\\\\.xml$\",        // Only XML files\n           fileContent: \"^<\\\\?xml\"     // Content starts with XML declaration\n       },\n       fileProcess: async (...) => {\n           // Process only XML files\n       }\n   }\n   \n   // ‚ö†Ô∏è TOO BROAD - processes all files\n   filePreImport: {\n       signaturePatterns: {\n           fileName: \".*\",      // Matches any filename\n           fileContent: \".*\"    // Matches any content\n       },\n       fileProcess: async (...) => {\n           // Processes ALL files - may not be desired\n       }\n   }\n   ```\n\n6. **Load configuration once per file operation**\n   ```typescript\n   // ‚úÖ CORRECT - loads configuration once, uses for entire file\n   fileProcess: async (\n        req: ProcessFileRequest,\n        content: FileImportExportContent,\n        client: Client,\n        context: CrowdinContextInfo,\n        projectId: number\n    ): Promise<StringsFileResponse> => {\n       const organizationId = context.jwtPayload.context.organization_id;\n       \n       // Load configuration once\n       const config = await getConfig(organizationId);\n       \n       // Early returns\n       if (!config.modules.postImport) {\n           return { strings: content as ProcessFileString[], notModified: true };\n       }\n       \n       // Use config for all strings\n       const strings = content as ProcessFileString[];\n       const modifiedStrings = strings.map(str => transformString(str, config.postImport.replaceRules));\n       \n       return { strings: modifiedStrings };\n   }\n   ```\n\n7. **Use notModified flag when no changes are made**\n   ```typescript\n   // ‚úÖ CORRECT - returns notModified when no processing needed\n   fileProcess: async (\n       req: ProcessFileRequest,\n       content: FileImportExportContent,\n       client: Client,\n       context: CrowdinContextInfo,\n       projectId: number\n   ): Promise<ContentFileResponse> => {\n       const organizationId = context.jwtPayload.context.organization_id;\n       const config = await getConfig(organizationId);\n       \n       // Check if content exists\n       if (!content) {\n           return { contentFile: Buffer.from(''), error: 'No content provided' };\n       }\n       \n       // Return notModified if module is disabled\n       if (!config.modules.preImport) {\n           return { contentFile: content as Buffer, notModified: true };\n       }\n       \n       // Return notModified if no rules configured\n       if (!config.preImport.replaceRules?.length) {\n           return { contentFile: content as Buffer, notModified: true };\n       }\n       \n       // Apply transformations only when needed\n       let contentString = (content as Buffer).toString('utf-8');\n       contentString = applyReplaceRules(contentString, config.preImport.replaceRules);\n       \n       return { contentFile: Buffer.from(contentString, 'utf-8') };\n   }\n   \n   // ‚ùå WRONG - always processes content even when no changes\n   fileProcess: async (\n       req: ProcessFileRequest,\n       content: FileImportExportContent,\n       client: Client,\n       context: CrowdinContextInfo,\n       projectId: number\n   ): Promise<ContentFileResponse> => {\n       const organizationId = context.jwtPayload.context.organization_id;\n       const config = await getConfig(organizationId);\n       \n       // BAD: Always converts to string and back to Buffer\n       let contentString = (content as Buffer).toString('utf-8');\n       \n       // BAD: Processes even when module is disabled or no rules\n       if (config.modules.preImport && config.preImport.replaceRules?.length) {\n           contentString = applyReplaceRules(contentString, config.preImport.replaceRules);\n       }\n       \n       // BAD: Unnecessary conversion, Crowdin re-processes unchanged content\n       return { contentFile: Buffer.from(contentString, 'utf-8') };\n   }\n   ```\n\n#### Complete Type Definitions\n\n**‚ö†Ô∏è CRITICAL**: Only use types from `@crowdin/app-project-module`.\n\n**Do NOT invent methods or properties that are not listed here.**\n\n##### out/types.d.ts\n\n```typescript\nexport interface CrowdinContextInfo {\n    jwtPayload: JwtPayload;\n    crowdinId: string;\n    clientId: string;\n    appIdentifier: string;\n}\n\ninterface JwtPayload {\n    aud: string;\n    sub: string;\n    domain?: string;\n    module?: string;\n    context: JwtPayloadContext;\n    iat: number;\n    exp: number;\n    code?: string;\n}\n\nexport interface JwtPayloadContext {\n    project_id: number;\n    project_identifier?: string;\n    organization_id: number;\n    organization_domain?: string;\n    user_id: number;\n    user_login?: string;\n}\n\nexport interface SignaturePatterns {\n    fileName?: string;\n    fileContent?: string;\n}\n\n// ... other types (CrowdinClientRequest, Environments, ModuleKey, UiModule, etc.)\n// See @crowdin/app-project-module/out/types.d.ts for complete type definitions\n```\n\n<!-- FILE_PROCESSING_TYPES_START -->\n##### out/modules/file-processing/types.d.ts\n\n```typescript\nimport Crowdin, { LanguagesModel, SourceStringsModel } from '@crowdin/crowdin-api-client';\nimport { CrowdinContextInfo, ModuleKey, SignaturePatterns } from '../../types';\nexport interface FileProcessLogic extends ModuleKey {\n    filesFolder?: string;\n    signaturePatterns?: SignaturePatterns;\n    storeFile?: (content: Buffer) => Promise<string>;\n}\nexport interface CustomFileFormatLogic extends FileProcessLogic {\n    type: string;\n    multilingual?: boolean;\n    autoUploadTranslations?: boolean;\n    stringsExport?: boolean;\n    extensions?: string[];\n    customSrxSupported?: boolean;\n    multilingualExport?: boolean;\n    parseFile?: (fileContent: Buffer, req: Omit<ProcessFileRequest, 'jobType' | 'file'>, client: Crowdin, context: CrowdinContextInfo, projectId: number) => Promise<ParseFileResponse>;\n    buildFile?: (fileContent: Buffer, req: Omit<ProcessFileRequest, 'jobType' | 'file'>, strings: ProcessFileString[], client: Crowdin, context: CrowdinContextInfo, projectId: number) => Promise<BuildFileResponse>;\n    exportStrings?: (req: Omit<ProcessFileRequest, 'jobType'>, strings: ProcessFileString[], client: Crowdin, context: CrowdinContextInfo, projectId: number) => Promise<BuildFileResponse>;\n}\nexport type FileImportExportLogic = FilePreImportLogic | FilePostImportLogic | FilePreExportLogic | FilePostExportLogic;\nexport type FileImportExportContent = ProcessFileString[] | Buffer | undefined;\nexport interface BaseFileProcessLogic<T> {\n    fileProcess: (req: ProcessFileRequest, content: FileImportExportContent, client: Crowdin, context: CrowdinContextInfo, projectId: number) => Promise<T>;\n}\nexport interface FilePreImportLogic extends FileProcessLogic, BaseFileProcessLogic<ContentFileResponse> {\n    processAssets?: boolean;\n}\nexport interface FilePostImportLogic extends FileProcessLogic, BaseFileProcessLogic<StringsFileResponse> {\n}\nexport interface FilePreExportLogic extends FileProcessLogic, BaseFileProcessLogic<StringsFileResponse> {\n}\nexport interface FilePostExportLogic extends FileProcessLogic, BaseFileProcessLogic<ContentFileResponse> {\n    processAssets?: boolean;\n}\nexport interface ProcessFileRequest {\n    jobType: ProcessFileJobType;\n    file: ProcessFileRecord;\n    sourceLanguage: LanguagesModel.Language;\n    targetLanguages: LanguagesModel.Language[];\n    strings: ProcessFileString[];\n    stringsUrl: string;\n    getRawContent?: (encoding: BufferEncoding) => Promise<string | Buffer>;\n}\nexport interface ProcessFileRecord {\n    content?: string;\n    contentUrl?: string;\n    path?: string;\n    id?: number;\n    name?: string;\n    type?: string;\n}\nexport declare enum ProcessFileJobType {\n    PARSE_FILE = \"parse-file\",\n    BUILD_FILE = \"build-file\",\n    PRE_IMPORT = \"pre-import-file\",\n    POST_IMPORT = \"post-import-file\",\n    PRE_EXPORT = \"pre-export-file\",\n    POST_EXPORT = \"post-export-file\"\n}\nexport interface ParseFileResponse {\n    previewFile?: Buffer;\n    strings?: ProcessFileString[];\n    error?: string;\n}\nexport interface BuildFileResponse {\n    contentFile: Buffer;\n    error?: string;\n    fileName?: string;\n    fileType?: string;\n}\nexport interface StringsFileResponse extends ParseFileResponse {\n    notModified?: boolean;\n}\nexport interface ContentFileResponse extends BuildFileResponse {\n    notModified?: boolean;\n}\nexport interface ProcessFileString {\n    previewId?: number;\n    id: number;\n    identifier: string;\n    context?: string;\n    customData?: string;\n    maxLength?: number;\n    isHidden?: boolean;\n    hasPlurals?: boolean;\n    labels?: string[];\n    text: string | SourceStringsModel.PluralText;\n    translations?: StringTranslations;\n    uniqId?: string;\n}\nexport interface StringTranslations {\n    [language: string]: {\n        text: string | SourceStringsModel.PluralText;\n    };\n}\n```\n<!-- FILE_PROCESSING_TYPES_END -->\n\n### Profile Resources Menu Module Configuration\n\n**‚ö†Ô∏è IMPORTANT**: This module is **REQUIRED** and cannot be removed from the application. The Profile Resources Menu provides essential functionality for user profile integration.\n\nConfigure the Profile Resources Menu module in `worker/app.ts`:\n\n```typescript\nconst configuration: ClientConfig = {\n    // ... other configuration ...\n\n    profileResourcesMenu: {\n      fileName: 'index.html',\n      uiPath: '/'\n    }\n}\n```\n\n**Note**: While you can customize the UI and functionality, you must not remove this module configuration from your app.\n\n### Organization Menu Module Configuration\n\n**‚ö†Ô∏è IMPORTANT**: This module is **REQUIRED** and cannot be removed from the application. The Organization Menu provides essential functionality for organization-level navigation and settings.\n\nConfigure the Organization Menu module in `worker/app.ts`:\n\n```typescript\nconst configuration: ClientConfig = {\n    // ... other configuration ...\n\n    organizationMenu: {\n      fileName: 'index.html',\n      uiPath: '/'\n    }\n}\n```\n\n**Note**: While you can customize the UI and functionality, you must not remove this module configuration from your app.\n\n### API Endpoints Best Practices\n\n#### Common Examples\n\n**Standard Endpoint:**\n```typescript\napp.post('/api/process-data', async (req: Request, res: Response) => {\n    try {\n        const jwt = req.query.jwt as string;\n        const { data } = req.body;\n        \n        if (!jwt) {\n            return res.status(400).json({ success: false, error: 'JWT token is required' });\n        }\n        if (!data) {\n            return res.status(400).json({ success: false, error: 'Data is required' });\n        }\n\n        const connection = await crowdinApp.establishCrowdinConnection(jwt, undefined);\n        \n        // Your async logic here\n        const result = await processData(data);\n        \n        res.json({ \n            success: true, \n            result\n        });\n    } catch (error) {\n        console.error('Error:', error);\n        res.status(500).json({ success: false, error: 'Operation failed' });\n    }\n});\n```\n\n#### Best Practices\n\n1. **Always await async operations**\n   ```typescript\n   // ‚úÖ CORRECT - all operations are awaited\n   app.post('/api/save-config', async (req: Request, res: Response) => {\n       const jwt = req.query.jwt as string;\n       const connection = await crowdinApp.establishCrowdinConnection(jwt, undefined);\n       \n       await crowdinApp.saveMetadata(key, data, connection.context.crowdinId);\n       \n       res.json({ success: true });\n   });\n   \n   // ‚ùå WRONG - missing await, operation will NOT complete\n   app.post('/api/save-config', async (req: Request, res: Response) => {\n       const jwt = req.query.jwt as string;\n       const connection = await crowdinApp.establishCrowdinConnection(jwt, undefined);\n       \n       // This will NOT save! Response is sent before operation completes\n       crowdinApp.saveMetadata(key, data, connection.context.crowdinId);\n       \n       res.json({ success: true });\n   });\n   ```\n\n2. **Always return response after all operations complete**\n   ```typescript\n   // ‚úÖ CORRECT - response sent after all operations\n   app.post('/api/update', async (req: Request, res: Response) => {\n       const connection = await crowdinApp.establishCrowdinConnection(jwt, undefined);\n       \n       await operation1();\n       await operation2();\n       await operation3();\n       \n       res.json({ success: true }); // All operations completed\n   });\n   \n   // ‚ùå WRONG - response sent too early\n   app.post('/api/update', async (req: Request, res: Response) => {\n       const connection = await crowdinApp.establishCrowdinConnection(jwt, undefined);\n       \n       res.json({ success: true }); // Sent immediately\n       \n       await operation1(); // These will NOT execute\n       await operation2();\n       await operation3();\n   });\n   ```\n\n3. **Use Promise.all for independent parallel operations**\n   ```typescript\n   // ‚úÖ CORRECT - parallel operations (faster)\n   const [result1, result2, result3] = await Promise.all([\n       connection.client.projectsGroupsApi.getProject(id1),\n       connection.client.projectsGroupsApi.getProject(id2),\n       connection.client.projectsGroupsApi.getProject(id3)\n   ]);\n   \n   // ‚ùå WRONG - sequential operations (slower)\n   const result1 = await connection.client.projectsGroupsApi.getProject(id1);\n   const result2 = await connection.client.projectsGroupsApi.getProject(id2);\n   const result3 = await connection.client.projectsGroupsApi.getProject(id3);\n   ```\n\n4. **Wrap all async code in try-catch**\n   ```typescript\n   // ‚úÖ CORRECT - comprehensive error handling\n   app.get('/api/data', async (req: Request, res: Response) => {\n       try {\n           const connection = await crowdinApp.establishCrowdinConnection(jwt, undefined);\n           const data = await fetchData();\n           res.json({ success: true, data });\n       } catch (error) {\n           console.error('Error:', error);\n           res.status(500).json({ success: false, error: 'Operation failed' });\n       }\n   });\n   \n   // ‚ùå WRONG - no error handling\n   app.get('/api/data', async (req: Request, res: Response) => {\n       const connection = await crowdinApp.establishCrowdinConnection(jwt, undefined);\n       const data = await fetchData(); // May throw unhandled error\n       res.json({ success: true, data });\n   });\n   ```\n\n5. **Never use setTimeout without proper promise wrapper**\n   ```typescript\n   // ‚úÖ CORRECT - setTimeout with promise wrapper\n   app.get('/api/delayed', async (req: Request, res: Response) => {\n       await new Promise((resolve) => {\n           setTimeout(async () => {\n               await saveData();\n               resolve(undefined);\n           }, 1000);\n       });\n       \n       res.json({ success: true });\n   });\n   \n   // ‚ùå WRONG - setTimeout without await (will NOT execute)\n   app.get('/api/delayed', async (req: Request, res: Response) => {\n       setTimeout(async () => {\n           await saveData(); // This will NOT execute\n       }, 1000);\n       \n       res.json({ success: true }); // Sent immediately\n   });\n   ```\n\n6. **Always check for required parameters early**\n   ```typescript\n   // ‚úÖ CORRECT - validate parameters first\n   app.post('/api/process', async (req: Request, res: Response) => {\n       const jwt = req.query.jwt as string;\n       const { projectId, data } = req.body;\n       \n       // Validate early\n       if (!jwt) {\n           return res.status(400).json({ error: 'JWT token is required' });\n       }\n       if (!projectId) {\n           return res.status(400).json({ error: 'Project ID is required' });\n       }\n       if (!data) {\n           return res.status(400).json({ error: 'Data is required' });\n       }\n       \n       // Continue with processing\n       const connection = await crowdinApp.establishCrowdinConnection(jwt, undefined);\n       // ... rest of the logic\n   });\n   ```\n\n### Crowdin API Client\n\n#### Official Documentation\n\nThe `connection.client` object is an instance of `@crowdin/crowdin-api-client`.\n\n**üìö Complete API Reference:** https://crowdin.github.io/crowdin-api-client-js/modules.html\n\n**‚ö†Ô∏è CRITICAL**: Only use methods documented in the official API reference. Do NOT invent or assume methods exist.\n\n#### Common Examples\n\n**Standard Endpoint Template:**\n```typescript\napp.get('/api/your-endpoint', async (req: Request, res: Response) => {\n    try {\n        const jwt = req.query.jwt as string;\n        if (!jwt) {\n            return res.status(400).json({ success: false, error: 'JWT token is required' });\n        }\n\n        if (!crowdinApp.establishCrowdinConnection) {\n            return res.status(500).json({ success: false, error: 'Crowdin connection method not available' });\n        }\n\n        const connection = await crowdinApp.establishCrowdinConnection(jwt, undefined);\n\n        if (!connection.client) {\n            return res.status(500).json({ success: false, error: 'Crowdin API client not available' });\n        }\n\n        const userId = connection.context.jwtPayload.context.user_id;\n        const organizationId = connection.context.jwtPayload.context.organization_id;\n\n        // Your logic here using connection.client API\n        \n        res.status(200).json({ success: true, data: result });\n    } catch (error) {\n        console.error('Error:', error);\n        res.status(500).json({ success: false, error: 'Operation failed' });\n    }\n});\n```\n\n**Get Project Details:**\n```typescript\nconst response = await connection.client.projectsGroupsApi.getProject(projectId);\n\n// Access project properties\nconst project = response.data;\nconst projectName = project.name;                    // string\nconst sourceLanguageId = project.sourceLanguageId;   // string\nconst targetLanguageIds = project.targetLanguageIds; // string[]\nconst description = project.description;             // string | null\n```\n\n**List All Projects (with pagination):**\n```typescript\nconst response = await connection.client.projectsGroupsApi.withFetchAll().listProjects();\n\n// Iterate through all projects\nresponse.data.forEach((projectItem: ResponseObject<ProjectsGroupsModel.Project>) => {\n  const projectId = projectItem.data.id;\n  const projectName = projectItem.data.name;\n  const groupId = projectItem.data.groupId; // number | null\n});\n```\n\n**Get Supported Languages:**\n```typescript\nconst response = await connection.client.languagesApi.withFetchAll().listSupportedLanguages();\n\n// Filter languages\nconst targetLanguageIds = ['uk', 'pl', 'de'];\nconst projectLanguages = response.data.filter(\n  (lang: ResponseObject<LanguagesModel.Language>) => targetLanguageIds.includes(lang.data.id)\n);\n\n// Map to simpler structure\nconst languages = projectLanguages.map((lang: ResponseObject<LanguagesModel.Language>) => ({\n  id: lang.data.id,           // string: \"uk\"\n  name: lang.data.name,       // string: \"Ukrainian\"\n  locale: lang.data.locale,   // string: \"uk-UA\"\n  osxLocale: lang.data.osxLocale // string\n}));\n```\n\n**List Source Files:**\n```typescript\nconst response = await connection.client.sourceFilesApi.withFetchAll().listProjectFiles(projectId);\n\nresponse.data.forEach((fileItem: ResponseObject<SourceFilesModel.File>) => {\n  const file = fileItem.data;\n  const fileId = file.id;             // number\n  const fileName = file.name;         // string\n  const branchId = file.branchId;     // number | null\n  const directoryId = file.directoryId; // number | null\n});\n```\n\n#### Best Practices\n\n1. **Always access data via `.data` property**\n   ```typescript\n   // ‚úÖ CORRECT\n   const project = response.data;\n   const projectName = response.data.name;\n   \n   // ‚ùå WRONG - will be undefined\n   const projectName = response.name;\n   ```\n\n2. **Use withFetchAll() for complete data**\n   ```typescript\n   // ‚úÖ CORRECT - gets all items\n   const response = await connection.client.languagesApi.withFetchAll().listSupportedLanguages();\n   \n   // ‚ö†Ô∏è PARTIAL - only first page (25 items)\n   const response = await connection.client.languagesApi.listSupportedLanguages();\n   ```\n\n3. **Handle nullable properties**\n   ```typescript\n   const description = response.data.description || 'No description';\n   const groupId = response.data.groupId ?? null;\n   ```\n\n4. **Handle errors properly**\n   ```typescript\n   try {\n     const response = await connection.client.projectsGroupsApi.getProject(projectId);\n     const project = response.data;\n     // Use project data\n   } catch (error: any) {\n     console.error('Crowdin API Error:', error);\n\n     // API errors have specific structure\n     if (error.code === 404) {\n       return res.status(404).json({ error: 'Project not found' });\n     }\n     \n     return res.status(500).json({\n       error: 'API request failed',\n       details: error.message\n     });\n   }\n   ```\n\n5. **Use TypeScript types**\n   ```typescript\n   import type { ResponseObject, ProjectsGroupsModel } from '@crowdin/crowdin-api-client';\n   \n   // Use in your code\n   const response: ResponseObject<ProjectsGroupsModel.Project> = await connection.client.projectsGroupsApi.getProject(projectId);\n   const project: ProjectsGroupsModel.Project = response.data;\n   ```\n\n6. **Always sort data explicitly when order matters**\n   ```typescript\n   // ‚úÖ CORRECT - sort projects by creation date (newest first)\n   const response = await connection.client.projectsGroupsApi.withFetchAll().listProjects();\n   const sortedByDate = response.data.sort(\n     (a: ResponseObject<ProjectsGroupsModel.Project>, b: ResponseObject<ProjectsGroupsModel.Project>) => {\n       const dateA = new Date(a.data.createdAt).getTime();\n       const dateB = new Date(b.data.createdAt).getTime();\n       return dateB - dateA; // Descending order (newest first)\n     }\n   );\n   \n   // ‚ùå WRONG - assuming data is already sorted by date\n   const response = await connection.client.projectsGroupsApi.withFetchAll().listProjects();\n   // Directly using response.data without sorting - order is not guaranteed!\n   ```\n\n7. **Never use CroQL - fetch all data and filter manually**\n   ```typescript\n   // ‚úÖ CORRECT - fetch all strings and filter manually\n   const allStrings = await connection.client.sourceStringsApi.withFetchAll().listProjectStrings(projectId);\n   \n   // Filter for specific criteria\n   const filteredStrings = allStrings.data.filter(\n     (item: ResponseObject<SourceStringsModel.String>) => {\n       const str = item.data;\n       return str.text.includes('welcome') && !str.isHidden;\n     }\n   );\n   \n   // ‚ùå WRONG - using CroQL queries\n   const response = await connection.client.sourceStringsApi.listProjectStrings(projectId, {\n     croql: 'text contains \"welcome\" AND isHidden = false'\n   });\n   // CroQL should be avoided - fetch all data and filter in your code instead\n   ```\n\n#### Complete Type Definitions\n\n**‚ö†Ô∏è CRITICAL**: Only use methods and types from `@crowdin/crowdin-api-client` definitions below.\n\n**Do NOT invent methods or properties that are not listed here.**\n\n<!-- CROWDIN_API_CLIENT_TYPES_START -->\n\n##### ai/index.d.ts\n\n```typescript\nimport { CrowdinApi, DownloadLink, PaginationOptions, PatchRequest, PlainObject, ResponseList, ResponseObject, Status } from '../core';\nexport declare class Ai extends CrowdinApi {\n    listAiOrganizationCustomPlaceholders(options?: PaginationOptions): Promise<ResponseList<AiModel.CustomPlaceholder>>;\n    addAiOrganizationCustomPlaceholder(request: AiModel.AddCustomPlaceholderRequest): Promise<ResponseObject<AiModel.CustomPlaceholder>>;\n    getAiOrganizationCustomPlaceholder(aiCustomPlaceholderId: number): Promise<ResponseObject<AiModel.CustomPlaceholder>>;\n    deleteAiOrganizationCustomPlaceholder(aiCustomPlaceholderId: number): Promise<void>;\n    editAiOrganizationCustomPlaceholder(aiCustomPlaceholderId: number, request: PatchRequest[]): Promise<ResponseObject<AiModel.CustomPlaceholder>>;\n    generateAiOrganizationPromptFineTuningDataset(aiPromptId: number, request: AiModel.GenerateFineTuningDataset): Promise<ResponseObject<Status<AiModel.FineTuningDataset>>>;\n    getAiOrganizationPromptFineTuningDatasetStatus(aiPromptId: number, jobIdentifier: string): Promise<ResponseObject<Status<AiModel.FineTuningDataset>>>;\n    listAiOrganizationPromptFineTuningEvents(aiPromptId: number, jobIdentifier: string, options?: PaginationOptions): Promise<ResponseList<AiModel.PromptFineTuningEvent>>;\n    listAiOrganizationPromptFineTuningJobs(options?: AiModel.ListPromptFineTuningJobsOptions): Promise<ResponseList<Status<AiModel.FineTuningJob>>>;\n    createAiOrganizationPromptFineTuningJob(aiPromptId: number, request: AiModel.GenerateFineTuningJob): Promise<ResponseObject<Status<AiModel.FineTuningJob>>>;\n    getAiOrganizationPromptFineTuningJobStatus(aiPromptId: number, jobIdentifier: string): Promise<ResponseObject<Status<AiModel.FineTuningJob>>>;\n    downloadAiOrganizationPromptFineTuningDataset(aiPromptId: number, jobIdentifier: string): Promise<ResponseObject<DownloadLink>>;\n    cloneAiOrganizationPrompt(aiPromptId: number, request?: {\n        name?: string;\n    }): Promise<ResponseObject<AiModel.AiPromptResponse>>;\n    listAiOrganizationPrompts(options?: AiModel.ListAiPromptsOptions): Promise<ResponseList<AiModel.AiPromptResponse>>;\n    addAiOrganizationPrompt(request: AiModel.AddAiPromptRequest): Promise<ResponseObject<AiModel.AiPromptResponse>>;\n    generateAiOrganizationPromptCompletion(aiPromptId: number, request: AiModel.GenerateAiPromptCompletionRequest): Promise<ResponseObject<Status<AiModel.AiPromptCompletionAttribute>>>;\n    getAiOrganizationPromptCompletionStatus(aiPromptId: number, completionId: string): Promise<ResponseObject<Status<AiModel.AiPromptCompletionAttribute>>>;\n    cancelAiOrganizationPromptCompletion(aiPromptId: number, completionId: string): Promise<void>;\n    downloadAiOrganizationPromptCompletion(aiPromptId: number, completionId: string): Promise<ResponseObject<DownloadLink>>;\n    getAiOrganizationPrompt(aiPromptId: number): Promise<ResponseObject<AiModel.AiPromptResponse>>;\n    deleteAiOrganizationPrompt(aiPromptId: number): Promise<void>;\n    editAiOrganizationPrompt(aiPromptId: number, request: PatchRequest[]): Promise<ResponseObject<AiModel.AiPromptResponse>>;\n    listAiOrganizationProviders(options?: PaginationOptions): Promise<ResponseList<AiModel.AiProviderResponse>>;\n    addAiOrganizationProvider(request: AiModel.AddAiProviderRequest): Promise<ResponseObject<AiModel.AiProviderResponse>>;\n    getAiOrganizationProvider(aiProviderId: number): Promise<ResponseObject<AiModel.AiProviderResponse>>;\n    deleteAiOrganizationProvider(aiProviderId: number): Promise<void>;\n    editAiOrganizationProvider(aiProviderId: number, request: PatchRequest[]): Promise<ResponseObject<AiModel.AiProviderResponse>>;\n    listAiOrganizationProviderModels(aiProviderId: number, options?: PaginationOptions): Promise<ResponseList<AiModel.AiProviderModelResponse>>;\n    listAiOrganizationAllProviderModels(options?: PaginationOptions): Promise<ResponseList<AiModel.AiProviderModelResponse>>;\n    createAiOrganizationProxyChatCompletion(aiProviderId: number, request?: AiModel.OtherChatCompletionRequest | AiModel.GoogleGeminiChatCompletionRequest): Promise<ResponseObject<AiModel.AiProviderProxyResponseData>>;\n    generateAiOrganizationReport(request: AiModel.AiReport): Promise<ResponseObject<Status<AiModel.AiReport>>>;\n    checkAiOrganizationReportStatus(aiReportId: string): Promise<ResponseObject<Status<AiModel.AiReport>>>;\n    downloadAiOrganizationReport(aiReportId: string): Promise<ResponseObject<DownloadLink>>;\n    getAiOrganizationSettings(): Promise<ResponseObject<AiModel.AiSettings>>;\n    editAiOrganizationSettings(request: PatchRequest[]): Promise<ResponseObject<AiModel.AiSettings>>;\n    listAiUserCustomPlaceholders(userId: number, options?: PaginationOptions): Promise<ResponseList<AiModel.CustomPlaceholder>>;\n    addAiUserCustomPlaceholder(userId: number, request: AiModel.AddCustomPlaceholderRequest): Promise<ResponseObject<AiModel.CustomPlaceholder>>;\n    getAiUserCustomPlaceholder(userId: number, aiCustomPlaceholderId: number): Promise<ResponseObject<AiModel.CustomPlaceholder>>;\n    deleteAiUserCustomPlaceholder(userId: number, aiCustomPlaceholderId: number): Promise<void>;\n    editAiUserCustomPlaceholder(userId: number, aiCustomPlaceholderId: number, request: PatchRequest[]): Promise<ResponseObject<AiModel.CustomPlaceholder>>;\n    generateAiUserPromptFineTuningDataset(userId: number, aiPromptId: number, request: AiModel.GenerateFineTuningDataset): Promise<ResponseObject<Status<AiModel.FineTuningDataset>>>;\n    getAiUserPromptFineTuningDatasetStatus(userId: number, aiPromptId: number, jobIdentifier: string): Promise<ResponseObject<Status<AiModel.FineTuningDataset>>>;\n    listAiUserPromptFineTuningEvents(userId: number, aiPromptId: number, jobIdentifier: string, options?: PaginationOptions): Promise<ResponseList<AiModel.PromptFineTuningEvent>>;\n    listAiUserPromptFineTuningJobs(userId: number, options?: AiModel.ListPromptFineTuningJobsOptions): Promise<ResponseList<Status<AiModel.FineTuningJob>>>;\n    createAiUserPromptFineTuningJob(userId: number, aiPromptId: number, request: AiModel.GenerateFineTuningJob): Promise<ResponseObject<Status<AiModel.FineTuningJob>>>;\n    getAiUserPromptFineTuningJobStatus(userId: number, aiPromptId: number, jobIdentifier: string): Promise<ResponseObject<Status<AiModel.FineTuningJob>>>;\n    downloadAiUserPromptFineTuningDataset(userId: number, aiPromptId: number, jobIdentifier: string): Promise<ResponseObject<DownloadLink>>;\n    cloneAiUserPrompt(userId: number, aiPromptId: number, request?: {\n        name?: string;\n    }): Promise<ResponseObject<AiModel.AiPromptResponse>>;\n    listAiUserPrompts(userId: number, options?: AiModel.ListAiPromptsOptions): Promise<ResponseList<AiModel.AiPromptResponse>>;\n    addAiUserPrompt(userId: number, request: AiModel.AddAiPromptRequest): Promise<ResponseObject<AiModel.AiPromptResponse>>;\n    generateAiUserPromptCompletion(userId: number, aiPromptId: number, request: AiModel.GenerateAiPromptCompletionRequest): Promise<ResponseObject<Status<AiModel.AiPromptCompletionAttribute>>>;\n    getAiUserPromptCompletionStatus(userId: number, aiPromptId: number, completionId: string): Promise<ResponseObject<Status<AiModel.AiPromptCompletionAttribute>>>;\n    cancelAiUserPromptCompletion(userId: number, aiPromptId: number, completionId: string): Promise<void>;\n    downloadAiUserPromptCompletion(userId: number, aiPromptId: number, completionId: string): Promise<ResponseObject<DownloadLink>>;\n    getAiUserPrompt(userId: number, aiPromptId: number): Promise<ResponseObject<AiModel.AiPromptResponse>>;\n    deleteAiUserPrompt(userId: number, aiPromptId: number): Promise<void>;\n    editAiUserPrompt(userId: number, aiPromptId: number, request: PatchRequest[]): Promise<ResponseObject<AiModel.AiPromptResponse>>;\n    listAiUserProviders(userId: number, options?: PaginationOptions): Promise<ResponseList<AiModel.AiProviderResponse>>;\n    addAiUserProvider(userId: number, request: AiModel.AddAiProviderRequest): Promise<ResponseObject<AiModel.AiProviderResponse>>;\n    getAiUserProvider(userId: number, aiProviderId: number): Promise<ResponseObject<AiModel.AiProviderResponse>>;\n    deleteAiUserProvider(userId: number, aiProviderId: number): Promise<void>;\n    editAiUserProvider(userId: number, aiProviderId: number, request: PatchRequest[]): Promise<ResponseObject<AiModel.AiProviderResponse>>;\n    listAiUserProviderModels(userId: number, aiProviderId: number, options?: PaginationOptions): Promise<ResponseList<AiModel.AiProviderModelResponse>>;\n    listAiUserAllProviderModels(userId: number, options?: PaginationOptions): Promise<ResponseList<AiModel.AiProviderModelResponse>>;\n    createAiUserProxyChatCompletion(userId: number, aiProviderId: number, request?: AiModel.OtherChatCompletionRequest | AiModel.GoogleGeminiChatCompletionRequest): Promise<ResponseObject<AiModel.AiProviderProxyResponseData>>;\n    generateAiUserReport(userId: number, request: AiModel.AiReport): Promise<ResponseObject<Status<AiModel.AiReport>>>;\n    checkAiUserReportStatus(userId: number, aiReportId: string): Promise<ResponseObject<Status<AiModel.AiReport>>>;\n    downloadAiUserReport(userId: number, aiReportId: string): Promise<ResponseObject<DownloadLink>>;\n    getAiUsertSettings(userId: number): Promise<ResponseObject<AiModel.AiSettings>>;\n    editAiUserSettings(userId: number, request: PatchRequest[]): Promise<ResponseObject<AiModel.AiSettings>>;\n}\nexport declare namespace AiModel {\n    interface CustomPlaceholder {\n        id: number;\n        description: string;\n        placeholder: string;\n        value: string;\n        createdAt: string;\n        updatedAt: string;\n    }\n    interface AddCustomPlaceholderRequest {\n        description: string;\n        placeholder: string;\n        value: string;\n    }\n    interface FineTuningDataset {\n        projectIds: number[];\n        tmIds: number[];\n        purpose: 'training' | 'validation';\n        dateFrom: string;\n        dateTo: string;\n        maxFileSize: number;\n        minExamplesCount: number;\n        maxExamplesCount: number;\n    }\n    interface GenerateFineTuningDataset {\n        projectIds?: number[];\n        tmIds?: number[];\n        purpose?: 'training' | 'validation';\n        dateFrom?: string;\n        dateTo?: string;\n        maxFileSize?: number;\n        minExamplesCount?: number;\n        maxExamplesCount?: number;\n    }\n    interface GenerateFineTuningJob {\n        dryRun?: boolean;\n        hyperparameters?: {\n            batchSize: number;\n            learningRateMultiplier: number;\n            nEpochs: number;\n        };\n        trainingOptions: Omit<GenerateFineTuningDataset, 'purpose'>;\n        validationOptions?: Omit<GenerateFineTuningDataset, 'purpose'>;\n    }\n    interface FineTuningJob {\n        dryRun: boolean;\n        aiPromptId: number;\n        hyperparameters: {\n            batchSize: number;\n            learningRateMultiplier: number;\n            nEpochs: number;\n        };\n        trainingOptions: Omit<GenerateFineTuningDataset, 'purpose'>;\n        validationOptions: Omit<GenerateFineTuningDataset, 'purpose'>;\n        baseModel: string;\n        fineTunedModel: string;\n        trainedTokensCount: number;\n        trainingDatasetUrl: string;\n        validationDatasetUrl: string;\n        metadata: PlainObject;\n    }\n    interface PromptFineTuningEvent {\n        id: string;\n        type: string;\n        message: string;\n        data: {\n            step: number;\n            totalSteps: number;\n            trainingLoss: number;\n            validationLoss: number;\n            fullValidationLoss: number;\n        };\n        createdAt: string;\n    }\n    interface ListPromptFineTuningJobsOptions extends PaginationOptions {\n        statuses: string;\n        orderBy: string;\n    }\n    interface ListAiPromptsOptions extends PaginationOptions {\n        projectId?: number;\n        action?: Action;\n    }\n    interface AiPromptResponse {\n        id: number;\n        name: string;\n        action: Action;\n        aiProviderId: number;\n        aiModelId: string;\n        isEnabled: boolean;\n        enabledProjectIds: number[];\n        config: AiModel.AiPromptConfigBasicPreTranslate | AiModel.AiPromptConfigBasicAssistAction | AiModel.AiPromptConfigBasicAligmentAction | AiModel.AiPromptConfigAdvanced | AiModel.AiPromptConfigExternal;\n        promptPreview: string;\n        isFineTuningAvailable: boolean;\n        createdAt: string;\n        updatedAt: string;\n    }\n    interface AiPromptConfigBasicOtherLanguageTranslations {\n        isEnabled?: boolean;\n        languageIds?: string[];\n    }\n    interface AiPromptConfigBasicPreTranslate {\n        mode: 'basic';\n        companyDescription?: string;\n        projectDescription?: string;\n        audienceDescription?: string;\n        customPlaceholders?: string[];\n        otherLanguageTranslations?: AiModel.AiPromptConfigBasicOtherLanguageTranslations;\n        glossaryTerms?: boolean;\n        tmSuggestions?: boolean;\n        fileContent?: boolean;\n        fileContext?: boolean;\n        screenshots?: boolean;\n        publicProjectDescription?: boolean;\n        siblingsStrings?: boolean;\n    }\n    interface AiPromptConfigBasicAssistAction {\n        mode: 'basic';\n        companyDescription?: string;\n        projectDescription?: string;\n        audienceDescription?: string;\n        otherLanguageTranslations?: AiModel.AiPromptConfigBasicOtherLanguageTranslations;\n        glossaryTerms?: boolean;\n        tmSuggestions?: boolean;\n        fileContext?: boolean;\n        screenshots?: boolean;\n        publicProjectDescription?: boolean;\n        siblingsStrings?: boolean;\n        filteredStrings?: boolean;\n    }\n    interface AiPromptConfigBasicAligmentAction {\n        mode: 'basic';\n        customPlaceholders?: string[];\n        publicProjectDescription?: boolean;\n    }\n    interface AiPromptConfigAdvanced {\n        mode: 'advanced';\n        screenshots?: boolean;\n        prompt: string;\n        otherLanguageTranslations?: AiModel.AiPromptConfigBasicOtherLanguageTranslations;\n    }\n    interface AiPromptConfigExternal {\n        mode: 'external';\n        identifier: string;\n        key: string;\n        options?: any;\n    }\n    interface AddAiPromptRequest {\n        name: string;\n        action: Action;\n        aiProviderId?: number;\n        aiModelId?: string;\n        isEnabled?: boolean;\n        enabledProjectIds?: number[];\n        config: AiModel.AiPromptConfigBasicPreTranslate | AiModel.AiPromptConfigBasicAssistAction | AiModel.AiPromptConfigBasicAligmentAction | AiModel.AiPromptConfigAdvanced | AiPromptConfigExternal;\n    }\n    interface GenerateAiPromptCompletionRequest {\n        resources: AiModel.AiPromptResourceWithPreTranslate | AiModel.AiPromptResourceWithAssist | AiModel.AiPromptResourceWithAlignment | AiModel.AiPromptResourceWithCustom;\n        tools?: {\n            tool: {\n                type: 'function';\n                function: {\n                    description?: string;\n                    name: string;\n                    parameters?: PlainObject;\n                };\n            };\n        }[];\n        tool_choice?: string | PlainObject;\n    }\n    interface AiPromptCompletionAttribute {\n        aiPromptId: number;\n    }\n    interface AiPromptResourceWithPreTranslate {\n        projectId: number;\n        sourceLanguageId?: string;\n        targetLanguageId?: string;\n        stringIds?: number[];\n        overridePromptValues?: OverridePromptValues;\n    }\n    interface AiPromptResourceWithAlignment {\n        projectId: number;\n        sourceLanguageId?: string;\n        targetLanguageId?: string;\n        stringIds?: number[];\n        overridePromptValues?: OverridePromptValues;\n    }\n    interface AiPromptResourceWithAssist {\n        projectId: number;\n        sourceLanguageId?: string;\n        targetLanguageId?: string;\n        stringIds?: number[];\n        filteredStringsIds?: number[];\n        overridePromptValues?: OverridePromptValues;\n    }\n    interface AiPromptResourceWithCustom {\n        projectId: number;\n        sourceLanguageId?: string;\n        targetLanguageId?: string;\n        stringIds?: number[];\n        overridePromptValues?: OverridePromptValues;\n        customInstruction?: string;\n    }\n    interface OverridePromptValues {\n        [key: string]: any;\n    }\n    interface AiProviderResponse {\n        id: number;\n        name: string;\n        type: ProviderType;\n        credentials: AiModel.AiProviderCredentialsBasic | AiModel.AiProviderCredentialsAzureOpenAi | AiProviderCredentialsGoogleGemini | AiProviderCredentialsCustom;\n        config: AiModel.AiProviderConfig;\n        isEnabled: boolean;\n        useSystemCredentials: boolean;\n        createdAt: string;\n        updatedAt: string;\n        promptsCount: string;\n    }\n    interface AiProviderCredentialsBasic {\n        apiKey: string;\n    }\n    interface AiProviderCredentialsAzureOpenAi extends AiProviderCredentialsBasic {\n        resourceName: string;\n        deploymentName: string;\n        apiVersion: string;\n    }\n    interface AiProviderCredentialsGoogleGemini {\n        project: string;\n        region: string;\n        serviceAccountKey: string;\n    }\n    interface AiProviderCredentialsWatsonx {\n        apiKey: string;\n        projectId: string;\n        region: string;\n    }\n    interface AiProviderCredentialsCustom {\n        identifier: string;\n        key: string;\n    }\n    interface AiProviderConfig {\n        actionRules?: AiModel.AiProviderConfigActionRule[];\n    }\n    interface AiProviderConfigActionRule {\n        action?: 'pre_translate' | 'assist';\n        availableAiModelIds?: string[];\n    }\n    interface AddAiProviderRequest {\n        name: string;\n        type: ProviderType;\n        credentials?: AiModel.AiProviderCredentialsBasic | AiModel.AiProviderCredentialsAzureOpenAi | AiProviderCredentialsGoogleGemini | AiProviderCredentialsWatsonx | AiProviderCredentialsCustom;\n        config?: AiModel.AiProviderConfig;\n        isEnabled?: boolean;\n        useSystemCredentials?: boolean;\n    }\n    interface AiProviderModelResponse {\n        id: string;\n    }\n    interface AiProviderProxyResponseData {\n        data: object;\n    }\n    interface OtherChatCompletionRequest {\n        stream?: boolean;\n        [key: string]: any;\n    }\n    interface GoogleGeminiChatCompletionRequest extends OtherChatCompletionRequest {\n        model: string;\n    }\n    type AiReport = AiReportTokenUsage;\n    interface AiReportTokenUsage {\n        type: 'tokens-usage-raw-data';\n        schema: AiReportGeneralSchema;\n    }\n    interface AiReportGeneralSchema {\n        dateFrom: string;\n        dateTo: string;\n        format?: 'json' | 'csv';\n        projectIds?: number[];\n        promptIds?: number[];\n        userIds?: number[];\n    }\n    interface AiSettings {\n        assistActionAiPromptId: number;\n        showSuggestion: boolean;\n        shortcuts: {\n            name: string;\n            prompt: string;\n            enabled: boolean;\n        }[];\n    }\n    type Action = 'pre_translate' | 'assist';\n    type ProviderType = 'open_ai' | 'azure_open_ai' | 'google_gemini' | 'mistral_ai' | 'anthropic' | 'custom_ai' | 'x_ai' | 'deepseek' | 'watsonx';\n}\n```\n\n##### applications/index.d.ts\n\n```typescript\nimport { CrowdinApi, ResponseObject, PatchRequest, Pagination, ResponseList } from '../core';\nexport declare class Applications extends CrowdinApi {\n    listApplicationInstallations(options?: Pagination): Promise<ResponseList<ApplicationsModel.Application>>;\n    installApplication(request: ApplicationsModel.InstallApplication): Promise<ResponseObject<ApplicationsModel.Application>>;\n    getApplicationInstallation(applicationId: string): Promise<ResponseObject<ApplicationsModel.Application>>;\n    deleteApplicationInstallation(applicationId: string, force?: boolean): Promise<ResponseObject<ApplicationsModel.Application>>;\n    editApplicationInstallation(applicationId: string, request: PatchRequest[]): Promise<ResponseObject<ApplicationsModel.Application>>;\n    getApplicationData(applicationId: string, path: string): Promise<ResponseObject<any>>;\n    updateOrRestoreApplicationData(applicationId: string, path: string, request: any): Promise<ResponseObject<any>>;\n    addApplicationData(applicationId: string, path: string, request: any): Promise<ResponseObject<any>>;\n    deleteApplicationData(applicationId: string, path: string): Promise<void>;\n    editApplicationData(applicationId: string, path: string, request: any): Promise<ResponseObject<any>>;\n}\nexport declare namespace ApplicationsModel {\n    interface Application {\n        identifier: string;\n        name: string;\n        description: string;\n        logo: string;\n        baseUrl: string;\n        manifestUrl: string;\n        createdAt: string;\n        modules: ApplicationModule[];\n        scopes: string[];\n        permissions: ApplicationPermissions;\n        defaultPermissions: any;\n        limitReached: boolean;\n    }\n    interface InstallApplication {\n        url: string;\n        permissions?: ApplicationPermissions;\n        modules?: ApplicationModule[];\n    }\n    interface ApplicationPermissions {\n        user: {\n            value: 'all' | 'owner' | 'managers' | 'guests' | 'restricted';\n            ids: number[];\n        };\n        project: {\n            value: 'own' | 'restricted';\n            ids: number[];\n        };\n    }\n    interface ApplicationModule {\n        key: string;\n        type?: string;\n        data?: any;\n        authenticationType?: string;\n        permissions: Omit<ApplicationPermissions, 'project'>;\n    }\n}\n```\n\n##### bundles/index.d.ts\n\n```typescript\nimport { CrowdinApi, DownloadLink, PaginationOptions, PatchRequest, ResponseList, ResponseObject, Status } from '../core';\nimport { SourceFilesModel } from '../sourceFiles';\nexport declare class Bundles extends CrowdinApi {\n    listBundles(projectId: number, options?: PaginationOptions): Promise<ResponseList<BundlesModel.Bundle>>;\n    addBundle(projectId: number, request: BundlesModel.CreateBundleRequest): Promise<ResponseObject<BundlesModel.Bundle>>;\n    getBundle(projectId: number, bundleId: number): Promise<ResponseObject<BundlesModel.Bundle>>;\n    deleteBundle(projectId: number, bundleId: number): Promise<void>;\n    editBundle(projectId: number, bundleId: number, request: PatchRequest[]): Promise<ResponseObject<BundlesModel.Bundle>>;\n    downloadBundle(projectId: number, bundleId: number, exportId: string): Promise<ResponseObject<DownloadLink>>;\n    exportBundle(projectId: number, bundleId: number): Promise<ResponseObject<Status<BundlesModel.ExportAttributes>>>;\n    checkBundleExportStatus(projectId: number, bundleId: number, exportId: string): Promise<ResponseObject<Status<BundlesModel.ExportAttributes>>>;\n    listBundleFiles(projectId: number, bundleId: number, options?: PaginationOptions): Promise<ResponseList<SourceFilesModel.File>>;\n    listBundleBranches(projectId: number, bundleId: number, options?: PaginationOptions): Promise<ResponseList<SourceFilesModel.Branch>>;\n}\nexport declare namespace BundlesModel {\n    interface Bundle {\n        id: number;\n        name: string;\n        format: string;\n        sourcePatterns: string[];\n        ignorePatterns: string[];\n        exportPattern: string;\n        isMultilingual: boolean;\n        includeProjectSourceLanguage: boolean;\n        labelIds: number[];\n        excludeLabelIds: number[];\n        createdAt: string;\n        webUrl: string;\n        updatedAt: string;\n    }\n    interface CreateBundleRequest {\n        name: string;\n        format: string;\n        sourcePatterns: string[];\n        ignorePatterns?: string[];\n        exportPattern: string;\n        isMultilingual?: boolean;\n        includeProjectSourceLanguage?: boolean;\n        includeInContextPseudoLanguage?: boolean;\n        labelIds?: number[];\n        excludeLabelIds?: number[];\n    }\n    interface ExportAttributes {\n        bundleId: number;\n    }\n}\n```\n\n##### clients/index.d.ts\n\n```typescript\nimport { CrowdinApi, PaginationOptions, ResponseList } from '../core';\nexport declare class Clients extends CrowdinApi {\n    listClients(options?: PaginationOptions): Promise<ResponseList<ClientsModel.Client>>;\n}\nexport declare namespace ClientsModel {\n    interface Client {\n        id: number;\n        name: string;\n        description: string;\n        status: 'pending' | 'confirmed' | 'rejected';\n        webUrl: string;\n    }\n}\n```\n\n##### core/http-client-error.d.ts\n\n```typescript\nimport { AxiosError } from 'axios';\nimport { FetchClientJsonPayloadError } from './internal/fetch/fetchClientError';\nexport type HttpClientError = AxiosError | FetchClientJsonPayloadError | Error;\nexport declare const toHttpClientError: (error?: unknown) => HttpClientError;\n```\n\n##### core/index.d.ts\n\n```typescript\nimport { HttpClientError } from './http-client-error';\nimport { RetryConfig, RetryService } from './internal/retry';\nexport interface HttpClient {\n    get<T>(url: string, config?: {\n        headers: Record<string, string>;\n    }): Promise<T>;\n    delete<T>(url: string, config?: {\n        headers: Record<string, string>;\n    }): Promise<T>;\n    head<T>(url: string, config?: {\n        headers: Record<string, string>;\n    }): Promise<T>;\n    post<T>(url: string, data?: unknown, config?: {\n        headers: Record<string, string>;\n    }): Promise<T>;\n    put<T>(url: string, data?: unknown, config?: {\n        headers: Record<string, string>;\n    }): Promise<T>;\n    patch<T>(url: string, data?: unknown, config?: {\n        headers: Record<string, string>;\n    }): Promise<T>;\n}\nexport type HttpClientType = 'axios' | 'fetch';\nexport interface Credentials {\n    token: string;\n    organization?: string;\n    baseUrl?: string;\n}\nexport interface ClientConfig {\n    httpClientType?: HttpClientType;\n    httpClient?: HttpClient;\n    userAgent?: string;\n    integrationUserAgent?: string;\n    retryConfig?: RetryConfig;\n    httpRequestTimeout?: number;\n}\nexport interface ResponseList<T> {\n    data: ResponseObject<T>[];\n    pagination: Pagination;\n}\nexport interface ResponseObject<T> {\n    data: T;\n}\nexport interface Pagination {\n    offset: number;\n    limit: number;\n}\nexport type PaginationOptions = Partial<Pagination>;\nexport interface PatchRequest {\n    value?: any;\n    op: PatchOperation;\n    path: string;\n}\nexport type PatchOperation = 'add' | 'remove' | 'replace' | 'move' | 'copy' | 'test';\nexport type ProjectRoles = 'manager' | 'developer' | 'translator' | 'proofreader' | 'language_coordinator' | 'member';\nexport interface DownloadLink {\n    url: string;\n    expireIn: string;\n}\nexport declare enum BooleanInt {\n    TRUE = 1,\n    FALSE = 0\n}\nexport interface Status<T> {\n    identifier: string;\n    status: string;\n    progress: number;\n    attributes: T;\n    createdAt: string;\n    updatedAt: string;\n    startedAt: string;\n    finishedAt: string;\n    eta: string;\n}\nexport interface Attribute {\n    [key: string]: string;\n}\nexport type PlainObject = Record<string, any>;\nexport declare class CrowdinError extends Error {\n    apiError: any;\n    code: number;\n    constructor(message: string, code: number, apiError: any);\n}\nexport declare class CrowdinValidationError extends CrowdinError {\n    validationCodes: {\n        key: string;\n        codes: string[];\n    }[];\n    constructor(message: string, validationCodes: {\n        key: string;\n        codes: string[];\n    }[], apiError: any);\n}\nexport declare function handleHttpClientError(error: HttpClientError): never;\nexport declare abstract class CrowdinApi {\n    private static readonly CROWDIN_URL_SUFFIX;\n    private static readonly AXIOS_INSTANCE;\n    private static readonly FETCH_INSTANCE;\n    readonly token: string;\n    readonly organization?: string;\n    readonly url: string;\n    readonly config: ClientConfig | undefined;\n    readonly retryService: RetryService;\n    protected fetchAllFlag: boolean;\n    protected maxLimit: number | undefined;\n    constructor(credentials: Credentials, config?: ClientConfig);\n    graphql<T>(req: {\n        query: string;\n        operationName?: string;\n        variables?: any;\n    }, config?: {\n        url?: string;\n    }): Promise<ResponseObject<T>>;\n    protected addQueryParam(url: string, name: string, value?: string | number): string;\n    protected defaultConfig(): {\n        headers: Record<string, string>;\n    };\n    get httpClient(): HttpClient;\n    withFetchAll(maxLimit?: number): this;\n    protected getList<T = any>(url: string, limit?: number, offset?: number, config?: {\n        headers: Record<string, string>;\n    }): Promise<ResponseList<T>>;\n    protected fetchAll<T>(url: string, config: {\n        headers: Record<string, string>;\n    }, maxAmount?: number): Promise<ResponseList<T>>;\n    protected encodeUrlParam(param: string | number | boolean): string;\n    protected get<T>(url: string, config?: {\n        headers: Record<string, string>;\n    }): Promise<T>;\n    protected delete<T>(url: string, config?: {\n        headers: Record<string, string>;\n    }): Promise<T>;\n    protected head<T>(url: string, config?: {\n        headers: Record<string, string>;\n    }): Promise<T>;\n    protected post<T>(url: string, data?: unknown, config?: {\n        headers: Record<string, string>;\n    }): Promise<T>;\n    protected put<T>(url: string, data?: unknown, config?: {\n        headers: Record<string, string>;\n    }): Promise<T>;\n    protected patch<T>(url: string, data?: unknown, config?: {\n        headers: Record<string, string>;\n    }): Promise<T>;\n}\nexport declare function isOptionalString(parameter: string | unknown, parameterInArgs: boolean): parameter is string | undefined;\nexport declare function isOptionalNumber(parameter: number | unknown, parameterInArgs: boolean): parameter is number | undefined;\nexport interface ProjectRole {\n    name: string;\n    permissions: ProjectRolePermissions;\n}\nexport interface ProjectRolePermissions {\n    allLanguages: boolean;\n    languagesAccess: {\n        [lang: string]: {\n            allContent: boolean;\n            workflowStepIds: number[];\n        };\n    };\n}\n```\n\n##### dictionaries/index.d.ts\n\n```typescript\nimport { CrowdinApi, PatchRequest, ResponseList, ResponseObject } from '../core';\nexport declare class Dictionaries extends CrowdinApi {\n    listDictionaries(projectId: number, options?: DictionariesModel.ListDictionariesOptions): Promise<ResponseList<DictionariesModel.Dictionary>>;\n    listDictionaries(projectId: number, languageIds?: string): Promise<ResponseList<DictionariesModel.Dictionary>>;\n    editDictionary(projectId: number, languageId: string, request: PatchRequest[]): Promise<ResponseObject<DictionariesModel.Dictionary>>;\n}\nexport declare namespace DictionariesModel {\n    interface Dictionary {\n        languageId: string;\n        words: string[];\n    }\n    interface ListDictionariesOptions {\n        languageIds?: string;\n    }\n}\n```\n\n##### distributions/index.d.ts\n\n```typescript\nimport { CrowdinApi, PaginationOptions, PatchRequest, ResponseList, ResponseObject } from '../core';\nexport declare class Distributions extends CrowdinApi {\n    listDistributions(projectId: number, options?: PaginationOptions): Promise<ResponseList<DistributionsModel.Distribution>>;\n    listDistributions(projectId: number, limit?: number, offset?: number): Promise<ResponseList<DistributionsModel.Distribution>>;\n    createDistribution(projectId: number, request: DistributionsModel.CreateDistributionRequest | DistributionsModel.CreateDistributionStringsBasedRequest): Promise<ResponseObject<DistributionsModel.Distribution>>;\n    getDistribution(projectId: number, hash: string): Promise<ResponseObject<DistributionsModel.Distribution>>;\n    deleteDistribution(projectId: number, hash: string): Promise<void>;\n    editDistribution(projectId: number, hash: string, request: PatchRequest[]): Promise<ResponseObject<DistributionsModel.Distribution>>;\n    getDistributionRelease(projectId: number, hash: string): Promise<ResponseObject<DistributionsModel.DistributionRelease | DistributionsModel.DistributionStringsBasedRelease>>;\n    createDistributionRelease(projectId: number, hash: string): Promise<ResponseObject<DistributionsModel.DistributionRelease | DistributionsModel.DistributionStringsBasedRelease>>;\n}\nexport declare namespace DistributionsModel {\n    interface Distribution {\n        hash: string;\n        manifestUrl: string;\n        name: string;\n        bundleIds: number[];\n        createdAt: string;\n        updatedAt: string;\n        exportMode: ExportMode;\n        fileIds: number[];\n    }\n    interface CreateDistributionRequest {\n        exportMode?: ExportMode;\n        name: string;\n        fileIds?: number[];\n        bundleIds?: number[];\n    }\n    interface CreateDistributionStringsBasedRequest {\n        name: string;\n        bundleIds: number[];\n    }\n    interface DistributionRelease {\n        status: string;\n        progress: number;\n        currentLanguageId: string;\n        currentFileId: number;\n        date: string;\n    }\n    interface DistributionStringsBasedRelease {\n        status: string;\n        progress: number;\n        currentLanguageId: string;\n        currentBranchId: number;\n        date: string;\n    }\n    type ExportMode = 'default' | 'bundle';\n}\n```\n\n##### fields/index.d.ts\n\n```typescript\nimport { CrowdinApi, PaginationOptions, PatchRequest, ResponseList, ResponseObject } from '../core';\nexport declare class Fields extends CrowdinApi {\n    listFields(options?: FieldsModel.ListFieldsParams): Promise<ResponseList<FieldsModel.Field>>;\n    addField(request: FieldsModel.AddFieldRequest): Promise<ResponseObject<FieldsModel.Field>>;\n    getField(fieldId: number): Promise<ResponseObject<FieldsModel.Field>>;\n    deleteField(fieldId: number): Promise<void>;\n    editField(fieldId: number, request: PatchRequest[]): Promise<ResponseObject<FieldsModel.Field>>;\n}\nexport declare namespace FieldsModel {\n    type Entity = 'project' | 'user' | 'task' | 'file' | 'translation' | 'string';\n    type Type = 'checkbox' | 'radiobuttons' | 'date' | 'datetime' | 'number' | 'labels' | 'select' | 'multiselect' | 'text' | 'textarea' | 'url';\n    type Place = 'projectCreateModal' | 'projectHeader' | 'projectDetails' | 'projectCrowdsourceDetails' | 'projectSettings' | 'projectTaskEditCreate' | 'projectTaskDetails' | 'projectTaskBoardCard' | 'fileDetails' | 'fileSettings' | 'userEditModal' | 'userDetails' | 'userPopover' | 'stringEditModal' | 'stringDetails' | 'translationUnderContent';\n    interface Location {\n        place: Place;\n    }\n    interface Option {\n        label: string;\n        value: string;\n    }\n    interface OtherFieldConfig {\n        locations: Location[];\n    }\n    interface ListFieldConfig extends OtherFieldConfig {\n        options: Option[];\n    }\n    interface NumberFieldConfig extends OtherFieldConfig {\n        min: number;\n        max: number;\n        units: string;\n    }\n    type Config = ListFieldConfig | NumberFieldConfig | OtherFieldConfig;\n    interface ListFieldsParams extends PaginationOptions {\n        search?: string;\n        entity?: Entity;\n        type?: Type;\n    }\n    interface Field {\n        id: number;\n        name: string;\n        slug: string;\n        type: Type;\n        description: string;\n        entities: Entity[];\n        config: Config;\n        createdAt: string;\n        updatedAt: string;\n    }\n    interface AddFieldRequest {\n        name: string;\n        slug: string;\n        type: Type;\n        description?: string;\n        entities: Entity[];\n        config?: Config;\n    }\n}\n```\n\n##### glossaries/index.d.ts\n\n```typescript\nimport { CrowdinApi, DownloadLink, PaginationOptions, PatchRequest, ResponseList, ResponseObject, Status } from '../core';\nexport declare class Glossaries extends CrowdinApi {\n    listGlossaries(options?: GlossariesModel.ListGlossariesOptions): Promise<ResponseList<GlossariesModel.Glossary>>;\n    listGlossaries(groupId?: number, limit?: number, offset?: number): Promise<ResponseList<GlossariesModel.Glossary>>;\n    addGlossary(request: GlossariesModel.CreateGlossaryRequest): Promise<ResponseObject<GlossariesModel.Glossary>>;\n    getGlossary(glossaryId: number): Promise<ResponseObject<GlossariesModel.Glossary>>;\n    deleteGlossary(glossaryId: number): Promise<void>;\n    editGlossary(glossaryId: number, request: PatchRequest[]): Promise<ResponseObject<GlossariesModel.Glossary>>;\n    exportGlossary(glossaryId: number, request: GlossariesModel.ExportGlossaryRequest): Promise<ResponseObject<Status<GlossariesModel.GlossaryExportStatusAttribute>>>;\n    checkGlossaryExportStatus(glossaryId: number, exportId: string): Promise<ResponseObject<Status<GlossariesModel.GlossaryExportStatusAttribute>>>;\n    downloadGlossary(glossaryId: number, exportId: string): Promise<ResponseObject<DownloadLink>>;\n    importGlossaryFile(glossaryId: number, request: GlossariesModel.GlossaryFile): Promise<ResponseObject<Status<GlossariesModel.GlossaryImportStatusAttribute>>>;\n    checkGlossaryImportStatus(glossaryId: number, importId: string): Promise<ResponseObject<Status<GlossariesModel.GlossaryImportStatusAttribute>>>;\n    listTerms(glossaryId: number, options?: GlossariesModel.ListTermsOptions): Promise<ResponseList<GlossariesModel.Term>>;\n    listTerms(glossaryId: number, userId?: number, limit?: number, offset?: number, languageId?: string, translationOfTermId?: number, conceptId?: number): Promise<ResponseList<GlossariesModel.Term>>;\n    addTerm(glossaryId: number, request: GlossariesModel.CreateTermRequest): Promise<ResponseObject<GlossariesModel.Term>>;\n    clearGlossary(glossaryId: number, options?: GlossariesModel.ClearGlossaryOptions): Promise<ResponseObject<GlossariesModel.Term>>;\n    clearGlossary(glossaryId: number, languageId?: number, translationOfTermId?: number, conceptId?: number): Promise<ResponseObject<GlossariesModel.Term>>;\n    getTerm(glossaryId: number, termId: number): Promise<ResponseObject<GlossariesModel.Term>>;\n    deleteTerm(glossaryId: number, termId: number): Promise<void>;\n    editTerm(glossaryId: number, termId: number, request: PatchRequest[]): Promise<ResponseObject<GlossariesModel.Term>>;\n    listConcepts(glossaryId: number, options?: {\n        orderBy?: string;\n    } & PaginationOptions): Promise<ResponseList<GlossariesModel.Concept>>;\n    getConcept(glossaryId: number, conceptId: number): Promise<ResponseObject<GlossariesModel.Concept>>;\n    updateConcept(glossaryId: number, conceptId: number, request: GlossariesModel.UpdateConceptRequest): Promise<ResponseObject<GlossariesModel.Concept>>;\n    deleteConcept(glossaryId: number, conceptId: number): Promise<void>;\n    concordanceSearch(projectId: number, request: GlossariesModel.ConcordanceSearchRequest): Promise<ResponseList<GlossariesModel.ConcordanceSearchResponse>>;\n}\nexport declare namespace GlossariesModel {\n    interface Glossary {\n        id: number;\n        name: string;\n        groupId: number;\n        userId: number;\n        terms: number;\n        languageId: string;\n        languageIds: string[];\n        defaultProjectIds: number[];\n        projectIds: number[];\n        webUrl: string;\n        createdAt: string;\n    }\n    interface CreateGlossaryRequest {\n        name: string;\n        languageId: string;\n        groupId?: number;\n    }\n    type ExportField = 'term' | 'description' | 'partOfSpeech' | 'type' | 'status' | 'gender' | 'note' | 'url' | 'conceptDefinition' | 'conceptSubject' | 'conceptNote' | 'conceptUrl' | 'conceptFigure';\n    interface ExportGlossaryRequest {\n        format?: GlossaryFormat;\n        exportFields?: ExportField[];\n    }\n    interface GlossaryExportStatusAttribute {\n        format: string;\n        exportFields: ExportField[];\n    }\n    interface GlossaryImportStatusAttribute {\n        storageId: number;\n        scheme: unknown;\n        firstLineContainsHeader: boolean;\n    }\n    interface GlossaryFile {\n        storageId: number;\n        scheme?: GlossaryFileScheme;\n        firstLineContainsHeader?: boolean;\n    }\n    interface ListTermsOptions extends PaginationOptions {\n        userId?: number;\n        languageId?: string;\n        conceptId?: number;\n        orderBy?: string;\n        croql?: string;\n        translationOfTermId?: number;\n    }\n    interface Term {\n        id: number;\n        userId: number;\n        glossaryId: number;\n        languageId: string;\n        text: string;\n        description: string;\n        partOfSpeech: PartOfSpeech;\n        status: Status;\n        type: Type;\n        gender: Gender;\n        note: string;\n        url: string;\n        conceptId: number;\n        lemma: string;\n        createdAt: string;\n        updatedAt: string;\n    }\n    interface CreateTermRequest {\n        languageId: string;\n        text: string;\n        description?: string;\n        partOfSpeech?: PartOfSpeech;\n        status?: Status;\n        type?: Type;\n        gender?: Gender;\n        note?: string;\n        url?: string;\n        conceptId?: number;\n        translationOfTermId?: number;\n    }\n    interface ConcordanceSearchRequest extends PaginationOptions {\n        sourceLanguageId: string;\n        targetLanguageId: string;\n        expressions: string[];\n        expression?: string;\n    }\n    interface ConcordanceSearchResponse {\n        glossary: Glossary;\n        concept: Concept;\n        sourceTerms: Term[];\n        targetTerms: Term[];\n    }\n    type Status = 'preferred' | 'admitted' | 'not recommended' | 'obsolete';\n    type Type = 'full form' | 'acronym' | 'abbreviation' | 'short form' | 'phrase' | 'variant';\n    type Gender = 'masculine' | 'feminine' | 'neuter' | 'other';\n    type GlossaryFormat = 'tbx' | 'tbx_v3' | 'csv' | 'xlsx';\n    interface GlossaryFileScheme {\n        [key: string]: number;\n    }\n    type PartOfSpeech = 'adjective' | 'adposition' | 'adverb' | 'auxiliary' | 'coordinating conjunction' | 'determiner' | 'interjection' | 'noun' | 'numeral' | 'particle' | 'pronoun' | 'proper noun' | 'subordinating conjunction' | 'verb' | 'other';\n    interface ListGlossariesOptions extends PaginationOptions {\n        groupId?: number;\n        userId?: number;\n        orderBy?: string;\n    }\n    interface ClearGlossaryOptions {\n        languageId?: number;\n        translationOfTermId?: number;\n        conceptId?: number;\n    }\n    interface Concept {\n        id: number;\n        userId: number;\n        glossaryId: number;\n        subject: string;\n        definition: string;\n        translatable: boolean;\n        note: string;\n        url: string;\n        figure: string;\n        languagesDetails: LanguageDetails[];\n        createdAt: string;\n        updatedAt: string;\n    }\n    interface LanguageDetails {\n        languageId: string;\n        userId: number;\n        definition: string;\n        note: string;\n        createdAt: string;\n        updatedAt: string;\n    }\n    interface UpdateConceptRequest {\n        subject?: string;\n        definition?: string;\n        translatable?: boolean;\n        note?: string;\n        url?: string;\n        figure?: string;\n        languagesDetails?: {\n            languageId: string;\n            definition: string;\n            note?: string;\n        }[];\n    }\n}\n```\n\n##### index.d.ts\n\n```typescript\nimport { Ai } from './ai';\nimport { Applications } from './applications';\nimport { Bundles } from './bundles';\nimport { Clients } from './clients';\nimport { ClientConfig, Credentials, CrowdinApi } from './core';\nimport { Dictionaries } from './dictionaries';\nimport { Distributions } from './distributions';\nimport { Fields } from './fields';\nimport { Glossaries } from './glossaries';\nimport { Issues } from './issues';\nimport { Labels } from './labels';\nimport { Languages } from './languages';\nimport { MachineTranslation } from './machineTranslation';\nimport { Notifications } from './notifications';\nimport { OrganizationWebhooks } from './organizationWebhooks';\nimport { ProjectsGroups } from './projectsGroups';\nimport { Reports } from './reports';\nimport { Screenshots } from './screenshots';\nimport { SecurityLogs } from './securityLogs';\nimport { SourceFiles } from './sourceFiles';\nimport { SourceStrings } from './sourceStrings';\nimport { StringComments } from './stringComments';\nimport { StringCorrections } from './stringCorrections';\nimport { StringTranslations } from './stringTranslations';\nimport { Tasks } from './tasks';\nimport { Teams } from './teams';\nimport { TranslationMemory } from './translationMemory';\nimport { TranslationStatus } from './translationStatus';\nimport { Translations } from './translations';\nimport { UploadStorage } from './uploadStorage';\nimport { Users } from './users';\nimport { Vendors } from './vendors';\nimport { Webhooks } from './webhooks';\nimport { Workflows } from './workflows';\nexport * from './ai';\nexport * from './applications';\nexport * from './bundles';\nexport * from './clients';\nexport * from './core';\nexport * from './dictionaries';\nexport * from './distributions';\nexport * from './fields';\nexport * from './glossaries';\nexport * from './issues';\nexport * from './labels';\nexport * from './languages';\nexport * from './machineTranslation';\nexport * from './notifications';\nexport * from './organizationWebhooks';\nexport * from './projectsGroups';\nexport * from './reports';\nexport * from './screenshots';\nexport * from './securityLogs';\nexport * from './sourceFiles';\nexport * from './sourceStrings';\nexport * from './stringComments';\nexport * from './stringCorrections';\nexport * from './stringTranslations';\nexport * from './tasks';\nexport * from './teams';\nexport * from './translationMemory';\nexport * from './translationStatus';\nexport * from './translations';\nexport * from './uploadStorage';\nexport * from './users';\nexport * from './vendors';\nexport * from './webhooks';\nexport * from './workflows';\nexport default class Client extends CrowdinApi {\n    readonly aiApi: Ai;\n    readonly applicationsApi: Applications;\n    readonly sourceFilesApi: SourceFiles;\n    readonly glossariesApi: Glossaries;\n    readonly languagesApi: Languages;\n    readonly translationsApi: Translations;\n    readonly translationStatusApi: TranslationStatus;\n    readonly projectsGroupsApi: ProjectsGroups;\n    readonly reportsApi: Reports;\n    readonly screenshotsApi: Screenshots;\n    readonly sourceStringsApi: SourceStrings;\n    readonly uploadStorageApi: UploadStorage;\n    readonly tasksApi: Tasks;\n    readonly translationMemoryApi: TranslationMemory;\n    readonly webhooksApi: Webhooks;\n    readonly organizationWebhooksApi: OrganizationWebhooks;\n    readonly machineTranslationApi: MachineTranslation;\n    readonly stringTranslationsApi: StringTranslations;\n    readonly workflowsApi: Workflows;\n    readonly usersApi: Users;\n    readonly vendorsApi: Vendors;\n    readonly issuesApi: Issues;\n    readonly teamsApi: Teams;\n    readonly distributionsApi: Distributions;\n    readonly dictionariesApi: Dictionaries;\n    readonly labelsApi: Labels;\n    readonly stringCommentsApi: StringComments;\n    readonly bundlesApi: Bundles;\n    readonly notificationsApi: Notifications;\n    readonly clientsApi: Clients;\n    readonly securityLogsApi: SecurityLogs;\n    readonly fieldsApi: Fields;\n    readonly stringCorrectionsApi: StringCorrections;\n    constructor(credentials: Credentials, config?: ClientConfig);\n}\nexport { Client };\n```\n\n##### issues/index.d.ts\n\n```typescript\nimport { CrowdinApi, PaginationOptions, PatchRequest, ResponseList, ResponseObject } from '../core';\nexport declare class Issues extends CrowdinApi {\n    listReportedIssues(projectId: number, options?: IssuesModel.ListReportedIssuesOptions): Promise<ResponseList<IssuesModel.Issue>>;\n    listReportedIssues(projectId: number, limit?: number, offset?: number, type?: IssuesModel.Type, status?: IssuesModel.Status): Promise<ResponseList<IssuesModel.Issue>>;\n    editIssue(projectId: number, issueId: number, request: PatchRequest[]): Promise<ResponseObject<IssuesModel.Issue>>;\n}\nexport declare namespace IssuesModel {\n    type Type = 'all' | 'general_question' | 'translation_mistake' | 'context_request' | 'source_mistake';\n    type Status = 'all' | 'resolved' | 'unresolved';\n    interface Issue {\n        id: number;\n        text: string;\n        userId: number;\n        stringId: number;\n        user: User;\n        string: string;\n        languageId: string;\n        type: Type;\n        status: Status;\n        createdAt: string;\n    }\n    interface User {\n        id: number;\n        username: string;\n        fullName: string;\n        avatarUrl: string;\n    }\n    interface String {\n        id: number;\n        text: string;\n        type: string;\n        hasPlurals: boolean;\n        isIcu: boolean;\n        context: string;\n        fileId: number;\n    }\n    interface ListReportedIssuesOptions extends PaginationOptions {\n        type?: IssuesModel.Type;\n        status?: IssuesModel.Status;\n    }\n}\n```\n\n##### labels/index.d.ts\n\n```typescript\nimport { CrowdinApi, PaginationOptions, PatchRequest, ResponseList, ResponseObject } from '../core';\nimport { ScreenshotsModel } from '../screenshots';\nimport { SourceStringsModel } from '../sourceStrings';\nexport declare class Labels extends CrowdinApi {\n    listLabels(projectId: number, options?: LabelsModel.ListLabelsParams): Promise<ResponseList<LabelsModel.Label>>;\n    listLabels(projectId: number, limit?: number, offset?: number): Promise<ResponseList<LabelsModel.Label>>;\n    addLabel(projectId: number, request: LabelsModel.AddLabelRequest): Promise<ResponseObject<LabelsModel.Label>>;\n    getLabel(projectId: number, labelId: number): Promise<ResponseObject<LabelsModel.Label>>;\n    deleteLabel(projectId: number, labelId: number): Promise<void>;\n    editLabel(projectId: number, labelId: number, request: PatchRequest[]): Promise<ResponseObject<LabelsModel.Label>>;\n    assignLabelToScreenshots(projectId: number, labelId: number, request: LabelsModel.AssignLabelToScreenshotsRequet): Promise<ResponseList<ScreenshotsModel.Screenshot>>;\n    unassignLabelFromScreenshots(projectId: number, labelId: number, screenshotIds: string): Promise<ResponseList<ScreenshotsModel.Screenshot>>;\n    assignLabelToString(projectId: number, labelId: number, request: LabelsModel.AssignLabelToStringsRequet): Promise<ResponseList<SourceStringsModel.String>>;\n    unassignLabelFromString(projectId: number, labelId: number, stringIds: string): Promise<ResponseList<SourceStringsModel.String>>;\n}\nexport declare namespace LabelsModel {\n    interface ListLabelsParams extends PaginationOptions {\n        orderBy?: string;\n    }\n    interface Label {\n        id: number;\n        title: string;\n        isSystem?: boolean;\n    }\n    interface AddLabelRequest {\n        title: string;\n    }\n    interface AssignLabelToStringsRequet {\n        stringIds: number[];\n    }\n    interface AssignLabelToScreenshotsRequet {\n        screenshotIds: number[];\n    }\n}\n```\n\n##### languages/index.d.ts\n\n```typescript\nimport { CrowdinApi, PaginationOptions, PatchRequest, ResponseList, ResponseObject } from '../core';\nexport declare class Languages extends CrowdinApi {\n    listSupportedLanguages(options?: PaginationOptions): Promise<ResponseList<LanguagesModel.Language>>;\n    listSupportedLanguages(limit?: number, offset?: number): Promise<ResponseList<LanguagesModel.Language>>;\n    addCustomLanguage(request: LanguagesModel.AddLanguageRequest): Promise<ResponseObject<LanguagesModel.Language>>;\n    getLanguage(languageId: string): Promise<ResponseObject<LanguagesModel.Language>>;\n    deleteCustomLanguage(languageId: string): Promise<void>;\n    editCustomLanguage(languageId: string, request: PatchRequest[]): Promise<ResponseObject<LanguagesModel.Language>>;\n}\nexport declare namespace LanguagesModel {\n    interface Language {\n        id: string;\n        name: string;\n        editorCode: string;\n        twoLettersCode: string;\n        threeLettersCode: string;\n        locale: string;\n        androidCode: string;\n        osxCode: string;\n        osxLocale: string;\n        pluralCategoryNames: string[];\n        pluralRules: string;\n        pluralExamples: string[];\n        textDirection: TextDirection;\n        dialectOf: string;\n    }\n    interface AddLanguageRequest {\n        name: string;\n        code: string;\n        localeCode: string;\n        textDirection: TextDirection;\n        pluralCategoryNames: string[];\n        threeLettersCode: string;\n        twoLettersCode?: string;\n        dialectOf?: string;\n    }\n    type TextDirection = 'ltr' | 'rtl';\n}\n```\n\n##### machineTranslation/index.d.ts\n\n```typescript\nimport { CrowdinApi, PaginationOptions, PatchRequest, ResponseList, ResponseObject } from '../core';\nexport declare class MachineTranslation extends CrowdinApi {\n    listMts(options?: MachineTranslationModel.ListMTsOptions): Promise<ResponseList<MachineTranslationModel.MachineTranslation>>;\n    listMts(groupId?: number, limit?: number, offset?: number): Promise<ResponseList<MachineTranslationModel.MachineTranslation>>;\n    createMt(request: MachineTranslationModel.CreateMachineTranslationRequest): Promise<ResponseObject<MachineTranslationModel.MachineTranslation>>;\n    getMt(mtId: number): Promise<ResponseObject<MachineTranslationModel.MachineTranslation>>;\n    deleteMt(mtId: number): Promise<void>;\n    updateMt(mtId: number, request: PatchRequest[]): Promise<ResponseObject<MachineTranslationModel.MachineTranslation>>;\n    translate(mtId: number, request: MachineTranslationModel.TranslateRequest): Promise<ResponseObject<MachineTranslationModel.TranslateResponse>>;\n}\nexport declare namespace MachineTranslationModel {\n    interface MachineTranslation {\n        id: number;\n        groupId: number;\n        name: string;\n        type: number;\n        credentials: Credentials;\n        projectIds: number[];\n        supportedLanguageIds: string[];\n        supportedLanguagePairs: Record<string, string[]>;\n        enabledLanguageIds: string[];\n        enabledProjectIds: number[];\n        isEnabled: boolean;\n    }\n    type Credentials = {\n        apiKey: string;\n    } | {\n        credentials: string;\n    } | {\n        model: string;\n        apiKey: string;\n    } | {\n        isSystemCredentials: boolean;\n        apiKey: string;\n    } | {\n        endpoint: string;\n        apiKey: string;\n    } | {\n        url: string;\n    } | {\n        accessKey: string;\n        secretKey: string;\n    };\n    interface CreateMachineTranslationRequest {\n        name: string;\n        type: string;\n        credentials: Credentials;\n        groupId?: number;\n        enabledLanguageIds?: string[];\n        enabledProjectIds?: number[];\n        isEnabled?: boolean;\n    }\n    interface TranslateRequest {\n        languageRecognitionProvider?: LanguageRecognitionProvider;\n        sourceLanguageId?: string;\n        targetLanguageId: string;\n        strings?: string[];\n    }\n    interface TranslateResponse {\n        sourceLanguageId: string;\n        targetLanguageId: string;\n        strings: string[];\n        translations: string[];\n    }\n    type LanguageRecognitionProvider = 'crowdin' | 'engine';\n    interface ListMTsOptions extends PaginationOptions {\n        groupId?: number;\n    }\n}\n```\n\n##### notifications/index.d.ts\n\n```typescript\nimport { CrowdinApi } from '../core';\nexport declare class Notifications extends CrowdinApi {\n    sendNotificationToAuthenticatedUser(request: NotificationsModel.Notification): Promise<void>;\n    sendNotificationToProjectMembers(projectId: number, request: NotificationsModel.NotificationByUsers | NotificationsModel.NotificationByRole): Promise<void>;\n    sendNotificationToOrganizationMembers(request: NotificationsModel.Notification | NotificationsModel.NotificationByUsers | NotificationsModel.NotificationByRole): Promise<void>;\n}\nexport declare namespace NotificationsModel {\n    interface Notification {\n        message: string;\n    }\n    interface NotificationByUsers extends Notification {\n        userIds: number[];\n    }\n    interface NotificationByRole extends Notification {\n        role: 'owner' | 'admin';\n    }\n}\n```\n\n##### organizationWebhooks/index.d.ts\n\n```typescript\nimport { CrowdinApi, PaginationOptions, PatchRequest, ResponseList, ResponseObject } from '../core';\nimport { WebhooksModel } from '../webhooks';\nexport declare class OrganizationWebhooks extends CrowdinApi {\n    listWebhooks(options?: PaginationOptions): Promise<ResponseList<OrganizationWebhooksModel.OrganizationWebhook>>;\n    addWebhook(request: OrganizationWebhooksModel.AddOrganizationWebhookRequest): Promise<ResponseObject<OrganizationWebhooksModel.OrganizationWebhook>>;\n    getWebhook(webhookId: number): Promise<ResponseObject<OrganizationWebhooksModel.OrganizationWebhook>>;\n    deleteWebhook(webhookId: number): Promise<void>;\n    editWebhook(webhookId: number, request: PatchRequest[]): Promise<ResponseObject<OrganizationWebhooksModel.OrganizationWebhook>>;\n}\nexport declare namespace OrganizationWebhooksModel {\n    type OrganizationWebhook = Omit<WebhooksModel.Webhook, 'projectId' | 'events'> & {\n        events: Event[];\n    };\n    type AddOrganizationWebhookRequest = Omit<WebhooksModel.AddWebhookRequest, 'events'> & {\n        events: Event[];\n    };\n    type Event = 'group.created' | 'group.deleted' | 'project.created' | 'project.deleted';\n}\n```\n\n##### projectsGroups/index.d.ts\n\n```typescript\nimport { BooleanInt, CrowdinApi, DownloadLink, PaginationOptions, PatchRequest, ResponseList, ResponseObject } from '../core';\nimport { LanguagesModel } from '../languages';\nexport declare class ProjectsGroups extends CrowdinApi {\n    listGroups(options?: ProjectsGroupsModel.ListGroupsOptions): Promise<ResponseList<ProjectsGroupsModel.Group>>;\n    listGroups(parentId?: number, offset?: number, userId?: number, limit?: number): Promise<ResponseList<ProjectsGroupsModel.Group>>;\n    addGroup(request: ProjectsGroupsModel.AddGroupRequest): Promise<ResponseObject<ProjectsGroupsModel.Group>>;\n    getGroup(groupId: number): Promise<ResponseObject<ProjectsGroupsModel.Group>>;\n    deleteGroup(groupId: number): Promise<void>;\n    editGroup(groupId: number, request: PatchRequest[]): Promise<ResponseObject<ProjectsGroupsModel.Group>>;\n    listProjects(options?: ProjectsGroupsModel.ListProjectsOptions): Promise<ResponseList<ProjectsGroupsModel.Project | ProjectsGroupsModel.ProjectSettings>>;\n    listProjects(groupId?: number, hasManagerAccess?: BooleanInt, limit?: number, offset?: number): Promise<ResponseList<ProjectsGroupsModel.Project | ProjectsGroupsModel.ProjectSettings>>;\n    addProject(request: ProjectsGroupsModel.CreateProjectEnterpriseRequest | ProjectsGroupsModel.CreateProjectRequest): Promise<ResponseObject<ProjectsGroupsModel.Project | ProjectsGroupsModel.ProjectSettings>>;\n    getProject(projectId: number): Promise<ResponseObject<ProjectsGroupsModel.Project | ProjectsGroupsModel.ProjectSettings>>;\n    deleteProject(projectId: number): Promise<void>;\n    editProject(projectId: number, request: PatchRequest[]): Promise<ResponseObject<ProjectsGroupsModel.Project | ProjectsGroupsModel.ProjectSettings>>;\n    downloadProjectFileFormatSettingsCustomSegmentation(projectId: number, fileFormatSettingsId: number): Promise<ResponseObject<DownloadLink>>;\n    resetProjectFileFormatSettingsCustomSegmentation(projectId: number, fileFormatSettingsId: number): Promise<ResponseObject<DownloadLink>>;\n    listProjectFileFormatSettings(projectId: number, options?: PaginationOptions): Promise<ResponseList<ProjectsGroupsModel.ProjectFileFormatSettings>>;\n    addProjectFileFormatSettings(projectId: number, request: ProjectsGroupsModel.AddProjectFileFormatSettingsRequest): Promise<ResponseObject<ProjectsGroupsModel.ProjectFileFormatSettings>>;\n    getProjectFileFormatSettings(projectId: number, fileFormatSettingsId: number): Promise<ResponseObject<ProjectsGroupsModel.ProjectFileFormatSettings>>;\n    deleteProjectFileFormatSettings(projectId: number, fileFormatSettingsId: number): Promise<void>;\n    editProjectFileFormatSettings(projectId: number, fileFormatSettingsId: number, request: PatchRequest[]): Promise<ResponseObject<ProjectsGroupsModel.ProjectFileFormatSettings>>;\n    listProjectStringsExporterSettings(projectId: number, options?: PaginationOptions): Promise<ResponseList<ProjectsGroupsModel.ProjectStringsExporterSettings>>;\n    addProjectStringsExporterSettings(projectId: number, request: ProjectsGroupsModel.AddProjectStringsExporterSettingsRequest): Promise<ResponseObject<ProjectsGroupsModel.ProjectStringsExporterSettings>>;\n    getProjectStringsExporterSettings(projectId: number, systemStringsExporterSettingsId: number): Promise<ResponseObject<ProjectsGroupsModel.ProjectStringsExporterSettings>>;\n    deleteProjectStringsExporterSettings(projectId: number, systemStringsExporterSettingsId: number): Promise<void>;\n    editProjectStringsExporterSettings(projectId: number, systemStringsExporterSettingsId: number, request: ProjectsGroupsModel.AddProjectStringsExporterSettingsRequest): Promise<ResponseObject<ProjectsGroupsModel.ProjectStringsExporterSettings>>;\n}\nexport declare namespace ProjectsGroupsModel {\n    interface Group {\n        id: number;\n        name: string;\n        description: string;\n        parentId: number;\n        organizationId: number;\n        userId: number;\n        subgroupsCount: number;\n        projectsCount: number;\n        webUrl: string;\n        createdAt: string;\n        updatedAt: string;\n    }\n    interface AddGroupRequest {\n        name: string;\n        parentId?: number;\n        description?: string;\n    }\n    interface Project {\n        id: number;\n        type: Type;\n        userId: number;\n        sourceLanguageId: string;\n        targetLanguageIds: string[];\n        languageAccessPolicy: LanguageAccessPolicy;\n        name: string;\n        identifier: string;\n        description: string;\n        visibility: string;\n        logo: string;\n        publicDownloads: boolean;\n        createdAt: string;\n        updatedAt: string;\n        lastActivity: string;\n        sourceLanguage: LanguagesModel.Language;\n        targetLanguages: LanguagesModel.Language[];\n        webUrl: string;\n        savingsReportSettingsTemplateId: number;\n        fields: Record<string, any>;\n        cname: string;\n        groupId: number;\n        background: string;\n        isExternal: boolean;\n        externalType: string;\n        externalProjectId: number;\n        externalOrganizationId: number;\n        workflowId: number;\n        hasCrowdsourcing: boolean;\n        publicUrl: string;\n    }\n    interface CreateProjectRequest {\n        name: string;\n        identifier: string;\n        sourceLanguageId: string;\n        targetLanguageIds?: string[];\n        visibility?: JoinPolicy;\n        languageAccessPolicy?: LanguageAccessPolicy;\n        cname?: string;\n        description?: string;\n        tagDetection?: TagDetection;\n        isMtAllowed?: boolean;\n        taskBasedAccessControl?: boolean;\n        autoSubstitution?: boolean;\n        autoTranslateDialects?: boolean;\n        publicDownloads?: boolean;\n        hiddenStringsProofreadersAccess?: boolean;\n        useGlobalTm?: boolean;\n        showTmSuggestionsDialects?: boolean;\n        tmApprovedSuggestionsOnly?: boolean;\n        skipUntranslatedStrings?: boolean;\n        exportApprovedOnly?: boolean;\n        qaCheckIsActive?: boolean;\n        qaCheckCategories?: CheckCategories;\n        qaChecksIgnorableCategories?: CheckCategories;\n        languageMapping?: LanguageMapping;\n        glossaryAccess?: boolean;\n        glossaryAccessOption?: GlossaryAccessOption;\n        normalizePlaceholder?: boolean;\n        notificationSettings?: NotificationSettings;\n        tmPreTranslate?: ProjectSettings['tmPreTranslate'];\n        mtPreTranslate?: ProjectSettings['mtPreTranslate'];\n        aiPreTranslate?: ProjectSettings['aiPreTranslate'];\n        assistActionAiPromptId?: number;\n        editorSuggestionAiPromptId?: number;\n        savingsReportSettingsTemplateId?: number;\n        defaultTmId?: number;\n        defaultGlossaryId?: number;\n        inContext?: boolean;\n        inContextProcessHiddenStrings?: boolean;\n        inContextPseudoLanguageId?: string;\n        saveMetaInfoInSource?: boolean;\n        type?: BooleanInt;\n        skipUntranslatedFiles?: boolean;\n        tmContextType?: TmContextType;\n    }\n    interface CreateProjectEnterpriseRequest {\n        name: string;\n        sourceLanguageId: string;\n        templateId?: number;\n        steps?: WorkflowTemplateStepConfig[];\n        groupId?: number;\n        targetLanguageIds?: string[];\n        vendorId?: number;\n        mtEngineId?: number;\n        description?: string;\n        translateDuplicates?: TranslateDuplicates;\n        tagsDetection?: TagDetection;\n        isMtAllowed?: boolean;\n        taskBasedAccessControl?: boolean;\n        taskReviewerIds?: number[];\n        autoSubstitution?: boolean;\n        showTmSuggestionsDialects?: boolean;\n        tmApprovedSuggestionsOnly?: boolean;\n        autoTranslateDialects?: boolean;\n        publicDownloads?: boolean;\n        hiddenStringsProofreadersAccess?: boolean;\n        delayedWorkflowStart?: boolean;\n        skipUntranslatedStrings?: boolean;\n        exportWithMinApprovalsCount?: number;\n        exportStringsThatPassedWorkflow?: number;\n        normalizePlaceholder?: boolean;\n        qaCheckIsActive?: boolean;\n        qaApprovalsCount?: number;\n        qaCheckCategories?: CheckCategories;\n        qaChecksIgnorableCategories?: CheckCategories;\n        customQaCheckIds?: number[];\n        languageMapping?: LanguageMapping;\n        glossaryAccess?: boolean;\n        glossaryAccessOption?: GlossaryAccessOption;\n        notificationSettings?: NotificationSettings;\n        savingsReportSettingsTemplateId?: number;\n        fields?: Record<string, any>;\n        assistActionAiPromptId?: number;\n        editorSuggestionAiPromptId?: number;\n        alignmentActionAiPromptId?: number;\n        defaultTmId?: number;\n        defaultGlossaryId?: number;\n        inContext?: boolean;\n        inContextProcessHiddenStrings?: boolean;\n        inContextPseudoLanguageId?: string;\n        saveMetaInfoInSource?: boolean;\n        type?: BooleanInt;\n        skipUntranslatedFiles?: boolean;\n        tmContextType?: TmContextType;\n    }\n    type GlossaryAccessOption = 'readOnly' | 'fullAccess' | 'manageDrafts';\n    interface ProjectSettings extends Project {\n        translateDuplicates: TranslateDuplicates;\n        tagsDetection: TagDetection;\n        glossaryAccess: boolean;\n        glossaryAccessOption: GlossaryAccessOption;\n        isMtAllowed: boolean;\n        taskBasedAccessControl: boolean;\n        hiddenStringsProofreadersAccess: boolean;\n        autoSubstitution: boolean;\n        exportTranslatedOnly: boolean;\n        skipUntranslatedStrings: boolean;\n        exportApprovedOnly: boolean;\n        autoTranslateDialects: boolean;\n        useGlobalTm: boolean;\n        showTmSuggestionsDialects: boolean;\n        tmApprovedSuggestionsOnly: boolean;\n        isSuspended: boolean;\n        qaCheckIsActive: boolean;\n        qaCheckCategories: CheckCategories;\n        qaChecksIgnorableCategories: CheckCategories;\n        languageMapping: LanguageMapping;\n        notificationSettings: NotificationSettings;\n        defaultTmId: number;\n        defaultGlossaryId: number;\n        assignedTms: {\n            [id: string]: {\n                priority: number;\n            };\n        };\n        assignedGlossaries: number[];\n        tmPenalties: {\n            autoSubstitution: number;\n            tmPriority: {\n                priority: number;\n                penalty: number;\n            };\n            multipleTranslations: number;\n            timeSinceLastUsage: {\n                months: number;\n                penalty: number;\n            };\n            timeSinceLastModified: {\n                months: number;\n                penalty: number;\n            };\n        };\n        normalizePlaceholder: boolean;\n        tmPreTranslate: {\n            enabled: boolean;\n            autoApproveOption: 'all' | 'perfectMatchOnly' | 'exceptAutoSubstituted' | 'perfectMatchApprovedOnly' | 'none';\n            minimumMatchRatio: 'perfect' | '100';\n        };\n        mtPreTranslate: {\n            enabled: boolean;\n            mts: {\n                mtId: number;\n                languageIds: string[];\n            }[];\n        };\n        aiPreTranslate: {\n            enabled: boolean;\n            aiPrompts: {\n                aiPromptId: number;\n                languageIds: string[];\n            }[];\n        };\n        assistActionAiPromptId: number;\n        editorSuggestionAiPromptId: number;\n        inContext: boolean;\n        inContextProcessHiddenStrings: string;\n        inContextPseudoLanguageId: string;\n        inContextPseudoLanguage: LanguagesModel.Language;\n        saveMetaInfoInSource: boolean;\n        skipUntranslatedFiles: boolean;\n        tmContextType: TmContextType;\n        clientOrganizationId: number;\n        taskReviewerIds: number[];\n        exportWithMinApprovalsCount: number;\n        exportStringsThatPassedWorkflow: boolean;\n        qaApprovalsCount: number;\n        customQaCheckIds: number[];\n        externalQaCheckIds: number[];\n        delayedWorkflowStart: boolean;\n        alignmentActionAiPromptId: number;\n    }\n    enum Type {\n        FILES_BASED = 0,\n        STRINGS_BASED = 1\n    }\n    enum TagDetection {\n        AUTO = 0,\n        COUNT_TAGS = 1,\n        SKIP_TAGS = 2\n    }\n    type JoinPolicy = 'open' | 'private';\n    type LanguageAccessPolicy = 'open' | 'moderate';\n    interface CheckCategories {\n        empty: boolean;\n        size: boolean;\n        tags: boolean;\n        spaces: boolean;\n        variables: boolean;\n        punctuation: boolean;\n        symbolRegister: boolean;\n        specialSymbols: boolean;\n        wrongTranslation: boolean;\n        spellcheck: boolean;\n        icu: boolean;\n        terms: boolean;\n        duplicate: boolean;\n        ftl: boolean;\n        android: boolean;\n    }\n    interface LanguageMapping {\n        [key: string]: LanguageMappingEntity;\n    }\n    interface LanguageMappingEntity {\n        name: string;\n        two_letters_code: string;\n        three_letters_code: string;\n        locale: string;\n        locale_with_underscore: string;\n        android_code: string;\n        osx_code: string;\n        osx_locale: string;\n    }\n    enum TranslateDuplicates {\n        SHOW = 0,\n        HIDE_REGULAR_DETECTION = 1,\n        SHOW_AUTO_TRANSLATE = 2,\n        SHOW_WITHIN_VERION_BRANCH_REGULAR_DETECTION = 3,\n        HIDE_STRICT_DETECTION = 4,\n        SHOW_WITHIN_VERION_BRANCH_STRICT_DETECTION = 5\n    }\n    interface NotificationSettings {\n        translatorNewStrings?: boolean;\n        managerNewStrings?: boolean;\n        managerLanguageCompleted?: boolean;\n    }\n    interface ListGroupsOptions extends PaginationOptions {\n        parentId?: number;\n        userId?: number;\n        orderBy?: string;\n    }\n    interface ListProjectsOptions extends PaginationOptions {\n        groupId?: number;\n        hasManagerAccess?: BooleanInt;\n        orderBy?: string;\n        type?: BooleanInt;\n    }\n    type Settings = PropertyFileFormatSettings | CommonFileFormatSettings | XmlFileFormatSettings | MdxV2FormatSettings | FmHtmlFormatSettings | HtmlFormatSettings | JsonFormatSettings | MdxV1FormatSettings | JavaScriptFileFormatSettings | DocxFileFormatSettings;\n    interface ProjectFileFormatSettings {\n        id: number;\n        name: string;\n        format: string;\n        extensions: string[];\n        settings: Settings;\n        createdAt: string;\n        updatedAt: string;\n    }\n    interface AddProjectFileFormatSettingsRequest {\n        format: string;\n        settings: Settings;\n    }\n    interface PropertyFileFormatSettings {\n        escapeQuotes?: 0 | 1 | 2 | 3;\n        escapeSpecialCharacters?: 0 | 1;\n        exportPattern?: string;\n    }\n    interface JavaScriptFileFormatSettings {\n        exportPattern?: 'string';\n        exportQuotes?: 'single' | 'double';\n    }\n    interface CommonFileFormatSettings {\n        contentSegmentation?: boolean;\n        srxStorageId?: number;\n        exportPattern?: string;\n    }\n    interface XmlFileFormatSettings extends CommonFileFormatSettings {\n        translateContent?: boolean;\n        translateAttributes?: boolean;\n        translatableElements?: string[];\n    }\n    interface JsonFormatSettings extends CommonFileFormatSettings {\n        type?: 'i18next_json' | 'nestjs_i18n';\n    }\n    interface MdxV2FormatSettings extends CommonFileFormatSettings {\n        excludeCodeBlocks?: boolean;\n        excludedFrontMatterElements?: string[];\n    }\n    interface MdxV1FormatSettings extends CommonFileFormatSettings {\n        excludeCodeBlocks?: boolean;\n        excludedFrontMatterElements?: string[];\n        type?: 'mdx_v1' | 'mdx_v2';\n    }\n    interface FmHtmlFormatSettings extends CommonFileFormatSettings {\n        excludedElements?: boolean;\n        excludedFrontMatterElements?: string[];\n    }\n    interface HtmlFormatSettings extends CommonFileFormatSettings {\n        excludedElements?: boolean;\n    }\n    interface DocxFileFormatSettings extends CommonFileFormatSettings {\n        cleanTagsAggressively?: boolean;\n        translateHiddenText?: boolean;\n        translateHyperlinkUrls?: boolean;\n        translateHiddenRowsAndColumns?: boolean;\n        importNotes?: boolean;\n        importHiddenSlides?: boolean;\n    }\n    type TmContextType = 'segmentContext' | 'auto' | 'prevAndNextSegment';\n    type WorkflowTemplateStepConfig = WorkflowTemplateStepConfigTranslateProofread | WorkflowTemplateStepConfigVendor | WorkflowTemplateStepConfigTMPreTranslate | WorkflowTemplateStepConfigMTPreTranslate;\n    interface WorkflowTemplateStepConfigTranslateProofread {\n        id: number;\n        languages?: string[];\n        assignees?: number[];\n        config?: {\n            assignees: {\n                [key: string]: number[];\n            };\n        };\n    }\n    interface WorkflowTemplateStepConfigVendor {\n        id: number;\n        languages?: string[];\n        vendorId?: number;\n    }\n    interface WorkflowTemplateStepConfigTMPreTranslate {\n        id: number;\n        languages?: string[];\n        config?: {\n            minRelevant?: number;\n            autoSubstitution?: boolean;\n        };\n    }\n    interface WorkflowTemplateStepConfigMTPreTranslate {\n        id: number;\n        languages?: string[];\n        mtId?: number;\n    }\n    type StringsExporterSettings = AndroidStringsExporterSettings | MacOSXStringsExporterSettings | XliffStringsExporterSettings;\n    interface ProjectStringsExporterSettings {\n        id: number;\n        format: string;\n        settings: StringsExporterSettings;\n        createdAt: string;\n        updatedAt: string;\n    }\n    interface AndroidStringsExporterSettings {\n        convertPlaceholders?: boolean;\n        convertLineBreaks?: boolean;\n        useCdataForStringsWithTags?: boolean;\n    }\n    interface MacOSXStringsExporterSettings {\n        convertPlaceholders?: boolean;\n        convertLineBreaks?: boolean;\n    }\n    interface XliffStringsExporterSettings {\n        languagePairMapping?: {\n            [key: string]: {\n                sourceLanguageId: string;\n            };\n        };\n        copySourceToEmptyTarget?: boolean;\n        exportTranslatorsComment?: boolean;\n    }\n    interface AddProjectStringsExporterSettingsRequest {\n        format: string;\n        settings: StringsExporterSettings;\n    }\n}\n```\n\n##### reports/index.d.ts\n\n```typescript\nimport { CrowdinApi, DownloadLink, PaginationOptions, PatchRequest, ResponseList, ResponseObject, Status } from '../core';\nexport declare class Reports extends CrowdinApi {\n    listOrganizationReportArchives(options?: ReportsModel.ListReportArchiveParams): Promise<ResponseList<ReportsModel.ReportArchive>>;\n    getOrganizationReportArchive(archiveId: number): Promise<ResponseObject<ReportsModel.ReportArchive>>;\n    deleteOrganizationReportArchive(archiveId: number): Promise<void>;\n    exportOrganizationReportArchive(archiveId: number, request?: {\n        format?: ReportsModel.Format;\n    }): Promise<ResponseObject<Status<ReportsModel.ReportArchiveStatusAttribute>>>;\n    checkOrganizationReportArchiveStatus(archiveId: number, exportId: string): Promise<ResponseObject<Status<ReportsModel.ReportArchiveStatusAttribute>>>;\n    downloadOrganizationReportArchive(archiveId: number, exportId: string): Promise<ResponseObject<DownloadLink>>;\n    listUserReportArchives(userId: number, options?: ReportsModel.ListReportArchiveParams): Promise<ResponseList<ReportsModel.ReportArchive>>;\n    getUserReportArchive(userId: number, archiveId: number): Promise<ResponseObject<ReportsModel.ReportArchive>>;\n    deleteUserReportArchive(userId: number, archiveId: number): Promise<void>;\n    exportUserReportArchive(userId: number, archiveId: number, request?: {\n        format?: ReportsModel.Format;\n    }): Promise<ResponseObject<Status<ReportsModel.ReportArchiveStatusAttribute>>>;\n    checkUserReportArchiveStatus(userId: number, archiveId: number, exportId: string): Promise<ResponseObject<Status<ReportsModel.ReportArchiveStatusAttribute>>>;\n    downloadUserReportArchive(userId: number, archiveId: number, exportId: string): Promise<ResponseObject<DownloadLink>>;\n    generateGroupReport(groupId: number, request: ReportsModel.GenerateGroupReportRequest): Promise<ResponseObject<Status<ReportsModel.ReportStatusAttributes<ReportsModel.GroupReportSchema>>>>;\n    checkGroupReportStatus(groupId: number, reportId: string): Promise<ResponseObject<Status<ReportsModel.ReportStatusAttributes<ReportsModel.GroupReportSchema>>>>;\n    downloadGroupReport(groupId: number, reportId: string): Promise<ResponseObject<DownloadLink>>;\n    listOrganizationReportSettingsTemplates(options?: ReportsModel.ListOrganizationReportSettingsParams): Promise<ResponseList<ReportsModel.OrganizationReportSettings>>;\n    addOrganizationReportSettingsTemplate(request: ReportsModel.AddOrganizationReportSettingsRequest): Promise<ResponseObject<ReportsModel.OrganizationReportSettings>>;\n    getOrganizationReportSettingsTemplate(reportSettingsTemplateId: number): Promise<ResponseObject<ReportsModel.OrganizationReportSettings>>;\n    editOrganizationReportSettingsTemplate(reportSettingsTemplateId: number, request: PatchRequest[]): Promise<ResponseObject<ReportsModel.OrganizationReportSettings>>;\n    deleteOrganizationReportSettingsTemplate(reportSettingsTemplateId: number): Promise<void>;\n    generateOrganizationReport(request: ReportsModel.GenerateOrganizationReportRequest): Promise<ResponseObject<Status<ReportsModel.ReportStatusAttributes<ReportsModel.OrganizationReportSchema>>>>;\n    checkOrganizationReportStatus(reportId: string): Promise<ResponseObject<Status<ReportsModel.ReportStatusAttributes<ReportsModel.OrganizationReportSchema>>>>;\n    downloadOrganizationReport(reportId: string): Promise<ResponseObject<DownloadLink>>;\n    generateReport(projectId: number, request: ReportsModel.GenerateReportRequest): Promise<ResponseObject<Status<ReportsModel.ReportStatusAttributes<ReportsModel.ReportSchema>>>>;\n    checkReportStatus(projectId: number, reportId: string): Promise<ResponseObject<Status<ReportsModel.ReportStatusAttributes<ReportsModel.ReportSchema>>>>;\n    downloadReport(projectId: number, reportId: string): Promise<ResponseObject<DownloadLink>>;\n    listReportSettingsTemplates(projectId: number, options?: PaginationOptions): Promise<ResponseList<ReportsModel.ReportSettings>>;\n    addReportSettingsTemplate(projectId: number, request: ReportsModel.AddReportSettingsRequest): Promise<ResponseObject<ReportsModel.ReportSettings>>;\n    getReportSettingsTemplate(projectId: number, reportSettingsTemplateId: number): Promise<ResponseObject<ReportsModel.ReportSettings>>;\n    editReportSettingsTemplate(projectId: number, reportSettingsTemplateId: number, request: PatchRequest[]): Promise<ResponseObject<ReportsModel.ReportSettings>>;\n    deleteReportSettingsTemplate(projectId: number, reportSettingsTemplateId: number): Promise<void>;\n    listUserReportSettingsTemplates(userId: number, options?: PaginationOptions): Promise<ResponseList<ReportsModel.UserReportSettings>>;\n    addUserReportSettingsTemplate(userId: number, request: ReportsModel.AddUserReportSettingsRequest): Promise<ResponseObject<ReportsModel.UserReportSettings>>;\n    getUserReportSettingsTemplate(userId: number, reportSettingsTemplateId: number): Promise<ResponseObject<ReportsModel.UserReportSettings>>;\n    editUserReportSettingsTemplate(userId: number, reportSettingsTemplateId: number, request: PatchRequest[]): Promise<ResponseObject<ReportsModel.UserReportSettings>>;\n    deleteUserReportSettingsTemplate(userId: number, reportSettingsTemplateId: number): Promise<void>;\n}\nexport declare namespace ReportsModel {\n    interface ReportArchive {\n        id: number;\n        scopeType: string;\n        scopeId: number;\n        userId: number;\n        name: string;\n        webUrl: string;\n        scheme: any;\n        createdAt: string;\n    }\n    interface ListReportArchiveParams extends PaginationOptions {\n        scopeType: string;\n        scopeId: number;\n    }\n    interface ReportArchiveStatusAttribute {\n        format: Format;\n        reportName: string;\n        schema: any;\n    }\n    type GroupReportSchema = GroupTranslationCostsPostEditingSchema | GroupTopMembersSchema | GroupTaskUsageSchema | GroupQaCheckIssuesSchema | GroupTranslationActivitySchema;\n    type OrganizationReportSchema = GroupTranslationCostsPostEditingSchema | GroupTopMembersSchema | GroupTaskUsageSchema | GroupQaCheckIssuesSchema | GroupTranslationActivitySchema;\n    interface GenerateGroupReportRequest {\n        name: string;\n        schema: GroupReportSchema;\n    }\n    interface GenerateOrganizationReportRequest {\n        name: string;\n        schema: OrganizationReportSchema;\n    }\n    interface GroupTranslationCostsPostEditingSchema {\n        projectIds?: number[];\n        unit?: Unit;\n        currency?: Currency;\n        format?: Format;\n        baseRates: BaseRate;\n        individualRates: IndividualRate[];\n        netRateSchemes: NetRateSchemas;\n        excludeApprovalsForEditedTranslations?: boolean;\n        preTranslatedStringsCategorizationAdjustment?: boolean;\n        groupBy?: GroupBy;\n        dateFrom?: string;\n        dateTo?: string;\n        userIds?: number[];\n    }\n    interface GroupTranslationCostsPerEditingByTaskSchema {\n        unit?: Unit;\n        currency?: Currency;\n        format?: Format;\n        baseRates: BaseRate;\n        individualRates: IndividualRate[];\n        netRateSchemes: NetRateSchemas;\n        taskId?: number;\n    }\n    interface CostsEstimationSchema {\n        projectIds?: number[];\n        unit?: Unit;\n        currency?: Currency;\n        format?: Format;\n        baseRates: BaseRate;\n        individualRates: IndividualRate[];\n        netRateSchemes: NetRateSchemas;\n        calculateInternalMatches?: boolean;\n        includePreTranslatedStrings?: boolean;\n        languageId?: string;\n        branchIds?: number[];\n        dateFrom?: string;\n        dateTo?: string;\n        labelIds?: number[];\n        labelIncludeType?: LabelIncludeType;\n    }\n    interface CostsEstimationByTaskSchema {\n        unit?: Unit;\n        currency?: Currency;\n        format?: Format;\n        baseRates?: BaseRate;\n        individualRates?: IndividualRate[];\n        netRateSchemes?: NetRateSchemas;\n        calculateInternalMatches?: boolean;\n        includePreTranslatedStrings?: boolean;\n        taskId?: number;\n    }\n    interface GroupTopMembersSchema {\n        projectIds?: number[];\n        unit?: Unit;\n        languageId?: string;\n        format?: Format;\n        dateFrom?: string;\n        dateTo?: string;\n    }\n    interface RawDataSchema {\n        mode: ContributionMode;\n        unit?: Unit;\n        languageId?: string;\n        userId?: number;\n        dateFrom?: string;\n        dateTo?: string;\n    }\n    type GenerateReportRequest = PreTranslateEfficeincy | PreTranslateAccuracy | TranslateAccuracy | CostEstimationPostEnding | TranslationCostsPostEnding | TopMembers | ContributionRawData | SourceContentUpdates | ProjectMembers | EditorIssues | QaCheckIssues | SavingActivity | TranslationActivity;\n    type ReportSchema = Pick<GenerateReportRequest, 'schema'>;\n    interface PreTranslateEfficeincy {\n        name: 'pre-translate-efficiency';\n        schema: PreTranslateAccuracySchema | PreTranslateAccuracySchemaByTask;\n    }\n    interface PreTranslateAccuracy {\n        name: 'pre-translate-accuracy';\n        schema: PreTranslateAccuracySchema | PreTranslateAccuracySchemaByTask;\n    }\n    interface TranslateAccuracy {\n        name: 'translator-accuracy';\n        schema: TranslateAccuracySchema;\n    }\n    interface CostEstimationPostEnding {\n        name: 'costs-estimation-pe';\n        schema: CostEstimationPostEndingSchema | CostEstimationPostEndingSchemaByTask;\n    }\n    interface TranslationCostsPostEnding {\n        name: 'translation-costs-pe';\n        schema: TranslationCostsPostEndingSchema | TranslationCostsPostEndingSchemaByTask;\n    }\n    interface TopMembers {\n        name: 'top-members';\n        schema: TopMembersSchema;\n    }\n    interface ContributionRawData {\n        name: 'contribution-raw-data';\n        schema: ContributionRawDataSchema | ContributionRawDataSchemaByTask;\n    }\n    interface SourceContentUpdates {\n        name: 'source-content-updates';\n        schema: SourceContentUpdatesSchema;\n    }\n    interface ProjectMembers {\n        name: 'project-members';\n        schema: MembersSchema;\n    }\n    interface EditorIssues {\n        name: 'editor-issues';\n        schema: EditorIssuesSchema;\n    }\n    interface QaCheckIssues {\n        name: 'qa-check-issues';\n        schema: ProjectQaCheckIssuesSchema;\n    }\n    interface SavingActivity {\n        name: 'saving-activity';\n        schema: SavingActivitySchema;\n    }\n    interface TranslationActivity {\n        name: 'translation-activity';\n        schema: ProjectConsumptionSchema;\n    }\n    interface ReportStatusAttributes<S> {\n        format: Format;\n        reportName: string;\n        schema: S;\n    }\n    interface PreTranslateAccuracySchema {\n        unit?: Unit;\n        format?: Format;\n        postEditingCategories?: string[];\n        languageId?: string;\n        dateFrom?: string;\n        dateTo?: string;\n    }\n    interface PreTranslateAccuracySchemaByTask {\n        unit?: Unit;\n        format?: Format;\n        postEditingCategories?: string[];\n        taskId?: number;\n    }\n    interface TranslateAccuracySchema {\n        unit?: Unit;\n        format?: Format;\n        postEditingCategories?: string[];\n        languageId?: string;\n        userIds?: number[];\n        dateFrom?: string;\n        dateTo?: string;\n    }\n    interface CostEstimationPostEndingSchema {\n        unit?: Unit;\n        currency?: Currency;\n        format?: Format;\n        baseRates: BaseRate;\n        individualRates: IndividualRate[];\n        netRateSchemes: Omit<NetRateSchemas, 'mtMatch' | 'suggestionMatch'>;\n        calculateInternalMatches?: boolean;\n        includePreTranslatedStrings?: boolean;\n        languageId?: string;\n        fileIds?: number[];\n        directoryIds?: number[];\n        branchIds?: number[];\n        dateFrom?: string;\n        dateTo?: string;\n        labelIds?: number[];\n        labelIncludeType?: LabelIncludeType;\n        workflowStepId?: number;\n    }\n    interface CostEstimationPostEndingSchemaByTask {\n        unit?: Unit;\n        currency?: Currency;\n        format?: Format;\n        baseRates?: BaseRate;\n        individualRates?: IndividualRate[];\n        netRateSchemes?: Omit<NetRateSchemas, 'mtMatch' | 'suggestionMatch'>;\n        calculateInternalMatches?: boolean;\n        includePreTranslatedStrings?: boolean;\n        taskId?: number;\n    }\n    interface TranslationCostsPostEndingSchemaByTask {\n        unit?: Unit;\n        currency?: Currency;\n        format?: Format;\n        baseRates: BaseRate;\n        individualRates: IndividualRate[];\n        netRateSchemes: NetRateSchemas;\n        taskId?: number;\n        excludeApprovalsForEditedTranslations?: boolean;\n        preTranslatedStringsCategorizationAdjustment?: boolean;\n    }\n    interface TranslationCostsPostEndingSchema {\n        unit?: Unit;\n        currency?: Currency;\n        format?: Format;\n        baseRates: BaseRate;\n        individualRates: IndividualRate[];\n        netRateSchemes: NetRateSchemas;\n        excludeApprovalsForEditedTranslations?: boolean;\n        preTranslatedStringsCategorizationAdjustment?: boolean;\n        groupBy?: GroupBy;\n        dateFrom?: string;\n        dateTo?: string;\n        languageId?: string;\n        userIds?: number[];\n        fileIds?: number[];\n        directoryIds?: number[];\n        branchIds?: number[];\n        labelIds?: number;\n        labelIncludeType?: LabelIncludeType;\n        workflowStepId?: number;\n    }\n    interface TopMembersSchema {\n        unit?: Unit;\n        languageId?: string;\n        format?: Format;\n        dateFrom?: string;\n        dateTo?: string;\n    }\n    interface ContributionRawDataSchema {\n        mode: ContributionMode;\n        unit?: Unit;\n        languageId?: string;\n        userId?: string;\n        columns?: Column[];\n        fileIds?: number[];\n        directoryIds?: number[];\n        branchIds?: number[];\n        tmIds?: number[];\n        mtIds?: number[];\n        aiPromptIds?: number[];\n        dateFrom?: string;\n        dateTo?: string;\n    }\n    interface ContributionRawDataSchemaByTask {\n        mode: ContributionMode;\n        unit?: Unit;\n        taskId: number;\n        columns?: Column[];\n        tmIds?: number[];\n        mtIds?: number[];\n        aiPromptIds?: number[];\n        dateFrom?: string;\n        dateTo?: string;\n    }\n    interface PreTranslateEfficiencySchema {\n        unit?: Unit;\n        format?: Format;\n        postEditingCategories?: string[];\n        languageId?: string;\n        dateFrom?: string;\n        dateTo?: string;\n    }\n    interface ListOrganizationReportSettingsParams extends PaginationOptions {\n        projectId?: number;\n        groupId?: number;\n    }\n    interface ReportSettings {\n        id: number;\n        name: string;\n        currency: Currency;\n        unit: Unit;\n        config: ReportSettinsConfig;\n        isPublic: boolean;\n        isGlobal: boolean;\n        createdAt: string;\n        updatedAt: string;\n    }\n    interface AddReportSettingsRequest {\n        name: string;\n        currency: Currency;\n        unit: Unit;\n        config: ReportSettinsConfig;\n        isPublic?: boolean;\n        isGlobal?: boolean;\n    }\n    type UserReportSettings = Omit<ReportSettings, 'isPublic' | 'isGlobal'>;\n    type AddUserReportSettingsRequest = Omit<AddReportSettingsRequest, 'isPublic' | 'isGlobal'>;\n    type OrganizationReportSettings = Omit<ReportSettings, 'isGlobal'> & {\n        projectId: number;\n        groupId: number;\n    };\n    type AddOrganizationReportSettingsRequest = Omit<AddReportSettingsRequest, 'isGlobal'> & {\n        projectId?: number;\n        groupId?: number;\n    };\n    interface ReportSettinsConfig {\n        baseRates: BaseRate;\n        netRateSchemes: NetRateSchemas[];\n        individualRates: IndividualRate[];\n    }\n    type Unit = 'strings' | 'words' | 'chars' | 'chars_with_spaces';\n    type Currency = 'USD' | 'EUR' | 'JPY' | 'GBP' | 'AUD' | 'CAD' | 'CHF' | 'CNY' | 'SEK' | 'NZD' | 'MXN' | 'SGD' | 'HKD' | 'NOK' | 'KRW' | 'TRY' | 'RUB' | 'INR' | 'BRL' | 'ZAR' | 'GEL' | 'UAH';\n    type Format = 'xlsx' | 'csv' | 'json';\n    interface BaseRate {\n        fullTranslation: number;\n        proofread: number;\n    }\n    interface IndividualRate extends BaseRate {\n        languageIds: string[];\n        userIds: number[];\n        fullTranslation: number;\n        proofread: number;\n    }\n    interface NetRateSchemas {\n        tmMatch: {\n            matchType: Mode;\n            price: number;\n        }[];\n        mtMatch: {\n            matchType: Mode;\n            price: number;\n        }[];\n        suggestionMatch: {\n            matchType: Mode;\n            price: number;\n        }[];\n        aiMatch?: {\n            matchType: Mode;\n            price: number;\n        }[];\n    }\n    type Mode = 'no_match' | 'tm_match' | 'approval' | '99-95' | '94-90' | '89-80' | 'perfect' | '100';\n    type ContributionMode = 'translations' | 'approvals' | 'votes';\n    type GroupBy = 'user' | 'language';\n    type LabelIncludeType = 'strings_with_label' | 'strings_without_label';\n    type Column = 'userId' | 'languageId' | 'stringId' | 'translationId' | 'fileId' | 'filePath' | 'pluralForm' | 'sourceStringTextHash' | 'mtEngine' | 'mtId' | 'tmName' | 'tmId' | 'aiPromptName' | 'aiPromptId' | 'preTranslated' | 'tmMatch' | 'mtMatch' | 'aiMatch' | 'suggestionMatch' | 'sourceUnits' | 'targetUnits' | 'createdAt' | 'updatedAt' | 'mark';\n    interface SourceContentUpdatesSchema {\n        unit?: Unit;\n        format?: Format;\n        dateFrom?: string;\n        dateTo?: string;\n        languageId?: string;\n        userIds?: number[];\n        fileIds?: number[];\n        directoryIds?: number[];\n        branchIds?: number[];\n        labelIds?: number[];\n        labelIncludeType?: LabelIncludeType;\n    }\n    interface MembersSchema {\n        format?: Format;\n        dateFrom?: string;\n        dateTo?: string;\n    }\n    interface EditorIssuesSchema {\n        dateFrom?: string;\n        dateTo?: string;\n        format?: Format;\n        languageId?: string;\n        userId?: number;\n    }\n    interface ProjectQaCheckIssuesSchema {\n        format?: Format;\n        dateFrom?: string;\n        dateTo?: string;\n        languageId?: string;\n    }\n    interface SavingActivitySchema {\n        unit?: Unit;\n        languageId?: string;\n        format?: Format;\n        dateFrom?: string;\n        dateTo?: string;\n        userIds?: number[];\n        fileIds?: number[];\n        directoryIds?: number[];\n        branchIds?: number[];\n        labelIds?: number[];\n        labelIncludeType?: LabelIncludeType;\n    }\n    interface ProjectConsumptionSchema {\n        unit?: Unit;\n        languageId?: string;\n        format?: Format;\n        dateFrom?: string;\n        dateTo?: string;\n        userIds?: number[];\n        fileIds?: number[];\n        directoryIds?: number[];\n        branchIds?: number[];\n        labelIds?: number[];\n        labelIncludeType?: LabelIncludeType;\n    }\n    interface GroupTaskUsageSchema {\n        format: Format;\n        type: 'workload' | 'create-vs-resolve' | 'performance' | 'time' | 'cost';\n        projectIds?: number[];\n        assigneeId?: number;\n        creatorId?: number;\n        dateFrom?: string;\n        dateTo?: string;\n        wordsCountFrom?: number;\n        wordsCountTo?: number;\n        excludeApprovalsForEditedTranslations?: boolean;\n        currency?: Currency;\n        baseRates?: BaseRate;\n        individualRates?: IndividualRate[];\n        netRateSchemes?: NetRateSchemas;\n    }\n    interface GroupQaCheckIssuesSchema {\n        projectIds?: number[];\n        format?: Format;\n        dateFrom?: string;\n        dateTo?: string;\n        languageId?: string;\n    }\n    interface GroupTranslationActivitySchema {\n        projectIds?: number[];\n        unit?: Unit;\n        languageId?: string;\n        format?: Format;\n        dateFrom?: string;\n        dateTo?: string;\n        userIds?: number[];\n        fileIds?: number[];\n        directoryIds?: number[];\n        branchIds?: number[];\n        labelIds?: number[];\n        labelIncludeType?: LabelIncludeType;\n    }\n}\n```\n\n##### screenshots/index.d.ts\n\n```typescript\nimport { CrowdinApi, PaginationOptions, PatchRequest, ResponseList, ResponseObject } from '../core';\nexport declare class Screenshots extends CrowdinApi {\n    listScreenshots(projectId: number, options?: ScreenshotsModel.ListScreenshotParams): Promise<ResponseList<ScreenshotsModel.Screenshot>>;\n    listScreenshots(projectId: number, limit?: number, offset?: number): Promise<ResponseList<ScreenshotsModel.Screenshot>>;\n    addScreenshot(projectId: number, request: ScreenshotsModel.CreateScreenshotRequest): Promise<ResponseObject<ScreenshotsModel.Screenshot>>;\n    getScreenshot(projectId: number, screenshotId: number): Promise<ResponseObject<ScreenshotsModel.Screenshot>>;\n    updateScreenshot(projectId: number, screenshotId: number, request: ScreenshotsModel.UpdateScreenshotRequest): Promise<ResponseObject<ScreenshotsModel.Screenshot>>;\n    deleteScreenshot(projectId: number, screenshotId: number): Promise<void>;\n    editScreenshot(projectId: number, screenshotId: number, request: PatchRequest[]): Promise<ResponseObject<ScreenshotsModel.Screenshot>>;\n    listScreenshotTags(projectId: number, screenshotId: number, options?: PaginationOptions): Promise<ResponseList<ScreenshotsModel.Tag>>;\n    listScreenshotTags(projectId: number, screenshotId: number, limit?: number, offset?: number): Promise<ResponseList<ScreenshotsModel.Tag>>;\n    replaceTags(projectId: number, screenshotId: number, request: ScreenshotsModel.ReplaceTagRequest[] | ScreenshotsModel.AutoTagRequest): Promise<void>;\n    addTag(projectId: number, screenshotId: number, request: ScreenshotsModel.ReplaceTagRequest[]): Promise<ResponseObject<ScreenshotsModel.Tag>>;\n    clearTags(projectId: number, screenshotId: number): Promise<void>;\n    getTag(projectId: number, screenshotId: number, tagId: number): Promise<ResponseObject<ScreenshotsModel.Tag>>;\n    deleteTag(projectId: number, screenshotId: number, tagId: number): Promise<void>;\n    updateTag(projectId: number, screenshotId: number, tagId: number, request: PatchRequest[]): Promise<ResponseObject<ScreenshotsModel.Screenshot>>;\n}\nexport declare namespace ScreenshotsModel {\n    interface ListScreenshotParams extends PaginationOptions {\n        stringIds?: number[];\n        stringId?: number;\n        labelIds?: string;\n        excludeLabelIds?: string;\n        orderBy?: string;\n    }\n    interface Screenshot {\n        id: number;\n        userId: number;\n        url: string;\n        webUrl: string;\n        name: string;\n        size: Size;\n        tagsCount: number;\n        tags: Tag[];\n        labels: number[];\n        labelIds: number[];\n        createdAt: string;\n        updatedAt: string;\n    }\n    interface CreateScreenshotRequest {\n        storageId: number;\n        name: string;\n        autoTag?: boolean;\n        fileId?: number;\n        branchId?: number;\n        directoryId?: number;\n        labelIds?: number[];\n    }\n    interface UpdateScreenshotRequest {\n        storageId: number;\n        name: string;\n    }\n    interface Tag {\n        id: number;\n        screenshotId: number;\n        stringId: number;\n        position: Position;\n        createdAt: string;\n    }\n    interface ReplaceTagRequest {\n        stringId: number;\n        position?: Position;\n    }\n    interface AutoTagRequest {\n        autoTag: boolean;\n        fileId?: number;\n        branchId?: number;\n        directoryId?: number;\n    }\n    interface Size {\n        width: number;\n        height: number;\n    }\n    interface Position {\n        x: number;\n        y: number;\n        width: number;\n        height: number;\n    }\n}\n```\n\n##### securityLogs/index.d.ts\n\n```typescript\nimport { CrowdinApi, PaginationOptions, ResponseList, ResponseObject } from '../core';\nexport declare class SecurityLogs extends CrowdinApi {\n    listOrganizationSecurityLogs(options?: SecurityLogsModel.ListOrganizationSecurityLogsParams): Promise<ResponseList<SecurityLogsModel.SecurityLog>>;\n    getOrganizationSecurityLog(securityLogId: number): Promise<ResponseObject<SecurityLogsModel.SecurityLog>>;\n    listUserSecurityLogs(userId: number, options?: SecurityLogsModel.ListUserSecurityLogsParams): Promise<ResponseList<SecurityLogsModel.SecurityLog>>;\n    getUserSecurityLog(userId: number, securityLogId: number): Promise<ResponseObject<SecurityLogsModel.SecurityLog>>;\n}\nexport declare namespace SecurityLogsModel {\n    type Event = 'login' | 'password.set' | 'password.change' | 'email.change' | 'login.change' | 'personal_token.issued' | 'personal_token.revoked' | 'mfa.enabled' | 'mfa.disabled' | 'session.revoke' | 'session.revoke_all' | 'sso.connect' | 'sso.disconnect' | 'user.remove' | 'application.connected' | 'application.disconnected' | 'webauthn.created' | 'webauthn.deleted' | 'trusted_device.remove' | 'trusted_device.remove_all' | 'device_verification.enabled' | 'device_verification.disabled';\n    interface ListOrganizationSecurityLogsParams extends PaginationOptions {\n        event?: Event;\n        createdAfter?: string;\n        createdBefore?: string;\n        ipAddress?: string;\n        userId?: number;\n    }\n    type ListUserSecurityLogsParams = Omit<ListOrganizationSecurityLogsParams, 'userId'>;\n    interface SecurityLog {\n        id: number;\n        event: string;\n        info: string;\n        userId: number;\n        location: string;\n        ipAddress: string;\n        deviceName: string;\n        createdAt: string;\n    }\n}\n```\n\n##### sourceFiles/index.d.ts\n\n```typescript\nimport { CrowdinApi, DownloadLink, PaginationOptions, PatchRequest, ResponseList, ResponseObject, Status } from '../core';\nexport declare class SourceFiles extends CrowdinApi {\n    getClonedBranch(projectId: number, branchId: number, cloneId: string): Promise<ResponseObject<SourceFilesModel.Branch>>;\n    clonedBranch(projectId: number, branchId: number, request: SourceFilesModel.CloneBranchRequest): Promise<ResponseObject<Status<object>>>;\n    checkBranchClonedStatus(projectId: number, branchId: number, cloneId: string): Promise<ResponseObject<Status<object>>>;\n    listProjectBranches(projectId: number, options?: SourceFilesModel.ListProjectBranchesOptions): Promise<ResponseList<SourceFilesModel.Branch>>;\n    listProjectBranches(projectId: number, name?: string, limit?: number, offset?: number): Promise<ResponseList<SourceFilesModel.Branch>>;\n    createBranch(projectId: number, request: SourceFilesModel.CreateBranchRequest): Promise<ResponseObject<SourceFilesModel.Branch>>;\n    getBranch(projectId: number, branchId: number): Promise<ResponseObject<SourceFilesModel.Branch>>;\n    deleteBranch(projectId: number, branchId: number): Promise<void>;\n    editBranch(projectId: number, branchId: number, request: PatchRequest[]): Promise<ResponseObject<SourceFilesModel.Branch>>;\n    mergeBranch(projectId: number, branchId: number, request: SourceFilesModel.MergeBranchRequest): Promise<ResponseObject<Status<SourceFilesModel.MergeBranchAttributes>>>;\n    checkBranchMergeStatus(projectId: number, branchId: number, mergeId: string): Promise<ResponseObject<Status<SourceFilesModel.MergeBranchAttributes>>>;\n    getBranchMergeSummary(projectId: number, branchId: number, mergeId: string): Promise<ResponseObject<SourceFilesModel.MergeBranchSummary>>;\n    listProjectDirectories(projectId: number, options?: SourceFilesModel.ListProjectDirectoriesOptions): Promise<ResponseList<SourceFilesModel.Directory>>;\n    listProjectDirectories(projectId: number, branchId?: number, directoryId?: number, limit?: number, offset?: number, filter?: string, recursion?: string): Promise<ResponseList<SourceFilesModel.Directory>>;\n    createDirectory(projectId: number, request: SourceFilesModel.CreateDirectoryRequest): Promise<ResponseObject<SourceFilesModel.Directory>>;\n    getDirectory(projectId: number, directoryId: number): Promise<ResponseObject<SourceFilesModel.Directory>>;\n    deleteDirectory(projectId: number, directoryId: number): Promise<void>;\n    editDirectory(projectId: number, directoryId: number, request: PatchRequest[]): Promise<ResponseObject<SourceFilesModel.Directory>>;\n    listProjectFiles(projectId: number, options?: SourceFilesModel.ListProjectFilesOptions): Promise<ResponseList<SourceFilesModel.File>>;\n    listProjectFiles(projectId: number, branchId?: number, directoryId?: number, limit?: number, offset?: number, recursion?: any, filter?: string): Promise<ResponseList<SourceFilesModel.File>>;\n    createFile(projectId: number, request: SourceFilesModel.CreateFileRequest): Promise<ResponseObject<SourceFilesModel.File>>;\n    getFile(projectId: number, fileId: number): Promise<ResponseObject<SourceFilesModel.File>>;\n    updateOrRestoreFile(projectId: number, fileId: number, request: SourceFilesModel.ReplaceFileFromStorageRequest | SourceFilesModel.RestoreFile): Promise<ResponseObject<SourceFilesModel.File>>;\n    deleteFile(projectId: number, fileId: number): Promise<void>;\n    editFile(projectId: number, fileId: number, request: PatchRequest[]): Promise<ResponseObject<SourceFilesModel.File>>;\n    downloadFilePreview(projectId: number, fileId: number): Promise<ResponseObject<DownloadLink>>;\n    downloadFile(projectId: number, fileId: number): Promise<ResponseObject<DownloadLink>>;\n    listAssetReferences(projectId: number, fileId: number, options?: PaginationOptions): Promise<ResponseList<SourceFilesModel.AssetReference>>;\n    getAssetReference(projectId: number, fileId: number, referenceId: number): Promise<ResponseObject<SourceFilesModel.AssetReference>>;\n    addAssetReference(projectId: number, fileId: number, request: SourceFilesModel.AssetReferenceRequest): Promise<ResponseObject<SourceFilesModel.AssetReference>>;\n    deleteAssetReference(projectId: number, fileId: number, referenceId: number): Promise<void>;\n    listFileRevisions(projectId: number, fileId: number, options?: PaginationOptions): Promise<ResponseList<SourceFilesModel.FileRevision>>;\n    listFileRevisions(projectId: number, fileId: number, limit?: number, offset?: number): Promise<ResponseList<SourceFilesModel.FileRevision>>;\n    getFileRevision(projectId: number, fileId: number, revisionId: number): Promise<ResponseObject<SourceFilesModel.FileRevision>>;\n    listReviewedSourceFilesBuild(projectId: number, options?: SourceFilesModel.ListReviewedSourceFilesBuildOptions): Promise<ResponseList<SourceFilesModel.ReviewedSourceFilesBuild>>;\n    listReviewedSourceFilesBuild(projectId: number, branchId?: number, limit?: number, offset?: number): Promise<ResponseList<SourceFilesModel.ReviewedSourceFilesBuild>>;\n    buildReviewedSourceFiles(projectId: number, request?: SourceFilesModel.BuildReviewedSourceFilesRequest): Promise<ResponseObject<SourceFilesModel.ReviewedSourceFilesBuild>>;\n    checkReviewedSourceFilesBuildStatus(projectId: number, buildId: number): Promise<ResponseObject<SourceFilesModel.ReviewedSourceFilesBuild>>;\n    downloadReviewedSourceFiles(projectId: number, buildId: number): Promise<ResponseObject<DownloadLink>>;\n}\nexport declare namespace SourceFilesModel {\n    interface Branch {\n        id: number;\n        projectId: number;\n        name: string;\n        title: string;\n        exportPattern: string;\n        priority: Priority;\n        createdAt: string;\n        updatedAt: string;\n    }\n    interface CreateBranchRequest {\n        name: string;\n        title?: string;\n        exportPattern?: string;\n        priority?: Priority;\n    }\n    interface CloneBranchRequest {\n        name: string;\n        title?: string;\n    }\n    interface MergeBranchRequest {\n        deleteAfterMerge?: boolean;\n        sourceBranchId: number;\n        acceptSourceChanges?: boolean;\n        dryRun?: boolean;\n    }\n    interface MergeBranchAttributes {\n        sourceBranchId: number;\n        deleteAfterMerge: boolean;\n        acceptSourceChanges?: boolean;\n    }\n    interface MergeBranchSummary {\n        status: string;\n        sourceBranchId: number;\n        targetBranchId: number;\n        dryRun: boolean;\n        details: {\n            added: number;\n            deleted: number;\n            updated: number;\n            conflicted: number;\n        };\n    }\n    type Priority = 'low' | 'normal' | 'high';\n    interface ListProjectDirectoriesOptions extends PaginationOptions {\n        branchId?: number;\n        directoryId?: number;\n        filter?: string;\n        recursion?: string;\n        orderBy?: string;\n    }\n    interface Directory {\n        id: number;\n        projectId: number;\n        branchId: number;\n        directoryId: number;\n        name: string;\n        title: string;\n        exportPattern: string;\n        path: string;\n        priority: Priority;\n        createdAt: string;\n        updatedAt: string;\n    }\n    interface CreateDirectoryRequest {\n        name: string;\n        branchId?: number;\n        directoryId?: number;\n        title?: string;\n        exportPattern?: string;\n        priority?: Priority;\n    }\n    interface ListProjectFilesOptions extends PaginationOptions {\n        branchId?: number;\n        directoryId?: number;\n        recursion?: any;\n        filter?: string;\n        orderBy?: string;\n    }\n    interface File {\n        id: number;\n        projectId: number;\n        branchId: number;\n        directoryId: number;\n        name: string;\n        title: string;\n        context: string;\n        type: string;\n        path: string;\n        status: string;\n        revisionId: number;\n        priority: Priority;\n        importOptions: ImportOptions;\n        exportOptions: GeneralExportOptions | PropertyExportOptions;\n        excludedTargetLanguages: string[];\n        parserVersion: number;\n        createdAt: string;\n        updatedAt: string;\n        fields: Record<string, any>;\n    }\n    interface CreateFileRequest {\n        storageId: number;\n        name: string;\n        branchId?: number;\n        directoryId?: number;\n        title?: string;\n        context?: string;\n        type?: FileType;\n        parserVersion?: number;\n        importOptions?: ImportOptions;\n        exportOptions?: ExportOptions;\n        excludedTargetLanguages?: string[];\n        attachLabelIds?: number[];\n        fields?: Record<string, any>;\n    }\n    interface ReplaceFileFromStorageRequest {\n        storageId: number;\n        name?: string;\n        updateOption?: UpdateOption;\n        importOptions?: ImportOptions;\n        exportOptions?: ExportOptions;\n        attachLabelIds?: number[];\n        detachLabelIds?: number[];\n        replaceModifiedContext?: boolean;\n    }\n    type ExportOptions = GeneralExportOptions | PropertyExportOptions | JavaScriptExportOptions | MdExportOptions;\n    type ImportOptions = SpreadsheetImportOptions | XmlImportOptions | WebXmlImportOptions | DocxFileImportOptions | HtmlFileImportOptions | HtmlFrontMatterFileImportOptions | MdxFileImportOptions | MdFileImportOptions | StringCatalogFileImportOptions | AdocFileImportOptions | OtherImportOptions;\n    interface RestoreFile {\n        revisionId: number;\n    }\n    interface FileRevision {\n        id: number;\n        projectId: number;\n        fileId: number;\n        restoreToRevision: number;\n        info: FileRevisionInfo;\n        date: string;\n    }\n    interface FileRevisionInfo {\n        added: FileRevisionInfoAttribute;\n        deleted: FileRevisionInfoAttribute;\n        updated: FileRevisionInfoAttribute;\n    }\n    interface FileRevisionInfoAttribute {\n        strings: number;\n        words: number;\n    }\n    type FileType = 'auto' | 'android' | 'macosx' | 'resx' | 'properties' | 'gettext' | 'yaml' | 'php' | 'json' | 'xml' | 'ini' | 'rc' | 'resw' | 'resjson' | 'qtts' | 'joomla' | 'chrome' | 'dtd' | 'dklang' | 'flex' | 'nsh' | 'wxl' | 'xliff' | 'xliff_two' | 'html' | 'haml' | 'txt' | 'csv' | 'md' | 'flsnp' | 'fm_html' | 'fm_md' | 'mediawiki' | 'docx' | 'xlsx' | 'sbv' | 'properties_play' | 'properties_xml' | 'maxthon' | 'go_json' | 'dita' | 'mif' | 'idml' | 'stringsdict' | 'plist' | 'vtt' | 'vdf' | 'srt' | 'stf' | 'toml' | 'contentful_rt' | 'svg' | 'js' | 'coffee' | 'nestjs_i18n' | 'webxml';\n    interface SpreadsheetImportOptions {\n        firstLineContainsHeader?: boolean;\n        contentSegmentation?: boolean;\n        srxStorageId?: number;\n        importTranslations?: boolean;\n        scheme?: Scheme;\n    }\n    interface Scheme {\n        none: number;\n        identifier: number;\n        sourcePhrase: number;\n        sourceOrTranslation: number;\n        translation: number;\n        context: number;\n        maxLength: number;\n        labels: number;\n        [key: string]: number;\n    }\n    interface XmlImportOptions {\n        translateContent?: boolean;\n        translateAttributes?: boolean;\n        inlineTags?: string[];\n        contentSegmentation?: boolean;\n        translatableElements?: string[];\n        srxStorageId?: number;\n    }\n    interface WebXmlImportOptions {\n        inlineTags?: string[];\n        contentSegmentation?: boolean;\n        srxStorageId?: number;\n    }\n    interface DocxFileImportOptions {\n        cleanTagsAggressively?: boolean;\n        translateHiddenText?: boolean;\n        translateHyperlinkUrls?: boolean;\n        translateHiddenRowsAndColumns?: boolean;\n        importNotes?: boolean;\n        importHiddenSlides?: boolean;\n        contentSegmentation?: boolean;\n        srxStorageId?: number;\n    }\n    interface HtmlFileImportOptions {\n        excludedElements?: string[];\n        inlineTags?: string[];\n        contentSegmentation?: boolean;\n        srxStorageId?: number;\n    }\n    interface HtmlFrontMatterFileImportOptions extends HtmlFileImportOptions {\n        excludedFrontMatterElements?: string[];\n    }\n    interface MdxFileImportOptions {\n        excludedFrontMatterElements?: string[];\n        excludeCodeBlocks?: boolean;\n        contentSegmentation?: boolean;\n        srxStorageId?: number;\n    }\n    interface MdFileImportOptions {\n        excludedFrontMatterElements?: string[];\n        excludeCodeBlocks?: boolean;\n        inlineTags?: string[];\n        contentSegmentation?: boolean;\n        srxStorageId?: number;\n    }\n    interface StringCatalogFileImportOptions {\n        importKeyAsSource?: boolean;\n    }\n    interface AdocFileImportOptions {\n        excludeIncludeDirectives?: boolean;\n    }\n    interface OtherImportOptions {\n        contentSegmentation: boolean;\n        srxStorageId: number;\n    }\n    interface GeneralExportOptions {\n        exportPattern?: string;\n    }\n    interface PropertyExportOptions {\n        escapeQuotes?: EscapeQuotes;\n        exportPattern?: string;\n        escapeSpecialCharacters?: 0 | 1;\n    }\n    interface JavaScriptExportOptions {\n        exportPattern?: string;\n        exportQuotes?: ExportQuotes;\n    }\n    interface MdExportOptions {\n        exportPattern?: string;\n        strongMarker?: 'asterisk' | 'underscore';\n        emphasisMarker?: 'asterisk' | 'underscore';\n        unorderedListBullet?: 'asterisks' | 'plus' | 'plus';\n        tableColumnWidth?: 'consolidate' | 'evenly_distribute_cells';\n    }\n    enum EscapeQuotes {\n        ZERO = 0,\n        ONE = 1,\n        TWO = 2,\n        THREE = 3\n    }\n    enum ExportQuotes {\n        SINGLE = \"single\",\n        DOUBLE = \"double\"\n    }\n    type UpdateOption = 'clear_translations_and_approvals' | 'keep_translations' | 'keep_translations_and_approvals';\n    interface ReviewedSourceFilesBuild {\n        id: number;\n        projectId: number;\n        status: string;\n        progress: number;\n        attributes: ReviewedSourceFilesBuildAttributes;\n    }\n    interface ReviewedSourceFilesBuildAttributes {\n        branchId: number;\n        targetLanguageId: string;\n    }\n    interface BuildReviewedSourceFilesRequest {\n        branchId?: number;\n    }\n    interface ListProjectBranchesOptions extends PaginationOptions {\n        name?: string;\n        orderBy?: string;\n    }\n    interface ListReviewedSourceFilesBuildOptions extends PaginationOptions {\n        branchId?: number;\n    }\n    interface User {\n        id: number;\n        username: string;\n        fullName: string;\n        avatarUrl: string;\n    }\n    interface AssetReference {\n        id: number;\n        name: string;\n        user: User;\n        createdAt: string;\n        mimeType: string;\n    }\n    interface AssetReferenceRequest {\n        storageId: number;\n        name: string;\n    }\n}\n```\n\n##### sourceStrings/index.d.ts\n\n```typescript\nimport { BooleanInt, CrowdinApi, PaginationOptions, PatchRequest, ResponseList, ResponseObject, Status } from '../core';\nimport { SourceFilesModel } from '../sourceFiles';\nexport declare class SourceStrings extends CrowdinApi {\n    uploadStringsStatus(projectId: number, uploadId: string): Promise<ResponseObject<Status<SourceStringsModel.UploadStringsStatus>>>;\n    uploadStrings(projectId: number, request: SourceStringsModel.UploadStringsRequest): Promise<ResponseObject<Status<SourceStringsModel.UploadStringsStatus>>>;\n    listProjectStrings(projectId: number, options?: SourceStringsModel.ListProjectStringsOptions): Promise<ResponseList<SourceStringsModel.String>>;\n    listProjectStrings(projectId: number, fileId?: number, limit?: number, offset?: number, filter?: string, denormalizePlaceholders?: BooleanInt, labelIds?: string, scope?: SourceStringsModel.Scope, croql?: string, branchId?: number, directoryId?: number): Promise<ResponseList<SourceStringsModel.String>>;\n    addString(projectId: number, request: SourceStringsModel.CreateStringRequest | SourceStringsModel.CreateStringStringsBasedRequest): Promise<ResponseObject<SourceStringsModel.String>>;\n    stringBatchOperations(projectId: number, request: PatchRequest[]): Promise<ResponseList<SourceStringsModel.String>>;\n    getString(projectId: number, stringId: number, query?: {\n        denormalizePlaceholders: BooleanInt;\n    }): Promise<ResponseObject<SourceStringsModel.String>>;\n    deleteString(projectId: number, stringId: number): Promise<void>;\n    editString(projectId: number, stringId: number, request: PatchRequest[]): Promise<ResponseObject<SourceStringsModel.String>>;\n}\nexport declare namespace SourceStringsModel {\n    type UploadStringsType = 'auto' | 'android' | 'macosx' | 'arb' | 'csv' | 'json' | 'xliff' | 'xliff_two' | 'xlsx';\n    interface UploadStringsStatus {\n        branchId: number;\n        storageId: number;\n        fileType: UploadStringsType;\n        parserVersion: number;\n        labelIds: number[];\n        importOptions: {\n            firstLineContainsHeader: boolean;\n            importTranslations: boolean;\n            scheme: SourceFilesModel.Scheme;\n        };\n        updateStrings: boolean;\n        cleanupMode: boolean;\n        updateOption: UpdateOption;\n    }\n    interface UploadStringsRequest {\n        branchId: number;\n        storageId: number;\n        type?: UploadStringsType;\n        parserVersion?: number;\n        labelIds?: number[];\n        updateStrings?: boolean;\n        cleanupMode?: boolean;\n        importOptions?: {\n            firstLineContainsHeader: boolean;\n            importTranslations: boolean;\n            scheme: SourceFilesModel.Scheme;\n        };\n        updateOption?: UpdateOption;\n    }\n    interface ListProjectStringsOptions extends PaginationOptions {\n        orderBy?: string;\n        denormalizePlaceholders?: BooleanInt;\n        labelIds?: string;\n        fileId?: number;\n        branchId?: number;\n        directoryId?: number;\n        taskId?: number;\n        croql?: string;\n        filter?: string;\n        scope?: SourceStringsModel.Scope;\n    }\n    interface String {\n        id: number;\n        projectId: number;\n        branchId: number;\n        identifier: string;\n        text: string | PluralText;\n        type: Type;\n        context: string;\n        maxLength: number;\n        isHidden: boolean;\n        isDuplicate: boolean;\n        masterStringId: boolean;\n        hasPlurals: boolean;\n        isIcu: boolean;\n        labelIds: number[];\n        webUrl: string;\n        createdAt: string;\n        updatedAt: string;\n        fileId: number;\n        directoryId: number;\n        revision: number;\n        fields: Record<string, any>;\n    }\n    interface CreateStringRequest {\n        text: string | PluralText;\n        identifier?: string;\n        fileId: number;\n        context?: string;\n        isHidden?: boolean;\n        maxLength?: number;\n        labelIds?: number[];\n        fields?: Record<string, any>;\n    }\n    interface CreateStringStringsBasedRequest {\n        text: string | PluralText;\n        identifier: string;\n        branchId: number;\n        context?: string;\n        isHidden?: boolean;\n        maxLength?: number;\n        labelIds?: number[];\n        fields?: Record<string, any>;\n    }\n    interface PluralText {\n        zero?: string;\n        one?: string;\n        two?: string;\n        few?: string;\n        many?: string;\n        other?: string;\n    }\n    enum Type {\n        TEXT = 0,\n        ASSET = 1,\n        ICU = 2\n    }\n    type Scope = 'identifier' | 'text' | 'context';\n    type UpdateOption = 'clear_translations_and_approvals' | 'keep_translations' | 'keep_translations_and_approvals';\n}\n```\n\n##### stringComments/index.d.ts\n\n```typescript\nimport { CrowdinApi, PaginationOptions, PatchRequest, ResponseList, ResponseObject } from '../core';\nexport declare class StringComments extends CrowdinApi {\n    listStringComments(projectId: number, options?: StringCommentsModel.ListStringCommentsOptions): Promise<ResponseList<StringCommentsModel.StringComment>>;\n    listStringComments(projectId: number, stringId?: number, type?: StringCommentsModel.Type, targetLanguageId?: string, issueType?: StringCommentsModel.IssueType, issueStatus?: StringCommentsModel.IssueStatus): Promise<ResponseList<StringCommentsModel.StringComment>>;\n    addStringComment(projectId: number, request: StringCommentsModel.AddStringCommentRequest): Promise<ResponseObject<StringCommentsModel.StringComment>>;\n    getStringComment(projectId: number, stringCommentId: number): Promise<ResponseObject<StringCommentsModel.StringComment>>;\n    deleteStringComment(projectId: number, stringCommentId: number): Promise<void>;\n    editStringComment(projectId: number, stringCommentId: number, request: PatchRequest[]): Promise<ResponseObject<StringCommentsModel.StringComment>>;\n    stringCommentBatchOperations(projectId: number, request: PatchRequest[]): Promise<ResponseList<StringCommentsModel.StringComment>>;\n}\nexport declare namespace StringCommentsModel {\n    interface ListStringCommentsOptions extends PaginationOptions {\n        stringId?: number;\n        type?: Type;\n        targetLanguageId?: string;\n        issueType?: IssueType;\n        issueStatus?: IssueStatus;\n        orderBy?: string;\n    }\n    interface StringComment {\n        id: number;\n        isShared?: boolean;\n        text: string;\n        userId: number;\n        stringId: number;\n        user: User;\n        string: StringModel;\n        projectId: number;\n        languageId: string;\n        type: Type;\n        issueType: IssueType;\n        issueStatus: IssueStatus;\n        resolverId: number;\n        senderOrganization: {\n            id: number;\n            domain: string;\n        };\n        resolverOrganization: {\n            id: number;\n            domain: string;\n        };\n        resolver: User;\n        resolvedAt: string;\n        createdAt: string;\n    }\n    interface User {\n        id: number;\n        username: string;\n        fullName: string;\n        avatarUrl: string;\n    }\n    interface StringModel {\n        id: number;\n        text: string;\n        type: string;\n        hasPlurals: boolean;\n        isIcu: boolean;\n        context: string;\n        fileId: number;\n    }\n    interface AddStringCommentRequest {\n        stringId: number;\n        text: string;\n        targetLanguageId: string;\n        type: Type;\n        isShared?: boolean;\n        issueType?: IssueType;\n    }\n    type Type = 'comment' | 'issue';\n    type IssueType = 'general_question' | 'translation_mistake' | 'context_request' | 'source_mistake';\n    type IssueStatus = 'unresolved' | 'resolved';\n}\n```\n\n##### stringCorrections/index.d.ts\n\n```typescript\nimport { BooleanInt, CrowdinApi, PaginationOptions, ResponseList, ResponseObject } from '../core';\nexport declare class StringCorrections extends CrowdinApi {\n    listStringCorrections(projectId: number, options: StringCorrectionsModel.ListStringCorrectionsParams): Promise<ResponseList<StringCorrectionsModel.StringCorrection>>;\n    addStringCorrection(projectId: number, request: StringCorrectionsModel.AddStringCorrectionRequest): Promise<ResponseObject<StringCorrectionsModel.StringCorrection>>;\n    deleteStringCorrections(projectId: number, stringId: number): Promise<void>;\n    getStringCorrection(projectId: number, correctionId: number, params?: {\n        denormalizePlaceholders?: BooleanInt;\n    }): Promise<ResponseObject<StringCorrectionsModel.StringCorrection>>;\n    restoreStringCorrection(projectId: number, correctionId: number): Promise<ResponseObject<StringCorrectionsModel.StringCorrection>>;\n    deleteStringCorrection(projectId: number, correctionId: number): Promise<void>;\n}\nexport declare namespace StringCorrectionsModel {\n    interface ListStringCorrectionsParams extends PaginationOptions {\n        stringId: number;\n        orderBy?: string;\n        denormalizePlaceholders?: BooleanInt;\n    }\n    interface StringCorrection {\n        id: number;\n        text: string;\n        pluralCategoryName: PluralCategoryName;\n        user: {\n            id: number;\n            username: string;\n            fullName: string;\n            avatarUrl: string;\n        };\n        createdAt: string;\n    }\n    type PluralCategoryName = 'zero' | 'one' | 'two' | 'few' | 'many' | 'other';\n    interface AddStringCorrectionRequest {\n        stringId: number;\n        text: string;\n        pluralCategoryName?: PluralCategoryName;\n    }\n}\n```\n\n##### stringTranslations/index.d.ts\n\n```typescript\nimport { BooleanInt, CrowdinApi, PaginationOptions, PatchRequest, ResponseList, ResponseObject } from '../core';\nexport declare class StringTranslations extends CrowdinApi {\n    listTranslationApprovals(projectId: number, options?: StringTranslationsModel.ListTranslationApprovalsOptions): Promise<ResponseList<StringTranslationsModel.Approval>>;\n    listTranslationApprovals(projectId: number, stringId?: number, languageId?: string, translationId?: number, limit?: number, offset?: number, fileId?: number, labelIds?: string, excludeLabelIds?: string): Promise<ResponseList<StringTranslationsModel.Approval>>;\n    addApproval(projectId: number, request: StringTranslationsModel.AddApprovalRequest): Promise<ResponseObject<StringTranslationsModel.Approval>>;\n    removeStringApprovals(projectId: number, stringId: number): Promise<void>;\n    approvalInfo(projectId: number, approvalId: number): Promise<ResponseObject<StringTranslationsModel.Approval>>;\n    approvalBatchOperations(projectId: number, request: PatchRequest[]): Promise<ResponseList<StringTranslationsModel.Approval>>;\n    removeApproval(projectId: number, approvalId: number): Promise<void>;\n    listLanguageTranslations(projectId: number, languageId: string, options?: StringTranslationsModel.ListLanguageTranslationsOptions): Promise<ResponseList<StringTranslationsModel.PlainLanguageTranslation | StringTranslationsModel.PluralLanguageTranslation | StringTranslationsModel.IcuLanguageTranslation>>;\n    listLanguageTranslations(projectId: number, languageId: string, stringIds?: string, fileId?: number, limit?: number, offset?: number, labelIds?: string, denormalizePlaceholders?: BooleanInt, croql?: string): Promise<ResponseList<StringTranslationsModel.PlainLanguageTranslation | StringTranslationsModel.PluralLanguageTranslation | StringTranslationsModel.IcuLanguageTranslation>>;\n    translationAlignment(projectId: number, request: StringTranslationsModel.TranslationAlignmentRequest): Promise<ResponseObject<StringTranslationsModel.TranslationAlignmentResponse>>;\n    listStringTranslations(projectId: number, stringId: number, languageId: string, options?: StringTranslationsModel.ListStringTranslationsOptions): Promise<ResponseList<StringTranslationsModel.StringTranslation>>;\n    listStringTranslations(projectId: number, stringId: number, languageId: string, limit?: number, offset?: number, denormalizePlaceholders?: BooleanInt): Promise<ResponseList<StringTranslationsModel.StringTranslation>>;\n    addTranslation(projectId: number, request: StringTranslationsModel.AddStringTranslationRequest): Promise<ResponseObject<StringTranslationsModel.StringTranslation>>;\n    deleteAllTranslations(projectId: number, stringId: number, languageId?: string): Promise<void>;\n    translationInfo(projectId: number, translationId: number): Promise<ResponseObject<StringTranslationsModel.StringTranslation>>;\n    restoreTranslation(projectId: number, translationId: number): Promise<ResponseObject<StringTranslationsModel.StringTranslation>>;\n    translationBatchOperations(projectId: number, request: PatchRequest[]): Promise<ResponseList<StringTranslationsModel.StringTranslation>>;\n    deleteTranslation(projectId: number, translationId: number): Promise<void>;\n    listTranslationVotes(projectId: number, options?: StringTranslationsModel.ListTranslationVotesOptions): Promise<ResponseList<StringTranslationsModel.Vote>>;\n    listTranslationVotes(projectId: number, stringId?: number, languageId?: string, translationId?: number, labelIds?: string, excludeLabelIds?: string, limit?: number, offset?: number): Promise<ResponseList<StringTranslationsModel.Vote>>;\n    addVote(projectId: number, request: StringTranslationsModel.AddVoteRequest): Promise<ResponseObject<StringTranslationsModel.Vote>>;\n    voteInfo(projectId: number, voteId: number): Promise<ResponseObject<StringTranslationsModel.Vote>>;\n    cancelVote(projectId: number, voteId: number): Promise<void>;\n}\nexport declare namespace StringTranslationsModel {\n    interface ListTranslationApprovalsOptions extends PaginationOptions {\n        stringId?: number;\n        languageId?: string;\n        translationId?: number;\n        fileId?: number;\n        labelIds?: string;\n        excludeLabelIds?: string;\n        orderBy?: string;\n    }\n    interface Approval {\n        id: number;\n        user: User;\n        translationId: number;\n        stringId: number;\n        languageId: string;\n        createdAt: string;\n    }\n    interface AddApprovalRequest {\n        translationId: number;\n    }\n    interface StringTranslation {\n        id: number;\n        text: string;\n        pluralCategoryName: PluralCategoryName;\n        user: User;\n        rating: number;\n        provider: string;\n        isPreTranslated: boolean;\n        createdAt: string;\n    }\n    interface ListLanguageTranslationsOptions extends PaginationOptions {\n        stringIds?: string;\n        fileId?: number;\n        labelIds?: string;\n        denormalizePlaceholders?: BooleanInt;\n        croql?: string;\n        approvedOnly?: BooleanInt;\n        passedWorkflow?: BooleanInt;\n        orderBy?: string;\n        branchId?: number;\n        minApprovalCount?: number;\n        directoryId?: number;\n    }\n    interface PlainLanguageTranslation {\n        stringId: number;\n        contentType: string;\n        translationId: number;\n        text: string;\n        user: User;\n        createdAt: string;\n    }\n    interface PluralLanguageTranslation {\n        stringId: number;\n        contentType: string;\n        plurals: Plural[];\n    }\n    interface IcuLanguageTranslation {\n        stringId: number;\n        contentType: string;\n        translationId: number;\n        text: string;\n        user: User;\n        createdAt: string;\n    }\n    interface Plural {\n        translationId: number;\n        text: string;\n        pluralForm: string;\n        user: User;\n        createdAt: string;\n    }\n    interface TranslationAlignmentRequest {\n        sourceLanguageId: string;\n        targetLanguageId: string;\n        text: string;\n    }\n    interface TranslationAlignmentResponse {\n        words: {\n            text: string;\n            alignments: {\n                sourceWord: string;\n                sourceLemma: string;\n                targetWord: string;\n                targetLemma: string;\n                match: number;\n                probability: number;\n            }[];\n        }[];\n    }\n    interface AddStringTranslationRequest {\n        stringId: number;\n        languageId: string;\n        text: string;\n        pluralCategoryName?: PluralCategoryName;\n        addToTm?: boolean;\n    }\n    interface ListTranslationVotesOptions extends PaginationOptions {\n        stringId?: number;\n        languageId?: string;\n        translationId?: number;\n        fileId?: number;\n        labelIds?: string;\n        excludeLabelIds?: string;\n    }\n    interface Vote {\n        id: number;\n        user: User;\n        translationId: number;\n        votedAt: string;\n        mark: Mark;\n    }\n    interface AddVoteRequest {\n        mark: Mark;\n        translationId: number;\n    }\n    interface User {\n        id: number;\n        username: string;\n        fullName: string;\n        avatarUrl: string;\n    }\n    type Mark = 'up' | 'down';\n    interface ListStringTranslationsOptions extends PaginationOptions {\n        denormalizePlaceholders?: BooleanInt;\n        orderBy?: string;\n    }\n    type PluralCategoryName = 'zero' | 'one' | 'two' | 'few' | 'many' | 'other';\n}\n```\n\n##### tasks/index.d.ts\n\n```typescript\nimport { BooleanInt, CrowdinApi, DownloadLink, PaginationOptions, PatchRequest, ResponseList, ResponseObject } from '../core';\nimport { LanguagesModel } from '../languages';\nexport declare class Tasks extends CrowdinApi {\n    listTasks(projectId: number, options?: TasksModel.ListTasksOptions): Promise<ResponseList<TasksModel.Task>>;\n    listTasks(projectId: number, limit?: number, offset?: number, status?: TasksModel.Status): Promise<ResponseList<TasksModel.Task>>;\n    addTask(projectId: number, request: TasksModel.CreateTaskRequest): Promise<ResponseObject<TasksModel.Task>>;\n    exportTaskStrings(projectId: number, taskId: number): Promise<ResponseObject<DownloadLink>>;\n    getTask(projectId: number, taskId: number): Promise<ResponseObject<TasksModel.Task>>;\n    deleteTask(projectId: number, taskId: number): Promise<void>;\n    editTask(projectId: number, taskId: number, request: PatchRequest[]): Promise<ResponseObject<TasksModel.Task>>;\n    listTasksComments(projectId: number, taskId: number, options?: PaginationOptions): Promise<ResponseList<TasksModel.TaskComment>>;\n    addTaskComment(projectId: number, taskId: number, request: TasksModel.CreateTaskCommentRequest): Promise<ResponseObject<TasksModel.TaskComment>>;\n    getTaskComment(projectId: number, taskId: number, commentId: number): Promise<ResponseObject<TasksModel.TaskComment>>;\n    deleteTaskComment(projectId: number, taskId: number, commentId: number): Promise<void>;\n    editTaskComment(projectId: number, taskId: number, commentId: number, request: PatchRequest[]): Promise<ResponseObject<TasksModel.TaskComment>>;\n    listUserTasks(options?: TasksModel.ListUserTasksOptions): Promise<ResponseList<TasksModel.UserTask>>;\n    listUserTasks(limit?: number, offset?: number, status?: TasksModel.Status, isArchived?: BooleanInt): Promise<ResponseList<TasksModel.UserTask>>;\n    editTaskArchivedStatus(projectId: number, taskId: number, request: PatchRequest[]): Promise<ResponseObject<TasksModel.UserTask>>;\n    listTaskSettingsTemplates(projectId: number, options?: PaginationOptions): Promise<ResponseList<TasksModel.TaskSettingsTemplate>>;\n    addTaskSettingsTemplate(projectId: number, request: TasksModel.AddTaskSettingsTemplate): Promise<ResponseObject<TasksModel.TaskSettingsTemplate>>;\n    getTaskSettingsTemplate(projectId: number, taskSettingsId: number): Promise<ResponseObject<TasksModel.TaskSettingsTemplate>>;\n    deleteTaskSettingsTemplate(projectId: number, taskSettingsId: number): Promise<void>;\n    editTaskSettingsTemplate(projectId: number, taskSettingsId: number, request: PatchRequest[]): Promise<ResponseObject<TasksModel.TaskSettingsTemplate>>;\n}\nexport declare namespace TasksModel {\n    interface Task {\n        id: number;\n        projectId: number;\n        creatorId: number;\n        type: Type | TypeVendor;\n        status: Status;\n        title: string;\n        assignees: Assignee[];\n        assignedTeams: AssignedTeam[];\n        progress: Progress;\n        translateProgress: Progress;\n        sourceLanguageId: string;\n        targetLanguageId: string;\n        description: string;\n        translationUrl: string;\n        webUrl: string;\n        wordsCount: number;\n        commentsCount: number;\n        deadline: string;\n        startedAt: string;\n        resolvedAt: string;\n        timeRange: string;\n        workflowStepId: number;\n        buyUrl: string;\n        createdAt: string;\n        updatedAt: string;\n        sourceLanguage: LanguagesModel.Language;\n        targetLanguages: LanguagesModel.Language[];\n        labelIds: number[];\n        excludeLabelIds: number[];\n        precedingTaskId: number;\n        filesCount: number;\n        fileIds: number[];\n        branchIds: number[];\n        vendor: string;\n        fields: Record<string, any>;\n    }\n    interface ListUserTasksOptions extends PaginationOptions {\n        status?: Status;\n        isArchived?: BooleanInt;\n        orderBy?: string;\n    }\n    interface UserTask extends Task {\n        isArchived: boolean;\n    }\n    type CreateTaskRequest = CreateTaskEnterpriseByBranchIds | CreateTaskEnterpriseByFileIds | CreateTaskEnterpriseByStringIds | CreateTaskEnterpriseVendorByBranchIds | CreateTaskEnterpriseVendorByFileIds | CreateTaskEnterpriseVendorByStringIds | CreateTaskEnterprisePendingTask | CreateTaskByFileIds | CreateTaskByStringIds | CreateTaskByBranchIds | CreateTaskByFileIdsLanguageService | CreateTaskByStringIdsLanguageService | CreateTaskByBranchIdsLanguageService | CreateTaskVendorOhtByFileIds | CreateTaskVendorOhtByStringIds | CreateTaskVendorOhtByBranchIds | CreateTaskVendorGengoByFileIds | CreateTaskVendorGengoByStringIds | CreateTaskVendorGengoByBranchIds | CreateTaskVendorManualByFileIds | CreateTaskVendorManualByStringIds | CreateTaskVendorManualByBranchIds | CreateTaskPendingTask | CreateTaskPendingTaskLanguageService | CreateTaskPendingTaskVendorManual;\n    interface CreateTaskEnterpriseByBranchIds {\n        type: Type;\n        workflowStepId: number;\n        title: string;\n        languageId: string;\n        branchIds: number[];\n        labelIds?: number[];\n        excludeLabelIds?: number[];\n        status?: RequestStatus;\n        description?: string;\n        splitContent?: boolean;\n        skipAssignedStrings?: boolean;\n        assignees?: CreateTaskAssignee[];\n        assignedTeams?: AssignedTeam[];\n        includePreTranslatedStringsOnly?: boolean;\n        deadline?: string;\n        startedAt?: string;\n        dateFrom?: string;\n        dateTo?: string;\n        fields?: Record<string, any>;\n    }\n    interface CreateTaskEnterpriseByStringIds {\n        type: Type;\n        workflowStepId: number;\n        title: string;\n        languageId: string;\n        stringIds: number[];\n        status?: RequestStatus;\n        description?: string;\n        splitContent?: boolean;\n        skipAssignedStrings?: boolean;\n        assignees?: CreateTaskAssignee[];\n        assignedTeams?: AssignedTeam[];\n        includePreTranslatedStringsOnly?: boolean;\n        deadline?: string;\n        startedAt?: string;\n        dateFrom?: string;\n        dateTo?: string;\n        fields?: Record<string, any>;\n    }\n    type CreateTaskEnterpriseVendorByStringIds = Omit<CreateTaskEnterpriseByStringIds, 'type' | 'status' | 'splitContent' | 'assignees' | 'assignedTeams'>;\n    type CreateTaskEnterpriseVendorByBranchIds = Omit<CreateTaskEnterpriseByBranchIds, 'type' | 'status' | 'splitContent' | 'assignees' | 'assignedTeams'>;\n    type CreateTaskEnterpriseByFileIds = Omit<CreateTaskEnterpriseByBranchIds, 'branchIds'> & {\n        fileIds: number[];\n    };\n    type CreateTaskEnterpriseVendorByFileIds = Omit<CreateTaskEnterpriseByFileIds, 'type' | 'status' | 'splitContent' | 'assignees' | 'assignedTeams'>;\n    interface CreateTaskEnterprisePendingTask {\n        precedingTaskId: number;\n        type: Type.PROOFREAD;\n        title: string;\n        description?: string;\n        assignees?: CreateTaskAssignee[];\n        assignedTeams?: AssignedTeam[];\n        deadline?: string;\n    }\n    interface CreateTaskByFileIds {\n        title: string;\n        languageId: string;\n        type: Type;\n        fileIds: number[];\n        labelIds?: number[];\n        excludeLabelIds?: number[];\n        status?: RequestStatus;\n        description?: string;\n        splitContent?: boolean;\n        skipAssignedStrings?: boolean;\n        includePreTranslatedStringsOnly?: boolean;\n        assignees?: CreateTaskAssignee[];\n        deadline?: string;\n        startedAt?: string;\n        dateFrom?: string;\n        dateTo?: string;\n    }\n    type CreateTaskByStringIds = Omit<CreateTaskByFileIds, 'fileIds' | 'labelIds' | 'excludeLabelIds'> & {\n        stringIds: number;\n    };\n    type CreateTaskByBranchIds = Omit<CreateTaskByFileIds, 'fileIds'> & {\n        branchIds: number;\n    };\n    interface CreateTaskByFileIdsLanguageService {\n        title: string;\n        languageId: string;\n        type: TypeVendor;\n        vendor: 'crowdin_language_service';\n        fileIds: number[];\n        labelIds?: number[];\n        excludeLabelIds?: number[];\n        status?: RequestStatus;\n        description?: string;\n        includePreTranslatedStringsOnly?: boolean;\n        assignees?: CreateTaskAssignee[];\n        dateFrom?: string;\n        dateTo?: string;\n    }\n    type CreateTaskByStringIdsLanguageService = Omit<CreateTaskByFileIdsLanguageService, 'fileIds' | 'labelIds' | 'excludeLabelIds'> & {\n        stringIds: number[];\n    };\n    type CreateTaskByBranchIdsLanguageService = Omit<CreateTaskByFileIdsLanguageService, 'fileIds'> & {\n        branchIds: number[];\n    };\n    interface CreateTaskVendorOhtByFileIds {\n        title: string;\n        languageId: string;\n        type: TypeVendor;\n        vendor: 'oht';\n        fileIds: number[];\n        labelIds?: number[];\n        excludeLabelIds?: number[];\n        status?: RequestStatus;\n        description?: string;\n        expertise?: Expertise;\n        editService?: boolean;\n        includePreTranslatedStringsOnly?: boolean;\n        dateFrom?: string;\n        dateTo?: string;\n    }\n    type CreateTaskVendorOhtByStringIds = Omit<CreateTaskVendorOhtByFileIds, 'fileIds' | 'labelIds' | 'excludeLabelIds'> & {\n        stringIds: number[];\n    };\n    type CreateTaskVendorOhtByBranchIds = Omit<CreateTaskVendorOhtByFileIds, 'fileIds'> & {\n        branchIds: number[];\n    };\n    interface CreateTaskVendorGengoByFileIds {\n        title: string;\n        languageId: string;\n        type: TypeVendor.TRANSLATE_BY_VENDOR;\n        vendor: 'gengo';\n        fileIds: number[];\n        labelIds?: number[];\n        excludeLabelIds?: number[];\n        status?: RequestStatus;\n        description?: string;\n        expertise?: 'standard' | 'pro';\n        tone?: Tone;\n        purpose?: Purpose;\n        customerMessage?: string;\n        usePreferred?: boolean;\n        editService?: boolean;\n        dateFrom?: string;\n        dateTo?: string;\n    }\n    type CreateTaskVendorGengoByStringIds = Omit<CreateTaskVendorGengoByFileIds, 'fileIds' | 'labelIds' | 'excludeLabelIds'> & {\n        stringIds: number[];\n    };\n    type CreateTaskVendorGengoByBranchIds = Omit<CreateTaskVendorGengoByFileIds, 'fileIds'> & {\n        branchIds: number[];\n    };\n    interface CreateTaskVendorManualByFileIds {\n        title: string;\n        languageId: string;\n        type: TypeVendor;\n        vendor: 'alconost' | 'babbleon' | 'tomedes' | 'e2f' | 'write_path_admin' | 'inlingo' | 'acclaro' | 'translate_by_humans' | 'lingo24' | 'assertio_language_services' | 'gte_localize' | 'kettu_solutions' | 'languageline_solutions';\n        fileIds: number[];\n        labelIds?: number[];\n        excludeLabelIds?: number[];\n        status?: RequestStatus;\n        description?: string;\n        skipAssignedStrings?: boolean;\n        includePreTranslatedStringsOnly?: boolean;\n        assignees?: CreateTaskAssignee[];\n        deadline?: string;\n        startedAt?: string;\n        dateFrom?: string;\n        dateTo?: string;\n    }\n    type CreateTaskVendorManualByStringIds = Omit<CreateTaskVendorManualByFileIds, 'fileIds' | 'labelIds' | 'excludeLabelIds'> & {\n        stringIds: number[];\n    };\n    type CreateTaskVendorManualByBranchIds = Omit<CreateTaskVendorManualByFileIds, 'fileIds'> & {\n        branchIds: number[];\n    };\n    interface CreateTaskPendingTask {\n        precedingTaskId: number;\n        type: Type.PROOFREAD;\n        title: string;\n        description?: string;\n        assignees?: CreateTaskAssignee[];\n        deadline?: string;\n    }\n    interface CreateTaskPendingTaskLanguageService {\n        precedingTaskId: number;\n        type: TypeVendor.PROOFREAD_BY_VENDOR;\n        vendor: 'crowdin_language_service';\n        title: string;\n        description?: string;\n        deadline?: string;\n    }\n    interface CreateTaskPendingTaskVendorManual {\n        precedingTaskId: number;\n        type: TypeVendor.PROOFREAD_BY_VENDOR;\n        vendor: CreateTaskVendorManualByFileIds['vendor'];\n        title: string;\n        description?: string;\n        deadline?: string;\n    }\n    interface CreateTaskAssignee {\n        id: number;\n        wordsCount?: number;\n    }\n    type Status = 'todo' | 'in_progress' | 'done' | 'closed';\n    type RequestStatus = Extract<Status, 'todo' | 'in_progress'>;\n    enum Type {\n        TRANSLATE = 0,\n        PROOFREAD = 1\n    }\n    enum TypeVendor {\n        TRANSLATE_BY_VENDOR = 2,\n        PROOFREAD_BY_VENDOR = 3\n    }\n    interface Assignee {\n        id: number;\n        username: string;\n        fullName: string;\n        avatarUrl: string;\n        wordsCount: number;\n        wordsLeft: number;\n    }\n    interface AssignedTeam {\n        id: number;\n        wordsCount: number;\n    }\n    interface Progress {\n        total: number;\n        done: number;\n        percent: number;\n    }\n    type Expertise = 'standard' | 'mobile-applications' | 'software-it' | 'gaming-video-games' | 'technical-engineering' | 'marketing-consumer-media' | 'business-finance' | 'legal-certificate' | 'medical' | 'ad-words-banners' | 'automotive-aerospace' | 'scientific' | 'scientific-academic' | 'tourism' | 'training-employee-handbooks' | 'forex-crypto';\n    enum TranslatedExpertise {\n        ECONOMY = \"P\",\n        PROFESSIONAL = \"T\",\n        PREMIUM = \"R\"\n    }\n    type Tone = '' | 'Informal' | 'Friendly' | 'Business' | 'Formal' | 'other';\n    type Purpose = 'standard' | 'Personal use' | 'Business' | 'Online content' | 'App/Web localization' | 'Media content' | 'Semi-technical' | 'other';\n    type Subject = 'general' | 'accounting_finance' | 'aerospace_defence' | 'architecture' | 'art' | 'automotive' | 'certificates_diplomas_licences_cv_etc' | 'chemical' | 'civil_engineering_construction' | 'corporate_social_responsibility' | 'cosmetics' | 'culinary' | 'electronics_electrical_engineering' | 'energy_power_generation_oil_gas' | 'environment' | 'fashion' | 'games_viseogames_casino' | 'general_business_commerce' | 'history_archaeology' | 'information_technology' | 'insurance' | 'internet_e-commerce' | 'legal_documents_contracts' | 'literary_translations' | 'marketing_advertising_material_public_relations' | 'matematics_and_physics' | 'mechanical_manufacturing' | 'media_journalism_publishing' | 'medical_pharmaceutical' | 'music' | 'private_correspondence_letters' | 'religion' | 'science' | 'shipping_sailing_maritime' | 'social_science' | 'telecommunications' | 'travel_tourism';\n    interface ListTasksOptions extends PaginationOptions {\n        status?: TasksModel.Status;\n        assigneeId?: number;\n        orderBy?: string;\n    }\n    interface TaskSettingsTemplate {\n        id: number;\n        name: string;\n        config: TaskSettingsTemplateConfig;\n        createdAt: string;\n        updatedAt: string;\n    }\n    interface AddTaskSettingsTemplate {\n        name: string;\n        config: TaskSettingsTemplateConfig;\n    }\n    interface TaskSettingsTemplateConfig {\n        languages: {\n            languageId?: string;\n            userIds?: number[];\n            teamIds?: number[];\n        }[];\n    }\n    interface TaskComment {\n        id: number;\n        userId: number;\n        taskId: number;\n        text: string;\n        timeSpent: number;\n        createdAt: string;\n        updatedAt: string;\n    }\n    interface CreateTaskCommentRequest {\n        text?: string;\n        timeSpent?: number;\n    }\n}\n```\n\n##### teams/index.d.ts\n\n```typescript\nimport { CrowdinApi, Pagination, PaginationOptions, PatchRequest, ProjectRole, ProjectRoles, ResponseList, ResponseObject } from '../core';\nimport { ProjectsGroupsModel } from '../projectsGroups';\nexport declare class Teams extends CrowdinApi {\n    listGroupTeams(groupId: number, options?: TeamsModel.ListGroupTeamsOptions): Promise<ResponseList<TeamsModel.TeamGroup>>;\n    updateGroupTeams(groupId: number, request: PatchRequest[]): Promise<ResponseList<TeamsModel.TeamGroup>>;\n    getGroupTeam(groupId: number, teamId: number): Promise<ResponseObject<TeamsModel.TeamGroup>>;\n    listTeamProjectPermissions(teamId: number, options?: PaginationOptions): Promise<ResponseList<TeamsModel.ProjectPermissions>>;\n    editTeamProjectPermissions(teamId: number, request: PatchRequest[]): Promise<ResponseList<TeamsModel.ProjectPermissions>>;\n    addTeamToProject(projectId: number, request: TeamsModel.AddTeamToProjectRequest): Promise<TeamsModel.ProjectTeamResources>;\n    listTeams(options?: TeamsModel.ListTeamsOptions): Promise<ResponseList<TeamsModel.Team>>;\n    listTeams(limit?: number, offset?: number): Promise<ResponseList<TeamsModel.Team>>;\n    addTeam(request: TeamsModel.AddTeamRequest): Promise<ResponseObject<TeamsModel.Team>>;\n    getTeam(teamId: number): Promise<ResponseObject<TeamsModel.Team>>;\n    deleteTeam(teamId: number): Promise<void>;\n    editTeam(teamId: number, request: PatchRequest[]): Promise<ResponseObject<TeamsModel.Team>>;\n    teamMembersList(teamId: number, options?: PaginationOptions): Promise<ResponseList<TeamsModel.TeamMember>>;\n    teamMembersList(teamId: number, limit?: number, offset?: number): Promise<ResponseList<TeamsModel.TeamMember>>;\n    addTeamMembers(teamId: number, request: TeamsModel.AddTeamMembersRequest): Promise<TeamsModel.AddTeamMembersResponse>;\n    deleteAllTeamMembers(teamId: number): Promise<void>;\n    deleteTeamMember(teamId: number, memberId: number): Promise<void>;\n}\nexport declare namespace TeamsModel {\n    interface ListGroupTeamsOptions extends PaginationOptions {\n        orderBy?: string;\n    }\n    interface ProjectPermissions {\n        id: number;\n        roles: ProjectRole[];\n        project: ProjectsGroupsModel.Project | ProjectsGroupsModel.ProjectSettings;\n    }\n    interface AddTeamToProjectRequest {\n        teamId: number;\n        managerAccess?: boolean;\n        developerAccess?: boolean;\n        roles?: ProjectRole[];\n        accessToAllWorkflowSteps?: boolean;\n        permissions?: Permissions;\n    }\n    interface ListTeamsOptions extends PaginationOptions {\n        search?: string;\n        projectIds?: string;\n        projectRoles?: ProjectRoles[];\n        languageIds?: string;\n        groupIds?: string;\n        orderBy?: string;\n    }\n    interface ProjectTeamResources {\n        skipped: ProjectTeamResource;\n        added: ProjectTeamResource;\n    }\n    interface ProjectTeamResource {\n        id: number;\n        hasManagerAccess: boolean;\n        hasDeveloperAccess: boolean;\n        hasAccessToAllWorkflowSteps: boolean;\n        permissions: Permissions;\n        roles: ProjectRole[];\n    }\n    interface Permissions {\n        [lang: string]: {\n            workflowStepIds: number[] | 'all';\n        };\n    }\n    interface Team {\n        id: number;\n        name: string;\n        totalMembers: number;\n        webUrl: string;\n        createdAt: string;\n        updatedAt: string;\n    }\n    interface TeamGroup {\n        id: number;\n        team: Team;\n    }\n    interface AddTeamRequest {\n        name: string;\n    }\n    interface TeamMember {\n        id: number;\n        username: string;\n        firstName: string;\n        lastName: string;\n        avatarUrl: string;\n        addedAt: string;\n    }\n    interface AddTeamMembersRequest {\n        userIds: number[];\n    }\n    interface AddTeamMembersResponse {\n        skipped: ResponseObject<TeamMember>[];\n        added: ResponseObject<TeamMember>[];\n        pagination: Pagination;\n    }\n}\n```\n\n##### translationMemory/index.d.ts\n\n```typescript\nimport { CrowdinApi, DownloadLink, PaginationOptions, PatchRequest, ResponseList, ResponseObject, Status } from '../core';\nexport declare class TranslationMemory extends CrowdinApi {\n    listTm(options?: TranslationMemoryModel.ListTMsOptions): Promise<ResponseList<TranslationMemoryModel.TranslationMemory>>;\n    listTm(groupId?: number, limit?: number, offset?: number): Promise<ResponseList<TranslationMemoryModel.TranslationMemory>>;\n    addTm(request: TranslationMemoryModel.AddTranslationMemoryRequest): Promise<ResponseObject<TranslationMemoryModel.TranslationMemory>>;\n    getTm(tmId: number): Promise<ResponseObject<TranslationMemoryModel.TranslationMemory>>;\n    deleteTm(tmId: number): Promise<void>;\n    editTm(tmId: number, request: PatchRequest[]): Promise<ResponseObject<TranslationMemoryModel.TranslationMemory>>;\n    listTmSegments(tmId: number, options?: TranslationMemoryModel.ListSegmentsOptions): Promise<ResponseList<TranslationMemoryModel.TMSegment>>;\n    addTmSegment(tmId: number, request: TranslationMemoryModel.AddTMSegment): Promise<ResponseObject<TranslationMemoryModel.TMSegment>>;\n    clearTm(tmId: number): Promise<void>;\n    exportTm(tmId: number, request?: TranslationMemoryModel.ExportTranslationMemoryRequest): Promise<ResponseObject<Status<TranslationMemoryModel.ExportTranslationMemoryAttribute>>>;\n    checkExportStatus(tmId: number, exportId: string): Promise<ResponseObject<Status<TranslationMemoryModel.ExportTranslationMemoryAttribute>>>;\n    downloadTm(tmId: number, exportId: string): Promise<ResponseObject<DownloadLink>>;\n    concordanceSearch(projectId: number, request: TranslationMemoryModel.ConcordanceSearchRequest): Promise<ResponseList<TranslationMemoryModel.ConcordanceSearchResponse>>;\n    importTm(tmId: number, request: TranslationMemoryModel.ImportTranslationMemoryRequest): Promise<ResponseObject<Status<TranslationMemoryModel.ImportTranslationMemoryAttribute>>>;\n    checkImportStatus(tmId: number, importId: string): Promise<ResponseObject<Status<TranslationMemoryModel.ImportTranslationMemoryAttribute>>>;\n    getTmSegment(tmId: number, segmentId: number): Promise<ResponseObject<TranslationMemoryModel.TMSegment>>;\n    deleteTmSegment(tmId: number, segmentId: number): Promise<void>;\n    editTmSegment(tmId: number, segmentId: number, request: PatchRequest[]): Promise<ResponseObject<TranslationMemoryModel.TMSegment>>;\n    deleteTmSegmentRecord(tmId: number, segmentId: number, recordId: number): Promise<void>;\n    editTmSegmentRecord(tmId: number, segmentId: number, recordId: number, request: PatchRequest[]): Promise<ResponseObject<TranslationMemoryModel.TMSegment>>;\n    addTmSegmentRecords(tmId: number, segmentId: number, request: TranslationMemoryModel.AddTMSegment): Promise<ResponseObject<TranslationMemoryModel.TMSegment>>;\n}\nexport declare namespace TranslationMemoryModel {\n    interface TranslationMemory {\n        id: number;\n        groupId: number;\n        userId: number;\n        name: string;\n        languageId: string;\n        languageIds: string[];\n        segmentsCount: number;\n        defaultProjectIds: number[];\n        projectIds: number[];\n        createdAt: string;\n        webUrl: string;\n    }\n    interface AddTranslationMemoryRequest {\n        name: string;\n        languageId: string;\n        groupId?: number;\n    }\n    interface ConcordanceSearchRequest {\n        sourceLanguageId: string;\n        targetLanguageId: string;\n        autoSubstitution: boolean;\n        minRelevant: number;\n        expressions: string[];\n        expression?: string;\n    }\n    interface ConcordanceSearchResponse {\n        tm: TranslationMemory;\n        recordId: number;\n        source: string;\n        target: string;\n        relevant: number;\n        substituted: string;\n        updatedAt: string;\n    }\n    interface ExportTranslationMemoryRequest {\n        sourceLanguageId?: number;\n        targetLanguageId?: number;\n        format?: Format;\n    }\n    interface ImportTranslationMemoryRequest {\n        storageId: number;\n        firstLineContainsHeader?: boolean;\n        scheme?: Scheme;\n    }\n    interface ExportTranslationMemoryAttribute {\n        sourceLanguageId: string;\n        targetLanguageId: string;\n        format: string;\n    }\n    interface ImportTranslationMemoryAttribute {\n        tmId: number;\n        storageId: number;\n        firstLineContainsHeader: number;\n        scheme: Scheme;\n    }\n    type Format = 'tmx' | 'csv' | 'xlsx';\n    interface Scheme {\n        [key: string]: number;\n    }\n    interface ListTMsOptions extends PaginationOptions {\n        groupId?: number;\n        userId?: number;\n        orderBy?: string;\n    }\n    interface ListSegmentsOptions extends PaginationOptions {\n        croql?: string;\n        orderBy?: string;\n    }\n    interface TMSegment {\n        id: number;\n        records: TMSegmentRecord[];\n    }\n    interface TMSegmentRecord {\n        id: number;\n        languageId: string;\n        text: string;\n        usageCount: number;\n        createdBy: number;\n        updatedBy: number;\n        createdAt: string;\n        updatedAt: string;\n    }\n    interface AddTMSegment {\n        records: AddTMSegmentRecord[];\n    }\n    interface AddTMSegmentRecord {\n        languageId: string;\n        text: string;\n    }\n}\n```\n\n##### translationStatus/index.d.ts\n\n```typescript\nimport { CrowdinApi, PaginationOptions, ResponseList } from '../core';\nimport { LanguagesModel } from '../languages';\nexport declare class TranslationStatus extends CrowdinApi {\n    getBranchProgress(projectId: number, branchId: number, options?: PaginationOptions): Promise<ResponseList<TranslationStatusModel.LanguageProgress>>;\n    getBranchProgress(projectId: number, branchId: number, limit?: number, offset?: number): Promise<ResponseList<TranslationStatusModel.LanguageProgress>>;\n    getDirectoryProgress(projectId: number, directoryId: number, options?: PaginationOptions): Promise<ResponseList<TranslationStatusModel.LanguageProgress>>;\n    getDirectoryProgress(projectId: number, directoryId: number, limit?: number, offset?: number): Promise<ResponseList<TranslationStatusModel.LanguageProgress>>;\n    getFileProgress(projectId: number, fileId: number, options?: PaginationOptions): Promise<ResponseList<TranslationStatusModel.LanguageProgress>>;\n    getFileProgress(projectId: number, fileId: number, limit?: number, offset?: number): Promise<ResponseList<TranslationStatusModel.LanguageProgress>>;\n    getLanguageProgress(projectId: number, languageId: string, options?: PaginationOptions): Promise<ResponseList<TranslationStatusModel.FileProgress>>;\n    getLanguageProgress(projectId: number, languageId: string, limit?: number, offset?: number): Promise<ResponseList<TranslationStatusModel.FileProgress>>;\n    getProjectProgress(projectId: number, options?: PaginationOptions): Promise<ResponseList<TranslationStatusModel.LanguageProgress>>;\n    getProjectProgress(projectId: number, limit?: number, offset?: number, languageIds?: string): Promise<ResponseList<TranslationStatusModel.LanguageProgress>>;\n    listQaCheckIssues(projectId: number, options?: TranslationStatusModel.ListQaCheckIssuesOptions): Promise<ResponseList<TranslationStatusModel.QaCheck>>;\n    listQaCheckIssues(projectId: number, limit?: number, offset?: number, category?: TranslationStatusModel.Category, validation?: TranslationStatusModel.Validation, languageIds?: string): Promise<ResponseList<TranslationStatusModel.QaCheck>>;\n}\nexport declare namespace TranslationStatusModel {\n    interface LanguageProgress {\n        words: Words;\n        phrases: Words;\n        translationProgress: number;\n        approvalProgress: number;\n        eTag: string;\n        languageId: string;\n        language: LanguagesModel.Language;\n    }\n    interface FileProgress {\n        words: Words;\n        phrases: Words;\n        translationProgress: number;\n        approvalProgress: number;\n        branchId: number;\n        fileId: number;\n        eTag: string;\n    }\n    interface Words {\n        total: number;\n        translated: number;\n        approved: number;\n        preTranslateAppliedTo: number;\n    }\n    type Category = 'empty' | 'variables' | 'tags' | 'punctuation' | 'symbol_register' | 'spaces' | 'size' | 'special_symbols' | 'wrong_translation' | 'spellcheck' | 'icu';\n    type Validation = 'empty_string_check' | 'empty_suggestion_check' | 'max_length_check' | 'tags_check' | 'mismatch_ids_check' | 'cdata_check' | 'specials_symbols_check' | 'leading_newlines_check' | 'trailing_newlines_check' | 'leading_spaces_check' | 'trailing_spaces_check' | 'multiple_spaces_check' | 'custom_blocked_variables_check' | 'highest_priority_custom_variables_check' | 'highest_priority_variables_check' | 'c_variables_check' | 'python_variables_check' | 'rails_variables_check' | 'java_variables_check' | 'dot_net_variables_check' | 'twig_variables_check' | 'php_variables_check' | 'freemarker_variables_check' | 'lowest_priority_variable_check' | 'lowest_priority_custom_variables_check' | 'punctuation_check' | 'spaces_before_punctuation_check' | 'spaces_after_punctuation_check' | 'non_breaking_spaces_check' | 'capitalize_check' | 'multiple_uppercase_check' | 'parentheses_check' | 'entities_check' | 'escaped_quotes_check' | 'wrong_translation_issue_check' | 'spellcheck' | 'icu_check';\n    interface ListQaCheckIssuesOptions extends PaginationOptions {\n        category?: Category | Category[];\n        validation?: Validation | Validation[];\n        languageIds?: string;\n    }\n    interface QaCheck {\n        stringId: number;\n        languageId: string;\n        category: Category;\n        categoryDescription: string;\n        validation: Validation;\n        validationDescription: string;\n        pluralId: number;\n        text: string;\n    }\n    interface GetProjectProgressOptions extends PaginationOptions {\n        languageIds?: string;\n    }\n}\n```\n\n##### translations/index.d.ts\n\n```typescript\nimport { CrowdinApi, DownloadLink, PaginationOptions, PatchRequest, ResponseList, ResponseObject, Status } from '../core';\nimport { ProjectsGroupsModel } from '../projectsGroups';\nexport declare class Translations extends CrowdinApi {\n    listPreTranslations(projectId: number, options?: PaginationOptions): Promise<ResponseList<Status<TranslationsModel.PreTranslationStatusAttributes>>>;\n    preTranslationStatus(projectId: number, preTranslationId: string): Promise<ResponseObject<Status<TranslationsModel.PreTranslationStatusAttributes>>>;\n    applyPreTranslation(projectId: number, request: TranslationsModel.PreTranslateRequest | TranslationsModel.PreTranslateStringsRequest): Promise<ResponseObject<Status<TranslationsModel.PreTranslationStatusAttributes>>>;\n    editPreTranslation(projectId: number, preTranslationId: string, request: PatchRequest[]): Promise<ResponseObject<Status<TranslationsModel.PreTranslationStatusAttributes>>>;\n    getPreTranslationReport(projectId: number, preTranslationId: string): Promise<ResponseObject<TranslationsModel.PreTranslationReport>>;\n    buildProjectDirectoryTranslation(projectId: number, directoryId: number, request?: TranslationsModel.BuildProjectDirectoryTranslationRequest): Promise<ResponseObject<TranslationsModel.BuildProjectDirectoryTranslationResponse>>;\n    buildProjectFileTranslation(projectId: number, fileId: number, request: TranslationsModel.BuildProjectFileTranslationRequest, eTag?: string): Promise<ResponseObject<TranslationsModel.BuildProjectFileTranslationResponse>>;\n    listProjectBuilds(projectId: number, options?: TranslationsModel.ListProjectBuildsOptions): Promise<ResponseList<TranslationsModel.Build>>;\n    listProjectBuilds(projectId: number, branchId?: number, limit?: number, offset?: number): Promise<ResponseList<TranslationsModel.Build>>;\n    buildProject(projectId: number, request?: TranslationsModel.BuildRequest | TranslationsModel.PseudoBuildRequest): Promise<ResponseObject<TranslationsModel.Build>>;\n    uploadTranslation(projectId: number, languageId: string, request: TranslationsModel.UploadTranslationRequest): Promise<ResponseObject<TranslationsModel.UploadTranslationResponse>>;\n    uploadTranslationStrings(projectId: number, languageId: string, request: TranslationsModel.UploadTranslationStringsRequest): Promise<ResponseObject<TranslationsModel.UploadTranslationStringsResponse>>;\n    downloadTranslations(projectId: number, buildId: number): Promise<ResponseObject<DownloadLink>>;\n    checkBuildStatus(projectId: number, buildId: number): Promise<ResponseObject<TranslationsModel.Build>>;\n    cancelBuild(projectId: number, buildId: number): Promise<void>;\n    exportProjectTranslation(projectId: number, request: TranslationsModel.ExportProjectTranslationRequest): Promise<ResponseObject<DownloadLink>>;\n}\nexport declare namespace TranslationsModel {\n    interface PreTranslateRequest {\n        languageIds: string[];\n        fileIds: number[];\n        method?: Method;\n        engineId?: number;\n        aiPromptId?: number;\n        autoApproveOption?: AutoApproveOption;\n        duplicateTranslations?: boolean;\n        skipApprovedTranslations?: boolean;\n        translateUntranslatedOnly?: boolean;\n        translateWithPerfectMatchOnly?: boolean;\n        fallbackLanguages?: {\n            languageId?: string[];\n        };\n        labelIds?: number[];\n        excludeLabelIds?: number[];\n    }\n    interface PreTranslateStringsRequest {\n        languageIds: string[];\n        branchIds?: number[];\n        method?: Method;\n        engineId?: number;\n        aiPromptId?: number;\n        autoApproveOption?: AutoApproveOption;\n        duplicateTranslations?: boolean;\n        skipApprovedTranslations?: boolean;\n        translateUntranslatedOnly?: boolean;\n        translateWithPerfectMatchOnly?: boolean;\n        fallbackLanguages?: {\n            languageId: string[];\n        };\n        labelIds?: number[];\n        excludeLabelIds?: number[];\n    }\n    interface BuildProjectDirectoryTranslationRequest {\n        targetLanguageIds?: string[];\n        skipUntranslatedStrings?: boolean;\n        skipUntranslatedFiles?: boolean;\n        preserveFolderHierarchy?: boolean;\n        exportStringsThatPassedWorkflow?: boolean;\n        exportWithMinApprovalsCount?: number;\n        exportApprovedOnly?: boolean;\n    }\n    interface BuildProjectDirectoryTranslationResponse {\n        id: number;\n        projectId: number;\n        status: BuildStatus;\n        progress: number;\n        createdAt: string;\n        updatedAt: string;\n        finishedAt: string;\n    }\n    type BuildStatus = 'created' | 'inProgress' | 'canceled' | 'failed' | 'finished';\n    interface BuildProjectFileTranslationRequest {\n        targetLanguageId: string;\n        exportAsXliff?: boolean;\n        skipUntranslatedStrings?: boolean;\n        skipUntranslatedFiles?: boolean;\n        exportApprovedOnly?: boolean;\n        exportWithMinApprovalsCount?: number;\n        exportStringsThatPassedWorkflow?: boolean;\n    }\n    interface BuildProjectFileTranslationResponse extends DownloadLink {\n        etag: string;\n    }\n    interface PreTranslationStatusAttributes {\n        languageIds: string[];\n        fileIds: number[];\n        branchIds: number[];\n        method: Method;\n        autoApproveOption: AutoApproveOption;\n        duplicateTranslations: boolean;\n        skipApprovedTranslations: boolean;\n        translateUntranslatedOnly: boolean;\n        translateWithPerfectMatchOnly: boolean;\n    }\n    type Method = 'tm' | 'mt' | 'ai';\n    type AutoApproveOption = 'all' | 'exceptAutoSubstituted' | 'perfectMatchOnly' | 'none';\n    type CharTransformation = 'asian' | 'european' | 'arabic' | 'cyrillic';\n    interface Build {\n        id: number;\n        projectId: number;\n        status: BuildStatus;\n        progress: number;\n        attributes: Attribute;\n        createdAt: string;\n        updatedAt: string;\n        finishedAt: string;\n    }\n    interface Attribute {\n        branchId: number;\n        directoryId: number;\n        targetLanguageIds: string[];\n        skipUntranslatedStrings: boolean;\n        skipUntranslatedFiles: boolean;\n        exportApprovedOnly: boolean;\n        exportWithMinApprovalsCount: number;\n        exportStringsThatPassedWorkflow: boolean;\n    }\n    interface BuildRequest {\n        branchId?: number;\n        targetLanguageIds?: string[];\n        skipUntranslatedStrings?: boolean;\n        skipUntranslatedFiles?: boolean;\n        exportApprovedOnly?: boolean;\n        exportWithMinApprovalsCount?: number;\n        exportStringsThatPassedWorkflow?: boolean;\n    }\n    interface PseudoBuildRequest {\n        pseudo: boolean;\n        branchId?: number;\n        prefix?: string;\n        suffix?: string;\n        lengthTransformation?: number;\n        charTransformation?: CharTransformation;\n    }\n    interface UploadTranslationRequest {\n        storageId: number;\n        fileId?: number;\n        importEqSuggestions?: boolean;\n        autoApproveImported?: boolean;\n        translateHidden?: boolean;\n        addToTm?: boolean;\n    }\n    interface UploadTranslationStringsRequest {\n        storageId: number;\n        branchId?: number;\n        importEqSuggestions?: boolean;\n        autoApproveImported?: boolean;\n        translateHidden?: boolean;\n        addToTm?: boolean;\n    }\n    interface UploadTranslationResponse {\n        projectId: number;\n        storageId: number;\n        languageId: string;\n        fileId: number;\n    }\n    interface UploadTranslationStringsResponse {\n        projectId: number;\n        storageId: number;\n        languageId: string;\n        branchId: number;\n    }\n    interface ExportProjectTranslationRequest {\n        targetLanguageId: string;\n        format?: string;\n        labelIds?: number[];\n        branchIds?: number[];\n        directoryIds?: number[];\n        fileIds?: number[];\n        skipUntranslatedStrings?: boolean;\n        skipUntranslatedFiles?: boolean;\n        exportApprovedOnly?: boolean;\n        exportWithMinApprovalsCount?: number;\n        exportStringsThatPassedWorkflow?: boolean;\n    }\n    interface ListProjectBuildsOptions extends PaginationOptions {\n        branchId?: number;\n    }\n    interface PreTranslationReport {\n        languages: TargetLanguage[];\n        preTranslateType: Method;\n    }\n    interface TargetLanguage {\n        id: string;\n        files: TargetLanguageFile[];\n        skipped: SkippedInfo;\n        skippedQaCheckCategories: ProjectsGroupsModel.CheckCategories;\n    }\n    interface TargetLanguageFile {\n        id: string;\n        statistics: TargetLanguageFileStatistics;\n    }\n    interface TargetLanguageFileStatistics {\n        phrases: number;\n        words: number;\n    }\n    interface SkippedInfo {\n        [key: string]: any;\n    }\n}\n```\n\n##### uploadStorage/index.d.ts\n\n```typescript\nimport { CrowdinApi, PaginationOptions, ResponseList, ResponseObject } from '../core';\nexport declare class UploadStorage extends CrowdinApi {\n    listStorages(options?: PaginationOptions): Promise<ResponseList<UploadStorageModel.Storage>>;\n    listStorages(limit?: number, offset?: number): Promise<ResponseList<UploadStorageModel.Storage>>;\n    addStorage(fileName: string, request: any, contentType?: string): Promise<ResponseObject<UploadStorageModel.Storage>>;\n    getStorage(storageId: number): Promise<ResponseObject<UploadStorageModel.Storage>>;\n    deleteStorage(storageId: number): Promise<void>;\n}\nexport declare namespace UploadStorageModel {\n    interface Storage {\n        id: number;\n        fileName: string;\n    }\n}\n```\n\n##### users/index.d.ts\n\n```typescript\nimport { CrowdinApi, Pagination, PaginationOptions, PatchRequest, ProjectRole, ProjectRoles, ResponseList, ResponseObject } from '../core';\nimport { ProjectsGroupsModel } from '../projectsGroups';\nimport { TeamsModel } from '../teams';\nexport declare class Users extends CrowdinApi {\n    listGroupManagers(groupId: number, options?: UsersModel.ListGroupManagersOptions): Promise<ResponseList<UsersModel.GroupManager>>;\n    updateGroupManagers(groupId: number, request: PatchRequest[]): Promise<ResponseList<UsersModel.GroupManager>>;\n    getGroupManager(groupId: number, userId: number): Promise<ResponseObject<UsersModel.GroupManager>>;\n    listProjectMembers(projectId: number, options?: UsersModel.ListProjectMembersOptions): Promise<ResponseList<UsersModel.ProjectMember | UsersModel.EnterpriseProjectMember>>;\n    listProjectMembers(projectId: number, search?: string, role?: UsersModel.Role, languageId?: string, limit?: number, offset?: number): Promise<ResponseList<UsersModel.ProjectMember | UsersModel.EnterpriseProjectMember>>;\n    addProjectMember(projectId: number, request: UsersModel.AddProjectMemberRequest): Promise<UsersModel.AddProjectMemberResponse>;\n    getProjectMemberPermissions(projectId: number, memberId: number): Promise<ResponseObject<UsersModel.ProjectMember | UsersModel.EnterpriseProjectMember>>;\n    replaceProjectMemberPermissions(projectId: number, memberId: number, request?: UsersModel.ReplaceProjectMemberRequest): Promise<ResponseObject<UsersModel.ProjectMember | UsersModel.EnterpriseProjectMember>>;\n    deleteMemberFromProject(projectId: number, memberId: number): Promise<void>;\n    listUsers(options?: UsersModel.ListUsersOptions): Promise<ResponseList<UsersModel.User>>;\n    listUsers(status?: UsersModel.Status, search?: string, twoFactor?: UsersModel.TwoFactor, limit?: number, offset?: number): Promise<ResponseList<UsersModel.User>>;\n    inviteUser(request: UsersModel.InviteUserRequest): Promise<ResponseObject<UsersModel.User>>;\n    getUserInfo(userId: number): Promise<ResponseObject<UsersModel.User>>;\n    deleteUser(userId: number): Promise<void>;\n    editUser(userId: number, request: PatchRequest[]): Promise<ResponseObject<UsersModel.User>>;\n    getAuthenticatedUser(): Promise<ResponseObject<UsersModel.User>>;\n    editAuthenticatedUser(request: PatchRequest[]): Promise<ResponseObject<UsersModel.User>>;\n    listUserProjectPermissions(userId: number, options?: PaginationOptions): Promise<ResponseList<UsersModel.ProjectPermissions>>;\n    editUserProjectPermissions(userId: number, request: PatchRequest[]): Promise<ResponseList<UsersModel.ProjectPermissions>>;\n    listUserProjectContributions(userId: number, options?: PaginationOptions): Promise<ResponseList<UsersModel.ProjectPermissions>>;\n}\nexport declare namespace UsersModel {\n    interface ListGroupManagersOptions extends PaginationOptions {\n        teamIds?: number[];\n        orderBy?: string;\n    }\n    interface ListProjectMembersOptions extends PaginationOptions {\n        search?: string;\n        role?: Role;\n        languageId?: string;\n        workflowStepId?: number;\n        orderBy?: string;\n    }\n    interface ListUsersOptions extends PaginationOptions {\n        status?: Status;\n        search?: string;\n        twoFactor?: TwoFactor;\n        orderBy?: string;\n        organizationRoles?: OrganizationRoles[];\n        teamId?: number;\n        projectIds?: string;\n        projectRoles?: ProjectRoles[];\n        languageIds?: string;\n        groupIds?: string;\n        lastSeenFrom?: string;\n        lastSeenTo?: string;\n    }\n    interface InviteUserRequest {\n        email: string;\n        firstName?: string;\n        lastName?: string;\n        timezone?: string;\n        adminAccess?: boolean;\n    }\n    interface User {\n        id: number;\n        username: string;\n        email: string;\n        firstName: string;\n        lastName: string;\n        status: Status;\n        avatarUrl: string;\n        fields: Record<string, any>;\n        createdAt: string;\n        lastSeen: string;\n        twoFactor: TwoFactor;\n        isAdmin: boolean;\n        timezone: string;\n        emailVerified: string;\n    }\n    type Status = 'active' | 'pending' | 'blocked';\n    type TwoFactor = 'enabled' | 'disabled';\n    type OrganizationRoles = 'admin' | 'manager' | 'vendor' | 'client';\n    interface GroupManager {\n        id: number;\n        user: User;\n        teams: TeamsModel.Team[];\n    }\n    interface ProjectMember {\n        id: number;\n        username: string;\n        fullName: string;\n        role: Role;\n        permissions: Permissions;\n        avatarUrl: string;\n        joinedAt: string;\n        timezone: string;\n        roles: ProjectRole[];\n    }\n    interface EnterpriseProjectMember {\n        id: number;\n        username: string;\n        firstName: string;\n        lastName: string;\n        isManager: boolean;\n        isDeveloperr: boolean;\n        managerOfGroup: Group;\n        accessToAllWorkflowSteps: boolean;\n        permissions: Permissions;\n        givenAccessAt: string;\n        roles: ProjectRole[];\n    }\n    interface Group {\n        id: number;\n        name: string;\n    }\n    type Role = 'all' | 'owner' | 'manager' | 'proofreader' | 'translator' | 'blocked';\n    type LanguageRole = 'proofreader' | 'translator' | 'denied';\n    interface AddProjectMemberRequest {\n        userIds?: number[];\n        usernames?: string[];\n        emails?: string[];\n        managerAccess?: boolean;\n        roles?: ProjectRole[];\n        developerAccess?: boolean;\n        accessToAllWorkflowSteps?: boolean;\n        permissions?: Permissions;\n    }\n    interface AddProjectMemberResponse {\n        skipped: ResponseObject<ProjectMember | EnterpriseProjectMember>[];\n        added: ResponseObject<ProjectMember | EnterpriseProjectMember>[];\n        pagination: Pagination;\n    }\n    interface ReplaceProjectMemberRequest {\n        managerAccess?: boolean;\n        developerAccess?: boolean;\n        roles?: ProjectRole[];\n        accessToAllWorkflowSteps?: boolean;\n        permissions?: Permissions;\n    }\n    interface ProjectPermissions {\n        id: number;\n        roles: ProjectRole[];\n        project: ProjectsGroupsModel.Project | ProjectsGroupsModel.ProjectSettings;\n        teams: TeamsModel.Team[];\n    }\n    interface Contributions {\n        id: number;\n        translated: Contribution;\n        approved: Contribution;\n        voted: Contribution;\n        commented: Contribution;\n        project: ProjectsGroupsModel.Project | ProjectsGroupsModel.ProjectSettings;\n    }\n    interface Contribution {\n        strings: number;\n        words?: number;\n    }\n    interface Permissions {\n        [lang: string]: string | {\n            workflowStepIds: number[] | 'all';\n        };\n    }\n}\n```\n\n##### vendors/index.d.ts\n\n```typescript\nimport { CrowdinApi, PaginationOptions, ResponseList } from '../core';\nexport declare class Vendors extends CrowdinApi {\n    listVendors(options?: PaginationOptions): Promise<ResponseList<VendorsModel.Vendor>>;\n    listVendors(limit?: number, offset?: number): Promise<ResponseList<VendorsModel.Vendor>>;\n}\nexport declare namespace VendorsModel {\n    interface Vendor {\n        id: number;\n        name: string;\n        description: string;\n        status: 'pending' | 'confirmed' | 'rejected';\n        webUrl: string;\n    }\n}\n```\n\n##### webhooks/index.d.ts\n\n```typescript\nimport { CrowdinApi, PaginationOptions, PatchRequest, ResponseList, ResponseObject } from '../core';\nexport declare class Webhooks extends CrowdinApi {\n    listWebhooks(projectId: number, options?: PaginationOptions): Promise<ResponseList<WebhooksModel.Webhook>>;\n    listWebhooks(projectId: number, limit?: number, offset?: number): Promise<ResponseList<WebhooksModel.Webhook>>;\n    addWebhook(projectId: number, request: WebhooksModel.AddWebhookRequest): Promise<ResponseObject<WebhooksModel.Webhook>>;\n    getWebhook(projectId: number, webhookId: number): Promise<ResponseObject<WebhooksModel.Webhook>>;\n    deleteWebhook(projectId: number, webhookId: number): Promise<void>;\n    editWebhook(projectId: number, webhookId: number, request: PatchRequest[]): Promise<ResponseObject<WebhooksModel.Webhook>>;\n}\nexport declare namespace WebhooksModel {\n    interface Webhook {\n        id: number;\n        projectId: number;\n        name: string;\n        url: string;\n        events: Event[];\n        headers: Record<string, string>;\n        payload: Record<string, any>;\n        isActive: boolean;\n        batchingEnabled: boolean;\n        requestType: RequestType;\n        contentType: ContentType;\n        createdAt: string;\n        updatedAt: string;\n    }\n    interface AddWebhookRequest {\n        name: string;\n        url: string;\n        events: Event[];\n        requestType: RequestType;\n        isActive?: boolean;\n        batchingEnabled?: boolean;\n        contentType?: ContentType;\n        headers?: Record<string, string>;\n        payload?: Record<string, any>;\n    }\n    type ContentType = 'multipart/form-data' | 'application/json' | 'application/x-www-form-urlencoded';\n    type Event = 'file.added' | 'file.updated' | 'file.reverted' | 'file.deleted' | 'file.translated' | 'file.approved' | 'project.translated' | 'project.approved' | 'project.built' | 'translation.updated' | 'string.added' | 'string.updated' | 'string.deleted' | 'stringComment.created' | 'stringComment.updated' | 'stringComment.deleted' | 'stringComment.restored' | 'suggestion.added' | 'suggestion.updated' | 'suggestion.deleted' | 'suggestion.approved' | 'suggestion.disapproved' | 'task.added' | 'task.statusChanged' | 'task.deleted';\n    type RequestType = 'POST' | 'GET';\n}\n```\n\n##### workflows/index.d.ts\n\n```typescript\nimport { CrowdinApi, PaginationOptions, PatchRequest, ResponseList, ResponseObject } from '../core';\nimport { SourceStringsModel } from '../sourceStrings';\nexport declare class Workflows extends CrowdinApi {\n    listWorkflowSteps(projectId: number, options?: PaginationOptions): Promise<ResponseList<WorkflowModel.WorkflowStep>>;\n    listWorkflowSteps(projectId: number, limit?: number, offset?: number): Promise<ResponseList<WorkflowModel.WorkflowStep>>;\n    getWorkflowStep(projectId: number, stepId: number): Promise<ResponseObject<WorkflowModel.WorkflowStep>>;\n    listStringsOnTheWorkflowStep(projectId: number, stepId: number, options?: WorkflowModel.ListStringsOntheWorkflowStepOptions): Promise<ResponseList<SourceStringsModel.String>>;\n    listWorkflowTemplates(options?: WorkflowModel.ListWorkflowTemplatesOptions): Promise<ResponseList<WorkflowModel.Workflow>>;\n    listWorkflowTemplates(groupId?: number, limit?: number, offset?: number): Promise<ResponseList<WorkflowModel.Workflow>>;\n    getWorkflowTemplateInfo(templateId: number): Promise<ResponseObject<WorkflowModel.Workflow>>;\n    updateWorkflowStepStringStatus(projectId: number, stepId: number, languageId: string, request: PatchRequest[]): Promise<ResponseList<WorkflowModel.WorkflowStepStringStatus>>;\n    getWorkflowStepStringStatus(projectId: number, stepId: number, languageId: string, options?: PaginationOptions): Promise<ResponseList<WorkflowModel.WorkflowStepStringStatus>>;\n}\nexport declare namespace WorkflowModel {\n    interface WorkflowStep {\n        id: number;\n        title: string;\n        type: string;\n        languages: string[];\n        config: {\n            assignees: {\n                [language: string]: number[];\n            };\n        };\n    }\n    interface ListWorkflowTemplatesOptions extends PaginationOptions {\n        groupId?: number;\n    }\n    interface ListStringsOntheWorkflowStepOptions extends PaginationOptions {\n        languageIds?: string;\n        orderBy?: string;\n        status?: 'todo' | 'done' | 'pending' | 'incomplete' | 'need_review';\n    }\n    interface Workflow {\n        id: number;\n        title: string;\n        description: string;\n        groupId: number;\n        isDefault: boolean;\n        webUrl: string;\n        steps: {\n            id: number;\n            languages: string[];\n            assignees: number[];\n            vendorId: number;\n            config: {\n                minRelevant: number;\n                autoSubstitution: boolean;\n            };\n            mtId: number;\n        }[];\n    }\n    interface WorkflowStepStringStatus {\n        stringId: number;\n        languageId: string;\n        stepId: number;\n        status: string;\n        output: string;\n    }\n}\n```\n\n<!-- CROWDIN_API_CLIENT_TYPES_END -->\n\n### App Metadata Storage\n\n#### Overview\n\nApp Metadata Storage is a built-in key-value storage system provided by the Crowdin Apps SDK. It allows your app to persist data across sessions without needing external databases or storage services.\n\n**Available Methods:**\n- `crowdinApp.saveMetadata(key, data, crowdinId)` - Save or update metadata (recommended)\n- `crowdinApp.getMetadata(key)` - Retrieve metadata\n- `crowdinApp.deleteMetadata(key)` - Delete metadata\n\n**Alternative approach:**\n- `crowdinModule.metadataStore.saveMetadata(key, data, crowdinId)`\n- `crowdinModule.metadataStore.getMetadata(key)`\n- `crowdinModule.metadataStore.deleteMetadata(key)`\n\n#### Official Documentation\n\n**üìö Complete Documentation:** Refer to Crowdin Apps SDK documentation for metadata storage\n\n**‚ö†Ô∏è CRITICAL**: Metadata is stored at the organization level. Always include `organizationId` in your keys to properly scope data.\n\n#### Common Examples\n\n**Save Metadata:**\n```typescript\napp.post('/api/save-data', async (req: Request, res: Response) => {\n    try {\n        const jwt = req.query.jwt as string;\n        const { data } = req.body;\n\n        if (!jwt) {\n            return res.status(400).json({ success: false, error: 'JWT token is required' });\n        }\n        \n        if (!crowdinApp.establishCrowdinConnection) {\n            return res.status(500).json({ success: false, error: 'Crowdin connection method not available' });\n        }\n\n        const connection = await crowdinApp.establishCrowdinConnection(jwt, undefined);\n\n        if (!connection.client) {\n            return res.status(500).json({ success: false, error: 'Crowdin API client not available' });\n        }\n\n        const userId = connection.context.jwtPayload.context.user_id;\n        const organizationId = connection.context.jwtPayload.context.organization_id;\n        \n        // Create a namespaced key\n        const key = `org_${organizationId}_user_${userId}_preferences`;\n        \n        // Save data to metadata storage\n        await crowdinApp.saveMetadata(key, data, connection.context.crowdinId);\n        res.json({ success: true, message: 'Data saved successfully' });\n    } catch (error) {\n        console.error('Save error:', error);\n        res.status(500).json({ success: false, error: 'Failed to save data' });\n    }\n});\n```\n\n**Get Metadata:**\n```typescript\napp.get('/api/get-data', async (req: Request, res: Response) => {\n    try {\n        const jwt = req.query.jwt as string;\n        \n        if (!jwt) {\n            return res.status(400).json({ success: false, error: 'JWT token is required' });\n        }\n        \n        if (!crowdinApp.establishCrowdinConnection) {\n            return res.status(500).json({ success: false, error: 'Crowdin connection method not available' });\n        }\n\n        const connection = await crowdinApp.establishCrowdinConnection(jwt, undefined);\n\n        if (!connection.client) {\n            return res.status(500).json({ success: false, error: 'Crowdin API client not available' });\n        }\n\n        const userId = connection.context.jwtPayload.context.user_id;\n        const organizationId = connection.context.jwtPayload.context.organization_id;\n        \n        const key = `org_${organizationId}_user_${userId}_preferences`;\n        \n        // Retrieve data from metadata storage\n        const data = await crowdinApp.getMetadata(key);\n            \n        // Handle case when no data exists\n        if (!data) {\n            return res.json({ \n                success: true, \n                data: null, \n                message: 'No data found' \n            });\n        }\n        \n        res.json({ success: true, data });\n    } catch (error) {\n        console.error('Get error:', error);\n        res.status(500).json({ success: false, error: 'Failed to retrieve data' });\n    }\n});\n```\n\n**Delete Metadata:**\n```typescript\napp.delete('/api/delete-data', async (req: Request, res: Response) => {\n    try {\n        const jwt = req.query.jwt as string;\n        \n        if (!jwt) {\n            return res.status(400).json({ success: false, error: 'JWT token is required' });\n        }\n        \n        if (!crowdinApp.establishCrowdinConnection) {\n            return res.status(500).json({ success: false, error: 'Crowdin connection method not available' });\n        }\n\n        const connection = await crowdinApp.establishCrowdinConnection(jwt, undefined);\n\n        if (!connection.client) {\n            return res.status(500).json({ success: false, error: 'Crowdin API client not available' });\n        }\n\n        const userId = connection.context.jwtPayload.context.user_id;\n        const organizationId = connection.context.jwtPayload.context.organization_id;\n        \n        const key = `org_${organizationId}_user_${userId}_preferences`;\n        \n        // Delete data from metadata storage\n        await crowdinApp.deleteMetadata(key);\n        res.json({ success: true, message: 'Data deleted successfully' });\n    } catch (error) {\n        console.error('Delete error:', error);\n        res.status(500).json({ success: false, error: 'Failed to delete data' });\n    }\n});\n```\n\n**Get All Metadata:**\n```typescript\napp.get('/api/all-metadata', async (req: Request, res: Response) => {\n    try {\n        const jwt = req.query.jwt as string;\n        \n        if (!jwt) {\n            return res.status(400).json({ success: false, error: 'JWT token is required' });\n        }\n        \n        if (!crowdinApp.establishCrowdinConnection) {\n            return res.status(500).json({ success: false, error: 'Crowdin connection method not available' });\n        }\n\n        const connection = await crowdinApp.establishCrowdinConnection(jwt, undefined);\n\n        if (!connection.client) {\n            return res.status(500).json({ success: false, error: 'Crowdin API client not available' });\n        }\n\n        // Retrieve all metadata records from storage\n        const allMetadata = await crowdinApp.storage.getAllMetadata();\n        \n        // allMetadata structure:\n        // [\n        //   {\n        //     id: \"org_123_user_456_preferences\",  // key\n        //     data: \"{\"theme\":\"dark\",\"lang\":\"en\"}\", // JSON stringified value\n        //     crowdin_id: \"domain\"     // crowdin identifier (from connection.context.crowdinId during save)\n        //   },\n        //   ...\n        // ]\n        \n        // Parse and format data\n        const formattedData = allMetadata.map(record => ({\n            key: record.id,\n            value: JSON.parse(record.data || '{}'),\n            crowdinId: record.crowdin_id\n        }));\n        \n        res.json({ success: true, metadata: formattedData, count: formattedData.length });\n    } catch (error) {\n        console.error('Error retrieving all metadata:', error);\n        res.status(500).json({ success: false, error: 'Failed to retrieve metadata' });\n    }\n});\n```\n\n**Store Complex Objects:**\n```typescript\n// Save complex user preferences\nconst preferences = {\n    theme: 'dark',\n    language: 'en',\n    notifications: {\n        email: true,\n        push: false,\n        digest: 'weekly'\n    },\n    lastUpdated: new Date().toISOString(),\n    settings: {\n        autoSave: true,\n        confirmActions: true\n    }\n};\n\nconst key = `org_${organizationId}_user_${userId}_preferences`;\nawait crowdinApp.saveMetadata(key, preferences, connection.context.crowdinId);\n\n// Retrieve and update\nconst currentPrefs = await crowdinApp.getMetadata(key) || {};\nconst updatedPrefs = {\n    ...currentPrefs,\n    theme: 'light',\n    lastUpdated: new Date().toISOString()\n};\nawait crowdinApp.saveMetadata(key, updatedPrefs, connection.context.crowdinId);\n```\n\n#### Best Practices\n\n1. **Always use namespaced keys**\n   ```typescript\n   // ‚úÖ CORRECT - includes organization and entity identifiers\n   const key = `org_${organizationId}_user_${userId}_preferences`;\n   const key = `org_${organizationId}_project_${projectId}_cache`;\n   \n   // ‚ùå WRONG - no organization scope, may cause conflicts\n   const key = `user_preferences`;\n   const key = `${userId}_data`;\n   ```\n\n2. **Handle missing data gracefully**\n   ```typescript\n   // ‚úÖ CORRECT - provide defaults for missing data\n   const data = await crowdinApp.getMetadata(key) || { \n       theme: 'auto', \n       language: 'en' \n   };\n   \n   // ‚úÖ CORRECT - check for null/undefined\n   const data = await crowdinApp.getMetadata(key);\n   if (!data) {\n       return defaultSettings;\n   }\n   \n   // ‚ùå WRONG - may cause errors if data is null\n   const theme = data.theme; // Error if data is null\n   ```\n\n3. **Always use the correct identifier for the third parameter**\n   ```typescript\n   // ‚úÖ CORRECT - when connection object is available\n   await crowdinApp.saveMetadata(key, data, connection.context.crowdinId);\n   \n   // ‚úÖ CORRECT - when using webhookContext (no connection object, crowdinApp not available)\n   await crowdinModule.metadataStore.saveMetadata(key, data, `${webhookContext.domain || webhookContext.organizationId}`);\n   \n   // ‚ùå WRONG - don't use organizationId directly\n   await crowdinApp.saveMetadata(key, data, String(organizationId));\n   ```\n\n4. **Use descriptive key patterns**\n   ```typescript\n   // ‚úÖ CORRECT - clear, hierarchical structure\n   `org_${orgId}_user_${userId}_preferences`\n   `org_${orgId}_project_${projectId}_settings`\n   `org_${orgId}_cache_${cacheType}_${identifier}`\n   \n   // ‚ùå WRONG - unclear, hard to maintain\n   `data_${id}`\n   `temp_storage`\n   ```\n\n5. **Handle errors properly**\n   ```typescript\n   // ‚úÖ CORRECT - comprehensive error handling\n   try {\n       await crowdinApp.saveMetadata(key, data, connection.context.crowdinId);\n       return { success: true };\n   } catch (error: any) {\n       console.error('Metadata save failed:', error);\n       return { \n           success: false, \n           error: 'Failed to save data'\n       };\n   }\n   ```\n\n7. **Store only JSON-serializable data**\n   ```typescript\n   // ‚úÖ CORRECT - simple JSON-serializable objects\n   const data = {\n       name: 'John',\n       age: 30,\n       preferences: ['option1', 'option2'],\n       metadata: { key: 'value' }\n   };\n   \n   // ‚ùå WRONG - functions, dates, circular references\n   const data = {\n       name: 'John',\n       callback: () => {},           // Functions don't serialize\n       created: new Date(),           // Dates become strings\n       circular: data                 // Circular reference\n   };\n   \n   // ‚úÖ CORRECT - convert dates to ISO strings\n   const data = {\n       name: 'John',\n       created: new Date().toISOString()\n   };\n   ```\n\n8. **NEVER use KVStore for configurations - use metadata storage instead**\n   ```typescript\n   // ‚úÖ CORRECT - use metadata storage for ALL configuration storage\n   const config = {\n       apiKey: userApiKey,\n       apiEndpoint: 'https://api.example.com',\n       languageMapping: { 'en': 'en-US' }\n   };\n   await crowdinApp.saveMetadata(\n       `config_org_${organizationId}`, \n       config, \n       connection.context.crowdinId\n   );\n   \n   // ‚úÖ CORRECT - read configuration from metadata storage\n   const config = await crowdinApp.getMetadata(`config_org_${organizationId}`) || {};\n   \n   // ‚ùå WRONG - using KVStore for configuration storage\n   const config = {\n       apiKey: userApiKey,\n       apiEndpoint: 'https://api.example.com',\n       languageMapping: { 'en': 'en-US' }\n   };\n   await env.KVStore.put(\n       `config_org_${organizationId}`, \n       JSON.stringify(config)\n   );\n   \n   // ‚ùå WRONG - reading configuration from KVStore\n   const configData = await env.KVStore.get(`config_org_${organizationId}`);\n   const config = JSON.parse(configData || '{}');\n   ```\n\n9. **Use crowdinApp.saveMetadata or crowdinModule.metadataStore.saveMetadata - both implement upsert**\n   ```typescript\n   // ‚úÖ CORRECT - implements upsert (insert or update)\n   await crowdinApp.saveMetadata(\n       key, \n       data, \n       connection.context.crowdinId\n   );\n   \n   // ‚úÖ CORRECT - also implements upsert (insert or update)\n   await crowdinModule.metadataStore.saveMetadata(\n       key, \n       data, \n       connection.context.crowdinId\n   );\n   \n   // ‚ùå WRONG - only insert, NOT upsert (will fail if key already exists)\n   await crowdinApp.storage.saveMetadata(\n       key, \n       data, \n       connection.context.crowdinId\n   );\n   ```\n\n### Cron Scheduling\n\n#### Overview\n\nCron Scheduling allows your app to execute background tasks at specified time intervals.\n\n#### Official Documentation\n\n**üìö Complete Documentation:** Refer to Crowdin Apps SDK documentation for cron scheduling\n\n**‚ö†Ô∏è CRITICAL**: Only specific cron intervals are supported. Using unsupported intervals will result in an error.\n\n#### Supported Intervals\n\nThe following cron expressions are supported:\n\n| Cron Expression | Description | Frequency |\n|----------------|-------------|-----------|\n| `0 * * * *` | Every hour | Runs at minute 0 of every hour |\n| `0 */3 * * *` | Every 3 hours | Runs at minute 0 every 3 hours |\n| `0 */6 * * *` | Every 6 hours | Runs at minute 0 every 6 hours |\n| `0 */12 * * *` | Every 12 hours | Runs at minute 0 every 12 hours |\n| `0 0 * * *` | Daily | Runs at midnight (00:00) every day |\n| `0 0 * * SUN` | Weekly | Runs at midnight (00:00) every Sunday |\n| `0 0 1 * *` | Monthly | Runs at midnight (00:00) on the 1st of each month |\n\n#### Common Examples\n\n**Simple Hourly Task:**\n```typescript\n// In worker/app.ts, after initializing crowdinApp\nconst crowdinApp = crowdinModule.addCrowdinEndpoints(app, configuration) as CrowdinAppUtilities;\n\n// Register cron job - runs every hour\ncrowdinApp.cron.schedule('0 * * * *', async () => {\n    try {\n        console.log('Hourly task started at', new Date().toISOString());\n        \n        // Perform your scheduled task\n        // Example: Check status, update cache, etc.\n        \n        console.log('Task completed');\n    } catch (error) {\n        console.error('Cron job error:', error);\n    }\n});\n```\n\n**Multiple Tasks for Same Schedule:**\n```typescript\n// In worker/app.ts, after initializing crowdinApp\nconst crowdinApp = crowdinModule.addCrowdinEndpoints(app, configuration) as CrowdinAppUtilities;\n\n// Both tasks will run daily at midnight\ncrowdinApp.cron.schedule('0 0 * * *', async () => {\n    try {\n        console.log('Daily cleanup started');\n        // Cleanup old data\n    } catch (error) {\n        console.error('Cleanup error:', error);\n    }\n});\n\ncrowdinApp.cron.schedule('0 0 * * *', async () => {\n    try {\n        console.log('Daily report started');\n        // Generate reports\n    } catch (error) {\n        console.error('Report error:', error);\n    }\n});\n```\n\n**Using Crowdin API Client in Cron Jobs:**\n```typescript\n// In worker/app.ts, after initializing crowdinApp\nconst crowdinApp = crowdinModule.addCrowdinEndpoints(app, configuration) as CrowdinAppUtilities;\n\n// Register cron job that processes data for multiple organizations\ncrowdinApp.cron.schedule('0 0 * * *', async () => {\n    try {\n        console.log('Daily sync started');\n        \n        // Get all metadata records\n        const allMetadata = await crowdinApp.storage.getAllMetadata();\n        \n        if (!allMetadata || allMetadata.length === 0) {\n            console.log('No metadata found, skipping sync');\n            return;\n        }\n        \n        // Filter metadata by pattern using regex (e.g., find all organization configs)\n        const configPattern = /^org_(\\d+)_config$/;\n        const orgConfigs = allMetadata.filter(record => \n            configPattern.test(record.id)\n        );\n        \n        console.log(`Found ${orgConfigs.length} organization configs to process`);\n        \n        // Process each organization separately\n        for (const configRecord of orgConfigs) {\n            try {\n                const match = configRecord.id.match(configPattern);\n                const organizationId = match?.[1];\n                const crowdinId = configRecord.crowdin_id; // domain or organizationId\n                const configData = JSON.parse(configRecord.data || '{}');\n                \n                console.log(`Processing organization ${organizationId}`);\n                \n                // Create individual Crowdin API client for this organization\n                const encryptedData = crowdinApp.encryptCrowdinConnection({\n                    crowdinId,\n                    extra: {}, // Always pass empty object\n                });\n                \n                const { client } = await crowdinApp.dencryptCrowdinConnection(encryptedData, true);\n                \n                // Use client to make API calls for this specific organization\n                const projects = await client.projectsGroupsApi.withFetchAll().listProjects();\n                console.log(`Organization ${organizationId}: Found ${projects.data.length} projects`);\n                \n                // Process organization-specific configuration\n                if (configData.autoSync) {\n                    console.log(`Organization ${organizationId}: Auto-sync enabled, processing...`);\n                    // Perform sync operations\n                }\n                \n            } catch (error) {\n                console.error(`Error processing organization ${organizationId}:`, error);\n                // Continue with next organization\n            }\n        }\n        \n        console.log('Daily sync completed');\n    } catch (error) {\n        console.error('Cron job error:', error);\n    }\n});\n```\n\n#### Best Practices\n\n1. **Use appropriate intervals for your task**\n   ```typescript\n   // ‚úÖ CORRECT - frequent checks for time-sensitive tasks\n   crowdinApp.cron.schedule('0 * * * *', async () => {\n       // Hourly notification checks\n   });\n   \n   // ‚úÖ CORRECT - less frequent for resource-intensive tasks\n   crowdinApp.cron.schedule('0 0 * * *', async () => {\n       // Daily cleanup or report generation\n   });\n   \n   // ‚ùå WRONG - using unsupported interval\n   crowdinApp.cron.schedule('*/5 * * * *', async () => {\n       // Every 5 minutes - NOT SUPPORTED\n   });\n   ```\n\n2. **Handle errors gracefully**\n   ```typescript\n   // ‚úÖ CORRECT - catch and log errors\n   crowdinApp.cron.schedule('0 * * * *', async () => {\n       try {\n           await performTask();\n       } catch (error) {\n           console.error('Cron job failed:', error);\n           // Log error but don't throw - let job complete\n       }\n   });\n   \n   // ‚ùå WRONG - unhandled errors\n   crowdinApp.cron.schedule('0 * * * *', async () => {\n       await performTask(); // May crash if it throws\n   });\n   ```\n\n3. **Keep cron jobs lightweight**\n   ```typescript\n   // ‚úÖ CORRECT - efficient processing\n   crowdinApp.cron.schedule('0 0 * * *', async () => {\n       const startTime = Date.now();\n       console.log('Task started');\n       \n       // Perform lightweight operations\n       await quickCleanup();\n       \n       console.log(`Completed in ${Date.now() - startTime}ms`);\n   });\n   \n   // ‚ùå WRONG - heavy processing that may timeout\n   crowdinApp.cron.schedule('0 * * * *', async () => {\n       // Processing millions of records - may timeout\n       const allData = await fetchAllData();\n       await processAll(allData);\n   });\n   ```\n\n4. **Always await async operations**\n   ```typescript\n   // ‚úÖ CORRECT - await all async operations\n   crowdinApp.cron.schedule('0 * * * *', async () => {\n       await saveData();\n       await processQueue();\n       console.log('All tasks completed');\n   });\n   \n   // ‚úÖ CORRECT - setTimeout with proper promise wrapper\n   crowdinApp.cron.schedule('0 * * * *', async () => {\n       await new Promise((resolve) => {\n           setTimeout(async () => {\n               await processData();\n               resolve();\n           }, 1000);\n       });\n   });\n   \n   // ‚ùå WRONG - promise without await (will not complete)\n   crowdinApp.cron.schedule('0 * * * *', async () => {\n       saveData(); // This will NOT complete before cron job ends\n       console.log('Done'); // Logs immediately, but saveData is not finished\n   });\n   \n   // ‚ùå WRONG - setTimeout without proper promise wrapper\n   crowdinApp.cron.schedule('0 * * * *', async () => {\n       setTimeout(async () => {\n           await processData(); // This will NOT execute\n       }, 1000);\n   });\n   ```\n\n5. **Log execution for debugging**\n   ```typescript\n   // ‚úÖ CORRECT - comprehensive logging\n   crowdinApp.cron.schedule('0 */6 * * *', async () => {\n       const startTime = Date.now();\n       console.log(`Cron job started at ${new Date().toISOString()}`);\n       \n       try {\n           await performTask();\n           console.log(`Completed in ${Date.now() - startTime}ms`);\n       } catch (error) {\n           console.error(`Failed after ${Date.now() - startTime}ms:`, error);\n       }\n   });\n   ```\n\n### Webhooks\n\n#### Overview\n\nWebhooks allow your app to subscribe to events that occur in Crowdin projects or organizations. When a subscribed event happens, Crowdin automatically sends the event data to your app's callback function.\n\n#### Official Documentation\n\n**üìö Complete Documentation:** [Crowdin Webhooks](https://crowdin.github.io/app-project-module/tools/webhook/)\n\n**üìö Available Events:** [Webhook Events List](https://support.crowdin.com/developer/webhooks/)\n\n**‚ö†Ô∏è CRITICAL**: Only use event names from the official events list. Invalid event names will be ignored.\n\n#### Configuration\n\nConfigure webhooks in your app configuration in `worker/app.ts`:\n\n```typescript\nconst configuration: ClientConfig = {\n    // ... other configuration ...\n    \n    // Webhook subscriptions\n    webhooks: [\n        {\n            // List of events to subscribe to\n            events: ['file.added', 'file.updated', 'file.deleted'],\n            \n            // Callback function that handles events\n            callback({ client, events, webhookContext }) {\n                console.log('Received events:', events);\n                console.log('Organization:', webhookContext.organizationId);\n                console.log('User:', webhookContext.userId);\n                \n                // Process events here\n                events.forEach(event => {\n                    console.log('Event:', event.event, 'Project:', event.file.project.id);\n                });\n            },\n            \n            deferResponse: true\n        },\n        {\n            // You can have multiple webhook subscriptions\n            events: ['suggestion.updated', 'string.added'],\n            callback({ client, events, webhookContext }) {\n                // Handle translation events\n            },\n            \n            deferResponse: true\n        }\n    ]\n};\n```\n\n#### Common Examples\n\n**File Events:**\n```typescript\nwebhooks: [\n    {\n        events: ['file.added', 'file.updated', 'file.deleted', 'file.reverted'],\n        async callback({ client, events, webhookContext }) {\n            for (const event of events) {\n                console.log(`File ${event.event} in project ${event.file.project.id}`);\n                console.log('File details:', event.file);\n                \n                // Example: Get project details when file is added\n                if (event.event === 'file.added') {\n                    const project = await client.projectsGroupsApi.getProject(event.file.project.id);\n                    console.log('Project name:', project.data.name);\n                }\n            }\n        },\n        deferResponse: true\n    }\n]\n```\n\n#### Callback Parameters\n\nThe callback function receives an object with three properties:\n\n```typescript\ninterface WebhookCallback {\n    /**\n     * Crowdin API client - use to make API calls\n     * Same client as connection.client in endpoints\n     */\n    client: CrowdinApi;\n    \n    /**\n     * Array of webhook event objects\n     * Multiple events may be batched together\n     */\n    events: WebhookEvent[];\n    \n    /**\n     * Context information about the webhook\n     */\n    webhookContext: {\n        /** Crowdin domain (e.g., \"crowdin.com\") */\n        domain: string;\n        \n        /** Organization ID where event occurred */\n        organizationId: number;\n        \n        /** User ID who installed the application */\n        userId: number;\n        \n        /** Agent ID (if authenticationType is \"crowdin_agent\") */\n        agentId?: number;\n    };\n}\n```\n\n#### Common Event Types\n\n**Project Events:**\n- `project.created` - New project added\n- `project.deleted` - Project deleted\n- `project.translated` - Project fully translated\n- `project.approved` - Project reviewed\n- `project.built` - Project built\n\n**Group Events:**\n- `group.created` - New group added\n- `group.deleted` - Group deleted\n\n**File Events:**\n- `file.added` - New file added to project\n- `file.updated` - File updated\n- `file.deleted` - File deleted from project\n- `file.reverted` - File reverted to previous version\n- `file.translated` - File fully translated\n- `file.approved` - File reviewed\n\n**String Events:**\n- `string.added` - New source string added\n- `string.updated` - Source string updated\n- `string.deleted` - Source string deleted\n\n**Translation Events:**\n- `suggestion.added` - String translation added\n- `suggestion.updated` - String translation updated\n- `suggestion.deleted` - String translation deleted\n- `suggestion.approved` - String translation approved\n- `suggestion.disapproved` - String translation disapproved\n\n**Comment Events:**\n- `stringComment.created` - String comment added\n- `stringComment.updated` - String comment updated\n- `stringComment.deleted` - String comment deleted\n- `stringComment.restored` - String comment restored\n\n**Task Events:**\n- `task.added` - New task added\n- `task.statusChanged` - Task status changed\n- `task.updated` - Task updated\n- `task.deleted` - Task deleted\n\n#### Best Practices\n\n1. **Always set deferResponse to true**\n   ```typescript\n   // ‚úÖ CORRECT - deferResponse is set to true\n   webhooks: [\n       {\n           events: ['file.added'],\n           callback({ client, events, webhookContext }) {\n               console.log('Processing events');\n           },\n           deferResponse: true  // REQUIRED!\n       }\n   ]\n   \n   // ‚ùå WRONG - missing deferResponse\n   webhooks: [\n       {\n           events: ['file.added'],\n           callback({ client, events, webhookContext }) {\n               console.log('Processing events');\n           }\n           // Missing deferResponse: true - this will cause issues!\n       }\n   ]\n   ```\n\n2. **Handle multiple events in batch**\n   ```typescript\n   // ‚úÖ CORRECT - process all events\n   callback({ client, events, webhookContext }) {\n       events.forEach(event => {\n           console.log('Processing event:', event.event);\n       });\n   }\n   \n   // ‚ùå WRONG - only processes first event\n   callback({ client, events, webhookContext }) {\n       const event = events[0];\n       console.log('Processing event:', event.event);\n   }\n   ```\n\n3. **Handle errors gracefully**\n   ```typescript\n   // ‚úÖ CORRECT - catches and logs errors\n   async callback({ client, events, webhookContext }) {\n       for (const event of events) {\n           try {\n               await processEvent(event);\n           } catch (error) {\n               console.error('Failed to process event:', event.event, error);\n               // Continue processing other events\n           }\n       }\n   }\n   ```\n\n4. **Check event type before processing**\n   ```typescript\n   // ‚úÖ CORRECT - checks event type\n   callback({ client, events, webhookContext }) {\n       events.forEach(event => {\n           if (event.event === 'file.added') {\n               console.log('New file:', event.file?.name);\n           } else if (event.event === 'file.updated') {\n               console.log('Updated file:', event.file?.name);\n           }\n       });\n   }\n   ```\n\n5. **Use webhookContext for scoping**\n   ```typescript\n   // ‚úÖ CORRECT - uses context for organization-specific logic\n   async callback({ client, events, webhookContext }) {\n       const orgId = webhookContext.organizationId;\n       const userId = webhookContext.userId;\n       \n       // Store event in metadata\n       const key = `org_${orgId}_events_${Date.now()}`;\n       // await crowdinModule.metadataStore.saveMetadata(key, events, `${webhookContext.domain || webhookContext.organizationId}`);\n   }\n   ```\n\n6. **Don't perform long-running operations**\n   ```typescript\n   // ‚úÖ CORRECT - quick processing, delegate heavy work\n   async callback({ client, events, webhookContext }) {\n       // Quick logging\n       console.log('Received', events.length, 'events');\n       \n       // Store for later processing\n       const key = `org_${webhookContext.organizationId}_queue`;\n       // await crowdinModule.metadataStore.saveMetadata(key, events, `${webhookContext.domain || webhookContext.organizationId}`);\n   }\n   \n   // ‚ö†Ô∏è PROBLEMATIC - long-running operation blocks webhook\n   async callback({ client, events, webhookContext }) {\n       // This might timeout\n       for (const event of events) {\n           await processLargeFile(event.file?.id);\n           await sendMultipleNotifications(event);\n           await updateExternalDatabase(event);\n       }\n   }\n   ```\n\n#### Event Object Structure\n\nEach event type has its own interface with specific fields. Use these interfaces to understand which data is available for each event:\n\n```typescript\n// ============================================================================\n// SHARED MODELS - Reusable data structures\n// ============================================================================\n\ninterface ProjectModel {\n    id: number;\n    name: string;\n    identifier: string;\n    sourceLanguageId: string;\n    targetLanguageIds: string[];\n}\n\ninterface UserModel {\n    id: number;\n    username: string;\n}\n\ninterface LanguageModel {\n    id: string;\n    name: string;\n}\n\ninterface FileModelBase {\n    id: number;\n    name: string;\n    title: string;\n    type: string;\n    path: string;\n    branchId: number | null;\n    directoryId: number | null;\n}\n\ninterface FileModel extends FileModelBase {\n    project: ProjectModel;\n}\n\ninterface GroupModel {\n    id: number;\n    name: string;\n    parentId: number | null;\n}\n\ninterface StringModelBase {\n    id: number;\n    identifier: string;\n    text: string;\n    context: string | null;\n    isHidden: boolean;\n}\n\ninterface StringModel extends StringModelBase {\n    file: FileModelBase;\n    project: ProjectModel;\n}\n\ninterface TranslationModelBase {\n    id: number;\n    text: string;\n}\n\ninterface TranslationModel extends TranslationModelBase {\n    user: UserModel;\n    targetLanguage: LanguageModel;\n    string: StringModel;\n}\n\ninterface TaskModel {\n    id: number;\n    type: 0 | 1; // 0 - Translate, 1 - Proofread\n    title: string;\n    status: 'todo' | 'in_progress' | 'done' | 'closed' | 'pending' | 'review';\n    sourceLanguage: LanguageModel;\n    targetLanguage: LanguageModel;\n    project: ProjectModel;\n    taskCreator: UserModel;\n}\n\ninterface CommentModelBase {\n    id: number;\n    text: string;\n    type: 'issue' | 'comment';\n    issueType: 'general_question' | 'translation_mistake' |  'context_request' |  'source_mistake';\n    issueStatus: 'resolved' | 'unresolved';\n}\n\ninterface CommentModel extends CommentModelBase {\n    string: StringModel;\n    targetLanguage: LanguageModel;\n    user: UserModel;\n    commentResolver: UserModel | null;\n}\n\ninterface BuildModel {\n    id: number;\n    downloadUrl: string;\n    project: ProjectModel;\n}\n\n// ============================================================================\n// BASE EVENT INTERFACES\n// ============================================================================\n\ninterface BaseEventWithUser {\n    user: UserModel;\n}\n\ninterface BaseProjectEvent {\n    project: ProjectModel;\n}\n\ninterface BaseGroupEvent {\n    group: GroupModel;\n}\n\ninterface BaseFileEvent {\n    file: FileModel;\n}\n\ninterface BaseStringEvent {\n    string: StringModel;\n}\n\ninterface BaseTranslationEvent {\n    translation: TranslationModel;\n}\n\ninterface BaseTaskEvent {\n    task: TaskModel;\n}\n\ninterface BaseCommentEvent {\n    comment: CommentModel;\n}\n\n// ============================================================================\n// PROJECT EVENTS\n// ============================================================================\n\ninterface ProjectCreatedEvent extends BaseProjectEvent, BaseEventWithUser {\n    event: 'project.created';\n}\n\ninterface ProjectDeletedEvent extends BaseProjectEvent, BaseEventWithUser {\n    event: 'project.deleted';\n}\n\ninterface ProjectTranslatedEvent extends BaseProjectEvent {\n    event: 'project.translated';\n    targetLanguage: LanguageModel;\n}\n\ninterface ProjectApprovedEvent extends BaseProjectEvent {\n    event: 'project.approved';\n    targetLanguage: LanguageModel;\n}\n\ninterface ProjectBuiltEvent {\n    event: 'project.built';\n    build: BuildModel;\n}\n\n// ============================================================================\n// GROUP EVENTS\n// ============================================================================\n\ninterface GroupCreatedEvent extends BaseGroupEvent, BaseEventWithUser {\n    event: 'group.created';\n}\n\ninterface GroupDeletedEvent extends BaseGroupEvent, BaseEventWithUser {\n    event: 'group.deleted';\n}\n\n// ============================================================================\n// FILE EVENTS\n// ============================================================================\n\ninterface FileAddedEvent extends BaseFileEvent, BaseEventWithUser {\n    event: 'file.added';\n}\n\ninterface FileUpdatedEvent extends BaseFileEvent, BaseEventWithUser {\n    event: 'file.updated';\n}\n\ninterface FileDeletedEvent extends BaseFileEvent, BaseEventWithUser {\n    event: 'file.deleted';\n}\n\ninterface FileRevertedEvent extends BaseFileEvent, BaseEventWithUser {\n    event: 'file.reverted';\n}\n\ninterface FileTranslatedEvent extends BaseFileEvent {\n    event: 'file.translated';\n    targetLanguage: LanguageModel;\n}\n\ninterface FileApprovedEvent extends BaseFileEvent {\n    event: 'file.approved';\n    targetLanguage: LanguageModel;\n}\n\n// ============================================================================\n// STRING EVENTS\n// ============================================================================\n\ninterface StringAddedEvent extends BaseStringEvent, BaseEventWithUser {\n    event: 'string.added';\n}\n\ninterface StringUpdatedEvent extends BaseStringEvent, BaseEventWithUser {\n    event: 'string.updated';\n}\n\ninterface StringDeletedEvent extends BaseStringEvent, BaseEventWithUser {\n    event: 'string.deleted';\n}\n\n// ============================================================================\n// TRANSLATION/SUGGESTION EVENTS\n// ============================================================================\n\ninterface SuggestionAddedEvent extends BaseTranslationEvent {\n    event: 'suggestion.added';\n}\n\ninterface SuggestionUpdatedEvent extends BaseTranslationEvent {\n    event: 'suggestion.updated';\n}\n\ninterface SuggestionDeletedEvent extends BaseTranslationEvent {\n    event: 'suggestion.deleted';\n}\n\ninterface SuggestionApprovedEvent extends BaseTranslationEvent {\n    event: 'suggestion.approved';\n}\n\ninterface SuggestionDisapprovedEvent extends BaseTranslationEvent {\n    event: 'suggestion.disapproved';\n}\n\ninterface TranslationUpdatedEvent {\n    event: 'translation.updated';\n    newTranslation: TranslationModel;\n}\n\n// ============================================================================\n// COMMENT EVENTS\n// ============================================================================\n\ninterface StringCommentCreatedEvent extends BaseCommentEvent {\n    event: 'stringComment.created';\n}\n\ninterface StringCommentUpdatedEvent extends BaseCommentEvent {\n    event: 'stringComment.updated';\n}\n\ninterface StringCommentDeletedEvent extends BaseCommentEvent {\n    event: 'stringComment.deleted';\n}\n\ninterface StringCommentRestoredEvent extends BaseCommentEvent {\n    event: 'stringComment.restored';\n}\n\n// ============================================================================\n// TASK EVENTS\n// ============================================================================\n\ninterface TaskAddedEvent extends BaseTaskEvent {\n    event: 'task.added';\n}\n\ninterface TaskStatusChangedEvent extends BaseTaskEvent {\n    event: 'task.statusChanged';\n}\n\ninterface TaskUpdatedEvent extends BaseTaskEvent {\n    event: 'task.updated';\n}\n\ninterface TaskDeletedEvent extends BaseTaskEvent {\n    event: 'task.deleted';\n}\n\n// ============================================================================\n// UNION TYPE - All possible webhook events\n// ============================================================================\n\ntype WebhookEvent = \n    // Project events\n    | ProjectCreatedEvent\n    | ProjectDeletedEvent\n    | ProjectTranslatedEvent\n    | ProjectApprovedEvent\n    | ProjectBuiltEvent\n    // Group events\n    | GroupCreatedEvent\n    | GroupDeletedEvent\n    // File events\n    | FileAddedEvent\n    | FileUpdatedEvent\n    | FileDeletedEvent\n    | FileRevertedEvent\n    | FileTranslatedEvent\n    | FileApprovedEvent\n    // String events\n    | StringAddedEvent\n    | StringUpdatedEvent\n    | StringDeletedEvent\n    // Translation/Suggestion events\n    | SuggestionAddedEvent\n    | SuggestionUpdatedEvent\n    | SuggestionDeletedEvent\n    | SuggestionApprovedEvent\n    | SuggestionDisapprovedEvent\n    | TranslationUpdatedEvent\n    // Comment events\n    | StringCommentCreatedEvent\n    | StringCommentUpdatedEvent\n    | StringCommentDeletedEvent\n    | StringCommentRestoredEvent\n    // Task events\n    | TaskAddedEvent\n    | TaskStatusChangedEvent\n    | TaskUpdatedEvent\n    | TaskDeletedEvent;\n```\n\n## Frontend Development\n\n### Crowdin Apps JS API\n\n#### Official Documentation\n\nThe `AP` object provides the Crowdin Apps JS API for interacting with the Crowdin application context.\n\n**üìö Complete API Reference:** https://support.crowdin.com/developer/crowdin-apps-js/\n\n**‚ö†Ô∏è CRITICAL**: Only use methods and types from the Crowdin Apps JS API definitions below.\n\n**Do NOT invent methods or properties that are not listed here.**\n\n#### Common Examples\n\n**Get Context (Promise-based):**\n```typescript\n// Promisified helper\nconst getContext = (): Promise<any> => {\n    return new Promise(resolve => window.AP.getContext(resolve));\n};\n\n// Usage\nconst context = await getContext();\nconsole.log('Project ID:', context.project_id);\n```\n\n**Get JWT Token (Promise-based):**\n```typescript\n// Promisified helper\nconst getJwtToken = (): Promise<string> => {\n    return new Promise(resolve => window.AP.getJwtToken(resolve));\n};\n\n// Usage with fetch\nconst token = await getJwtToken();\nconst response = await fetch(`/api/endpoint?jwt=${token}`);\nconst data = await response.json();\n```\n\n#### Best Practices\n\n1. **Handle errors gracefully**\n   ```typescript\n   try {\n       const context = await getContext();\n       if (!context.organization_id) {\n           throw new Error('Organization ID not found');\n       }\n       // Your code\n   } catch (error) {\n       console.error('Failed to get context:', error);\n   }\n   ```\n\n#### Complete Type Definitions\n\n##### Global AP Object Structure\n\n```typescript\ndeclare namespace AP {\n    // Global Actions\n    function getContext(callback: (context: Context) => void): void;\n    function getJwtToken(callback: (token: string) => void): void;\n    function getTheme(): 'light' | 'dark';\n    function redirect(path: string): void;\n}\n```\n\n##### Type Definitions\n\n```typescript\n// Context Information\ninterface Context {\n    project_id: number;\n    organization_id: number;\n}\n```\n\n## Development Workflow\n\n### 1. Configure Your App Identity\n\n**‚ö†Ô∏è Important**: You MUST update the configuration in `worker/app.ts` before deployment:\n\n```typescript\nconst configuration: ClientConfig = {\n    name: \"Your App Name\",           // Change this to your app's display name\n    identifier: \"your-app-id\",       // Change to unique identifier (lowercase, hyphens)\n    description: \"Your app description\", // Change to describe your app's purpose\n    // ... rest of configuration\n}\n```\n\n**Note**: The `identifier` must be unique across all Crowdin apps. Use format like: `company-file-processor`\n\n### 2. Key Files to Modify\n\n- `worker/app.ts` - Add new API endpoints here\n- `src/pages/HomePage.tsx` - Main page component (customize for your app logic)\n- `src/components/app-sidebar.tsx` - Sidebar navigation (customize menu items)\n- `src/components/layout/AppLayout.tsx` - Application layout (customize layout structure)\n- `src/index.css` - Customize global styles and Tailwind theme\n- `tailwind.config.js` - Add custom colors and extend theme"
    }
  },
  {
    "name": "crowdin-custom-mt",
    "language": "typescript",
    "frameworks": [
      "@dnd-kit",
      "@hookform/resolvers",
      "autoprefixer",
      "class-variance-authority",
      "cloudflare",
      "clsx",
      "cmdk",
      "date-fns",
      "express",
      "framer-motion",
      "immer",
      "input-otp",
      "next",
      "postcss",
      "react",
      "recharts",
      "sonner",
      "tailwind",
      "tw-animate-css",
      "typescript",
      "vaul",
      "vite",
      "wrangler",
      "zod",
      "zustand"
    ],
    "description": {
      "selection": "# Template Selection\n\nCrowdin app with Custom MT (Machine Translation) module.\n\nUse when:\n- Connecting custom machine translation engines not yet supported by Crowdin\n- Integrating proprietary or internal MT services\n- Building custom translation logic with context awareness\n- Creating MT adapters for niche language pairs or domains\n- Implementing specialized translation engines for technical content\n\nAvoid when:\n- Integrating custom AI providers (use AI Provider instead)\n- Transforming files during import/export (use File Processing instead)\n- Building editor extensions (use Editor Right Panel instead)\n- Building organization-wide tools (use Organization Menu instead)\n- Building user profile tools (use Profile Resources Menu instead)\n- Building project-specific tools (use Project Tools instead)\n\nBuilt with:\n- Crowdin Apps JS API\n- Crowdin Apps SDK (@crowdin/app-project-module)\n- React\n- ShadCN UI\n- Tailwind\n- Lucide Icons\n- ESLint\n- Vite\n- TypeScript\n- Express.js\n- Cloudflare Workers",
      "usage": "# Usage\n\n## Overview\nCrowdin app with Custom MT (Machine Translation), Profile Resources Menu and Organization Menu modules for connecting external machine translation engines.\n- Backend: TypeScript with Express.js and Crowdin Apps SDK\n- Frontend: React + TypeScript + ShadCN UI + Crowdin Apps JS API\n\n## Tech Stack\n- Crowdin Apps JS API\n- Crowdin Apps SDK (@crowdin/app-project-module)\n- React\n- ShadCN UI\n- Tailwind\n- Lucide Icons\n- ESLint\n- Vite\n- TypeScript\n- Express.js\n- Cloudflare Workers\n\n## Development Restrictions\n- **Tailwind Colors**: Hardcode custom colors in `tailwind.config.js`, NOT in `index.css`\n- **Components**: Use existing ShadCN components instead of writing custom ones\n- **Icons**: Import from `lucide-react` directly\n- **Error Handling**: ErrorBoundary components are pre-implemented\n- **Authentication**: Always use JWT tokens from Crowdin for API requests\n- **Custom MT Configuration**: Don't modify the customMT configuration structure\n- **Profile Resources Menu Configuration**: Don't modify the profileResourcesMenu configuration structure\n- **Organization Menu Configuration**: Don't modify the organizationMenu configuration structure\n- **Scopes**: Ensure your app has appropriate API scopes\n- **Storage Keys**: Always include organizationId in metadata keys to isolate data per organization\n- **Return Values**: translate function must return array of strings matching input length\n- **Error Handling**: Return empty strings for failed translations instead of throwing errors to avoid failing entire batches\n- **Critical Errors**: Throw errors for critical configuration issues (missing API keys, invalid credentials) that prevent the entire translation service from working\n\n## Styling\n- Responsive, accessible\n- Prefer ShadCN components; Tailwind for layout/spacing/typography\n- Use framer-motion sparingly for micro-interactions\n\n## Project Structure\n\n### Backend Structure\n- `worker/app.ts` - Express app factory with Custom MT module configuration\n- `worker/index.ts` - Cloudflare Worker entry point (HTTP handler, cron scheduler, middleware)\n- `worker/types/` - Backend TypeScript type definitions\n  - `cloudflare-env.d.ts` - Cloudflare environment types (KV storage, secrets)\n\n### Frontend Structure\n- `index.html` - HTML entry point with Crowdin Apps JS API script\n- `src/main.tsx` - React entry point with ErrorBoundary wrapper\n- `src/index.css` - Global styles and Tailwind CSS customizations\n- `src/components/` - React components\n  - `app-sidebar.tsx` - Application sidebar navigation\n  - `ErrorBoundary.tsx` - React error boundary with backend error reporting\n  - `ErrorFallback.tsx` - Fallback UI component for error states\n  - `RouteErrorBoundary.tsx` - Error boundary for routing errors\n  - `layout/` - Layout components\n    - `AppLayout.tsx` - Main application layout wrapper\n  - `ui/` - ShadCN UI components (button, card, sonner, etc.)\n- `src/pages/` - Page components\n  - `HomePage.tsx` - Home page component (main entry point for your app logic)\n- `src/hooks/` - Custom React hooks\n  - `use-mobile.tsx` - Hook for detecting mobile breakpoints\n- `src/lib/` - Utility modules\n  - `utils.ts` - Tailwind utility functions (`cn` for class merging)\n  - `errorReporter.ts` - Client-side error reporting to backend\n  - `apiClient.ts` - Generic API call wrapper with JWT token handling\n- `src/types/` - TypeScript type definitions\n  - `global.d.ts` - Global type declarations\n  - `vite-env.d.ts` - Vite environment types\n\n## Backend Development\n\n### App Configuration\n\nConfigure your app identity in `worker/app.ts`:\n\n```typescript\nconst configuration: ClientConfig = {\n    name: \"Your App Name\",                    // Display name shown in Crowdin UI\n    identifier: \"your-unique-app-identifier\", // Unique ID (lowercase, hyphens)\n    description: \"Your app description\",      // Brief description of functionality\n    // ... rest of configuration\n}\n```\n\n**Guidelines:**\n- **identifier**: Must be unique across all Crowdin apps. Format: `company-custom-mt`\n- **name**: User-friendly display name (e.g., \"Company MT Engine\")\n- **description**: Brief explanation of what your MT engine does\n\n#### Required Scopes\n\nAdd scopes to configuration in `worker/app.ts` based on your app's functionality.\n\n**‚ö†Ô∏è IMPORTANT**: Only use scopes from the list below. Do not invent or use non-existent scopes!\n\n```typescript\nconst configuration: ClientConfig = {\n    // ... other configuration ...\n    scopes: [\n        // Choose from the following valid scopes:\n        \n        // General scopes\n        crowdinModule.Scope.NOTIFICATIONS,               // 'notification' - Notifications management\n        \n        // Project-level scopes\n        crowdinModule.Scope.PROJECTS,                    // 'project' - Project management\n        crowdinModule.Scope.TASKS,                       // 'project.task' - Project tasks\n        crowdinModule.Scope.REPORTS,                     // 'project.report' - Project reports\n        crowdinModule.Scope.TRANSLATION_STATUS,          // 'project.status' - Translation status\n        crowdinModule.Scope.SOURCE_FILES_AND_STRINGS,    // 'project.source' - Source files and strings\n        crowdinModule.Scope.WEBHOOKS,                    // 'project.webhook' - Project webhooks\n        crowdinModule.Scope.TRANSLATIONS,                // 'project.translation' - Translations\n        crowdinModule.Scope.SCREENSHOTS,                 // 'project.screenshot' - Screenshots\n        \n        // Organization-level scopes\n        crowdinModule.Scope.USERS,                       // 'user' - User management\n        crowdinModule.Scope.TEAMS,                       // 'team' - Team management\n        crowdinModule.Scope.GROUPS,                      // 'group' - Group management\n        crowdinModule.Scope.ORGANIZATION_WEBHOOKS,       // 'webhook' - Organization webhooks\n        crowdinModule.Scope.VENDORS,                     // 'vendor' - Vendor management\n        crowdinModule.Scope.FIELDS,                      // 'field' - Custom fields\n        crowdinModule.Scope.SECURITY_LOGS,               // 'security-log' - Security logs\n        crowdinModule.Scope.APPLICATIONS,                // 'application' - Applications management\n        \n        // Resources\n        crowdinModule.Scope.TRANSLATION_MEMORIES,        // 'tm' - Translation memories\n        crowdinModule.Scope.MACHINE_TRANSLATION_ENGINES, // 'mt' - Machine translation engines\n        crowdinModule.Scope.GLOSSARIES,                  // 'glossary' - Glossaries\n        \n        // AI-related scopes\n        crowdinModule.Scope.AI,                          // 'ai' - AI features\n        crowdinModule.Scope.AI_PROVIDERS,                // 'ai.provider' - AI providers\n        crowdinModule.Scope.AI_PROMPTS,                  // 'ai.prompt' - AI prompts\n        crowdinModule.Scope.AI_PROXIES,                  // 'ai.proxy' - AI proxies\n    ]\n}\n```\n\n### Custom MT Module Configuration\n\nConfigure the Custom MT module in `worker/app.ts`:\n\n```typescript\nimport type { Client } from '@crowdin/crowdin-api-client';\nimport type { CrowdinContextInfo, ClientConfig } from '@crowdin/app-project-module/out/types';\nimport type { CustomMtString } from '@crowdin/app-project-module/out/modules/custom-mt/types';\n\nconst configuration: ClientConfig = {\n    // ... other configuration ...\n\n    customMT: {\n        // When true, strings will be received as objects with context\n        withContext: true,\n\n        // The maximum quantity of strings that can be sent to the Custom MT app in one request\n        batchSize: 100,\n        \n        // Main translation function (required)\n        translate: async (\n            client: Client,\n            context: CrowdinContextInfo,\n            projectId: number,\n            sourceLanguage: string,\n            targetLanguage: string,\n            strings: CustomMtString[]\n        ): Promise<string[]> => {\n            // Your translation logic here\n            const translations = strings.map(string => {\n                // Extract and translate text\n                return translatedText;\n            });\n            \n            return translations; // Must return array of strings in same order\n        },\n    }\n}\n```\n\n#### Common Examples\n\n**Integration with External MT API:**\n```typescript\nimport type { Client, SourceStringsModel } from '@crowdin/crowdin-api-client';\nimport type { CrowdinContextInfo, ClientConfig } from '@crowdin/app-project-module/out/types';\nimport type { CustomMtString } from '@crowdin/app-project-module/out/modules/custom-mt/types';\n\n// Helper function to extract source text from CustomMtString\nfunction extractSourceText(string: CustomMtString): string {\n    if (typeof string === 'string') {\n        return string;\n    }\n    \n    const text = string.text;\n    if (typeof text === 'string') {\n        return text;\n    }\n    \n    // Handle plural forms\n    if (string.pluralForm && text[string.pluralForm as keyof SourceStringsModel.PluralText]) {\n        return text[string.pluralForm as keyof SourceStringsModel.PluralText] as string;\n    }\n    \n    return '';\n}\n\nconst configuration: ClientConfig = {\n    // ... other configuration ...\n\n    customMT: {\n        withContext: true,\n        batchSize: 50,\n\n        translate: async (\n            client: Client,\n            context: CrowdinContextInfo,\n            projectId: number,\n            sourceLanguage: string,\n            targetLanguage: string,\n            strings: CustomMtString[]\n        ): Promise<string[]> => {\n            return await Promise.all(\n                strings.map(async (string: CustomMtString) => {\n                    try {\n                        const sourceText = extractSourceText(string);\n\n                        // Call your external MT API\n                        const response = await fetch('https://your-mt-api.com/translate', {\n                            method: 'POST',\n                            headers: { 'Content-Type': 'application/json' },\n                            body: JSON.stringify({\n                                text: sourceText,\n                                source: sourceLanguage,\n                                target: targetLanguage\n                            })\n                        });\n\n                        if (!response.ok) {\n                            console.error(`MT API failed: ${response.statusText}`);\n                            return '';\n                        }\n\n                        const result = await response.json();\n                        return result.translation || '';\n                    } catch (error) {\n                        console.error('Translation failed:', error);\n                        return '';\n                    }\n                })\n            );\n        }\n    }\n}\n```\n\n#### Best Practices\n\n1. **Always return translations in the same order**\n   ```typescript\n   // ‚úÖ CORRECT - maintains order\n   translate: async (\n        client: Client,\n        context: CrowdinContextInfo,\n        projectId: number,\n        sourceLanguage: string,\n        targetLanguage: string,\n        strings: CustomMtString[]\n    ): Promise<string[]> => {\n       return await Promise.all(\n           strings.map(string => translateString(string))\n       );\n   }\n   \n   // ‚ùå WRONG - order may change\n   translate: async (\n        client: Client,\n        context: CrowdinContextInfo,\n        projectId: number,\n        sourceLanguage: string,\n        targetLanguage: string,\n        strings: CustomMtString[]\n    ): Promise<string[]> => {\n       const translations = [];\n       for (const string of strings) {\n           translations.push(await translateString(string)); // Sequential, but order preserved\n       }\n       return translations;\n   }\n   ```\n\n2. **Handle plural forms correctly**\n   ```typescript\n   // ‚úÖ CORRECT - extracts specific plural form using extractSourceText\n   translate: async (\n        client: Client,\n        context: CrowdinContextInfo,\n        projectId: number,\n        sourceLanguage: string,\n        targetLanguage: string,\n        strings: CustomMtString[]\n    ): Promise<string[]> => {\n        return strings.map((string: CustomMtString) => {\n            const sourceText = extractSourceText(string);\n            return translateText(sourceText);\n        });\n    }\n    \n    // ‚ùå WRONG - direct access without type casting and fallback\n    translate: async (\n        client: Client,\n        context: CrowdinContextInfo,\n        projectId: number,\n        sourceLanguage: string,\n        targetLanguage: string,\n        strings: CustomMtString[]\n    ): Promise<string[]> => {\n        return strings.map((string: CustomMtString) => {\n            if (typeof string === 'string') {\n                return translateText(string);\n            }\n            \n            // BAD: Direct access without keyof casting\n            const sourceText = typeof string.text === 'string' \n                ? string.text \n                : string.text[string.pluralForm]; // Type error! pluralForm is 'any'\n                \n            return translateText(sourceText);\n        });\n    }\n   ```\n\n3. **Return empty string for failed translations instead of throwing errors**\n   ```typescript\n   // ‚úÖ CORRECT - returns empty string for failed translations, doesn't fail entire batch\n   translate: async (\n       client: Client,\n       context: CrowdinContextInfo,\n       projectId: number,\n       sourceLanguage: string,\n       targetLanguage: string,\n       strings: CustomMtString[]\n   ): Promise<string[]> => {\n       return await Promise.all(\n           strings.map(async (string: CustomMtString) => {\n               try {\n                   const sourceText = extractSourceText(string);\n                   const translation = await callMTAPI(sourceText, sourceLanguage, targetLanguage);\n                   \n                   // If translation failed, return empty string\n                   return translation || '';\n               } catch (error) {\n                   // Return empty string instead of failing entire batch\n                   console.error('Translation failed:', error);\n                   return '';\n               }\n           })\n       );\n   }\n   \n   // ‚ùå WRONG - throws error and fails entire batch when 1 string fails\n   translate: async (\n       client: Client,\n       context: CrowdinContextInfo,\n       projectId: number,\n       sourceLanguage: string,\n       targetLanguage: string,\n       strings: CustomMtString[]\n   ): Promise<string[]> => {\n       const translations = await Promise.all(\n           strings.map(async (string: CustomMtString) => {\n               const sourceText = extractSourceText(string);\n               const translation = await callMTAPI(sourceText, sourceLanguage, targetLanguage);\n               \n               if (!translation) {\n                   // BAD: This fails entire batch of 100 strings if 1 fails!\n                   throw new Error(`Failed to translate: \"${sourceText}\"`);\n               }\n               \n               return translation;\n           })\n       );\n       \n       return translations;\n   }\n   ```\n\n4. **Throw errors for critical configuration issues**\n   ```typescript\n   // ‚úÖ CORRECT - throws error for missing critical configuration\n   translate: async (\n       client: Client,\n       context: CrowdinContextInfo,\n       projectId: number,\n       sourceLanguage: string,\n       targetLanguage: string,\n       strings: CustomMtString[]\n   ): Promise<string[]> => {\n       // Load organization-specific configuration\n       const organizationId = context.jwtPayload.context.organization_id;\n       const configKey = `mt_config_org_${organizationId}`;\n       const config = await crowdinModule.metadataStore.getMetadata(configKey);\n       \n       // Check for critical configuration at the start\n       if (!config) {\n           throw new Error('MT service is not configured. Please configure the MT service in app settings.');\n       }\n       \n       if (!config.apiKey) {\n           throw new Error('MT API key is missing. Please add your API key in the app configuration.');\n       }\n       \n       if (!config.apiUrl) {\n           throw new Error('MT API URL is missing. Please add your API URL in the app configuration.');\n       }\n       \n       // Process translations - return empty strings for individual failures\n       return await Promise.all(\n           strings.map(async (string: CustomMtString) => {\n               try {\n                   const sourceText = extractSourceText(string);\n                   const translation = await callMTAPI(sourceText, sourceLanguage, targetLanguage, config.apiKey, config.apiUrl);\n                   return translation || '';\n               } catch (error) {\n                   console.error('Translation failed for individual string:', error);\n                   return ''; // Individual failure - return empty string\n               }\n           })\n       );\n   }\n   \n   // ‚ùå WRONG - doesn't check critical configuration, fails silently\n   translate: async (\n       client: Client,\n       context: CrowdinContextInfo,\n       projectId: number,\n       sourceLanguage: string,\n       targetLanguage: string,\n       strings: CustomMtString[]\n   ): Promise<string[]> => {\n       // BAD: No check for configuration, will fail for all requests\n       const organizationId = context.jwtPayload.context.organization_id;\n       const configKey = `mt_config_org_${organizationId}`;\n       const config = await crowdinModule.metadataStore.getMetadata(configKey);\n       \n       return await Promise.all(\n           strings.map(async (string: CustomMtString) => {\n               try {\n                   const sourceText = extractSourceText(string);\n                   // BAD: Using config without checking if it exists\n                   const translation = await callMTAPI(sourceText, sourceLanguage, targetLanguage, config?.apiKey, config?.apiUrl);\n                   return translation || '';\n               } catch (error) {\n                   // Silently returns empty strings even when service is misconfigured\n                   return '';\n               }\n           })\n       );\n   }\n   ```\n\n5. **Use batchSize appropriately**\n   ```typescript\n   // ‚úÖ CORRECT - reasonable batch size for API limits\n   customMT: {\n       withContext: true,\n       batchSize: 50, // Adjust based on your MT API limits\n       translate: async (\n            client: Client,\n            context: CrowdinContextInfo,\n            projectId: number,\n            sourceLanguage: string,\n            targetLanguage: string,\n            strings: CustomMtString[]\n        ): Promise<string[]> => {\n           // Process batch of up to 50 strings\n       }\n   }\n   \n   // ‚ö†Ô∏è PROBLEMATIC - too large, may timeout\n   customMT: {\n       withContext: true,\n       batchSize: 1000, // Too many strings at once\n       translate: async (\n            client: Client,\n            context: CrowdinContextInfo,\n            projectId: number,\n            sourceLanguage: string,\n            targetLanguage: string,\n            strings: CustomMtString[]\n        ): Promise<string[]> => {\n           // May exceed MT API limits or timeout\n       }\n   }\n   ```\n\n6. **Use context information for customization**\n   ```typescript\n   // ‚úÖ CORRECT - uses context for per-organization settings\n   translate: async (\n        client: Client,\n        context: CrowdinContextInfo,\n        projectId: number,\n        sourceLanguage: string,\n        targetLanguage: string,\n        strings: CustomMtString[]\n    ): Promise<string[]> => {\n       const orgId = context.jwtPayload.context.organization_id;\n       \n       // Load organization-specific MT settings\n       const settings = await crowdinModule.metadataStore.getMetadata(`mt_settings_${orgId}`);\n       \n       // Apply organization-specific logic\n       return strings.map(string => {\n           const sourceText = extractSourceText(string);\n           return translateWithSettings(sourceText, settings);\n       });\n   }\n   ```\n\n#### Complete Type Definitions\n\n**‚ö†Ô∏è CRITICAL**: Only use types from `@crowdin/app-project-module`.\n\n**Do NOT invent methods or properties that are not listed here.**\n\n##### out/types.d.ts\n\n```typescript\nexport interface CrowdinContextInfo {\n    jwtPayload: JwtPayload;\n    crowdinId: string;\n    clientId: string;\n    appIdentifier: string;\n}\n\ninterface JwtPayload {\n    aud: string;\n    sub: string;\n    domain?: string;\n    module?: string;\n    context: JwtPayloadContext;\n    iat: number;\n    exp: number;\n    code?: string;\n}\n\nexport interface JwtPayloadContext {\n    project_id: number;\n    project_identifier?: string;\n    organization_id: number;\n    organization_domain?: string;\n    user_id: number;\n    user_login?: string;\n}\n\n// ... other types (CrowdinClientRequest, Environments, ModuleKey, UiModule, etc.)\n// See @crowdin/app-project-module/out/types.d.ts for complete type definitions\n```\n\n<!-- CUSTOM_MT_TYPES_START -->\n##### out/modules/custom-mt/types.d.ts\n\n```typescript\nimport Crowdin, { SourceStringsModel } from '@crowdin/crowdin-api-client';\nimport { CrowdinContextInfo, ModuleKey } from '../../types';\n\nexport interface CustomMTLogic extends ModuleKey {\n    withContext?: boolean;\n    batchSize?: number;\n    maskEntities?: boolean;\n    translate: (\n        client: Crowdin,\n        context: CrowdinContextInfo,\n        projectId: number,\n        source: string,\n        target: string,\n        strings: CustomMtString[],\n    ) => Promise<string[]>;\n    validate?: (client: Crowdin) => Promise<void>;\n}\n\nexport interface CustomMTRequest {\n    strings: CustomMtString[];\n}\n\nexport type CustomMtString =\n    | string\n    | {\n          id: number;\n          projectId: number;\n          fileId: number;\n          identifier: string;\n          context: string;\n          maxLength: number;\n          isHidden: boolean;\n          text: string | SourceStringsModel.PluralText;\n          isPlural: boolean;\n          pluralForm: any;\n      };\n```\n<!-- CUSTOM_MT_TYPES_END -->\n\n### Profile Resources Menu Module Configuration\n\n**‚ö†Ô∏è IMPORTANT**: This module is **REQUIRED** and cannot be removed from the application. The Profile Resources Menu provides essential functionality for user profile integration.\n\nConfigure the Profile Resources Menu module in `worker/app.ts`:\n\n```typescript\nconst configuration: ClientConfig = {\n    // ... other configuration ...\n\n    profileResourcesMenu: {\n      fileName: 'index.html',\n      uiPath: '/'\n    }\n}\n```\n\n**Note**: While you can customize the UI and functionality, you must not remove this module configuration from your app.\n\n### Organization Menu Module Configuration\n\n**‚ö†Ô∏è IMPORTANT**: This module is **REQUIRED** and cannot be removed from the application. The Organization Menu provides essential functionality for organization-level navigation and settings.\n\nConfigure the Organization Menu module in `worker/app.ts`:\n\n```typescript\nconst configuration: ClientConfig = {\n    // ... other configuration ...\n\n    organizationMenu: {\n      fileName: 'index.html',\n      uiPath: '/'\n    }\n}\n```\n\n**Note**: While you can customize the UI and functionality, you must not remove this module configuration from your app.\n\n### API Endpoints Best Practices\n\n#### Common Examples\n\n**Standard Endpoint:**\n```typescript\napp.post('/api/process-data', async (req: Request, res: Response) => {\n    try {\n        const jwt = req.query.jwt as string;\n        const { data } = req.body;\n        \n        if (!jwt) {\n            return res.status(400).json({ success: false, error: 'JWT token is required' });\n        }\n        if (!data) {\n            return res.status(400).json({ success: false, error: 'Data is required' });\n        }\n\n        const connection = await crowdinApp.establishCrowdinConnection(jwt, undefined);\n        \n        // Your async logic here\n        const result = await processData(data);\n        \n        res.json({ \n            success: true, \n            result\n        });\n    } catch (error) {\n        console.error('Error:', error);\n        res.status(500).json({ success: false, error: 'Operation failed' });\n    }\n});\n```\n\n#### Best Practices\n\n1. **Always await async operations**\n   ```typescript\n   // ‚úÖ CORRECT - all operations are awaited\n   app.post('/api/save-config', async (req: Request, res: Response) => {\n       const jwt = req.query.jwt as string;\n       const connection = await crowdinApp.establishCrowdinConnection(jwt, undefined);\n       \n       await crowdinApp.saveMetadata(key, data, connection.context.crowdinId);\n       \n       res.json({ success: true });\n   });\n   \n   // ‚ùå WRONG - missing await, operation will NOT complete\n   app.post('/api/save-config', async (req: Request, res: Response) => {\n       const jwt = req.query.jwt as string;\n       const connection = await crowdinApp.establishCrowdinConnection(jwt, undefined);\n       \n       // This will NOT save! Response is sent before operation completes\n       crowdinApp.saveMetadata(key, data, connection.context.crowdinId);\n       \n       res.json({ success: true });\n   });\n   ```\n\n2. **Always return response after all operations complete**\n   ```typescript\n   // ‚úÖ CORRECT - response sent after all operations\n   app.post('/api/update', async (req: Request, res: Response) => {\n       const connection = await crowdinApp.establishCrowdinConnection(jwt, undefined);\n       \n       await operation1();\n       await operation2();\n       await operation3();\n       \n       res.json({ success: true }); // All operations completed\n   });\n   \n   // ‚ùå WRONG - response sent too early\n   app.post('/api/update', async (req: Request, res: Response) => {\n       const connection = await crowdinApp.establishCrowdinConnection(jwt, undefined);\n       \n       res.json({ success: true }); // Sent immediately\n       \n       await operation1(); // These will NOT execute\n       await operation2();\n       await operation3();\n   });\n   ```\n\n3. **Use Promise.all for independent parallel operations**\n   ```typescript\n   // ‚úÖ CORRECT - parallel operations (faster)\n   const [result1, result2, result3] = await Promise.all([\n       connection.client.projectsGroupsApi.getProject(id1),\n       connection.client.projectsGroupsApi.getProject(id2),\n       connection.client.projectsGroupsApi.getProject(id3)\n   ]);\n   \n   // ‚ùå WRONG - sequential operations (slower)\n   const result1 = await connection.client.projectsGroupsApi.getProject(id1);\n   const result2 = await connection.client.projectsGroupsApi.getProject(id2);\n   const result3 = await connection.client.projectsGroupsApi.getProject(id3);\n   ```\n\n4. **Wrap all async code in try-catch**\n   ```typescript\n   // ‚úÖ CORRECT - comprehensive error handling\n   app.get('/api/data', async (req: Request, res: Response) => {\n       try {\n           const connection = await crowdinApp.establishCrowdinConnection(jwt, undefined);\n           const data = await fetchData();\n           res.json({ success: true, data });\n       } catch (error) {\n           console.error('Error:', error);\n           res.status(500).json({ success: false, error: 'Operation failed' });\n       }\n   });\n   \n   // ‚ùå WRONG - no error handling\n   app.get('/api/data', async (req: Request, res: Response) => {\n       const connection = await crowdinApp.establishCrowdinConnection(jwt, undefined);\n       const data = await fetchData(); // May throw unhandled error\n       res.json({ success: true, data });\n   });\n   ```\n\n5. **Never use setTimeout without proper promise wrapper**\n   ```typescript\n   // ‚úÖ CORRECT - setTimeout with promise wrapper\n   app.get('/api/delayed', async (req: Request, res: Response) => {\n       await new Promise((resolve) => {\n           setTimeout(async () => {\n               await saveData();\n               resolve(undefined);\n           }, 1000);\n       });\n       \n       res.json({ success: true });\n   });\n   \n   // ‚ùå WRONG - setTimeout without await (will NOT execute)\n   app.get('/api/delayed', async (req: Request, res: Response) => {\n       setTimeout(async () => {\n           await saveData(); // This will NOT execute\n       }, 1000);\n       \n       res.json({ success: true }); // Sent immediately\n   });\n   ```\n\n6. **Always check for required parameters early**\n   ```typescript\n   // ‚úÖ CORRECT - validate parameters first\n   app.post('/api/process', async (req: Request, res: Response) => {\n       const jwt = req.query.jwt as string;\n       const { projectId, data } = req.body;\n       \n       // Validate early\n       if (!jwt) {\n           return res.status(400).json({ error: 'JWT token is required' });\n       }\n       if (!projectId) {\n           return res.status(400).json({ error: 'Project ID is required' });\n       }\n       if (!data) {\n           return res.status(400).json({ error: 'Data is required' });\n       }\n       \n       // Continue with processing\n       const connection = await crowdinApp.establishCrowdinConnection(jwt, undefined);\n       // ... rest of the logic\n   });\n   ```\n\n### Crowdin API Client\n\n#### Official Documentation\n\nThe `connection.client` object is an instance of `@crowdin/crowdin-api-client`.\n\n**üìö Complete API Reference:** https://crowdin.github.io/crowdin-api-client-js/modules.html\n\n**‚ö†Ô∏è CRITICAL**: Only use methods documented in the official API reference. Do NOT invent or assume methods exist.\n\n#### Common Examples\n\n**Standard Endpoint Template:**\n```typescript\napp.get('/api/your-endpoint', async (req: Request, res: Response) => {\n    try {\n        const jwt = req.query.jwt as string;\n        if (!jwt) {\n            return res.status(400).json({ success: false, error: 'JWT token is required' });\n        }\n\n        if (!crowdinApp.establishCrowdinConnection) {\n            return res.status(500).json({ success: false, error: 'Crowdin connection method not available' });\n        }\n\n        const connection = await crowdinApp.establishCrowdinConnection(jwt, undefined);\n\n        if (!connection.client) {\n            return res.status(500).json({ success: false, error: 'Crowdin API client not available' });\n        }\n\n        const userId = connection.context.jwtPayload.context.user_id;\n        const organizationId = connection.context.jwtPayload.context.organization_id;\n\n        // Your logic here using connection.client API\n        \n        res.status(200).json({ success: true, data: result });\n    } catch (error) {\n        console.error('Error:', error);\n        res.status(500).json({ success: false, error: 'Operation failed' });\n    }\n});\n```\n\n**Get Project Details:**\n```typescript\nconst response = await connection.client.projectsGroupsApi.getProject(projectId);\n\n// Access project properties\nconst project = response.data;\nconst projectName = project.name;                    // string\nconst sourceLanguageId = project.sourceLanguageId;   // string\nconst targetLanguageIds = project.targetLanguageIds; // string[]\nconst description = project.description;             // string | null\n```\n\n**List All Projects (with pagination):**\n```typescript\nconst response = await connection.client.projectsGroupsApi.withFetchAll().listProjects();\n\n// Iterate through all projects\nresponse.data.forEach((projectItem: ResponseObject<ProjectsGroupsModel.Project>) => {\n  const projectId = projectItem.data.id;\n  const projectName = projectItem.data.name;\n  const groupId = projectItem.data.groupId; // number | null\n});\n```\n\n**Get Supported Languages:**\n```typescript\nconst response = await connection.client.languagesApi.withFetchAll().listSupportedLanguages();\n\n// Filter languages\nconst targetLanguageIds = ['uk', 'pl', 'de'];\nconst projectLanguages = response.data.filter(\n  (lang: ResponseObject<LanguagesModel.Language>) => targetLanguageIds.includes(lang.data.id)\n);\n\n// Map to simpler structure\nconst languages = projectLanguages.map((lang: ResponseObject<LanguagesModel.Language>) => ({\n  id: lang.data.id,           // string: \"uk\"\n  name: lang.data.name,       // string: \"Ukrainian\"\n  locale: lang.data.locale,   // string: \"uk-UA\"\n  osxLocale: lang.data.osxLocale // string\n}));\n```\n\n**List Source Files:**\n```typescript\nconst response = await connection.client.sourceFilesApi.withFetchAll().listProjectFiles(projectId);\n\nresponse.data.forEach((fileItem: ResponseObject<SourceFilesModel.File>) => {\n  const file = fileItem.data;\n  const fileId = file.id;             // number\n  const fileName = file.name;         // string\n  const branchId = file.branchId;     // number | null\n  const directoryId = file.directoryId; // number | null\n});\n```\n\n#### Best Practices\n\n1. **Always access data via `.data` property**\n   ```typescript\n   // ‚úÖ CORRECT\n   const project = response.data;\n   const projectName = response.data.name;\n   \n   // ‚ùå WRONG - will be undefined\n   const projectName = response.name;\n   ```\n\n2. **Use withFetchAll() for complete data**\n   ```typescript\n   // ‚úÖ CORRECT - gets all items\n   const response = await connection.client.languagesApi.withFetchAll().listSupportedLanguages();\n   \n   // ‚ö†Ô∏è PARTIAL - only first page (25 items)\n   const response = await connection.client.languagesApi.listSupportedLanguages();\n   ```\n\n3. **Handle nullable properties**\n   ```typescript\n   const description = response.data.description || 'No description';\n   const groupId = response.data.groupId ?? null;\n   ```\n\n4. **Handle errors properly**\n   ```typescript\n   try {\n     const response = await connection.client.projectsGroupsApi.getProject(projectId);\n     const project = response.data;\n     // Use project data\n   } catch (error: any) {\n     console.error('Crowdin API Error:', error);\n\n     // API errors have specific structure\n     if (error.code === 404) {\n       return res.status(404).json({ error: 'Project not found' });\n     }\n     \n     return res.status(500).json({\n       error: 'API request failed',\n       details: error.message\n     });\n   }\n   ```\n\n5. **Use TypeScript types**\n   ```typescript\n   import type { ResponseObject, ProjectsGroupsModel } from '@crowdin/crowdin-api-client';\n   \n   // Use in your code\n   const response: ResponseObject<ProjectsGroupsModel.Project> = await connection.client.projectsGroupsApi.getProject(projectId);\n   const project: ProjectsGroupsModel.Project = response.data;\n   ```\n\n6. **Always sort data explicitly when order matters**\n   ```typescript\n   // ‚úÖ CORRECT - sort projects by creation date (newest first)\n   const response = await connection.client.projectsGroupsApi.withFetchAll().listProjects();\n   const sortedByDate = response.data.sort(\n     (a: ResponseObject<ProjectsGroupsModel.Project>, b: ResponseObject<ProjectsGroupsModel.Project>) => {\n       const dateA = new Date(a.data.createdAt).getTime();\n       const dateB = new Date(b.data.createdAt).getTime();\n       return dateB - dateA; // Descending order (newest first)\n     }\n   );\n   \n   // ‚ùå WRONG - assuming data is already sorted by date\n   const response = await connection.client.projectsGroupsApi.withFetchAll().listProjects();\n   // Directly using response.data without sorting - order is not guaranteed!\n   ```\n\n7. **Never use CroQL - fetch all data and filter manually**\n   ```typescript\n   // ‚úÖ CORRECT - fetch all strings and filter manually\n   const allStrings = await connection.client.sourceStringsApi.withFetchAll().listProjectStrings(projectId);\n   \n   // Filter for specific criteria\n   const filteredStrings = allStrings.data.filter(\n     (item: ResponseObject<SourceStringsModel.String>) => {\n       const str = item.data;\n       return str.text.includes('welcome') && !str.isHidden;\n     }\n   );\n   \n   // ‚ùå WRONG - using CroQL queries\n   const response = await connection.client.sourceStringsApi.listProjectStrings(projectId, {\n     croql: 'text contains \"welcome\" AND isHidden = false'\n   });\n   // CroQL should be avoided - fetch all data and filter in your code instead\n   ```\n\n#### Complete Type Definitions\n\n**‚ö†Ô∏è CRITICAL**: Only use methods and types from `@crowdin/crowdin-api-client` definitions below.\n\n**Do NOT invent methods or properties that are not listed here.**\n\n<!-- CROWDIN_API_CLIENT_TYPES_START -->\n\n##### ai/index.d.ts\n\n```typescript\nimport { CrowdinApi, DownloadLink, PaginationOptions, PatchRequest, PlainObject, ResponseList, ResponseObject, Status } from '../core';\nexport declare class Ai extends CrowdinApi {\n    listAiOrganizationCustomPlaceholders(options?: PaginationOptions): Promise<ResponseList<AiModel.CustomPlaceholder>>;\n    addAiOrganizationCustomPlaceholder(request: AiModel.AddCustomPlaceholderRequest): Promise<ResponseObject<AiModel.CustomPlaceholder>>;\n    getAiOrganizationCustomPlaceholder(aiCustomPlaceholderId: number): Promise<ResponseObject<AiModel.CustomPlaceholder>>;\n    deleteAiOrganizationCustomPlaceholder(aiCustomPlaceholderId: number): Promise<void>;\n    editAiOrganizationCustomPlaceholder(aiCustomPlaceholderId: number, request: PatchRequest[]): Promise<ResponseObject<AiModel.CustomPlaceholder>>;\n    generateAiOrganizationPromptFineTuningDataset(aiPromptId: number, request: AiModel.GenerateFineTuningDataset): Promise<ResponseObject<Status<AiModel.FineTuningDataset>>>;\n    getAiOrganizationPromptFineTuningDatasetStatus(aiPromptId: number, jobIdentifier: string): Promise<ResponseObject<Status<AiModel.FineTuningDataset>>>;\n    listAiOrganizationPromptFineTuningEvents(aiPromptId: number, jobIdentifier: string, options?: PaginationOptions): Promise<ResponseList<AiModel.PromptFineTuningEvent>>;\n    listAiOrganizationPromptFineTuningJobs(options?: AiModel.ListPromptFineTuningJobsOptions): Promise<ResponseList<Status<AiModel.FineTuningJob>>>;\n    createAiOrganizationPromptFineTuningJob(aiPromptId: number, request: AiModel.GenerateFineTuningJob): Promise<ResponseObject<Status<AiModel.FineTuningJob>>>;\n    getAiOrganizationPromptFineTuningJobStatus(aiPromptId: number, jobIdentifier: string): Promise<ResponseObject<Status<AiModel.FineTuningJob>>>;\n    downloadAiOrganizationPromptFineTuningDataset(aiPromptId: number, jobIdentifier: string): Promise<ResponseObject<DownloadLink>>;\n    cloneAiOrganizationPrompt(aiPromptId: number, request?: {\n        name?: string;\n    }): Promise<ResponseObject<AiModel.AiPromptResponse>>;\n    listAiOrganizationPrompts(options?: AiModel.ListAiPromptsOptions): Promise<ResponseList<AiModel.AiPromptResponse>>;\n    addAiOrganizationPrompt(request: AiModel.AddAiPromptRequest): Promise<ResponseObject<AiModel.AiPromptResponse>>;\n    generateAiOrganizationPromptCompletion(aiPromptId: number, request: AiModel.GenerateAiPromptCompletionRequest): Promise<ResponseObject<Status<AiModel.AiPromptCompletionAttribute>>>;\n    getAiOrganizationPromptCompletionStatus(aiPromptId: number, completionId: string): Promise<ResponseObject<Status<AiModel.AiPromptCompletionAttribute>>>;\n    cancelAiOrganizationPromptCompletion(aiPromptId: number, completionId: string): Promise<void>;\n    downloadAiOrganizationPromptCompletion(aiPromptId: number, completionId: string): Promise<ResponseObject<DownloadLink>>;\n    getAiOrganizationPrompt(aiPromptId: number): Promise<ResponseObject<AiModel.AiPromptResponse>>;\n    deleteAiOrganizationPrompt(aiPromptId: number): Promise<void>;\n    editAiOrganizationPrompt(aiPromptId: number, request: PatchRequest[]): Promise<ResponseObject<AiModel.AiPromptResponse>>;\n    listAiOrganizationProviders(options?: PaginationOptions): Promise<ResponseList<AiModel.AiProviderResponse>>;\n    addAiOrganizationProvider(request: AiModel.AddAiProviderRequest): Promise<ResponseObject<AiModel.AiProviderResponse>>;\n    getAiOrganizationProvider(aiProviderId: number): Promise<ResponseObject<AiModel.AiProviderResponse>>;\n    deleteAiOrganizationProvider(aiProviderId: number): Promise<void>;\n    editAiOrganizationProvider(aiProviderId: number, request: PatchRequest[]): Promise<ResponseObject<AiModel.AiProviderResponse>>;\n    listAiOrganizationProviderModels(aiProviderId: number, options?: PaginationOptions): Promise<ResponseList<AiModel.AiProviderModelResponse>>;\n    listAiOrganizationAllProviderModels(options?: PaginationOptions): Promise<ResponseList<AiModel.AiProviderModelResponse>>;\n    createAiOrganizationProxyChatCompletion(aiProviderId: number, request?: AiModel.OtherChatCompletionRequest | AiModel.GoogleGeminiChatCompletionRequest): Promise<ResponseObject<AiModel.AiProviderProxyResponseData>>;\n    generateAiOrganizationReport(request: AiModel.AiReport): Promise<ResponseObject<Status<AiModel.AiReport>>>;\n    checkAiOrganizationReportStatus(aiReportId: string): Promise<ResponseObject<Status<AiModel.AiReport>>>;\n    downloadAiOrganizationReport(aiReportId: string): Promise<ResponseObject<DownloadLink>>;\n    getAiOrganizationSettings(): Promise<ResponseObject<AiModel.AiSettings>>;\n    editAiOrganizationSettings(request: PatchRequest[]): Promise<ResponseObject<AiModel.AiSettings>>;\n    listAiUserCustomPlaceholders(userId: number, options?: PaginationOptions): Promise<ResponseList<AiModel.CustomPlaceholder>>;\n    addAiUserCustomPlaceholder(userId: number, request: AiModel.AddCustomPlaceholderRequest): Promise<ResponseObject<AiModel.CustomPlaceholder>>;\n    getAiUserCustomPlaceholder(userId: number, aiCustomPlaceholderId: number): Promise<ResponseObject<AiModel.CustomPlaceholder>>;\n    deleteAiUserCustomPlaceholder(userId: number, aiCustomPlaceholderId: number): Promise<void>;\n    editAiUserCustomPlaceholder(userId: number, aiCustomPlaceholderId: number, request: PatchRequest[]): Promise<ResponseObject<AiModel.CustomPlaceholder>>;\n    generateAiUserPromptFineTuningDataset(userId: number, aiPromptId: number, request: AiModel.GenerateFineTuningDataset): Promise<ResponseObject<Status<AiModel.FineTuningDataset>>>;\n    getAiUserPromptFineTuningDatasetStatus(userId: number, aiPromptId: number, jobIdentifier: string): Promise<ResponseObject<Status<AiModel.FineTuningDataset>>>;\n    listAiUserPromptFineTuningEvents(userId: number, aiPromptId: number, jobIdentifier: string, options?: PaginationOptions): Promise<ResponseList<AiModel.PromptFineTuningEvent>>;\n    listAiUserPromptFineTuningJobs(userId: number, options?: AiModel.ListPromptFineTuningJobsOptions): Promise<ResponseList<Status<AiModel.FineTuningJob>>>;\n    createAiUserPromptFineTuningJob(userId: number, aiPromptId: number, request: AiModel.GenerateFineTuningJob): Promise<ResponseObject<Status<AiModel.FineTuningJob>>>;\n    getAiUserPromptFineTuningJobStatus(userId: number, aiPromptId: number, jobIdentifier: string): Promise<ResponseObject<Status<AiModel.FineTuningJob>>>;\n    downloadAiUserPromptFineTuningDataset(userId: number, aiPromptId: number, jobIdentifier: string): Promise<ResponseObject<DownloadLink>>;\n    cloneAiUserPrompt(userId: number, aiPromptId: number, request?: {\n        name?: string;\n    }): Promise<ResponseObject<AiModel.AiPromptResponse>>;\n    listAiUserPrompts(userId: number, options?: AiModel.ListAiPromptsOptions): Promise<ResponseList<AiModel.AiPromptResponse>>;\n    addAiUserPrompt(userId: number, request: AiModel.AddAiPromptRequest): Promise<ResponseObject<AiModel.AiPromptResponse>>;\n    generateAiUserPromptCompletion(userId: number, aiPromptId: number, request: AiModel.GenerateAiPromptCompletionRequest): Promise<ResponseObject<Status<AiModel.AiPromptCompletionAttribute>>>;\n    getAiUserPromptCompletionStatus(userId: number, aiPromptId: number, completionId: string): Promise<ResponseObject<Status<AiModel.AiPromptCompletionAttribute>>>;\n    cancelAiUserPromptCompletion(userId: number, aiPromptId: number, completionId: string): Promise<void>;\n    downloadAiUserPromptCompletion(userId: number, aiPromptId: number, completionId: string): Promise<ResponseObject<DownloadLink>>;\n    getAiUserPrompt(userId: number, aiPromptId: number): Promise<ResponseObject<AiModel.AiPromptResponse>>;\n    deleteAiUserPrompt(userId: number, aiPromptId: number): Promise<void>;\n    editAiUserPrompt(userId: number, aiPromptId: number, request: PatchRequest[]): Promise<ResponseObject<AiModel.AiPromptResponse>>;\n    listAiUserProviders(userId: number, options?: PaginationOptions): Promise<ResponseList<AiModel.AiProviderResponse>>;\n    addAiUserProvider(userId: number, request: AiModel.AddAiProviderRequest): Promise<ResponseObject<AiModel.AiProviderResponse>>;\n    getAiUserProvider(userId: number, aiProviderId: number): Promise<ResponseObject<AiModel.AiProviderResponse>>;\n    deleteAiUserProvider(userId: number, aiProviderId: number): Promise<void>;\n    editAiUserProvider(userId: number, aiProviderId: number, request: PatchRequest[]): Promise<ResponseObject<AiModel.AiProviderResponse>>;\n    listAiUserProviderModels(userId: number, aiProviderId: number, options?: PaginationOptions): Promise<ResponseList<AiModel.AiProviderModelResponse>>;\n    listAiUserAllProviderModels(userId: number, options?: PaginationOptions): Promise<ResponseList<AiModel.AiProviderModelResponse>>;\n    createAiUserProxyChatCompletion(userId: number, aiProviderId: number, request?: AiModel.OtherChatCompletionRequest | AiModel.GoogleGeminiChatCompletionRequest): Promise<ResponseObject<AiModel.AiProviderProxyResponseData>>;\n    generateAiUserReport(userId: number, request: AiModel.AiReport): Promise<ResponseObject<Status<AiModel.AiReport>>>;\n    checkAiUserReportStatus(userId: number, aiReportId: string): Promise<ResponseObject<Status<AiModel.AiReport>>>;\n    downloadAiUserReport(userId: number, aiReportId: string): Promise<ResponseObject<DownloadLink>>;\n    getAiUsertSettings(userId: number): Promise<ResponseObject<AiModel.AiSettings>>;\n    editAiUserSettings(userId: number, request: PatchRequest[]): Promise<ResponseObject<AiModel.AiSettings>>;\n}\nexport declare namespace AiModel {\n    interface CustomPlaceholder {\n        id: number;\n        description: string;\n        placeholder: string;\n        value: string;\n        createdAt: string;\n        updatedAt: string;\n    }\n    interface AddCustomPlaceholderRequest {\n        description: string;\n        placeholder: string;\n        value: string;\n    }\n    interface FineTuningDataset {\n        projectIds: number[];\n        tmIds: number[];\n        purpose: 'training' | 'validation';\n        dateFrom: string;\n        dateTo: string;\n        maxFileSize: number;\n        minExamplesCount: number;\n        maxExamplesCount: number;\n    }\n    interface GenerateFineTuningDataset {\n        projectIds?: number[];\n        tmIds?: number[];\n        purpose?: 'training' | 'validation';\n        dateFrom?: string;\n        dateTo?: string;\n        maxFileSize?: number;\n        minExamplesCount?: number;\n        maxExamplesCount?: number;\n    }\n    interface GenerateFineTuningJob {\n        dryRun?: boolean;\n        hyperparameters?: {\n            batchSize: number;\n            learningRateMultiplier: number;\n            nEpochs: number;\n        };\n        trainingOptions: Omit<GenerateFineTuningDataset, 'purpose'>;\n        validationOptions?: Omit<GenerateFineTuningDataset, 'purpose'>;\n    }\n    interface FineTuningJob {\n        dryRun: boolean;\n        aiPromptId: number;\n        hyperparameters: {\n            batchSize: number;\n            learningRateMultiplier: number;\n            nEpochs: number;\n        };\n        trainingOptions: Omit<GenerateFineTuningDataset, 'purpose'>;\n        validationOptions: Omit<GenerateFineTuningDataset, 'purpose'>;\n        baseModel: string;\n        fineTunedModel: string;\n        trainedTokensCount: number;\n        trainingDatasetUrl: string;\n        validationDatasetUrl: string;\n        metadata: PlainObject;\n    }\n    interface PromptFineTuningEvent {\n        id: string;\n        type: string;\n        message: string;\n        data: {\n            step: number;\n            totalSteps: number;\n            trainingLoss: number;\n            validationLoss: number;\n            fullValidationLoss: number;\n        };\n        createdAt: string;\n    }\n    interface ListPromptFineTuningJobsOptions extends PaginationOptions {\n        statuses: string;\n        orderBy: string;\n    }\n    interface ListAiPromptsOptions extends PaginationOptions {\n        projectId?: number;\n        action?: Action;\n    }\n    interface AiPromptResponse {\n        id: number;\n        name: string;\n        action: Action;\n        aiProviderId: number;\n        aiModelId: string;\n        isEnabled: boolean;\n        enabledProjectIds: number[];\n        config: AiModel.AiPromptConfigBasicPreTranslate | AiModel.AiPromptConfigBasicAssistAction | AiModel.AiPromptConfigBasicAligmentAction | AiModel.AiPromptConfigAdvanced | AiModel.AiPromptConfigExternal;\n        promptPreview: string;\n        isFineTuningAvailable: boolean;\n        createdAt: string;\n        updatedAt: string;\n    }\n    interface AiPromptConfigBasicOtherLanguageTranslations {\n        isEnabled?: boolean;\n        languageIds?: string[];\n    }\n    interface AiPromptConfigBasicPreTranslate {\n        mode: 'basic';\n        companyDescription?: string;\n        projectDescription?: string;\n        audienceDescription?: string;\n        customPlaceholders?: string[];\n        otherLanguageTranslations?: AiModel.AiPromptConfigBasicOtherLanguageTranslations;\n        glossaryTerms?: boolean;\n        tmSuggestions?: boolean;\n        fileContent?: boolean;\n        fileContext?: boolean;\n        screenshots?: boolean;\n        publicProjectDescription?: boolean;\n        siblingsStrings?: boolean;\n    }\n    interface AiPromptConfigBasicAssistAction {\n        mode: 'basic';\n        companyDescription?: string;\n        projectDescription?: string;\n        audienceDescription?: string;\n        otherLanguageTranslations?: AiModel.AiPromptConfigBasicOtherLanguageTranslations;\n        glossaryTerms?: boolean;\n        tmSuggestions?: boolean;\n        fileContext?: boolean;\n        screenshots?: boolean;\n        publicProjectDescription?: boolean;\n        siblingsStrings?: boolean;\n        filteredStrings?: boolean;\n    }\n    interface AiPromptConfigBasicAligmentAction {\n        mode: 'basic';\n        customPlaceholders?: string[];\n        publicProjectDescription?: boolean;\n    }\n    interface AiPromptConfigAdvanced {\n        mode: 'advanced';\n        screenshots?: boolean;\n        prompt: string;\n        otherLanguageTranslations?: AiModel.AiPromptConfigBasicOtherLanguageTranslations;\n    }\n    interface AiPromptConfigExternal {\n        mode: 'external';\n        identifier: string;\n        key: string;\n        options?: any;\n    }\n    interface AddAiPromptRequest {\n        name: string;\n        action: Action;\n        aiProviderId?: number;\n        aiModelId?: string;\n        isEnabled?: boolean;\n        enabledProjectIds?: number[];\n        config: AiModel.AiPromptConfigBasicPreTranslate | AiModel.AiPromptConfigBasicAssistAction | AiModel.AiPromptConfigBasicAligmentAction | AiModel.AiPromptConfigAdvanced | AiPromptConfigExternal;\n    }\n    interface GenerateAiPromptCompletionRequest {\n        resources: AiModel.AiPromptResourceWithPreTranslate | AiModel.AiPromptResourceWithAssist | AiModel.AiPromptResourceWithAlignment | AiModel.AiPromptResourceWithCustom;\n        tools?: {\n            tool: {\n                type: 'function';\n                function: {\n                    description?: string;\n                    name: string;\n                    parameters?: PlainObject;\n                };\n            };\n        }[];\n        tool_choice?: string | PlainObject;\n    }\n    interface AiPromptCompletionAttribute {\n        aiPromptId: number;\n    }\n    interface AiPromptResourceWithPreTranslate {\n        projectId: number;\n        sourceLanguageId?: string;\n        targetLanguageId?: string;\n        stringIds?: number[];\n        overridePromptValues?: OverridePromptValues;\n    }\n    interface AiPromptResourceWithAlignment {\n        projectId: number;\n        sourceLanguageId?: string;\n        targetLanguageId?: string;\n        stringIds?: number[];\n        overridePromptValues?: OverridePromptValues;\n    }\n    interface AiPromptResourceWithAssist {\n        projectId: number;\n        sourceLanguageId?: string;\n        targetLanguageId?: string;\n        stringIds?: number[];\n        filteredStringsIds?: number[];\n        overridePromptValues?: OverridePromptValues;\n    }\n    interface AiPromptResourceWithCustom {\n        projectId: number;\n        sourceLanguageId?: string;\n        targetLanguageId?: string;\n        stringIds?: number[];\n        overridePromptValues?: OverridePromptValues;\n        customInstruction?: string;\n    }\n    interface OverridePromptValues {\n        [key: string]: any;\n    }\n    interface AiProviderResponse {\n        id: number;\n        name: string;\n        type: ProviderType;\n        credentials: AiModel.AiProviderCredentialsBasic | AiModel.AiProviderCredentialsAzureOpenAi | AiProviderCredentialsGoogleGemini | AiProviderCredentialsCustom;\n        config: AiModel.AiProviderConfig;\n        isEnabled: boolean;\n        useSystemCredentials: boolean;\n        createdAt: string;\n        updatedAt: string;\n        promptsCount: string;\n    }\n    interface AiProviderCredentialsBasic {\n        apiKey: string;\n    }\n    interface AiProviderCredentialsAzureOpenAi extends AiProviderCredentialsBasic {\n        resourceName: string;\n        deploymentName: string;\n        apiVersion: string;\n    }\n    interface AiProviderCredentialsGoogleGemini {\n        project: string;\n        region: string;\n        serviceAccountKey: string;\n    }\n    interface AiProviderCredentialsWatsonx {\n        apiKey: string;\n        projectId: string;\n        region: string;\n    }\n    interface AiProviderCredentialsCustom {\n        identifier: string;\n        key: string;\n    }\n    interface AiProviderConfig {\n        actionRules?: AiModel.AiProviderConfigActionRule[];\n    }\n    interface AiProviderConfigActionRule {\n        action?: 'pre_translate' | 'assist';\n        availableAiModelIds?: string[];\n    }\n    interface AddAiProviderRequest {\n        name: string;\n        type: ProviderType;\n        credentials?: AiModel.AiProviderCredentialsBasic | AiModel.AiProviderCredentialsAzureOpenAi | AiProviderCredentialsGoogleGemini | AiProviderCredentialsWatsonx | AiProviderCredentialsCustom;\n        config?: AiModel.AiProviderConfig;\n        isEnabled?: boolean;\n        useSystemCredentials?: boolean;\n    }\n    interface AiProviderModelResponse {\n        id: string;\n    }\n    interface AiProviderProxyResponseData {\n        data: object;\n    }\n    interface OtherChatCompletionRequest {\n        stream?: boolean;\n        [key: string]: any;\n    }\n    interface GoogleGeminiChatCompletionRequest extends OtherChatCompletionRequest {\n        model: string;\n    }\n    type AiReport = AiReportTokenUsage;\n    interface AiReportTokenUsage {\n        type: 'tokens-usage-raw-data';\n        schema: AiReportGeneralSchema;\n    }\n    interface AiReportGeneralSchema {\n        dateFrom: string;\n        dateTo: string;\n        format?: 'json' | 'csv';\n        projectIds?: number[];\n        promptIds?: number[];\n        userIds?: number[];\n    }\n    interface AiSettings {\n        assistActionAiPromptId: number;\n        showSuggestion: boolean;\n        shortcuts: {\n            name: string;\n            prompt: string;\n            enabled: boolean;\n        }[];\n    }\n    type Action = 'pre_translate' | 'assist';\n    type ProviderType = 'open_ai' | 'azure_open_ai' | 'google_gemini' | 'mistral_ai' | 'anthropic' | 'custom_ai' | 'x_ai' | 'deepseek' | 'watsonx';\n}\n```\n\n##### applications/index.d.ts\n\n```typescript\nimport { CrowdinApi, ResponseObject, PatchRequest, Pagination, ResponseList } from '../core';\nexport declare class Applications extends CrowdinApi {\n    listApplicationInstallations(options?: Pagination): Promise<ResponseList<ApplicationsModel.Application>>;\n    installApplication(request: ApplicationsModel.InstallApplication): Promise<ResponseObject<ApplicationsModel.Application>>;\n    getApplicationInstallation(applicationId: string): Promise<ResponseObject<ApplicationsModel.Application>>;\n    deleteApplicationInstallation(applicationId: string, force?: boolean): Promise<ResponseObject<ApplicationsModel.Application>>;\n    editApplicationInstallation(applicationId: string, request: PatchRequest[]): Promise<ResponseObject<ApplicationsModel.Application>>;\n    getApplicationData(applicationId: string, path: string): Promise<ResponseObject<any>>;\n    updateOrRestoreApplicationData(applicationId: string, path: string, request: any): Promise<ResponseObject<any>>;\n    addApplicationData(applicationId: string, path: string, request: any): Promise<ResponseObject<any>>;\n    deleteApplicationData(applicationId: string, path: string): Promise<void>;\n    editApplicationData(applicationId: string, path: string, request: any): Promise<ResponseObject<any>>;\n}\nexport declare namespace ApplicationsModel {\n    interface Application {\n        identifier: string;\n        name: string;\n        description: string;\n        logo: string;\n        baseUrl: string;\n        manifestUrl: string;\n        createdAt: string;\n        modules: ApplicationModule[];\n        scopes: string[];\n        permissions: ApplicationPermissions;\n        defaultPermissions: any;\n        limitReached: boolean;\n    }\n    interface InstallApplication {\n        url: string;\n        permissions?: ApplicationPermissions;\n        modules?: ApplicationModule[];\n    }\n    interface ApplicationPermissions {\n        user: {\n            value: 'all' | 'owner' | 'managers' | 'guests' | 'restricted';\n            ids: number[];\n        };\n        project: {\n            value: 'own' | 'restricted';\n            ids: number[];\n        };\n    }\n    interface ApplicationModule {\n        key: string;\n        type?: string;\n        data?: any;\n        authenticationType?: string;\n        permissions: Omit<ApplicationPermissions, 'project'>;\n    }\n}\n```\n\n##### bundles/index.d.ts\n\n```typescript\nimport { CrowdinApi, DownloadLink, PaginationOptions, PatchRequest, ResponseList, ResponseObject, Status } from '../core';\nimport { SourceFilesModel } from '../sourceFiles';\nexport declare class Bundles extends CrowdinApi {\n    listBundles(projectId: number, options?: PaginationOptions): Promise<ResponseList<BundlesModel.Bundle>>;\n    addBundle(projectId: number, request: BundlesModel.CreateBundleRequest): Promise<ResponseObject<BundlesModel.Bundle>>;\n    getBundle(projectId: number, bundleId: number): Promise<ResponseObject<BundlesModel.Bundle>>;\n    deleteBundle(projectId: number, bundleId: number): Promise<void>;\n    editBundle(projectId: number, bundleId: number, request: PatchRequest[]): Promise<ResponseObject<BundlesModel.Bundle>>;\n    downloadBundle(projectId: number, bundleId: number, exportId: string): Promise<ResponseObject<DownloadLink>>;\n    exportBundle(projectId: number, bundleId: number): Promise<ResponseObject<Status<BundlesModel.ExportAttributes>>>;\n    checkBundleExportStatus(projectId: number, bundleId: number, exportId: string): Promise<ResponseObject<Status<BundlesModel.ExportAttributes>>>;\n    listBundleFiles(projectId: number, bundleId: number, options?: PaginationOptions): Promise<ResponseList<SourceFilesModel.File>>;\n    listBundleBranches(projectId: number, bundleId: number, options?: PaginationOptions): Promise<ResponseList<SourceFilesModel.Branch>>;\n}\nexport declare namespace BundlesModel {\n    interface Bundle {\n        id: number;\n        name: string;\n        format: string;\n        sourcePatterns: string[];\n        ignorePatterns: string[];\n        exportPattern: string;\n        isMultilingual: boolean;\n        includeProjectSourceLanguage: boolean;\n        labelIds: number[];\n        excludeLabelIds: number[];\n        createdAt: string;\n        webUrl: string;\n        updatedAt: string;\n    }\n    interface CreateBundleRequest {\n        name: string;\n        format: string;\n        sourcePatterns: string[];\n        ignorePatterns?: string[];\n        exportPattern: string;\n        isMultilingual?: boolean;\n        includeProjectSourceLanguage?: boolean;\n        includeInContextPseudoLanguage?: boolean;\n        labelIds?: number[];\n        excludeLabelIds?: number[];\n    }\n    interface ExportAttributes {\n        bundleId: number;\n    }\n}\n```\n\n##### clients/index.d.ts\n\n```typescript\nimport { CrowdinApi, PaginationOptions, ResponseList } from '../core';\nexport declare class Clients extends CrowdinApi {\n    listClients(options?: PaginationOptions): Promise<ResponseList<ClientsModel.Client>>;\n}\nexport declare namespace ClientsModel {\n    interface Client {\n        id: number;\n        name: string;\n        description: string;\n        status: 'pending' | 'confirmed' | 'rejected';\n        webUrl: string;\n    }\n}\n```\n\n##### core/http-client-error.d.ts\n\n```typescript\nimport { AxiosError } from 'axios';\nimport { FetchClientJsonPayloadError } from './internal/fetch/fetchClientError';\nexport type HttpClientError = AxiosError | FetchClientJsonPayloadError | Error;\nexport declare const toHttpClientError: (error?: unknown) => HttpClientError;\n```\n\n##### core/index.d.ts\n\n```typescript\nimport { HttpClientError } from './http-client-error';\nimport { RetryConfig, RetryService } from './internal/retry';\nexport interface HttpClient {\n    get<T>(url: string, config?: {\n        headers: Record<string, string>;\n    }): Promise<T>;\n    delete<T>(url: string, config?: {\n        headers: Record<string, string>;\n    }): Promise<T>;\n    head<T>(url: string, config?: {\n        headers: Record<string, string>;\n    }): Promise<T>;\n    post<T>(url: string, data?: unknown, config?: {\n        headers: Record<string, string>;\n    }): Promise<T>;\n    put<T>(url: string, data?: unknown, config?: {\n        headers: Record<string, string>;\n    }): Promise<T>;\n    patch<T>(url: string, data?: unknown, config?: {\n        headers: Record<string, string>;\n    }): Promise<T>;\n}\nexport type HttpClientType = 'axios' | 'fetch';\nexport interface Credentials {\n    token: string;\n    organization?: string;\n    baseUrl?: string;\n}\nexport interface ClientConfig {\n    httpClientType?: HttpClientType;\n    httpClient?: HttpClient;\n    userAgent?: string;\n    integrationUserAgent?: string;\n    retryConfig?: RetryConfig;\n    httpRequestTimeout?: number;\n}\nexport interface ResponseList<T> {\n    data: ResponseObject<T>[];\n    pagination: Pagination;\n}\nexport interface ResponseObject<T> {\n    data: T;\n}\nexport interface Pagination {\n    offset: number;\n    limit: number;\n}\nexport type PaginationOptions = Partial<Pagination>;\nexport interface PatchRequest {\n    value?: any;\n    op: PatchOperation;\n    path: string;\n}\nexport type PatchOperation = 'add' | 'remove' | 'replace' | 'move' | 'copy' | 'test';\nexport type ProjectRoles = 'manager' | 'developer' | 'translator' | 'proofreader' | 'language_coordinator' | 'member';\nexport interface DownloadLink {\n    url: string;\n    expireIn: string;\n}\nexport declare enum BooleanInt {\n    TRUE = 1,\n    FALSE = 0\n}\nexport interface Status<T> {\n    identifier: string;\n    status: string;\n    progress: number;\n    attributes: T;\n    createdAt: string;\n    updatedAt: string;\n    startedAt: string;\n    finishedAt: string;\n    eta: string;\n}\nexport interface Attribute {\n    [key: string]: string;\n}\nexport type PlainObject = Record<string, any>;\nexport declare class CrowdinError extends Error {\n    apiError: any;\n    code: number;\n    constructor(message: string, code: number, apiError: any);\n}\nexport declare class CrowdinValidationError extends CrowdinError {\n    validationCodes: {\n        key: string;\n        codes: string[];\n    }[];\n    constructor(message: string, validationCodes: {\n        key: string;\n        codes: string[];\n    }[], apiError: any);\n}\nexport declare function handleHttpClientError(error: HttpClientError): never;\nexport declare abstract class CrowdinApi {\n    private static readonly CROWDIN_URL_SUFFIX;\n    private static readonly AXIOS_INSTANCE;\n    private static readonly FETCH_INSTANCE;\n    readonly token: string;\n    readonly organization?: string;\n    readonly url: string;\n    readonly config: ClientConfig | undefined;\n    readonly retryService: RetryService;\n    protected fetchAllFlag: boolean;\n    protected maxLimit: number | undefined;\n    constructor(credentials: Credentials, config?: ClientConfig);\n    graphql<T>(req: {\n        query: string;\n        operationName?: string;\n        variables?: any;\n    }, config?: {\n        url?: string;\n    }): Promise<ResponseObject<T>>;\n    protected addQueryParam(url: string, name: string, value?: string | number): string;\n    protected defaultConfig(): {\n        headers: Record<string, string>;\n    };\n    get httpClient(): HttpClient;\n    withFetchAll(maxLimit?: number): this;\n    protected getList<T = any>(url: string, limit?: number, offset?: number, config?: {\n        headers: Record<string, string>;\n    }): Promise<ResponseList<T>>;\n    protected fetchAll<T>(url: string, config: {\n        headers: Record<string, string>;\n    }, maxAmount?: number): Promise<ResponseList<T>>;\n    protected encodeUrlParam(param: string | number | boolean): string;\n    protected get<T>(url: string, config?: {\n        headers: Record<string, string>;\n    }): Promise<T>;\n    protected delete<T>(url: string, config?: {\n        headers: Record<string, string>;\n    }): Promise<T>;\n    protected head<T>(url: string, config?: {\n        headers: Record<string, string>;\n    }): Promise<T>;\n    protected post<T>(url: string, data?: unknown, config?: {\n        headers: Record<string, string>;\n    }): Promise<T>;\n    protected put<T>(url: string, data?: unknown, config?: {\n        headers: Record<string, string>;\n    }): Promise<T>;\n    protected patch<T>(url: string, data?: unknown, config?: {\n        headers: Record<string, string>;\n    }): Promise<T>;\n}\nexport declare function isOptionalString(parameter: string | unknown, parameterInArgs: boolean): parameter is string | undefined;\nexport declare function isOptionalNumber(parameter: number | unknown, parameterInArgs: boolean): parameter is number | undefined;\nexport interface ProjectRole {\n    name: string;\n    permissions: ProjectRolePermissions;\n}\nexport interface ProjectRolePermissions {\n    allLanguages: boolean;\n    languagesAccess: {\n        [lang: string]: {\n            allContent: boolean;\n            workflowStepIds: number[];\n        };\n    };\n}\n```\n\n##### dictionaries/index.d.ts\n\n```typescript\nimport { CrowdinApi, PatchRequest, ResponseList, ResponseObject } from '../core';\nexport declare class Dictionaries extends CrowdinApi {\n    listDictionaries(projectId: number, options?: DictionariesModel.ListDictionariesOptions): Promise<ResponseList<DictionariesModel.Dictionary>>;\n    listDictionaries(projectId: number, languageIds?: string): Promise<ResponseList<DictionariesModel.Dictionary>>;\n    editDictionary(projectId: number, languageId: string, request: PatchRequest[]): Promise<ResponseObject<DictionariesModel.Dictionary>>;\n}\nexport declare namespace DictionariesModel {\n    interface Dictionary {\n        languageId: string;\n        words: string[];\n    }\n    interface ListDictionariesOptions {\n        languageIds?: string;\n    }\n}\n```\n\n##### distributions/index.d.ts\n\n```typescript\nimport { CrowdinApi, PaginationOptions, PatchRequest, ResponseList, ResponseObject } from '../core';\nexport declare class Distributions extends CrowdinApi {\n    listDistributions(projectId: number, options?: PaginationOptions): Promise<ResponseList<DistributionsModel.Distribution>>;\n    listDistributions(projectId: number, limit?: number, offset?: number): Promise<ResponseList<DistributionsModel.Distribution>>;\n    createDistribution(projectId: number, request: DistributionsModel.CreateDistributionRequest | DistributionsModel.CreateDistributionStringsBasedRequest): Promise<ResponseObject<DistributionsModel.Distribution>>;\n    getDistribution(projectId: number, hash: string): Promise<ResponseObject<DistributionsModel.Distribution>>;\n    deleteDistribution(projectId: number, hash: string): Promise<void>;\n    editDistribution(projectId: number, hash: string, request: PatchRequest[]): Promise<ResponseObject<DistributionsModel.Distribution>>;\n    getDistributionRelease(projectId: number, hash: string): Promise<ResponseObject<DistributionsModel.DistributionRelease | DistributionsModel.DistributionStringsBasedRelease>>;\n    createDistributionRelease(projectId: number, hash: string): Promise<ResponseObject<DistributionsModel.DistributionRelease | DistributionsModel.DistributionStringsBasedRelease>>;\n}\nexport declare namespace DistributionsModel {\n    interface Distribution {\n        hash: string;\n        manifestUrl: string;\n        name: string;\n        bundleIds: number[];\n        createdAt: string;\n        updatedAt: string;\n        exportMode: ExportMode;\n        fileIds: number[];\n    }\n    interface CreateDistributionRequest {\n        exportMode?: ExportMode;\n        name: string;\n        fileIds?: number[];\n        bundleIds?: number[];\n    }\n    interface CreateDistributionStringsBasedRequest {\n        name: string;\n        bundleIds: number[];\n    }\n    interface DistributionRelease {\n        status: string;\n        progress: number;\n        currentLanguageId: string;\n        currentFileId: number;\n        date: string;\n    }\n    interface DistributionStringsBasedRelease {\n        status: string;\n        progress: number;\n        currentLanguageId: string;\n        currentBranchId: number;\n        date: string;\n    }\n    type ExportMode = 'default' | 'bundle';\n}\n```\n\n##### fields/index.d.ts\n\n```typescript\nimport { CrowdinApi, PaginationOptions, PatchRequest, ResponseList, ResponseObject } from '../core';\nexport declare class Fields extends CrowdinApi {\n    listFields(options?: FieldsModel.ListFieldsParams): Promise<ResponseList<FieldsModel.Field>>;\n    addField(request: FieldsModel.AddFieldRequest): Promise<ResponseObject<FieldsModel.Field>>;\n    getField(fieldId: number): Promise<ResponseObject<FieldsModel.Field>>;\n    deleteField(fieldId: number): Promise<void>;\n    editField(fieldId: number, request: PatchRequest[]): Promise<ResponseObject<FieldsModel.Field>>;\n}\nexport declare namespace FieldsModel {\n    type Entity = 'project' | 'user' | 'task' | 'file' | 'translation' | 'string';\n    type Type = 'checkbox' | 'radiobuttons' | 'date' | 'datetime' | 'number' | 'labels' | 'select' | 'multiselect' | 'text' | 'textarea' | 'url';\n    type Place = 'projectCreateModal' | 'projectHeader' | 'projectDetails' | 'projectCrowdsourceDetails' | 'projectSettings' | 'projectTaskEditCreate' | 'projectTaskDetails' | 'projectTaskBoardCard' | 'fileDetails' | 'fileSettings' | 'userEditModal' | 'userDetails' | 'userPopover' | 'stringEditModal' | 'stringDetails' | 'translationUnderContent';\n    interface Location {\n        place: Place;\n    }\n    interface Option {\n        label: string;\n        value: string;\n    }\n    interface OtherFieldConfig {\n        locations: Location[];\n    }\n    interface ListFieldConfig extends OtherFieldConfig {\n        options: Option[];\n    }\n    interface NumberFieldConfig extends OtherFieldConfig {\n        min: number;\n        max: number;\n        units: string;\n    }\n    type Config = ListFieldConfig | NumberFieldConfig | OtherFieldConfig;\n    interface ListFieldsParams extends PaginationOptions {\n        search?: string;\n        entity?: Entity;\n        type?: Type;\n    }\n    interface Field {\n        id: number;\n        name: string;\n        slug: string;\n        type: Type;\n        description: string;\n        entities: Entity[];\n        config: Config;\n        createdAt: string;\n        updatedAt: string;\n    }\n    interface AddFieldRequest {\n        name: string;\n        slug: string;\n        type: Type;\n        description?: string;\n        entities: Entity[];\n        config?: Config;\n    }\n}\n```\n\n##### glossaries/index.d.ts\n\n```typescript\nimport { CrowdinApi, DownloadLink, PaginationOptions, PatchRequest, ResponseList, ResponseObject, Status } from '../core';\nexport declare class Glossaries extends CrowdinApi {\n    listGlossaries(options?: GlossariesModel.ListGlossariesOptions): Promise<ResponseList<GlossariesModel.Glossary>>;\n    listGlossaries(groupId?: number, limit?: number, offset?: number): Promise<ResponseList<GlossariesModel.Glossary>>;\n    addGlossary(request: GlossariesModel.CreateGlossaryRequest): Promise<ResponseObject<GlossariesModel.Glossary>>;\n    getGlossary(glossaryId: number): Promise<ResponseObject<GlossariesModel.Glossary>>;\n    deleteGlossary(glossaryId: number): Promise<void>;\n    editGlossary(glossaryId: number, request: PatchRequest[]): Promise<ResponseObject<GlossariesModel.Glossary>>;\n    exportGlossary(glossaryId: number, request: GlossariesModel.ExportGlossaryRequest): Promise<ResponseObject<Status<GlossariesModel.GlossaryExportStatusAttribute>>>;\n    checkGlossaryExportStatus(glossaryId: number, exportId: string): Promise<ResponseObject<Status<GlossariesModel.GlossaryExportStatusAttribute>>>;\n    downloadGlossary(glossaryId: number, exportId: string): Promise<ResponseObject<DownloadLink>>;\n    importGlossaryFile(glossaryId: number, request: GlossariesModel.GlossaryFile): Promise<ResponseObject<Status<GlossariesModel.GlossaryImportStatusAttribute>>>;\n    checkGlossaryImportStatus(glossaryId: number, importId: string): Promise<ResponseObject<Status<GlossariesModel.GlossaryImportStatusAttribute>>>;\n    listTerms(glossaryId: number, options?: GlossariesModel.ListTermsOptions): Promise<ResponseList<GlossariesModel.Term>>;\n    listTerms(glossaryId: number, userId?: number, limit?: number, offset?: number, languageId?: string, translationOfTermId?: number, conceptId?: number): Promise<ResponseList<GlossariesModel.Term>>;\n    addTerm(glossaryId: number, request: GlossariesModel.CreateTermRequest): Promise<ResponseObject<GlossariesModel.Term>>;\n    clearGlossary(glossaryId: number, options?: GlossariesModel.ClearGlossaryOptions): Promise<ResponseObject<GlossariesModel.Term>>;\n    clearGlossary(glossaryId: number, languageId?: number, translationOfTermId?: number, conceptId?: number): Promise<ResponseObject<GlossariesModel.Term>>;\n    getTerm(glossaryId: number, termId: number): Promise<ResponseObject<GlossariesModel.Term>>;\n    deleteTerm(glossaryId: number, termId: number): Promise<void>;\n    editTerm(glossaryId: number, termId: number, request: PatchRequest[]): Promise<ResponseObject<GlossariesModel.Term>>;\n    listConcepts(glossaryId: number, options?: {\n        orderBy?: string;\n    } & PaginationOptions): Promise<ResponseList<GlossariesModel.Concept>>;\n    getConcept(glossaryId: number, conceptId: number): Promise<ResponseObject<GlossariesModel.Concept>>;\n    updateConcept(glossaryId: number, conceptId: number, request: GlossariesModel.UpdateConceptRequest): Promise<ResponseObject<GlossariesModel.Concept>>;\n    deleteConcept(glossaryId: number, conceptId: number): Promise<void>;\n    concordanceSearch(projectId: number, request: GlossariesModel.ConcordanceSearchRequest): Promise<ResponseList<GlossariesModel.ConcordanceSearchResponse>>;\n}\nexport declare namespace GlossariesModel {\n    interface Glossary {\n        id: number;\n        name: string;\n        groupId: number;\n        userId: number;\n        terms: number;\n        languageId: string;\n        languageIds: string[];\n        defaultProjectIds: number[];\n        projectIds: number[];\n        webUrl: string;\n        createdAt: string;\n    }\n    interface CreateGlossaryRequest {\n        name: string;\n        languageId: string;\n        groupId?: number;\n    }\n    type ExportField = 'term' | 'description' | 'partOfSpeech' | 'type' | 'status' | 'gender' | 'note' | 'url' | 'conceptDefinition' | 'conceptSubject' | 'conceptNote' | 'conceptUrl' | 'conceptFigure';\n    interface ExportGlossaryRequest {\n        format?: GlossaryFormat;\n        exportFields?: ExportField[];\n    }\n    interface GlossaryExportStatusAttribute {\n        format: string;\n        exportFields: ExportField[];\n    }\n    interface GlossaryImportStatusAttribute {\n        storageId: number;\n        scheme: unknown;\n        firstLineContainsHeader: boolean;\n    }\n    interface GlossaryFile {\n        storageId: number;\n        scheme?: GlossaryFileScheme;\n        firstLineContainsHeader?: boolean;\n    }\n    interface ListTermsOptions extends PaginationOptions {\n        userId?: number;\n        languageId?: string;\n        conceptId?: number;\n        orderBy?: string;\n        croql?: string;\n        translationOfTermId?: number;\n    }\n    interface Term {\n        id: number;\n        userId: number;\n        glossaryId: number;\n        languageId: string;\n        text: string;\n        description: string;\n        partOfSpeech: PartOfSpeech;\n        status: Status;\n        type: Type;\n        gender: Gender;\n        note: string;\n        url: string;\n        conceptId: number;\n        lemma: string;\n        createdAt: string;\n        updatedAt: string;\n    }\n    interface CreateTermRequest {\n        languageId: string;\n        text: string;\n        description?: string;\n        partOfSpeech?: PartOfSpeech;\n        status?: Status;\n        type?: Type;\n        gender?: Gender;\n        note?: string;\n        url?: string;\n        conceptId?: number;\n        translationOfTermId?: number;\n    }\n    interface ConcordanceSearchRequest extends PaginationOptions {\n        sourceLanguageId: string;\n        targetLanguageId: string;\n        expressions: string[];\n        expression?: string;\n    }\n    interface ConcordanceSearchResponse {\n        glossary: Glossary;\n        concept: Concept;\n        sourceTerms: Term[];\n        targetTerms: Term[];\n    }\n    type Status = 'preferred' | 'admitted' | 'not recommended' | 'obsolete';\n    type Type = 'full form' | 'acronym' | 'abbreviation' | 'short form' | 'phrase' | 'variant';\n    type Gender = 'masculine' | 'feminine' | 'neuter' | 'other';\n    type GlossaryFormat = 'tbx' | 'tbx_v3' | 'csv' | 'xlsx';\n    interface GlossaryFileScheme {\n        [key: string]: number;\n    }\n    type PartOfSpeech = 'adjective' | 'adposition' | 'adverb' | 'auxiliary' | 'coordinating conjunction' | 'determiner' | 'interjection' | 'noun' | 'numeral' | 'particle' | 'pronoun' | 'proper noun' | 'subordinating conjunction' | 'verb' | 'other';\n    interface ListGlossariesOptions extends PaginationOptions {\n        groupId?: number;\n        userId?: number;\n        orderBy?: string;\n    }\n    interface ClearGlossaryOptions {\n        languageId?: number;\n        translationOfTermId?: number;\n        conceptId?: number;\n    }\n    interface Concept {\n        id: number;\n        userId: number;\n        glossaryId: number;\n        subject: string;\n        definition: string;\n        translatable: boolean;\n        note: string;\n        url: string;\n        figure: string;\n        languagesDetails: LanguageDetails[];\n        createdAt: string;\n        updatedAt: string;\n    }\n    interface LanguageDetails {\n        languageId: string;\n        userId: number;\n        definition: string;\n        note: string;\n        createdAt: string;\n        updatedAt: string;\n    }\n    interface UpdateConceptRequest {\n        subject?: string;\n        definition?: string;\n        translatable?: boolean;\n        note?: string;\n        url?: string;\n        figure?: string;\n        languagesDetails?: {\n            languageId: string;\n            definition: string;\n            note?: string;\n        }[];\n    }\n}\n```\n\n##### index.d.ts\n\n```typescript\nimport { Ai } from './ai';\nimport { Applications } from './applications';\nimport { Bundles } from './bundles';\nimport { Clients } from './clients';\nimport { ClientConfig, Credentials, CrowdinApi } from './core';\nimport { Dictionaries } from './dictionaries';\nimport { Distributions } from './distributions';\nimport { Fields } from './fields';\nimport { Glossaries } from './glossaries';\nimport { Issues } from './issues';\nimport { Labels } from './labels';\nimport { Languages } from './languages';\nimport { MachineTranslation } from './machineTranslation';\nimport { Notifications } from './notifications';\nimport { OrganizationWebhooks } from './organizationWebhooks';\nimport { ProjectsGroups } from './projectsGroups';\nimport { Reports } from './reports';\nimport { Screenshots } from './screenshots';\nimport { SecurityLogs } from './securityLogs';\nimport { SourceFiles } from './sourceFiles';\nimport { SourceStrings } from './sourceStrings';\nimport { StringComments } from './stringComments';\nimport { StringCorrections } from './stringCorrections';\nimport { StringTranslations } from './stringTranslations';\nimport { Tasks } from './tasks';\nimport { Teams } from './teams';\nimport { TranslationMemory } from './translationMemory';\nimport { TranslationStatus } from './translationStatus';\nimport { Translations } from './translations';\nimport { UploadStorage } from './uploadStorage';\nimport { Users } from './users';\nimport { Vendors } from './vendors';\nimport { Webhooks } from './webhooks';\nimport { Workflows } from './workflows';\nexport * from './ai';\nexport * from './applications';\nexport * from './bundles';\nexport * from './clients';\nexport * from './core';\nexport * from './dictionaries';\nexport * from './distributions';\nexport * from './fields';\nexport * from './glossaries';\nexport * from './issues';\nexport * from './labels';\nexport * from './languages';\nexport * from './machineTranslation';\nexport * from './notifications';\nexport * from './organizationWebhooks';\nexport * from './projectsGroups';\nexport * from './reports';\nexport * from './screenshots';\nexport * from './securityLogs';\nexport * from './sourceFiles';\nexport * from './sourceStrings';\nexport * from './stringComments';\nexport * from './stringCorrections';\nexport * from './stringTranslations';\nexport * from './tasks';\nexport * from './teams';\nexport * from './translationMemory';\nexport * from './translationStatus';\nexport * from './translations';\nexport * from './uploadStorage';\nexport * from './users';\nexport * from './vendors';\nexport * from './webhooks';\nexport * from './workflows';\nexport default class Client extends CrowdinApi {\n    readonly aiApi: Ai;\n    readonly applicationsApi: Applications;\n    readonly sourceFilesApi: SourceFiles;\n    readonly glossariesApi: Glossaries;\n    readonly languagesApi: Languages;\n    readonly translationsApi: Translations;\n    readonly translationStatusApi: TranslationStatus;\n    readonly projectsGroupsApi: ProjectsGroups;\n    readonly reportsApi: Reports;\n    readonly screenshotsApi: Screenshots;\n    readonly sourceStringsApi: SourceStrings;\n    readonly uploadStorageApi: UploadStorage;\n    readonly tasksApi: Tasks;\n    readonly translationMemoryApi: TranslationMemory;\n    readonly webhooksApi: Webhooks;\n    readonly organizationWebhooksApi: OrganizationWebhooks;\n    readonly machineTranslationApi: MachineTranslation;\n    readonly stringTranslationsApi: StringTranslations;\n    readonly workflowsApi: Workflows;\n    readonly usersApi: Users;\n    readonly vendorsApi: Vendors;\n    readonly issuesApi: Issues;\n    readonly teamsApi: Teams;\n    readonly distributionsApi: Distributions;\n    readonly dictionariesApi: Dictionaries;\n    readonly labelsApi: Labels;\n    readonly stringCommentsApi: StringComments;\n    readonly bundlesApi: Bundles;\n    readonly notificationsApi: Notifications;\n    readonly clientsApi: Clients;\n    readonly securityLogsApi: SecurityLogs;\n    readonly fieldsApi: Fields;\n    readonly stringCorrectionsApi: StringCorrections;\n    constructor(credentials: Credentials, config?: ClientConfig);\n}\nexport { Client };\n```\n\n##### issues/index.d.ts\n\n```typescript\nimport { CrowdinApi, PaginationOptions, PatchRequest, ResponseList, ResponseObject } from '../core';\nexport declare class Issues extends CrowdinApi {\n    listReportedIssues(projectId: number, options?: IssuesModel.ListReportedIssuesOptions): Promise<ResponseList<IssuesModel.Issue>>;\n    listReportedIssues(projectId: number, limit?: number, offset?: number, type?: IssuesModel.Type, status?: IssuesModel.Status): Promise<ResponseList<IssuesModel.Issue>>;\n    editIssue(projectId: number, issueId: number, request: PatchRequest[]): Promise<ResponseObject<IssuesModel.Issue>>;\n}\nexport declare namespace IssuesModel {\n    type Type = 'all' | 'general_question' | 'translation_mistake' | 'context_request' | 'source_mistake';\n    type Status = 'all' | 'resolved' | 'unresolved';\n    interface Issue {\n        id: number;\n        text: string;\n        userId: number;\n        stringId: number;\n        user: User;\n        string: string;\n        languageId: string;\n        type: Type;\n        status: Status;\n        createdAt: string;\n    }\n    interface User {\n        id: number;\n        username: string;\n        fullName: string;\n        avatarUrl: string;\n    }\n    interface String {\n        id: number;\n        text: string;\n        type: string;\n        hasPlurals: boolean;\n        isIcu: boolean;\n        context: string;\n        fileId: number;\n    }\n    interface ListReportedIssuesOptions extends PaginationOptions {\n        type?: IssuesModel.Type;\n        status?: IssuesModel.Status;\n    }\n}\n```\n\n##### labels/index.d.ts\n\n```typescript\nimport { CrowdinApi, PaginationOptions, PatchRequest, ResponseList, ResponseObject } from '../core';\nimport { ScreenshotsModel } from '../screenshots';\nimport { SourceStringsModel } from '../sourceStrings';\nexport declare class Labels extends CrowdinApi {\n    listLabels(projectId: number, options?: LabelsModel.ListLabelsParams): Promise<ResponseList<LabelsModel.Label>>;\n    listLabels(projectId: number, limit?: number, offset?: number): Promise<ResponseList<LabelsModel.Label>>;\n    addLabel(projectId: number, request: LabelsModel.AddLabelRequest): Promise<ResponseObject<LabelsModel.Label>>;\n    getLabel(projectId: number, labelId: number): Promise<ResponseObject<LabelsModel.Label>>;\n    deleteLabel(projectId: number, labelId: number): Promise<void>;\n    editLabel(projectId: number, labelId: number, request: PatchRequest[]): Promise<ResponseObject<LabelsModel.Label>>;\n    assignLabelToScreenshots(projectId: number, labelId: number, request: LabelsModel.AssignLabelToScreenshotsRequet): Promise<ResponseList<ScreenshotsModel.Screenshot>>;\n    unassignLabelFromScreenshots(projectId: number, labelId: number, screenshotIds: string): Promise<ResponseList<ScreenshotsModel.Screenshot>>;\n    assignLabelToString(projectId: number, labelId: number, request: LabelsModel.AssignLabelToStringsRequet): Promise<ResponseList<SourceStringsModel.String>>;\n    unassignLabelFromString(projectId: number, labelId: number, stringIds: string): Promise<ResponseList<SourceStringsModel.String>>;\n}\nexport declare namespace LabelsModel {\n    interface ListLabelsParams extends PaginationOptions {\n        orderBy?: string;\n    }\n    interface Label {\n        id: number;\n        title: string;\n        isSystem?: boolean;\n    }\n    interface AddLabelRequest {\n        title: string;\n    }\n    interface AssignLabelToStringsRequet {\n        stringIds: number[];\n    }\n    interface AssignLabelToScreenshotsRequet {\n        screenshotIds: number[];\n    }\n}\n```\n\n##### languages/index.d.ts\n\n```typescript\nimport { CrowdinApi, PaginationOptions, PatchRequest, ResponseList, ResponseObject } from '../core';\nexport declare class Languages extends CrowdinApi {\n    listSupportedLanguages(options?: PaginationOptions): Promise<ResponseList<LanguagesModel.Language>>;\n    listSupportedLanguages(limit?: number, offset?: number): Promise<ResponseList<LanguagesModel.Language>>;\n    addCustomLanguage(request: LanguagesModel.AddLanguageRequest): Promise<ResponseObject<LanguagesModel.Language>>;\n    getLanguage(languageId: string): Promise<ResponseObject<LanguagesModel.Language>>;\n    deleteCustomLanguage(languageId: string): Promise<void>;\n    editCustomLanguage(languageId: string, request: PatchRequest[]): Promise<ResponseObject<LanguagesModel.Language>>;\n}\nexport declare namespace LanguagesModel {\n    interface Language {\n        id: string;\n        name: string;\n        editorCode: string;\n        twoLettersCode: string;\n        threeLettersCode: string;\n        locale: string;\n        androidCode: string;\n        osxCode: string;\n        osxLocale: string;\n        pluralCategoryNames: string[];\n        pluralRules: string;\n        pluralExamples: string[];\n        textDirection: TextDirection;\n        dialectOf: string;\n    }\n    interface AddLanguageRequest {\n        name: string;\n        code: string;\n        localeCode: string;\n        textDirection: TextDirection;\n        pluralCategoryNames: string[];\n        threeLettersCode: string;\n        twoLettersCode?: string;\n        dialectOf?: string;\n    }\n    type TextDirection = 'ltr' | 'rtl';\n}\n```\n\n##### machineTranslation/index.d.ts\n\n```typescript\nimport { CrowdinApi, PaginationOptions, PatchRequest, ResponseList, ResponseObject } from '../core';\nexport declare class MachineTranslation extends CrowdinApi {\n    listMts(options?: MachineTranslationModel.ListMTsOptions): Promise<ResponseList<MachineTranslationModel.MachineTranslation>>;\n    listMts(groupId?: number, limit?: number, offset?: number): Promise<ResponseList<MachineTranslationModel.MachineTranslation>>;\n    createMt(request: MachineTranslationModel.CreateMachineTranslationRequest): Promise<ResponseObject<MachineTranslationModel.MachineTranslation>>;\n    getMt(mtId: number): Promise<ResponseObject<MachineTranslationModel.MachineTranslation>>;\n    deleteMt(mtId: number): Promise<void>;\n    updateMt(mtId: number, request: PatchRequest[]): Promise<ResponseObject<MachineTranslationModel.MachineTranslation>>;\n    translate(mtId: number, request: MachineTranslationModel.TranslateRequest): Promise<ResponseObject<MachineTranslationModel.TranslateResponse>>;\n}\nexport declare namespace MachineTranslationModel {\n    interface MachineTranslation {\n        id: number;\n        groupId: number;\n        name: string;\n        type: number;\n        credentials: Credentials;\n        projectIds: number[];\n        supportedLanguageIds: string[];\n        supportedLanguagePairs: Record<string, string[]>;\n        enabledLanguageIds: string[];\n        enabledProjectIds: number[];\n        isEnabled: boolean;\n    }\n    type Credentials = {\n        apiKey: string;\n    } | {\n        credentials: string;\n    } | {\n        model: string;\n        apiKey: string;\n    } | {\n        isSystemCredentials: boolean;\n        apiKey: string;\n    } | {\n        endpoint: string;\n        apiKey: string;\n    } | {\n        url: string;\n    } | {\n        accessKey: string;\n        secretKey: string;\n    };\n    interface CreateMachineTranslationRequest {\n        name: string;\n        type: string;\n        credentials: Credentials;\n        groupId?: number;\n        enabledLanguageIds?: string[];\n        enabledProjectIds?: number[];\n        isEnabled?: boolean;\n    }\n    interface TranslateRequest {\n        languageRecognitionProvider?: LanguageRecognitionProvider;\n        sourceLanguageId?: string;\n        targetLanguageId: string;\n        strings?: string[];\n    }\n    interface TranslateResponse {\n        sourceLanguageId: string;\n        targetLanguageId: string;\n        strings: string[];\n        translations: string[];\n    }\n    type LanguageRecognitionProvider = 'crowdin' | 'engine';\n    interface ListMTsOptions extends PaginationOptions {\n        groupId?: number;\n    }\n}\n```\n\n##### notifications/index.d.ts\n\n```typescript\nimport { CrowdinApi } from '../core';\nexport declare class Notifications extends CrowdinApi {\n    sendNotificationToAuthenticatedUser(request: NotificationsModel.Notification): Promise<void>;\n    sendNotificationToProjectMembers(projectId: number, request: NotificationsModel.NotificationByUsers | NotificationsModel.NotificationByRole): Promise<void>;\n    sendNotificationToOrganizationMembers(request: NotificationsModel.Notification | NotificationsModel.NotificationByUsers | NotificationsModel.NotificationByRole): Promise<void>;\n}\nexport declare namespace NotificationsModel {\n    interface Notification {\n        message: string;\n    }\n    interface NotificationByUsers extends Notification {\n        userIds: number[];\n    }\n    interface NotificationByRole extends Notification {\n        role: 'owner' | 'admin';\n    }\n}\n```\n\n##### organizationWebhooks/index.d.ts\n\n```typescript\nimport { CrowdinApi, PaginationOptions, PatchRequest, ResponseList, ResponseObject } from '../core';\nimport { WebhooksModel } from '../webhooks';\nexport declare class OrganizationWebhooks extends CrowdinApi {\n    listWebhooks(options?: PaginationOptions): Promise<ResponseList<OrganizationWebhooksModel.OrganizationWebhook>>;\n    addWebhook(request: OrganizationWebhooksModel.AddOrganizationWebhookRequest): Promise<ResponseObject<OrganizationWebhooksModel.OrganizationWebhook>>;\n    getWebhook(webhookId: number): Promise<ResponseObject<OrganizationWebhooksModel.OrganizationWebhook>>;\n    deleteWebhook(webhookId: number): Promise<void>;\n    editWebhook(webhookId: number, request: PatchRequest[]): Promise<ResponseObject<OrganizationWebhooksModel.OrganizationWebhook>>;\n}\nexport declare namespace OrganizationWebhooksModel {\n    type OrganizationWebhook = Omit<WebhooksModel.Webhook, 'projectId' | 'events'> & {\n        events: Event[];\n    };\n    type AddOrganizationWebhookRequest = Omit<WebhooksModel.AddWebhookRequest, 'events'> & {\n        events: Event[];\n    };\n    type Event = 'group.created' | 'group.deleted' | 'project.created' | 'project.deleted';\n}\n```\n\n##### projectsGroups/index.d.ts\n\n```typescript\nimport { BooleanInt, CrowdinApi, DownloadLink, PaginationOptions, PatchRequest, ResponseList, ResponseObject } from '../core';\nimport { LanguagesModel } from '../languages';\nexport declare class ProjectsGroups extends CrowdinApi {\n    listGroups(options?: ProjectsGroupsModel.ListGroupsOptions): Promise<ResponseList<ProjectsGroupsModel.Group>>;\n    listGroups(parentId?: number, offset?: number, userId?: number, limit?: number): Promise<ResponseList<ProjectsGroupsModel.Group>>;\n    addGroup(request: ProjectsGroupsModel.AddGroupRequest): Promise<ResponseObject<ProjectsGroupsModel.Group>>;\n    getGroup(groupId: number): Promise<ResponseObject<ProjectsGroupsModel.Group>>;\n    deleteGroup(groupId: number): Promise<void>;\n    editGroup(groupId: number, request: PatchRequest[]): Promise<ResponseObject<ProjectsGroupsModel.Group>>;\n    listProjects(options?: ProjectsGroupsModel.ListProjectsOptions): Promise<ResponseList<ProjectsGroupsModel.Project | ProjectsGroupsModel.ProjectSettings>>;\n    listProjects(groupId?: number, hasManagerAccess?: BooleanInt, limit?: number, offset?: number): Promise<ResponseList<ProjectsGroupsModel.Project | ProjectsGroupsModel.ProjectSettings>>;\n    addProject(request: ProjectsGroupsModel.CreateProjectEnterpriseRequest | ProjectsGroupsModel.CreateProjectRequest): Promise<ResponseObject<ProjectsGroupsModel.Project | ProjectsGroupsModel.ProjectSettings>>;\n    getProject(projectId: number): Promise<ResponseObject<ProjectsGroupsModel.Project | ProjectsGroupsModel.ProjectSettings>>;\n    deleteProject(projectId: number): Promise<void>;\n    editProject(projectId: number, request: PatchRequest[]): Promise<ResponseObject<ProjectsGroupsModel.Project | ProjectsGroupsModel.ProjectSettings>>;\n    downloadProjectFileFormatSettingsCustomSegmentation(projectId: number, fileFormatSettingsId: number): Promise<ResponseObject<DownloadLink>>;\n    resetProjectFileFormatSettingsCustomSegmentation(projectId: number, fileFormatSettingsId: number): Promise<ResponseObject<DownloadLink>>;\n    listProjectFileFormatSettings(projectId: number, options?: PaginationOptions): Promise<ResponseList<ProjectsGroupsModel.ProjectFileFormatSettings>>;\n    addProjectFileFormatSettings(projectId: number, request: ProjectsGroupsModel.AddProjectFileFormatSettingsRequest): Promise<ResponseObject<ProjectsGroupsModel.ProjectFileFormatSettings>>;\n    getProjectFileFormatSettings(projectId: number, fileFormatSettingsId: number): Promise<ResponseObject<ProjectsGroupsModel.ProjectFileFormatSettings>>;\n    deleteProjectFileFormatSettings(projectId: number, fileFormatSettingsId: number): Promise<void>;\n    editProjectFileFormatSettings(projectId: number, fileFormatSettingsId: number, request: PatchRequest[]): Promise<ResponseObject<ProjectsGroupsModel.ProjectFileFormatSettings>>;\n    listProjectStringsExporterSettings(projectId: number, options?: PaginationOptions): Promise<ResponseList<ProjectsGroupsModel.ProjectStringsExporterSettings>>;\n    addProjectStringsExporterSettings(projectId: number, request: ProjectsGroupsModel.AddProjectStringsExporterSettingsRequest): Promise<ResponseObject<ProjectsGroupsModel.ProjectStringsExporterSettings>>;\n    getProjectStringsExporterSettings(projectId: number, systemStringsExporterSettingsId: number): Promise<ResponseObject<ProjectsGroupsModel.ProjectStringsExporterSettings>>;\n    deleteProjectStringsExporterSettings(projectId: number, systemStringsExporterSettingsId: number): Promise<void>;\n    editProjectStringsExporterSettings(projectId: number, systemStringsExporterSettingsId: number, request: ProjectsGroupsModel.AddProjectStringsExporterSettingsRequest): Promise<ResponseObject<ProjectsGroupsModel.ProjectStringsExporterSettings>>;\n}\nexport declare namespace ProjectsGroupsModel {\n    interface Group {\n        id: number;\n        name: string;\n        description: string;\n        parentId: number;\n        organizationId: number;\n        userId: number;\n        subgroupsCount: number;\n        projectsCount: number;\n        webUrl: string;\n        createdAt: string;\n        updatedAt: string;\n    }\n    interface AddGroupRequest {\n        name: string;\n        parentId?: number;\n        description?: string;\n    }\n    interface Project {\n        id: number;\n        type: Type;\n        userId: number;\n        sourceLanguageId: string;\n        targetLanguageIds: string[];\n        languageAccessPolicy: LanguageAccessPolicy;\n        name: string;\n        identifier: string;\n        description: string;\n        visibility: string;\n        logo: string;\n        publicDownloads: boolean;\n        createdAt: string;\n        updatedAt: string;\n        lastActivity: string;\n        sourceLanguage: LanguagesModel.Language;\n        targetLanguages: LanguagesModel.Language[];\n        webUrl: string;\n        savingsReportSettingsTemplateId: number;\n        fields: Record<string, any>;\n        cname: string;\n        groupId: number;\n        background: string;\n        isExternal: boolean;\n        externalType: string;\n        externalProjectId: number;\n        externalOrganizationId: number;\n        workflowId: number;\n        hasCrowdsourcing: boolean;\n        publicUrl: string;\n    }\n    interface CreateProjectRequest {\n        name: string;\n        identifier: string;\n        sourceLanguageId: string;\n        targetLanguageIds?: string[];\n        visibility?: JoinPolicy;\n        languageAccessPolicy?: LanguageAccessPolicy;\n        cname?: string;\n        description?: string;\n        tagDetection?: TagDetection;\n        isMtAllowed?: boolean;\n        taskBasedAccessControl?: boolean;\n        autoSubstitution?: boolean;\n        autoTranslateDialects?: boolean;\n        publicDownloads?: boolean;\n        hiddenStringsProofreadersAccess?: boolean;\n        useGlobalTm?: boolean;\n        showTmSuggestionsDialects?: boolean;\n        tmApprovedSuggestionsOnly?: boolean;\n        skipUntranslatedStrings?: boolean;\n        exportApprovedOnly?: boolean;\n        qaCheckIsActive?: boolean;\n        qaCheckCategories?: CheckCategories;\n        qaChecksIgnorableCategories?: CheckCategories;\n        languageMapping?: LanguageMapping;\n        glossaryAccess?: boolean;\n        glossaryAccessOption?: GlossaryAccessOption;\n        normalizePlaceholder?: boolean;\n        notificationSettings?: NotificationSettings;\n        tmPreTranslate?: ProjectSettings['tmPreTranslate'];\n        mtPreTranslate?: ProjectSettings['mtPreTranslate'];\n        aiPreTranslate?: ProjectSettings['aiPreTranslate'];\n        assistActionAiPromptId?: number;\n        editorSuggestionAiPromptId?: number;\n        savingsReportSettingsTemplateId?: number;\n        defaultTmId?: number;\n        defaultGlossaryId?: number;\n        inContext?: boolean;\n        inContextProcessHiddenStrings?: boolean;\n        inContextPseudoLanguageId?: string;\n        saveMetaInfoInSource?: boolean;\n        type?: BooleanInt;\n        skipUntranslatedFiles?: boolean;\n        tmContextType?: TmContextType;\n    }\n    interface CreateProjectEnterpriseRequest {\n        name: string;\n        sourceLanguageId: string;\n        templateId?: number;\n        steps?: WorkflowTemplateStepConfig[];\n        groupId?: number;\n        targetLanguageIds?: string[];\n        vendorId?: number;\n        mtEngineId?: number;\n        description?: string;\n        translateDuplicates?: TranslateDuplicates;\n        tagsDetection?: TagDetection;\n        isMtAllowed?: boolean;\n        taskBasedAccessControl?: boolean;\n        taskReviewerIds?: number[];\n        autoSubstitution?: boolean;\n        showTmSuggestionsDialects?: boolean;\n        tmApprovedSuggestionsOnly?: boolean;\n        autoTranslateDialects?: boolean;\n        publicDownloads?: boolean;\n        hiddenStringsProofreadersAccess?: boolean;\n        delayedWorkflowStart?: boolean;\n        skipUntranslatedStrings?: boolean;\n        exportWithMinApprovalsCount?: number;\n        exportStringsThatPassedWorkflow?: number;\n        normalizePlaceholder?: boolean;\n        qaCheckIsActive?: boolean;\n        qaApprovalsCount?: number;\n        qaCheckCategories?: CheckCategories;\n        qaChecksIgnorableCategories?: CheckCategories;\n        customQaCheckIds?: number[];\n        languageMapping?: LanguageMapping;\n        glossaryAccess?: boolean;\n        glossaryAccessOption?: GlossaryAccessOption;\n        notificationSettings?: NotificationSettings;\n        savingsReportSettingsTemplateId?: number;\n        fields?: Record<string, any>;\n        assistActionAiPromptId?: number;\n        editorSuggestionAiPromptId?: number;\n        alignmentActionAiPromptId?: number;\n        defaultTmId?: number;\n        defaultGlossaryId?: number;\n        inContext?: boolean;\n        inContextProcessHiddenStrings?: boolean;\n        inContextPseudoLanguageId?: string;\n        saveMetaInfoInSource?: boolean;\n        type?: BooleanInt;\n        skipUntranslatedFiles?: boolean;\n        tmContextType?: TmContextType;\n    }\n    type GlossaryAccessOption = 'readOnly' | 'fullAccess' | 'manageDrafts';\n    interface ProjectSettings extends Project {\n        translateDuplicates: TranslateDuplicates;\n        tagsDetection: TagDetection;\n        glossaryAccess: boolean;\n        glossaryAccessOption: GlossaryAccessOption;\n        isMtAllowed: boolean;\n        taskBasedAccessControl: boolean;\n        hiddenStringsProofreadersAccess: boolean;\n        autoSubstitution: boolean;\n        exportTranslatedOnly: boolean;\n        skipUntranslatedStrings: boolean;\n        exportApprovedOnly: boolean;\n        autoTranslateDialects: boolean;\n        useGlobalTm: boolean;\n        showTmSuggestionsDialects: boolean;\n        tmApprovedSuggestionsOnly: boolean;\n        isSuspended: boolean;\n        qaCheckIsActive: boolean;\n        qaCheckCategories: CheckCategories;\n        qaChecksIgnorableCategories: CheckCategories;\n        languageMapping: LanguageMapping;\n        notificationSettings: NotificationSettings;\n        defaultTmId: number;\n        defaultGlossaryId: number;\n        assignedTms: {\n            [id: string]: {\n                priority: number;\n            };\n        };\n        assignedGlossaries: number[];\n        tmPenalties: {\n            autoSubstitution: number;\n            tmPriority: {\n                priority: number;\n                penalty: number;\n            };\n            multipleTranslations: number;\n            timeSinceLastUsage: {\n                months: number;\n                penalty: number;\n            };\n            timeSinceLastModified: {\n                months: number;\n                penalty: number;\n            };\n        };\n        normalizePlaceholder: boolean;\n        tmPreTranslate: {\n            enabled: boolean;\n            autoApproveOption: 'all' | 'perfectMatchOnly' | 'exceptAutoSubstituted' | 'perfectMatchApprovedOnly' | 'none';\n            minimumMatchRatio: 'perfect' | '100';\n        };\n        mtPreTranslate: {\n            enabled: boolean;\n            mts: {\n                mtId: number;\n                languageIds: string[];\n            }[];\n        };\n        aiPreTranslate: {\n            enabled: boolean;\n            aiPrompts: {\n                aiPromptId: number;\n                languageIds: string[];\n            }[];\n        };\n        assistActionAiPromptId: number;\n        editorSuggestionAiPromptId: number;\n        inContext: boolean;\n        inContextProcessHiddenStrings: string;\n        inContextPseudoLanguageId: string;\n        inContextPseudoLanguage: LanguagesModel.Language;\n        saveMetaInfoInSource: boolean;\n        skipUntranslatedFiles: boolean;\n        tmContextType: TmContextType;\n        clientOrganizationId: number;\n        taskReviewerIds: number[];\n        exportWithMinApprovalsCount: number;\n        exportStringsThatPassedWorkflow: boolean;\n        qaApprovalsCount: number;\n        customQaCheckIds: number[];\n        externalQaCheckIds: number[];\n        delayedWorkflowStart: boolean;\n        alignmentActionAiPromptId: number;\n    }\n    enum Type {\n        FILES_BASED = 0,\n        STRINGS_BASED = 1\n    }\n    enum TagDetection {\n        AUTO = 0,\n        COUNT_TAGS = 1,\n        SKIP_TAGS = 2\n    }\n    type JoinPolicy = 'open' | 'private';\n    type LanguageAccessPolicy = 'open' | 'moderate';\n    interface CheckCategories {\n        empty: boolean;\n        size: boolean;\n        tags: boolean;\n        spaces: boolean;\n        variables: boolean;\n        punctuation: boolean;\n        symbolRegister: boolean;\n        specialSymbols: boolean;\n        wrongTranslation: boolean;\n        spellcheck: boolean;\n        icu: boolean;\n        terms: boolean;\n        duplicate: boolean;\n        ftl: boolean;\n        android: boolean;\n    }\n    interface LanguageMapping {\n        [key: string]: LanguageMappingEntity;\n    }\n    interface LanguageMappingEntity {\n        name: string;\n        two_letters_code: string;\n        three_letters_code: string;\n        locale: string;\n        locale_with_underscore: string;\n        android_code: string;\n        osx_code: string;\n        osx_locale: string;\n    }\n    enum TranslateDuplicates {\n        SHOW = 0,\n        HIDE_REGULAR_DETECTION = 1,\n        SHOW_AUTO_TRANSLATE = 2,\n        SHOW_WITHIN_VERION_BRANCH_REGULAR_DETECTION = 3,\n        HIDE_STRICT_DETECTION = 4,\n        SHOW_WITHIN_VERION_BRANCH_STRICT_DETECTION = 5\n    }\n    interface NotificationSettings {\n        translatorNewStrings?: boolean;\n        managerNewStrings?: boolean;\n        managerLanguageCompleted?: boolean;\n    }\n    interface ListGroupsOptions extends PaginationOptions {\n        parentId?: number;\n        userId?: number;\n        orderBy?: string;\n    }\n    interface ListProjectsOptions extends PaginationOptions {\n        groupId?: number;\n        hasManagerAccess?: BooleanInt;\n        orderBy?: string;\n        type?: BooleanInt;\n    }\n    type Settings = PropertyFileFormatSettings | CommonFileFormatSettings | XmlFileFormatSettings | MdxV2FormatSettings | FmHtmlFormatSettings | HtmlFormatSettings | JsonFormatSettings | MdxV1FormatSettings | JavaScriptFileFormatSettings | DocxFileFormatSettings;\n    interface ProjectFileFormatSettings {\n        id: number;\n        name: string;\n        format: string;\n        extensions: string[];\n        settings: Settings;\n        createdAt: string;\n        updatedAt: string;\n    }\n    interface AddProjectFileFormatSettingsRequest {\n        format: string;\n        settings: Settings;\n    }\n    interface PropertyFileFormatSettings {\n        escapeQuotes?: 0 | 1 | 2 | 3;\n        escapeSpecialCharacters?: 0 | 1;\n        exportPattern?: string;\n    }\n    interface JavaScriptFileFormatSettings {\n        exportPattern?: 'string';\n        exportQuotes?: 'single' | 'double';\n    }\n    interface CommonFileFormatSettings {\n        contentSegmentation?: boolean;\n        srxStorageId?: number;\n        exportPattern?: string;\n    }\n    interface XmlFileFormatSettings extends CommonFileFormatSettings {\n        translateContent?: boolean;\n        translateAttributes?: boolean;\n        translatableElements?: string[];\n    }\n    interface JsonFormatSettings extends CommonFileFormatSettings {\n        type?: 'i18next_json' | 'nestjs_i18n';\n    }\n    interface MdxV2FormatSettings extends CommonFileFormatSettings {\n        excludeCodeBlocks?: boolean;\n        excludedFrontMatterElements?: string[];\n    }\n    interface MdxV1FormatSettings extends CommonFileFormatSettings {\n        excludeCodeBlocks?: boolean;\n        excludedFrontMatterElements?: string[];\n        type?: 'mdx_v1' | 'mdx_v2';\n    }\n    interface FmHtmlFormatSettings extends CommonFileFormatSettings {\n        excludedElements?: boolean;\n        excludedFrontMatterElements?: string[];\n    }\n    interface HtmlFormatSettings extends CommonFileFormatSettings {\n        excludedElements?: boolean;\n    }\n    interface DocxFileFormatSettings extends CommonFileFormatSettings {\n        cleanTagsAggressively?: boolean;\n        translateHiddenText?: boolean;\n        translateHyperlinkUrls?: boolean;\n        translateHiddenRowsAndColumns?: boolean;\n        importNotes?: boolean;\n        importHiddenSlides?: boolean;\n    }\n    type TmContextType = 'segmentContext' | 'auto' | 'prevAndNextSegment';\n    type WorkflowTemplateStepConfig = WorkflowTemplateStepConfigTranslateProofread | WorkflowTemplateStepConfigVendor | WorkflowTemplateStepConfigTMPreTranslate | WorkflowTemplateStepConfigMTPreTranslate;\n    interface WorkflowTemplateStepConfigTranslateProofread {\n        id: number;\n        languages?: string[];\n        assignees?: number[];\n        config?: {\n            assignees: {\n                [key: string]: number[];\n            };\n        };\n    }\n    interface WorkflowTemplateStepConfigVendor {\n        id: number;\n        languages?: string[];\n        vendorId?: number;\n    }\n    interface WorkflowTemplateStepConfigTMPreTranslate {\n        id: number;\n        languages?: string[];\n        config?: {\n            minRelevant?: number;\n            autoSubstitution?: boolean;\n        };\n    }\n    interface WorkflowTemplateStepConfigMTPreTranslate {\n        id: number;\n        languages?: string[];\n        mtId?: number;\n    }\n    type StringsExporterSettings = AndroidStringsExporterSettings | MacOSXStringsExporterSettings | XliffStringsExporterSettings;\n    interface ProjectStringsExporterSettings {\n        id: number;\n        format: string;\n        settings: StringsExporterSettings;\n        createdAt: string;\n        updatedAt: string;\n    }\n    interface AndroidStringsExporterSettings {\n        convertPlaceholders?: boolean;\n        convertLineBreaks?: boolean;\n        useCdataForStringsWithTags?: boolean;\n    }\n    interface MacOSXStringsExporterSettings {\n        convertPlaceholders?: boolean;\n        convertLineBreaks?: boolean;\n    }\n    interface XliffStringsExporterSettings {\n        languagePairMapping?: {\n            [key: string]: {\n                sourceLanguageId: string;\n            };\n        };\n        copySourceToEmptyTarget?: boolean;\n        exportTranslatorsComment?: boolean;\n    }\n    interface AddProjectStringsExporterSettingsRequest {\n        format: string;\n        settings: StringsExporterSettings;\n    }\n}\n```\n\n##### reports/index.d.ts\n\n```typescript\nimport { CrowdinApi, DownloadLink, PaginationOptions, PatchRequest, ResponseList, ResponseObject, Status } from '../core';\nexport declare class Reports extends CrowdinApi {\n    listOrganizationReportArchives(options?: ReportsModel.ListReportArchiveParams): Promise<ResponseList<ReportsModel.ReportArchive>>;\n    getOrganizationReportArchive(archiveId: number): Promise<ResponseObject<ReportsModel.ReportArchive>>;\n    deleteOrganizationReportArchive(archiveId: number): Promise<void>;\n    exportOrganizationReportArchive(archiveId: number, request?: {\n        format?: ReportsModel.Format;\n    }): Promise<ResponseObject<Status<ReportsModel.ReportArchiveStatusAttribute>>>;\n    checkOrganizationReportArchiveStatus(archiveId: number, exportId: string): Promise<ResponseObject<Status<ReportsModel.ReportArchiveStatusAttribute>>>;\n    downloadOrganizationReportArchive(archiveId: number, exportId: string): Promise<ResponseObject<DownloadLink>>;\n    listUserReportArchives(userId: number, options?: ReportsModel.ListReportArchiveParams): Promise<ResponseList<ReportsModel.ReportArchive>>;\n    getUserReportArchive(userId: number, archiveId: number): Promise<ResponseObject<ReportsModel.ReportArchive>>;\n    deleteUserReportArchive(userId: number, archiveId: number): Promise<void>;\n    exportUserReportArchive(userId: number, archiveId: number, request?: {\n        format?: ReportsModel.Format;\n    }): Promise<ResponseObject<Status<ReportsModel.ReportArchiveStatusAttribute>>>;\n    checkUserReportArchiveStatus(userId: number, archiveId: number, exportId: string): Promise<ResponseObject<Status<ReportsModel.ReportArchiveStatusAttribute>>>;\n    downloadUserReportArchive(userId: number, archiveId: number, exportId: string): Promise<ResponseObject<DownloadLink>>;\n    generateGroupReport(groupId: number, request: ReportsModel.GenerateGroupReportRequest): Promise<ResponseObject<Status<ReportsModel.ReportStatusAttributes<ReportsModel.GroupReportSchema>>>>;\n    checkGroupReportStatus(groupId: number, reportId: string): Promise<ResponseObject<Status<ReportsModel.ReportStatusAttributes<ReportsModel.GroupReportSchema>>>>;\n    downloadGroupReport(groupId: number, reportId: string): Promise<ResponseObject<DownloadLink>>;\n    listOrganizationReportSettingsTemplates(options?: ReportsModel.ListOrganizationReportSettingsParams): Promise<ResponseList<ReportsModel.OrganizationReportSettings>>;\n    addOrganizationReportSettingsTemplate(request: ReportsModel.AddOrganizationReportSettingsRequest): Promise<ResponseObject<ReportsModel.OrganizationReportSettings>>;\n    getOrganizationReportSettingsTemplate(reportSettingsTemplateId: number): Promise<ResponseObject<ReportsModel.OrganizationReportSettings>>;\n    editOrganizationReportSettingsTemplate(reportSettingsTemplateId: number, request: PatchRequest[]): Promise<ResponseObject<ReportsModel.OrganizationReportSettings>>;\n    deleteOrganizationReportSettingsTemplate(reportSettingsTemplateId: number): Promise<void>;\n    generateOrganizationReport(request: ReportsModel.GenerateOrganizationReportRequest): Promise<ResponseObject<Status<ReportsModel.ReportStatusAttributes<ReportsModel.OrganizationReportSchema>>>>;\n    checkOrganizationReportStatus(reportId: string): Promise<ResponseObject<Status<ReportsModel.ReportStatusAttributes<ReportsModel.OrganizationReportSchema>>>>;\n    downloadOrganizationReport(reportId: string): Promise<ResponseObject<DownloadLink>>;\n    generateReport(projectId: number, request: ReportsModel.GenerateReportRequest): Promise<ResponseObject<Status<ReportsModel.ReportStatusAttributes<ReportsModel.ReportSchema>>>>;\n    checkReportStatus(projectId: number, reportId: string): Promise<ResponseObject<Status<ReportsModel.ReportStatusAttributes<ReportsModel.ReportSchema>>>>;\n    downloadReport(projectId: number, reportId: string): Promise<ResponseObject<DownloadLink>>;\n    listReportSettingsTemplates(projectId: number, options?: PaginationOptions): Promise<ResponseList<ReportsModel.ReportSettings>>;\n    addReportSettingsTemplate(projectId: number, request: ReportsModel.AddReportSettingsRequest): Promise<ResponseObject<ReportsModel.ReportSettings>>;\n    getReportSettingsTemplate(projectId: number, reportSettingsTemplateId: number): Promise<ResponseObject<ReportsModel.ReportSettings>>;\n    editReportSettingsTemplate(projectId: number, reportSettingsTemplateId: number, request: PatchRequest[]): Promise<ResponseObject<ReportsModel.ReportSettings>>;\n    deleteReportSettingsTemplate(projectId: number, reportSettingsTemplateId: number): Promise<void>;\n    listUserReportSettingsTemplates(userId: number, options?: PaginationOptions): Promise<ResponseList<ReportsModel.UserReportSettings>>;\n    addUserReportSettingsTemplate(userId: number, request: ReportsModel.AddUserReportSettingsRequest): Promise<ResponseObject<ReportsModel.UserReportSettings>>;\n    getUserReportSettingsTemplate(userId: number, reportSettingsTemplateId: number): Promise<ResponseObject<ReportsModel.UserReportSettings>>;\n    editUserReportSettingsTemplate(userId: number, reportSettingsTemplateId: number, request: PatchRequest[]): Promise<ResponseObject<ReportsModel.UserReportSettings>>;\n    deleteUserReportSettingsTemplate(userId: number, reportSettingsTemplateId: number): Promise<void>;\n}\nexport declare namespace ReportsModel {\n    interface ReportArchive {\n        id: number;\n        scopeType: string;\n        scopeId: number;\n        userId: number;\n        name: string;\n        webUrl: string;\n        scheme: any;\n        createdAt: string;\n    }\n    interface ListReportArchiveParams extends PaginationOptions {\n        scopeType: string;\n        scopeId: number;\n    }\n    interface ReportArchiveStatusAttribute {\n        format: Format;\n        reportName: string;\n        schema: any;\n    }\n    type GroupReportSchema = GroupTranslationCostsPostEditingSchema | GroupTopMembersSchema | GroupTaskUsageSchema | GroupQaCheckIssuesSchema | GroupTranslationActivitySchema;\n    type OrganizationReportSchema = GroupTranslationCostsPostEditingSchema | GroupTopMembersSchema | GroupTaskUsageSchema | GroupQaCheckIssuesSchema | GroupTranslationActivitySchema;\n    interface GenerateGroupReportRequest {\n        name: string;\n        schema: GroupReportSchema;\n    }\n    interface GenerateOrganizationReportRequest {\n        name: string;\n        schema: OrganizationReportSchema;\n    }\n    interface GroupTranslationCostsPostEditingSchema {\n        projectIds?: number[];\n        unit?: Unit;\n        currency?: Currency;\n        format?: Format;\n        baseRates: BaseRate;\n        individualRates: IndividualRate[];\n        netRateSchemes: NetRateSchemas;\n        excludeApprovalsForEditedTranslations?: boolean;\n        preTranslatedStringsCategorizationAdjustment?: boolean;\n        groupBy?: GroupBy;\n        dateFrom?: string;\n        dateTo?: string;\n        userIds?: number[];\n    }\n    interface GroupTranslationCostsPerEditingByTaskSchema {\n        unit?: Unit;\n        currency?: Currency;\n        format?: Format;\n        baseRates: BaseRate;\n        individualRates: IndividualRate[];\n        netRateSchemes: NetRateSchemas;\n        taskId?: number;\n    }\n    interface CostsEstimationSchema {\n        projectIds?: number[];\n        unit?: Unit;\n        currency?: Currency;\n        format?: Format;\n        baseRates: BaseRate;\n        individualRates: IndividualRate[];\n        netRateSchemes: NetRateSchemas;\n        calculateInternalMatches?: boolean;\n        includePreTranslatedStrings?: boolean;\n        languageId?: string;\n        branchIds?: number[];\n        dateFrom?: string;\n        dateTo?: string;\n        labelIds?: number[];\n        labelIncludeType?: LabelIncludeType;\n    }\n    interface CostsEstimationByTaskSchema {\n        unit?: Unit;\n        currency?: Currency;\n        format?: Format;\n        baseRates?: BaseRate;\n        individualRates?: IndividualRate[];\n        netRateSchemes?: NetRateSchemas;\n        calculateInternalMatches?: boolean;\n        includePreTranslatedStrings?: boolean;\n        taskId?: number;\n    }\n    interface GroupTopMembersSchema {\n        projectIds?: number[];\n        unit?: Unit;\n        languageId?: string;\n        format?: Format;\n        dateFrom?: string;\n        dateTo?: string;\n    }\n    interface RawDataSchema {\n        mode: ContributionMode;\n        unit?: Unit;\n        languageId?: string;\n        userId?: number;\n        dateFrom?: string;\n        dateTo?: string;\n    }\n    type GenerateReportRequest = PreTranslateEfficeincy | PreTranslateAccuracy | TranslateAccuracy | CostEstimationPostEnding | TranslationCostsPostEnding | TopMembers | ContributionRawData | SourceContentUpdates | ProjectMembers | EditorIssues | QaCheckIssues | SavingActivity | TranslationActivity;\n    type ReportSchema = Pick<GenerateReportRequest, 'schema'>;\n    interface PreTranslateEfficeincy {\n        name: 'pre-translate-efficiency';\n        schema: PreTranslateAccuracySchema | PreTranslateAccuracySchemaByTask;\n    }\n    interface PreTranslateAccuracy {\n        name: 'pre-translate-accuracy';\n        schema: PreTranslateAccuracySchema | PreTranslateAccuracySchemaByTask;\n    }\n    interface TranslateAccuracy {\n        name: 'translator-accuracy';\n        schema: TranslateAccuracySchema;\n    }\n    interface CostEstimationPostEnding {\n        name: 'costs-estimation-pe';\n        schema: CostEstimationPostEndingSchema | CostEstimationPostEndingSchemaByTask;\n    }\n    interface TranslationCostsPostEnding {\n        name: 'translation-costs-pe';\n        schema: TranslationCostsPostEndingSchema | TranslationCostsPostEndingSchemaByTask;\n    }\n    interface TopMembers {\n        name: 'top-members';\n        schema: TopMembersSchema;\n    }\n    interface ContributionRawData {\n        name: 'contribution-raw-data';\n        schema: ContributionRawDataSchema | ContributionRawDataSchemaByTask;\n    }\n    interface SourceContentUpdates {\n        name: 'source-content-updates';\n        schema: SourceContentUpdatesSchema;\n    }\n    interface ProjectMembers {\n        name: 'project-members';\n        schema: MembersSchema;\n    }\n    interface EditorIssues {\n        name: 'editor-issues';\n        schema: EditorIssuesSchema;\n    }\n    interface QaCheckIssues {\n        name: 'qa-check-issues';\n        schema: ProjectQaCheckIssuesSchema;\n    }\n    interface SavingActivity {\n        name: 'saving-activity';\n        schema: SavingActivitySchema;\n    }\n    interface TranslationActivity {\n        name: 'translation-activity';\n        schema: ProjectConsumptionSchema;\n    }\n    interface ReportStatusAttributes<S> {\n        format: Format;\n        reportName: string;\n        schema: S;\n    }\n    interface PreTranslateAccuracySchema {\n        unit?: Unit;\n        format?: Format;\n        postEditingCategories?: string[];\n        languageId?: string;\n        dateFrom?: string;\n        dateTo?: string;\n    }\n    interface PreTranslateAccuracySchemaByTask {\n        unit?: Unit;\n        format?: Format;\n        postEditingCategories?: string[];\n        taskId?: number;\n    }\n    interface TranslateAccuracySchema {\n        unit?: Unit;\n        format?: Format;\n        postEditingCategories?: string[];\n        languageId?: string;\n        userIds?: number[];\n        dateFrom?: string;\n        dateTo?: string;\n    }\n    interface CostEstimationPostEndingSchema {\n        unit?: Unit;\n        currency?: Currency;\n        format?: Format;\n        baseRates: BaseRate;\n        individualRates: IndividualRate[];\n        netRateSchemes: Omit<NetRateSchemas, 'mtMatch' | 'suggestionMatch'>;\n        calculateInternalMatches?: boolean;\n        includePreTranslatedStrings?: boolean;\n        languageId?: string;\n        fileIds?: number[];\n        directoryIds?: number[];\n        branchIds?: number[];\n        dateFrom?: string;\n        dateTo?: string;\n        labelIds?: number[];\n        labelIncludeType?: LabelIncludeType;\n        workflowStepId?: number;\n    }\n    interface CostEstimationPostEndingSchemaByTask {\n        unit?: Unit;\n        currency?: Currency;\n        format?: Format;\n        baseRates?: BaseRate;\n        individualRates?: IndividualRate[];\n        netRateSchemes?: Omit<NetRateSchemas, 'mtMatch' | 'suggestionMatch'>;\n        calculateInternalMatches?: boolean;\n        includePreTranslatedStrings?: boolean;\n        taskId?: number;\n    }\n    interface TranslationCostsPostEndingSchemaByTask {\n        unit?: Unit;\n        currency?: Currency;\n        format?: Format;\n        baseRates: BaseRate;\n        individualRates: IndividualRate[];\n        netRateSchemes: NetRateSchemas;\n        taskId?: number;\n        excludeApprovalsForEditedTranslations?: boolean;\n        preTranslatedStringsCategorizationAdjustment?: boolean;\n    }\n    interface TranslationCostsPostEndingSchema {\n        unit?: Unit;\n        currency?: Currency;\n        format?: Format;\n        baseRates: BaseRate;\n        individualRates: IndividualRate[];\n        netRateSchemes: NetRateSchemas;\n        excludeApprovalsForEditedTranslations?: boolean;\n        preTranslatedStringsCategorizationAdjustment?: boolean;\n        groupBy?: GroupBy;\n        dateFrom?: string;\n        dateTo?: string;\n        languageId?: string;\n        userIds?: number[];\n        fileIds?: number[];\n        directoryIds?: number[];\n        branchIds?: number[];\n        labelIds?: number;\n        labelIncludeType?: LabelIncludeType;\n        workflowStepId?: number;\n    }\n    interface TopMembersSchema {\n        unit?: Unit;\n        languageId?: string;\n        format?: Format;\n        dateFrom?: string;\n        dateTo?: string;\n    }\n    interface ContributionRawDataSchema {\n        mode: ContributionMode;\n        unit?: Unit;\n        languageId?: string;\n        userId?: string;\n        columns?: Column[];\n        fileIds?: number[];\n        directoryIds?: number[];\n        branchIds?: number[];\n        tmIds?: number[];\n        mtIds?: number[];\n        aiPromptIds?: number[];\n        dateFrom?: string;\n        dateTo?: string;\n    }\n    interface ContributionRawDataSchemaByTask {\n        mode: ContributionMode;\n        unit?: Unit;\n        taskId: number;\n        columns?: Column[];\n        tmIds?: number[];\n        mtIds?: number[];\n        aiPromptIds?: number[];\n        dateFrom?: string;\n        dateTo?: string;\n    }\n    interface PreTranslateEfficiencySchema {\n        unit?: Unit;\n        format?: Format;\n        postEditingCategories?: string[];\n        languageId?: string;\n        dateFrom?: string;\n        dateTo?: string;\n    }\n    interface ListOrganizationReportSettingsParams extends PaginationOptions {\n        projectId?: number;\n        groupId?: number;\n    }\n    interface ReportSettings {\n        id: number;\n        name: string;\n        currency: Currency;\n        unit: Unit;\n        config: ReportSettinsConfig;\n        isPublic: boolean;\n        isGlobal: boolean;\n        createdAt: string;\n        updatedAt: string;\n    }\n    interface AddReportSettingsRequest {\n        name: string;\n        currency: Currency;\n        unit: Unit;\n        config: ReportSettinsConfig;\n        isPublic?: boolean;\n        isGlobal?: boolean;\n    }\n    type UserReportSettings = Omit<ReportSettings, 'isPublic' | 'isGlobal'>;\n    type AddUserReportSettingsRequest = Omit<AddReportSettingsRequest, 'isPublic' | 'isGlobal'>;\n    type OrganizationReportSettings = Omit<ReportSettings, 'isGlobal'> & {\n        projectId: number;\n        groupId: number;\n    };\n    type AddOrganizationReportSettingsRequest = Omit<AddReportSettingsRequest, 'isGlobal'> & {\n        projectId?: number;\n        groupId?: number;\n    };\n    interface ReportSettinsConfig {\n        baseRates: BaseRate;\n        netRateSchemes: NetRateSchemas[];\n        individualRates: IndividualRate[];\n    }\n    type Unit = 'strings' | 'words' | 'chars' | 'chars_with_spaces';\n    type Currency = 'USD' | 'EUR' | 'JPY' | 'GBP' | 'AUD' | 'CAD' | 'CHF' | 'CNY' | 'SEK' | 'NZD' | 'MXN' | 'SGD' | 'HKD' | 'NOK' | 'KRW' | 'TRY' | 'RUB' | 'INR' | 'BRL' | 'ZAR' | 'GEL' | 'UAH';\n    type Format = 'xlsx' | 'csv' | 'json';\n    interface BaseRate {\n        fullTranslation: number;\n        proofread: number;\n    }\n    interface IndividualRate extends BaseRate {\n        languageIds: string[];\n        userIds: number[];\n        fullTranslation: number;\n        proofread: number;\n    }\n    interface NetRateSchemas {\n        tmMatch: {\n            matchType: Mode;\n            price: number;\n        }[];\n        mtMatch: {\n            matchType: Mode;\n            price: number;\n        }[];\n        suggestionMatch: {\n            matchType: Mode;\n            price: number;\n        }[];\n        aiMatch?: {\n            matchType: Mode;\n            price: number;\n        }[];\n    }\n    type Mode = 'no_match' | 'tm_match' | 'approval' | '99-95' | '94-90' | '89-80' | 'perfect' | '100';\n    type ContributionMode = 'translations' | 'approvals' | 'votes';\n    type GroupBy = 'user' | 'language';\n    type LabelIncludeType = 'strings_with_label' | 'strings_without_label';\n    type Column = 'userId' | 'languageId' | 'stringId' | 'translationId' | 'fileId' | 'filePath' | 'pluralForm' | 'sourceStringTextHash' | 'mtEngine' | 'mtId' | 'tmName' | 'tmId' | 'aiPromptName' | 'aiPromptId' | 'preTranslated' | 'tmMatch' | 'mtMatch' | 'aiMatch' | 'suggestionMatch' | 'sourceUnits' | 'targetUnits' | 'createdAt' | 'updatedAt' | 'mark';\n    interface SourceContentUpdatesSchema {\n        unit?: Unit;\n        format?: Format;\n        dateFrom?: string;\n        dateTo?: string;\n        languageId?: string;\n        userIds?: number[];\n        fileIds?: number[];\n        directoryIds?: number[];\n        branchIds?: number[];\n        labelIds?: number[];\n        labelIncludeType?: LabelIncludeType;\n    }\n    interface MembersSchema {\n        format?: Format;\n        dateFrom?: string;\n        dateTo?: string;\n    }\n    interface EditorIssuesSchema {\n        dateFrom?: string;\n        dateTo?: string;\n        format?: Format;\n        languageId?: string;\n        userId?: number;\n    }\n    interface ProjectQaCheckIssuesSchema {\n        format?: Format;\n        dateFrom?: string;\n        dateTo?: string;\n        languageId?: string;\n    }\n    interface SavingActivitySchema {\n        unit?: Unit;\n        languageId?: string;\n        format?: Format;\n        dateFrom?: string;\n        dateTo?: string;\n        userIds?: number[];\n        fileIds?: number[];\n        directoryIds?: number[];\n        branchIds?: number[];\n        labelIds?: number[];\n        labelIncludeType?: LabelIncludeType;\n    }\n    interface ProjectConsumptionSchema {\n        unit?: Unit;\n        languageId?: string;\n        format?: Format;\n        dateFrom?: string;\n        dateTo?: string;\n        userIds?: number[];\n        fileIds?: number[];\n        directoryIds?: number[];\n        branchIds?: number[];\n        labelIds?: number[];\n        labelIncludeType?: LabelIncludeType;\n    }\n    interface GroupTaskUsageSchema {\n        format: Format;\n        type: 'workload' | 'create-vs-resolve' | 'performance' | 'time' | 'cost';\n        projectIds?: number[];\n        assigneeId?: number;\n        creatorId?: number;\n        dateFrom?: string;\n        dateTo?: string;\n        wordsCountFrom?: number;\n        wordsCountTo?: number;\n        excludeApprovalsForEditedTranslations?: boolean;\n        currency?: Currency;\n        baseRates?: BaseRate;\n        individualRates?: IndividualRate[];\n        netRateSchemes?: NetRateSchemas;\n    }\n    interface GroupQaCheckIssuesSchema {\n        projectIds?: number[];\n        format?: Format;\n        dateFrom?: string;\n        dateTo?: string;\n        languageId?: string;\n    }\n    interface GroupTranslationActivitySchema {\n        projectIds?: number[];\n        unit?: Unit;\n        languageId?: string;\n        format?: Format;\n        dateFrom?: string;\n        dateTo?: string;\n        userIds?: number[];\n        fileIds?: number[];\n        directoryIds?: number[];\n        branchIds?: number[];\n        labelIds?: number[];\n        labelIncludeType?: LabelIncludeType;\n    }\n}\n```\n\n##### screenshots/index.d.ts\n\n```typescript\nimport { CrowdinApi, PaginationOptions, PatchRequest, ResponseList, ResponseObject } from '../core';\nexport declare class Screenshots extends CrowdinApi {\n    listScreenshots(projectId: number, options?: ScreenshotsModel.ListScreenshotParams): Promise<ResponseList<ScreenshotsModel.Screenshot>>;\n    listScreenshots(projectId: number, limit?: number, offset?: number): Promise<ResponseList<ScreenshotsModel.Screenshot>>;\n    addScreenshot(projectId: number, request: ScreenshotsModel.CreateScreenshotRequest): Promise<ResponseObject<ScreenshotsModel.Screenshot>>;\n    getScreenshot(projectId: number, screenshotId: number): Promise<ResponseObject<ScreenshotsModel.Screenshot>>;\n    updateScreenshot(projectId: number, screenshotId: number, request: ScreenshotsModel.UpdateScreenshotRequest): Promise<ResponseObject<ScreenshotsModel.Screenshot>>;\n    deleteScreenshot(projectId: number, screenshotId: number): Promise<void>;\n    editScreenshot(projectId: number, screenshotId: number, request: PatchRequest[]): Promise<ResponseObject<ScreenshotsModel.Screenshot>>;\n    listScreenshotTags(projectId: number, screenshotId: number, options?: PaginationOptions): Promise<ResponseList<ScreenshotsModel.Tag>>;\n    listScreenshotTags(projectId: number, screenshotId: number, limit?: number, offset?: number): Promise<ResponseList<ScreenshotsModel.Tag>>;\n    replaceTags(projectId: number, screenshotId: number, request: ScreenshotsModel.ReplaceTagRequest[] | ScreenshotsModel.AutoTagRequest): Promise<void>;\n    addTag(projectId: number, screenshotId: number, request: ScreenshotsModel.ReplaceTagRequest[]): Promise<ResponseObject<ScreenshotsModel.Tag>>;\n    clearTags(projectId: number, screenshotId: number): Promise<void>;\n    getTag(projectId: number, screenshotId: number, tagId: number): Promise<ResponseObject<ScreenshotsModel.Tag>>;\n    deleteTag(projectId: number, screenshotId: number, tagId: number): Promise<void>;\n    updateTag(projectId: number, screenshotId: number, tagId: number, request: PatchRequest[]): Promise<ResponseObject<ScreenshotsModel.Screenshot>>;\n}\nexport declare namespace ScreenshotsModel {\n    interface ListScreenshotParams extends PaginationOptions {\n        stringIds?: number[];\n        stringId?: number;\n        labelIds?: string;\n        excludeLabelIds?: string;\n        orderBy?: string;\n    }\n    interface Screenshot {\n        id: number;\n        userId: number;\n        url: string;\n        webUrl: string;\n        name: string;\n        size: Size;\n        tagsCount: number;\n        tags: Tag[];\n        labels: number[];\n        labelIds: number[];\n        createdAt: string;\n        updatedAt: string;\n    }\n    interface CreateScreenshotRequest {\n        storageId: number;\n        name: string;\n        autoTag?: boolean;\n        fileId?: number;\n        branchId?: number;\n        directoryId?: number;\n        labelIds?: number[];\n    }\n    interface UpdateScreenshotRequest {\n        storageId: number;\n        name: string;\n    }\n    interface Tag {\n        id: number;\n        screenshotId: number;\n        stringId: number;\n        position: Position;\n        createdAt: string;\n    }\n    interface ReplaceTagRequest {\n        stringId: number;\n        position?: Position;\n    }\n    interface AutoTagRequest {\n        autoTag: boolean;\n        fileId?: number;\n        branchId?: number;\n        directoryId?: number;\n    }\n    interface Size {\n        width: number;\n        height: number;\n    }\n    interface Position {\n        x: number;\n        y: number;\n        width: number;\n        height: number;\n    }\n}\n```\n\n##### securityLogs/index.d.ts\n\n```typescript\nimport { CrowdinApi, PaginationOptions, ResponseList, ResponseObject } from '../core';\nexport declare class SecurityLogs extends CrowdinApi {\n    listOrganizationSecurityLogs(options?: SecurityLogsModel.ListOrganizationSecurityLogsParams): Promise<ResponseList<SecurityLogsModel.SecurityLog>>;\n    getOrganizationSecurityLog(securityLogId: number): Promise<ResponseObject<SecurityLogsModel.SecurityLog>>;\n    listUserSecurityLogs(userId: number, options?: SecurityLogsModel.ListUserSecurityLogsParams): Promise<ResponseList<SecurityLogsModel.SecurityLog>>;\n    getUserSecurityLog(userId: number, securityLogId: number): Promise<ResponseObject<SecurityLogsModel.SecurityLog>>;\n}\nexport declare namespace SecurityLogsModel {\n    type Event = 'login' | 'password.set' | 'password.change' | 'email.change' | 'login.change' | 'personal_token.issued' | 'personal_token.revoked' | 'mfa.enabled' | 'mfa.disabled' | 'session.revoke' | 'session.revoke_all' | 'sso.connect' | 'sso.disconnect' | 'user.remove' | 'application.connected' | 'application.disconnected' | 'webauthn.created' | 'webauthn.deleted' | 'trusted_device.remove' | 'trusted_device.remove_all' | 'device_verification.enabled' | 'device_verification.disabled';\n    interface ListOrganizationSecurityLogsParams extends PaginationOptions {\n        event?: Event;\n        createdAfter?: string;\n        createdBefore?: string;\n        ipAddress?: string;\n        userId?: number;\n    }\n    type ListUserSecurityLogsParams = Omit<ListOrganizationSecurityLogsParams, 'userId'>;\n    interface SecurityLog {\n        id: number;\n        event: string;\n        info: string;\n        userId: number;\n        location: string;\n        ipAddress: string;\n        deviceName: string;\n        createdAt: string;\n    }\n}\n```\n\n##### sourceFiles/index.d.ts\n\n```typescript\nimport { CrowdinApi, DownloadLink, PaginationOptions, PatchRequest, ResponseList, ResponseObject, Status } from '../core';\nexport declare class SourceFiles extends CrowdinApi {\n    getClonedBranch(projectId: number, branchId: number, cloneId: string): Promise<ResponseObject<SourceFilesModel.Branch>>;\n    clonedBranch(projectId: number, branchId: number, request: SourceFilesModel.CloneBranchRequest): Promise<ResponseObject<Status<object>>>;\n    checkBranchClonedStatus(projectId: number, branchId: number, cloneId: string): Promise<ResponseObject<Status<object>>>;\n    listProjectBranches(projectId: number, options?: SourceFilesModel.ListProjectBranchesOptions): Promise<ResponseList<SourceFilesModel.Branch>>;\n    listProjectBranches(projectId: number, name?: string, limit?: number, offset?: number): Promise<ResponseList<SourceFilesModel.Branch>>;\n    createBranch(projectId: number, request: SourceFilesModel.CreateBranchRequest): Promise<ResponseObject<SourceFilesModel.Branch>>;\n    getBranch(projectId: number, branchId: number): Promise<ResponseObject<SourceFilesModel.Branch>>;\n    deleteBranch(projectId: number, branchId: number): Promise<void>;\n    editBranch(projectId: number, branchId: number, request: PatchRequest[]): Promise<ResponseObject<SourceFilesModel.Branch>>;\n    mergeBranch(projectId: number, branchId: number, request: SourceFilesModel.MergeBranchRequest): Promise<ResponseObject<Status<SourceFilesModel.MergeBranchAttributes>>>;\n    checkBranchMergeStatus(projectId: number, branchId: number, mergeId: string): Promise<ResponseObject<Status<SourceFilesModel.MergeBranchAttributes>>>;\n    getBranchMergeSummary(projectId: number, branchId: number, mergeId: string): Promise<ResponseObject<SourceFilesModel.MergeBranchSummary>>;\n    listProjectDirectories(projectId: number, options?: SourceFilesModel.ListProjectDirectoriesOptions): Promise<ResponseList<SourceFilesModel.Directory>>;\n    listProjectDirectories(projectId: number, branchId?: number, directoryId?: number, limit?: number, offset?: number, filter?: string, recursion?: string): Promise<ResponseList<SourceFilesModel.Directory>>;\n    createDirectory(projectId: number, request: SourceFilesModel.CreateDirectoryRequest): Promise<ResponseObject<SourceFilesModel.Directory>>;\n    getDirectory(projectId: number, directoryId: number): Promise<ResponseObject<SourceFilesModel.Directory>>;\n    deleteDirectory(projectId: number, directoryId: number): Promise<void>;\n    editDirectory(projectId: number, directoryId: number, request: PatchRequest[]): Promise<ResponseObject<SourceFilesModel.Directory>>;\n    listProjectFiles(projectId: number, options?: SourceFilesModel.ListProjectFilesOptions): Promise<ResponseList<SourceFilesModel.File>>;\n    listProjectFiles(projectId: number, branchId?: number, directoryId?: number, limit?: number, offset?: number, recursion?: any, filter?: string): Promise<ResponseList<SourceFilesModel.File>>;\n    createFile(projectId: number, request: SourceFilesModel.CreateFileRequest): Promise<ResponseObject<SourceFilesModel.File>>;\n    getFile(projectId: number, fileId: number): Promise<ResponseObject<SourceFilesModel.File>>;\n    updateOrRestoreFile(projectId: number, fileId: number, request: SourceFilesModel.ReplaceFileFromStorageRequest | SourceFilesModel.RestoreFile): Promise<ResponseObject<SourceFilesModel.File>>;\n    deleteFile(projectId: number, fileId: number): Promise<void>;\n    editFile(projectId: number, fileId: number, request: PatchRequest[]): Promise<ResponseObject<SourceFilesModel.File>>;\n    downloadFilePreview(projectId: number, fileId: number): Promise<ResponseObject<DownloadLink>>;\n    downloadFile(projectId: number, fileId: number): Promise<ResponseObject<DownloadLink>>;\n    listAssetReferences(projectId: number, fileId: number, options?: PaginationOptions): Promise<ResponseList<SourceFilesModel.AssetReference>>;\n    getAssetReference(projectId: number, fileId: number, referenceId: number): Promise<ResponseObject<SourceFilesModel.AssetReference>>;\n    addAssetReference(projectId: number, fileId: number, request: SourceFilesModel.AssetReferenceRequest): Promise<ResponseObject<SourceFilesModel.AssetReference>>;\n    deleteAssetReference(projectId: number, fileId: number, referenceId: number): Promise<void>;\n    listFileRevisions(projectId: number, fileId: number, options?: PaginationOptions): Promise<ResponseList<SourceFilesModel.FileRevision>>;\n    listFileRevisions(projectId: number, fileId: number, limit?: number, offset?: number): Promise<ResponseList<SourceFilesModel.FileRevision>>;\n    getFileRevision(projectId: number, fileId: number, revisionId: number): Promise<ResponseObject<SourceFilesModel.FileRevision>>;\n    listReviewedSourceFilesBuild(projectId: number, options?: SourceFilesModel.ListReviewedSourceFilesBuildOptions): Promise<ResponseList<SourceFilesModel.ReviewedSourceFilesBuild>>;\n    listReviewedSourceFilesBuild(projectId: number, branchId?: number, limit?: number, offset?: number): Promise<ResponseList<SourceFilesModel.ReviewedSourceFilesBuild>>;\n    buildReviewedSourceFiles(projectId: number, request?: SourceFilesModel.BuildReviewedSourceFilesRequest): Promise<ResponseObject<SourceFilesModel.ReviewedSourceFilesBuild>>;\n    checkReviewedSourceFilesBuildStatus(projectId: number, buildId: number): Promise<ResponseObject<SourceFilesModel.ReviewedSourceFilesBuild>>;\n    downloadReviewedSourceFiles(projectId: number, buildId: number): Promise<ResponseObject<DownloadLink>>;\n}\nexport declare namespace SourceFilesModel {\n    interface Branch {\n        id: number;\n        projectId: number;\n        name: string;\n        title: string;\n        exportPattern: string;\n        priority: Priority;\n        createdAt: string;\n        updatedAt: string;\n    }\n    interface CreateBranchRequest {\n        name: string;\n        title?: string;\n        exportPattern?: string;\n        priority?: Priority;\n    }\n    interface CloneBranchRequest {\n        name: string;\n        title?: string;\n    }\n    interface MergeBranchRequest {\n        deleteAfterMerge?: boolean;\n        sourceBranchId: number;\n        acceptSourceChanges?: boolean;\n        dryRun?: boolean;\n    }\n    interface MergeBranchAttributes {\n        sourceBranchId: number;\n        deleteAfterMerge: boolean;\n        acceptSourceChanges?: boolean;\n    }\n    interface MergeBranchSummary {\n        status: string;\n        sourceBranchId: number;\n        targetBranchId: number;\n        dryRun: boolean;\n        details: {\n            added: number;\n            deleted: number;\n            updated: number;\n            conflicted: number;\n        };\n    }\n    type Priority = 'low' | 'normal' | 'high';\n    interface ListProjectDirectoriesOptions extends PaginationOptions {\n        branchId?: number;\n        directoryId?: number;\n        filter?: string;\n        recursion?: string;\n        orderBy?: string;\n    }\n    interface Directory {\n        id: number;\n        projectId: number;\n        branchId: number;\n        directoryId: number;\n        name: string;\n        title: string;\n        exportPattern: string;\n        path: string;\n        priority: Priority;\n        createdAt: string;\n        updatedAt: string;\n    }\n    interface CreateDirectoryRequest {\n        name: string;\n        branchId?: number;\n        directoryId?: number;\n        title?: string;\n        exportPattern?: string;\n        priority?: Priority;\n    }\n    interface ListProjectFilesOptions extends PaginationOptions {\n        branchId?: number;\n        directoryId?: number;\n        recursion?: any;\n        filter?: string;\n        orderBy?: string;\n    }\n    interface File {\n        id: number;\n        projectId: number;\n        branchId: number;\n        directoryId: number;\n        name: string;\n        title: string;\n        context: string;\n        type: string;\n        path: string;\n        status: string;\n        revisionId: number;\n        priority: Priority;\n        importOptions: ImportOptions;\n        exportOptions: GeneralExportOptions | PropertyExportOptions;\n        excludedTargetLanguages: string[];\n        parserVersion: number;\n        createdAt: string;\n        updatedAt: string;\n        fields: Record<string, any>;\n    }\n    interface CreateFileRequest {\n        storageId: number;\n        name: string;\n        branchId?: number;\n        directoryId?: number;\n        title?: string;\n        context?: string;\n        type?: FileType;\n        parserVersion?: number;\n        importOptions?: ImportOptions;\n        exportOptions?: ExportOptions;\n        excludedTargetLanguages?: string[];\n        attachLabelIds?: number[];\n        fields?: Record<string, any>;\n    }\n    interface ReplaceFileFromStorageRequest {\n        storageId: number;\n        name?: string;\n        updateOption?: UpdateOption;\n        importOptions?: ImportOptions;\n        exportOptions?: ExportOptions;\n        attachLabelIds?: number[];\n        detachLabelIds?: number[];\n        replaceModifiedContext?: boolean;\n    }\n    type ExportOptions = GeneralExportOptions | PropertyExportOptions | JavaScriptExportOptions | MdExportOptions;\n    type ImportOptions = SpreadsheetImportOptions | XmlImportOptions | WebXmlImportOptions | DocxFileImportOptions | HtmlFileImportOptions | HtmlFrontMatterFileImportOptions | MdxFileImportOptions | MdFileImportOptions | StringCatalogFileImportOptions | AdocFileImportOptions | OtherImportOptions;\n    interface RestoreFile {\n        revisionId: number;\n    }\n    interface FileRevision {\n        id: number;\n        projectId: number;\n        fileId: number;\n        restoreToRevision: number;\n        info: FileRevisionInfo;\n        date: string;\n    }\n    interface FileRevisionInfo {\n        added: FileRevisionInfoAttribute;\n        deleted: FileRevisionInfoAttribute;\n        updated: FileRevisionInfoAttribute;\n    }\n    interface FileRevisionInfoAttribute {\n        strings: number;\n        words: number;\n    }\n    type FileType = 'auto' | 'android' | 'macosx' | 'resx' | 'properties' | 'gettext' | 'yaml' | 'php' | 'json' | 'xml' | 'ini' | 'rc' | 'resw' | 'resjson' | 'qtts' | 'joomla' | 'chrome' | 'dtd' | 'dklang' | 'flex' | 'nsh' | 'wxl' | 'xliff' | 'xliff_two' | 'html' | 'haml' | 'txt' | 'csv' | 'md' | 'flsnp' | 'fm_html' | 'fm_md' | 'mediawiki' | 'docx' | 'xlsx' | 'sbv' | 'properties_play' | 'properties_xml' | 'maxthon' | 'go_json' | 'dita' | 'mif' | 'idml' | 'stringsdict' | 'plist' | 'vtt' | 'vdf' | 'srt' | 'stf' | 'toml' | 'contentful_rt' | 'svg' | 'js' | 'coffee' | 'nestjs_i18n' | 'webxml';\n    interface SpreadsheetImportOptions {\n        firstLineContainsHeader?: boolean;\n        contentSegmentation?: boolean;\n        srxStorageId?: number;\n        importTranslations?: boolean;\n        scheme?: Scheme;\n    }\n    interface Scheme {\n        none: number;\n        identifier: number;\n        sourcePhrase: number;\n        sourceOrTranslation: number;\n        translation: number;\n        context: number;\n        maxLength: number;\n        labels: number;\n        [key: string]: number;\n    }\n    interface XmlImportOptions {\n        translateContent?: boolean;\n        translateAttributes?: boolean;\n        inlineTags?: string[];\n        contentSegmentation?: boolean;\n        translatableElements?: string[];\n        srxStorageId?: number;\n    }\n    interface WebXmlImportOptions {\n        inlineTags?: string[];\n        contentSegmentation?: boolean;\n        srxStorageId?: number;\n    }\n    interface DocxFileImportOptions {\n        cleanTagsAggressively?: boolean;\n        translateHiddenText?: boolean;\n        translateHyperlinkUrls?: boolean;\n        translateHiddenRowsAndColumns?: boolean;\n        importNotes?: boolean;\n        importHiddenSlides?: boolean;\n        contentSegmentation?: boolean;\n        srxStorageId?: number;\n    }\n    interface HtmlFileImportOptions {\n        excludedElements?: string[];\n        inlineTags?: string[];\n        contentSegmentation?: boolean;\n        srxStorageId?: number;\n    }\n    interface HtmlFrontMatterFileImportOptions extends HtmlFileImportOptions {\n        excludedFrontMatterElements?: string[];\n    }\n    interface MdxFileImportOptions {\n        excludedFrontMatterElements?: string[];\n        excludeCodeBlocks?: boolean;\n        contentSegmentation?: boolean;\n        srxStorageId?: number;\n    }\n    interface MdFileImportOptions {\n        excludedFrontMatterElements?: string[];\n        excludeCodeBlocks?: boolean;\n        inlineTags?: string[];\n        contentSegmentation?: boolean;\n        srxStorageId?: number;\n    }\n    interface StringCatalogFileImportOptions {\n        importKeyAsSource?: boolean;\n    }\n    interface AdocFileImportOptions {\n        excludeIncludeDirectives?: boolean;\n    }\n    interface OtherImportOptions {\n        contentSegmentation: boolean;\n        srxStorageId: number;\n    }\n    interface GeneralExportOptions {\n        exportPattern?: string;\n    }\n    interface PropertyExportOptions {\n        escapeQuotes?: EscapeQuotes;\n        exportPattern?: string;\n        escapeSpecialCharacters?: 0 | 1;\n    }\n    interface JavaScriptExportOptions {\n        exportPattern?: string;\n        exportQuotes?: ExportQuotes;\n    }\n    interface MdExportOptions {\n        exportPattern?: string;\n        strongMarker?: 'asterisk' | 'underscore';\n        emphasisMarker?: 'asterisk' | 'underscore';\n        unorderedListBullet?: 'asterisks' | 'plus' | 'plus';\n        tableColumnWidth?: 'consolidate' | 'evenly_distribute_cells';\n    }\n    enum EscapeQuotes {\n        ZERO = 0,\n        ONE = 1,\n        TWO = 2,\n        THREE = 3\n    }\n    enum ExportQuotes {\n        SINGLE = \"single\",\n        DOUBLE = \"double\"\n    }\n    type UpdateOption = 'clear_translations_and_approvals' | 'keep_translations' | 'keep_translations_and_approvals';\n    interface ReviewedSourceFilesBuild {\n        id: number;\n        projectId: number;\n        status: string;\n        progress: number;\n        attributes: ReviewedSourceFilesBuildAttributes;\n    }\n    interface ReviewedSourceFilesBuildAttributes {\n        branchId: number;\n        targetLanguageId: string;\n    }\n    interface BuildReviewedSourceFilesRequest {\n        branchId?: number;\n    }\n    interface ListProjectBranchesOptions extends PaginationOptions {\n        name?: string;\n        orderBy?: string;\n    }\n    interface ListReviewedSourceFilesBuildOptions extends PaginationOptions {\n        branchId?: number;\n    }\n    interface User {\n        id: number;\n        username: string;\n        fullName: string;\n        avatarUrl: string;\n    }\n    interface AssetReference {\n        id: number;\n        name: string;\n        user: User;\n        createdAt: string;\n        mimeType: string;\n    }\n    interface AssetReferenceRequest {\n        storageId: number;\n        name: string;\n    }\n}\n```\n\n##### sourceStrings/index.d.ts\n\n```typescript\nimport { BooleanInt, CrowdinApi, PaginationOptions, PatchRequest, ResponseList, ResponseObject, Status } from '../core';\nimport { SourceFilesModel } from '../sourceFiles';\nexport declare class SourceStrings extends CrowdinApi {\n    uploadStringsStatus(projectId: number, uploadId: string): Promise<ResponseObject<Status<SourceStringsModel.UploadStringsStatus>>>;\n    uploadStrings(projectId: number, request: SourceStringsModel.UploadStringsRequest): Promise<ResponseObject<Status<SourceStringsModel.UploadStringsStatus>>>;\n    listProjectStrings(projectId: number, options?: SourceStringsModel.ListProjectStringsOptions): Promise<ResponseList<SourceStringsModel.String>>;\n    listProjectStrings(projectId: number, fileId?: number, limit?: number, offset?: number, filter?: string, denormalizePlaceholders?: BooleanInt, labelIds?: string, scope?: SourceStringsModel.Scope, croql?: string, branchId?: number, directoryId?: number): Promise<ResponseList<SourceStringsModel.String>>;\n    addString(projectId: number, request: SourceStringsModel.CreateStringRequest | SourceStringsModel.CreateStringStringsBasedRequest): Promise<ResponseObject<SourceStringsModel.String>>;\n    stringBatchOperations(projectId: number, request: PatchRequest[]): Promise<ResponseList<SourceStringsModel.String>>;\n    getString(projectId: number, stringId: number, query?: {\n        denormalizePlaceholders: BooleanInt;\n    }): Promise<ResponseObject<SourceStringsModel.String>>;\n    deleteString(projectId: number, stringId: number): Promise<void>;\n    editString(projectId: number, stringId: number, request: PatchRequest[]): Promise<ResponseObject<SourceStringsModel.String>>;\n}\nexport declare namespace SourceStringsModel {\n    type UploadStringsType = 'auto' | 'android' | 'macosx' | 'arb' | 'csv' | 'json' | 'xliff' | 'xliff_two' | 'xlsx';\n    interface UploadStringsStatus {\n        branchId: number;\n        storageId: number;\n        fileType: UploadStringsType;\n        parserVersion: number;\n        labelIds: number[];\n        importOptions: {\n            firstLineContainsHeader: boolean;\n            importTranslations: boolean;\n            scheme: SourceFilesModel.Scheme;\n        };\n        updateStrings: boolean;\n        cleanupMode: boolean;\n        updateOption: UpdateOption;\n    }\n    interface UploadStringsRequest {\n        branchId: number;\n        storageId: number;\n        type?: UploadStringsType;\n        parserVersion?: number;\n        labelIds?: number[];\n        updateStrings?: boolean;\n        cleanupMode?: boolean;\n        importOptions?: {\n            firstLineContainsHeader: boolean;\n            importTranslations: boolean;\n            scheme: SourceFilesModel.Scheme;\n        };\n        updateOption?: UpdateOption;\n    }\n    interface ListProjectStringsOptions extends PaginationOptions {\n        orderBy?: string;\n        denormalizePlaceholders?: BooleanInt;\n        labelIds?: string;\n        fileId?: number;\n        branchId?: number;\n        directoryId?: number;\n        taskId?: number;\n        croql?: string;\n        filter?: string;\n        scope?: SourceStringsModel.Scope;\n    }\n    interface String {\n        id: number;\n        projectId: number;\n        branchId: number;\n        identifier: string;\n        text: string | PluralText;\n        type: Type;\n        context: string;\n        maxLength: number;\n        isHidden: boolean;\n        isDuplicate: boolean;\n        masterStringId: boolean;\n        hasPlurals: boolean;\n        isIcu: boolean;\n        labelIds: number[];\n        webUrl: string;\n        createdAt: string;\n        updatedAt: string;\n        fileId: number;\n        directoryId: number;\n        revision: number;\n        fields: Record<string, any>;\n    }\n    interface CreateStringRequest {\n        text: string | PluralText;\n        identifier?: string;\n        fileId: number;\n        context?: string;\n        isHidden?: boolean;\n        maxLength?: number;\n        labelIds?: number[];\n        fields?: Record<string, any>;\n    }\n    interface CreateStringStringsBasedRequest {\n        text: string | PluralText;\n        identifier: string;\n        branchId: number;\n        context?: string;\n        isHidden?: boolean;\n        maxLength?: number;\n        labelIds?: number[];\n        fields?: Record<string, any>;\n    }\n    interface PluralText {\n        zero?: string;\n        one?: string;\n        two?: string;\n        few?: string;\n        many?: string;\n        other?: string;\n    }\n    enum Type {\n        TEXT = 0,\n        ASSET = 1,\n        ICU = 2\n    }\n    type Scope = 'identifier' | 'text' | 'context';\n    type UpdateOption = 'clear_translations_and_approvals' | 'keep_translations' | 'keep_translations_and_approvals';\n}\n```\n\n##### stringComments/index.d.ts\n\n```typescript\nimport { CrowdinApi, PaginationOptions, PatchRequest, ResponseList, ResponseObject } from '../core';\nexport declare class StringComments extends CrowdinApi {\n    listStringComments(projectId: number, options?: StringCommentsModel.ListStringCommentsOptions): Promise<ResponseList<StringCommentsModel.StringComment>>;\n    listStringComments(projectId: number, stringId?: number, type?: StringCommentsModel.Type, targetLanguageId?: string, issueType?: StringCommentsModel.IssueType, issueStatus?: StringCommentsModel.IssueStatus): Promise<ResponseList<StringCommentsModel.StringComment>>;\n    addStringComment(projectId: number, request: StringCommentsModel.AddStringCommentRequest): Promise<ResponseObject<StringCommentsModel.StringComment>>;\n    getStringComment(projectId: number, stringCommentId: number): Promise<ResponseObject<StringCommentsModel.StringComment>>;\n    deleteStringComment(projectId: number, stringCommentId: number): Promise<void>;\n    editStringComment(projectId: number, stringCommentId: number, request: PatchRequest[]): Promise<ResponseObject<StringCommentsModel.StringComment>>;\n    stringCommentBatchOperations(projectId: number, request: PatchRequest[]): Promise<ResponseList<StringCommentsModel.StringComment>>;\n}\nexport declare namespace StringCommentsModel {\n    interface ListStringCommentsOptions extends PaginationOptions {\n        stringId?: number;\n        type?: Type;\n        targetLanguageId?: string;\n        issueType?: IssueType;\n        issueStatus?: IssueStatus;\n        orderBy?: string;\n    }\n    interface StringComment {\n        id: number;\n        isShared?: boolean;\n        text: string;\n        userId: number;\n        stringId: number;\n        user: User;\n        string: StringModel;\n        projectId: number;\n        languageId: string;\n        type: Type;\n        issueType: IssueType;\n        issueStatus: IssueStatus;\n        resolverId: number;\n        senderOrganization: {\n            id: number;\n            domain: string;\n        };\n        resolverOrganization: {\n            id: number;\n            domain: string;\n        };\n        resolver: User;\n        resolvedAt: string;\n        createdAt: string;\n    }\n    interface User {\n        id: number;\n        username: string;\n        fullName: string;\n        avatarUrl: string;\n    }\n    interface StringModel {\n        id: number;\n        text: string;\n        type: string;\n        hasPlurals: boolean;\n        isIcu: boolean;\n        context: string;\n        fileId: number;\n    }\n    interface AddStringCommentRequest {\n        stringId: number;\n        text: string;\n        targetLanguageId: string;\n        type: Type;\n        isShared?: boolean;\n        issueType?: IssueType;\n    }\n    type Type = 'comment' | 'issue';\n    type IssueType = 'general_question' | 'translation_mistake' | 'context_request' | 'source_mistake';\n    type IssueStatus = 'unresolved' | 'resolved';\n}\n```\n\n##### stringCorrections/index.d.ts\n\n```typescript\nimport { BooleanInt, CrowdinApi, PaginationOptions, ResponseList, ResponseObject } from '../core';\nexport declare class StringCorrections extends CrowdinApi {\n    listStringCorrections(projectId: number, options: StringCorrectionsModel.ListStringCorrectionsParams): Promise<ResponseList<StringCorrectionsModel.StringCorrection>>;\n    addStringCorrection(projectId: number, request: StringCorrectionsModel.AddStringCorrectionRequest): Promise<ResponseObject<StringCorrectionsModel.StringCorrection>>;\n    deleteStringCorrections(projectId: number, stringId: number): Promise<void>;\n    getStringCorrection(projectId: number, correctionId: number, params?: {\n        denormalizePlaceholders?: BooleanInt;\n    }): Promise<ResponseObject<StringCorrectionsModel.StringCorrection>>;\n    restoreStringCorrection(projectId: number, correctionId: number): Promise<ResponseObject<StringCorrectionsModel.StringCorrection>>;\n    deleteStringCorrection(projectId: number, correctionId: number): Promise<void>;\n}\nexport declare namespace StringCorrectionsModel {\n    interface ListStringCorrectionsParams extends PaginationOptions {\n        stringId: number;\n        orderBy?: string;\n        denormalizePlaceholders?: BooleanInt;\n    }\n    interface StringCorrection {\n        id: number;\n        text: string;\n        pluralCategoryName: PluralCategoryName;\n        user: {\n            id: number;\n            username: string;\n            fullName: string;\n            avatarUrl: string;\n        };\n        createdAt: string;\n    }\n    type PluralCategoryName = 'zero' | 'one' | 'two' | 'few' | 'many' | 'other';\n    interface AddStringCorrectionRequest {\n        stringId: number;\n        text: string;\n        pluralCategoryName?: PluralCategoryName;\n    }\n}\n```\n\n##### stringTranslations/index.d.ts\n\n```typescript\nimport { BooleanInt, CrowdinApi, PaginationOptions, PatchRequest, ResponseList, ResponseObject } from '../core';\nexport declare class StringTranslations extends CrowdinApi {\n    listTranslationApprovals(projectId: number, options?: StringTranslationsModel.ListTranslationApprovalsOptions): Promise<ResponseList<StringTranslationsModel.Approval>>;\n    listTranslationApprovals(projectId: number, stringId?: number, languageId?: string, translationId?: number, limit?: number, offset?: number, fileId?: number, labelIds?: string, excludeLabelIds?: string): Promise<ResponseList<StringTranslationsModel.Approval>>;\n    addApproval(projectId: number, request: StringTranslationsModel.AddApprovalRequest): Promise<ResponseObject<StringTranslationsModel.Approval>>;\n    removeStringApprovals(projectId: number, stringId: number): Promise<void>;\n    approvalInfo(projectId: number, approvalId: number): Promise<ResponseObject<StringTranslationsModel.Approval>>;\n    approvalBatchOperations(projectId: number, request: PatchRequest[]): Promise<ResponseList<StringTranslationsModel.Approval>>;\n    removeApproval(projectId: number, approvalId: number): Promise<void>;\n    listLanguageTranslations(projectId: number, languageId: string, options?: StringTranslationsModel.ListLanguageTranslationsOptions): Promise<ResponseList<StringTranslationsModel.PlainLanguageTranslation | StringTranslationsModel.PluralLanguageTranslation | StringTranslationsModel.IcuLanguageTranslation>>;\n    listLanguageTranslations(projectId: number, languageId: string, stringIds?: string, fileId?: number, limit?: number, offset?: number, labelIds?: string, denormalizePlaceholders?: BooleanInt, croql?: string): Promise<ResponseList<StringTranslationsModel.PlainLanguageTranslation | StringTranslationsModel.PluralLanguageTranslation | StringTranslationsModel.IcuLanguageTranslation>>;\n    translationAlignment(projectId: number, request: StringTranslationsModel.TranslationAlignmentRequest): Promise<ResponseObject<StringTranslationsModel.TranslationAlignmentResponse>>;\n    listStringTranslations(projectId: number, stringId: number, languageId: string, options?: StringTranslationsModel.ListStringTranslationsOptions): Promise<ResponseList<StringTranslationsModel.StringTranslation>>;\n    listStringTranslations(projectId: number, stringId: number, languageId: string, limit?: number, offset?: number, denormalizePlaceholders?: BooleanInt): Promise<ResponseList<StringTranslationsModel.StringTranslation>>;\n    addTranslation(projectId: number, request: StringTranslationsModel.AddStringTranslationRequest): Promise<ResponseObject<StringTranslationsModel.StringTranslation>>;\n    deleteAllTranslations(projectId: number, stringId: number, languageId?: string): Promise<void>;\n    translationInfo(projectId: number, translationId: number): Promise<ResponseObject<StringTranslationsModel.StringTranslation>>;\n    restoreTranslation(projectId: number, translationId: number): Promise<ResponseObject<StringTranslationsModel.StringTranslation>>;\n    translationBatchOperations(projectId: number, request: PatchRequest[]): Promise<ResponseList<StringTranslationsModel.StringTranslation>>;\n    deleteTranslation(projectId: number, translationId: number): Promise<void>;\n    listTranslationVotes(projectId: number, options?: StringTranslationsModel.ListTranslationVotesOptions): Promise<ResponseList<StringTranslationsModel.Vote>>;\n    listTranslationVotes(projectId: number, stringId?: number, languageId?: string, translationId?: number, labelIds?: string, excludeLabelIds?: string, limit?: number, offset?: number): Promise<ResponseList<StringTranslationsModel.Vote>>;\n    addVote(projectId: number, request: StringTranslationsModel.AddVoteRequest): Promise<ResponseObject<StringTranslationsModel.Vote>>;\n    voteInfo(projectId: number, voteId: number): Promise<ResponseObject<StringTranslationsModel.Vote>>;\n    cancelVote(projectId: number, voteId: number): Promise<void>;\n}\nexport declare namespace StringTranslationsModel {\n    interface ListTranslationApprovalsOptions extends PaginationOptions {\n        stringId?: number;\n        languageId?: string;\n        translationId?: number;\n        fileId?: number;\n        labelIds?: string;\n        excludeLabelIds?: string;\n        orderBy?: string;\n    }\n    interface Approval {\n        id: number;\n        user: User;\n        translationId: number;\n        stringId: number;\n        languageId: string;\n        createdAt: string;\n    }\n    interface AddApprovalRequest {\n        translationId: number;\n    }\n    interface StringTranslation {\n        id: number;\n        text: string;\n        pluralCategoryName: PluralCategoryName;\n        user: User;\n        rating: number;\n        provider: string;\n        isPreTranslated: boolean;\n        createdAt: string;\n    }\n    interface ListLanguageTranslationsOptions extends PaginationOptions {\n        stringIds?: string;\n        fileId?: number;\n        labelIds?: string;\n        denormalizePlaceholders?: BooleanInt;\n        croql?: string;\n        approvedOnly?: BooleanInt;\n        passedWorkflow?: BooleanInt;\n        orderBy?: string;\n        branchId?: number;\n        minApprovalCount?: number;\n        directoryId?: number;\n    }\n    interface PlainLanguageTranslation {\n        stringId: number;\n        contentType: string;\n        translationId: number;\n        text: string;\n        user: User;\n        createdAt: string;\n    }\n    interface PluralLanguageTranslation {\n        stringId: number;\n        contentType: string;\n        plurals: Plural[];\n    }\n    interface IcuLanguageTranslation {\n        stringId: number;\n        contentType: string;\n        translationId: number;\n        text: string;\n        user: User;\n        createdAt: string;\n    }\n    interface Plural {\n        translationId: number;\n        text: string;\n        pluralForm: string;\n        user: User;\n        createdAt: string;\n    }\n    interface TranslationAlignmentRequest {\n        sourceLanguageId: string;\n        targetLanguageId: string;\n        text: string;\n    }\n    interface TranslationAlignmentResponse {\n        words: {\n            text: string;\n            alignments: {\n                sourceWord: string;\n                sourceLemma: string;\n                targetWord: string;\n                targetLemma: string;\n                match: number;\n                probability: number;\n            }[];\n        }[];\n    }\n    interface AddStringTranslationRequest {\n        stringId: number;\n        languageId: string;\n        text: string;\n        pluralCategoryName?: PluralCategoryName;\n        addToTm?: boolean;\n    }\n    interface ListTranslationVotesOptions extends PaginationOptions {\n        stringId?: number;\n        languageId?: string;\n        translationId?: number;\n        fileId?: number;\n        labelIds?: string;\n        excludeLabelIds?: string;\n    }\n    interface Vote {\n        id: number;\n        user: User;\n        translationId: number;\n        votedAt: string;\n        mark: Mark;\n    }\n    interface AddVoteRequest {\n        mark: Mark;\n        translationId: number;\n    }\n    interface User {\n        id: number;\n        username: string;\n        fullName: string;\n        avatarUrl: string;\n    }\n    type Mark = 'up' | 'down';\n    interface ListStringTranslationsOptions extends PaginationOptions {\n        denormalizePlaceholders?: BooleanInt;\n        orderBy?: string;\n    }\n    type PluralCategoryName = 'zero' | 'one' | 'two' | 'few' | 'many' | 'other';\n}\n```\n\n##### tasks/index.d.ts\n\n```typescript\nimport { BooleanInt, CrowdinApi, DownloadLink, PaginationOptions, PatchRequest, ResponseList, ResponseObject } from '../core';\nimport { LanguagesModel } from '../languages';\nexport declare class Tasks extends CrowdinApi {\n    listTasks(projectId: number, options?: TasksModel.ListTasksOptions): Promise<ResponseList<TasksModel.Task>>;\n    listTasks(projectId: number, limit?: number, offset?: number, status?: TasksModel.Status): Promise<ResponseList<TasksModel.Task>>;\n    addTask(projectId: number, request: TasksModel.CreateTaskRequest): Promise<ResponseObject<TasksModel.Task>>;\n    exportTaskStrings(projectId: number, taskId: number): Promise<ResponseObject<DownloadLink>>;\n    getTask(projectId: number, taskId: number): Promise<ResponseObject<TasksModel.Task>>;\n    deleteTask(projectId: number, taskId: number): Promise<void>;\n    editTask(projectId: number, taskId: number, request: PatchRequest[]): Promise<ResponseObject<TasksModel.Task>>;\n    listTasksComments(projectId: number, taskId: number, options?: PaginationOptions): Promise<ResponseList<TasksModel.TaskComment>>;\n    addTaskComment(projectId: number, taskId: number, request: TasksModel.CreateTaskCommentRequest): Promise<ResponseObject<TasksModel.TaskComment>>;\n    getTaskComment(projectId: number, taskId: number, commentId: number): Promise<ResponseObject<TasksModel.TaskComment>>;\n    deleteTaskComment(projectId: number, taskId: number, commentId: number): Promise<void>;\n    editTaskComment(projectId: number, taskId: number, commentId: number, request: PatchRequest[]): Promise<ResponseObject<TasksModel.TaskComment>>;\n    listUserTasks(options?: TasksModel.ListUserTasksOptions): Promise<ResponseList<TasksModel.UserTask>>;\n    listUserTasks(limit?: number, offset?: number, status?: TasksModel.Status, isArchived?: BooleanInt): Promise<ResponseList<TasksModel.UserTask>>;\n    editTaskArchivedStatus(projectId: number, taskId: number, request: PatchRequest[]): Promise<ResponseObject<TasksModel.UserTask>>;\n    listTaskSettingsTemplates(projectId: number, options?: PaginationOptions): Promise<ResponseList<TasksModel.TaskSettingsTemplate>>;\n    addTaskSettingsTemplate(projectId: number, request: TasksModel.AddTaskSettingsTemplate): Promise<ResponseObject<TasksModel.TaskSettingsTemplate>>;\n    getTaskSettingsTemplate(projectId: number, taskSettingsId: number): Promise<ResponseObject<TasksModel.TaskSettingsTemplate>>;\n    deleteTaskSettingsTemplate(projectId: number, taskSettingsId: number): Promise<void>;\n    editTaskSettingsTemplate(projectId: number, taskSettingsId: number, request: PatchRequest[]): Promise<ResponseObject<TasksModel.TaskSettingsTemplate>>;\n}\nexport declare namespace TasksModel {\n    interface Task {\n        id: number;\n        projectId: number;\n        creatorId: number;\n        type: Type | TypeVendor;\n        status: Status;\n        title: string;\n        assignees: Assignee[];\n        assignedTeams: AssignedTeam[];\n        progress: Progress;\n        translateProgress: Progress;\n        sourceLanguageId: string;\n        targetLanguageId: string;\n        description: string;\n        translationUrl: string;\n        webUrl: string;\n        wordsCount: number;\n        commentsCount: number;\n        deadline: string;\n        startedAt: string;\n        resolvedAt: string;\n        timeRange: string;\n        workflowStepId: number;\n        buyUrl: string;\n        createdAt: string;\n        updatedAt: string;\n        sourceLanguage: LanguagesModel.Language;\n        targetLanguages: LanguagesModel.Language[];\n        labelIds: number[];\n        excludeLabelIds: number[];\n        precedingTaskId: number;\n        filesCount: number;\n        fileIds: number[];\n        branchIds: number[];\n        vendor: string;\n        fields: Record<string, any>;\n    }\n    interface ListUserTasksOptions extends PaginationOptions {\n        status?: Status;\n        isArchived?: BooleanInt;\n        orderBy?: string;\n    }\n    interface UserTask extends Task {\n        isArchived: boolean;\n    }\n    type CreateTaskRequest = CreateTaskEnterpriseByBranchIds | CreateTaskEnterpriseByFileIds | CreateTaskEnterpriseByStringIds | CreateTaskEnterpriseVendorByBranchIds | CreateTaskEnterpriseVendorByFileIds | CreateTaskEnterpriseVendorByStringIds | CreateTaskEnterprisePendingTask | CreateTaskByFileIds | CreateTaskByStringIds | CreateTaskByBranchIds | CreateTaskByFileIdsLanguageService | CreateTaskByStringIdsLanguageService | CreateTaskByBranchIdsLanguageService | CreateTaskVendorOhtByFileIds | CreateTaskVendorOhtByStringIds | CreateTaskVendorOhtByBranchIds | CreateTaskVendorGengoByFileIds | CreateTaskVendorGengoByStringIds | CreateTaskVendorGengoByBranchIds | CreateTaskVendorManualByFileIds | CreateTaskVendorManualByStringIds | CreateTaskVendorManualByBranchIds | CreateTaskPendingTask | CreateTaskPendingTaskLanguageService | CreateTaskPendingTaskVendorManual;\n    interface CreateTaskEnterpriseByBranchIds {\n        type: Type;\n        workflowStepId: number;\n        title: string;\n        languageId: string;\n        branchIds: number[];\n        labelIds?: number[];\n        excludeLabelIds?: number[];\n        status?: RequestStatus;\n        description?: string;\n        splitContent?: boolean;\n        skipAssignedStrings?: boolean;\n        assignees?: CreateTaskAssignee[];\n        assignedTeams?: AssignedTeam[];\n        includePreTranslatedStringsOnly?: boolean;\n        deadline?: string;\n        startedAt?: string;\n        dateFrom?: string;\n        dateTo?: string;\n        fields?: Record<string, any>;\n    }\n    interface CreateTaskEnterpriseByStringIds {\n        type: Type;\n        workflowStepId: number;\n        title: string;\n        languageId: string;\n        stringIds: number[];\n        status?: RequestStatus;\n        description?: string;\n        splitContent?: boolean;\n        skipAssignedStrings?: boolean;\n        assignees?: CreateTaskAssignee[];\n        assignedTeams?: AssignedTeam[];\n        includePreTranslatedStringsOnly?: boolean;\n        deadline?: string;\n        startedAt?: string;\n        dateFrom?: string;\n        dateTo?: string;\n        fields?: Record<string, any>;\n    }\n    type CreateTaskEnterpriseVendorByStringIds = Omit<CreateTaskEnterpriseByStringIds, 'type' | 'status' | 'splitContent' | 'assignees' | 'assignedTeams'>;\n    type CreateTaskEnterpriseVendorByBranchIds = Omit<CreateTaskEnterpriseByBranchIds, 'type' | 'status' | 'splitContent' | 'assignees' | 'assignedTeams'>;\n    type CreateTaskEnterpriseByFileIds = Omit<CreateTaskEnterpriseByBranchIds, 'branchIds'> & {\n        fileIds: number[];\n    };\n    type CreateTaskEnterpriseVendorByFileIds = Omit<CreateTaskEnterpriseByFileIds, 'type' | 'status' | 'splitContent' | 'assignees' | 'assignedTeams'>;\n    interface CreateTaskEnterprisePendingTask {\n        precedingTaskId: number;\n        type: Type.PROOFREAD;\n        title: string;\n        description?: string;\n        assignees?: CreateTaskAssignee[];\n        assignedTeams?: AssignedTeam[];\n        deadline?: string;\n    }\n    interface CreateTaskByFileIds {\n        title: string;\n        languageId: string;\n        type: Type;\n        fileIds: number[];\n        labelIds?: number[];\n        excludeLabelIds?: number[];\n        status?: RequestStatus;\n        description?: string;\n        splitContent?: boolean;\n        skipAssignedStrings?: boolean;\n        includePreTranslatedStringsOnly?: boolean;\n        assignees?: CreateTaskAssignee[];\n        deadline?: string;\n        startedAt?: string;\n        dateFrom?: string;\n        dateTo?: string;\n    }\n    type CreateTaskByStringIds = Omit<CreateTaskByFileIds, 'fileIds' | 'labelIds' | 'excludeLabelIds'> & {\n        stringIds: number;\n    };\n    type CreateTaskByBranchIds = Omit<CreateTaskByFileIds, 'fileIds'> & {\n        branchIds: number;\n    };\n    interface CreateTaskByFileIdsLanguageService {\n        title: string;\n        languageId: string;\n        type: TypeVendor;\n        vendor: 'crowdin_language_service';\n        fileIds: number[];\n        labelIds?: number[];\n        excludeLabelIds?: number[];\n        status?: RequestStatus;\n        description?: string;\n        includePreTranslatedStringsOnly?: boolean;\n        assignees?: CreateTaskAssignee[];\n        dateFrom?: string;\n        dateTo?: string;\n    }\n    type CreateTaskByStringIdsLanguageService = Omit<CreateTaskByFileIdsLanguageService, 'fileIds' | 'labelIds' | 'excludeLabelIds'> & {\n        stringIds: number[];\n    };\n    type CreateTaskByBranchIdsLanguageService = Omit<CreateTaskByFileIdsLanguageService, 'fileIds'> & {\n        branchIds: number[];\n    };\n    interface CreateTaskVendorOhtByFileIds {\n        title: string;\n        languageId: string;\n        type: TypeVendor;\n        vendor: 'oht';\n        fileIds: number[];\n        labelIds?: number[];\n        excludeLabelIds?: number[];\n        status?: RequestStatus;\n        description?: string;\n        expertise?: Expertise;\n        editService?: boolean;\n        includePreTranslatedStringsOnly?: boolean;\n        dateFrom?: string;\n        dateTo?: string;\n    }\n    type CreateTaskVendorOhtByStringIds = Omit<CreateTaskVendorOhtByFileIds, 'fileIds' | 'labelIds' | 'excludeLabelIds'> & {\n        stringIds: number[];\n    };\n    type CreateTaskVendorOhtByBranchIds = Omit<CreateTaskVendorOhtByFileIds, 'fileIds'> & {\n        branchIds: number[];\n    };\n    interface CreateTaskVendorGengoByFileIds {\n        title: string;\n        languageId: string;\n        type: TypeVendor.TRANSLATE_BY_VENDOR;\n        vendor: 'gengo';\n        fileIds: number[];\n        labelIds?: number[];\n        excludeLabelIds?: number[];\n        status?: RequestStatus;\n        description?: string;\n        expertise?: 'standard' | 'pro';\n        tone?: Tone;\n        purpose?: Purpose;\n        customerMessage?: string;\n        usePreferred?: boolean;\n        editService?: boolean;\n        dateFrom?: string;\n        dateTo?: string;\n    }\n    type CreateTaskVendorGengoByStringIds = Omit<CreateTaskVendorGengoByFileIds, 'fileIds' | 'labelIds' | 'excludeLabelIds'> & {\n        stringIds: number[];\n    };\n    type CreateTaskVendorGengoByBranchIds = Omit<CreateTaskVendorGengoByFileIds, 'fileIds'> & {\n        branchIds: number[];\n    };\n    interface CreateTaskVendorManualByFileIds {\n        title: string;\n        languageId: string;\n        type: TypeVendor;\n        vendor: 'alconost' | 'babbleon' | 'tomedes' | 'e2f' | 'write_path_admin' | 'inlingo' | 'acclaro' | 'translate_by_humans' | 'lingo24' | 'assertio_language_services' | 'gte_localize' | 'kettu_solutions' | 'languageline_solutions';\n        fileIds: number[];\n        labelIds?: number[];\n        excludeLabelIds?: number[];\n        status?: RequestStatus;\n        description?: string;\n        skipAssignedStrings?: boolean;\n        includePreTranslatedStringsOnly?: boolean;\n        assignees?: CreateTaskAssignee[];\n        deadline?: string;\n        startedAt?: string;\n        dateFrom?: string;\n        dateTo?: string;\n    }\n    type CreateTaskVendorManualByStringIds = Omit<CreateTaskVendorManualByFileIds, 'fileIds' | 'labelIds' | 'excludeLabelIds'> & {\n        stringIds: number[];\n    };\n    type CreateTaskVendorManualByBranchIds = Omit<CreateTaskVendorManualByFileIds, 'fileIds'> & {\n        branchIds: number[];\n    };\n    interface CreateTaskPendingTask {\n        precedingTaskId: number;\n        type: Type.PROOFREAD;\n        title: string;\n        description?: string;\n        assignees?: CreateTaskAssignee[];\n        deadline?: string;\n    }\n    interface CreateTaskPendingTaskLanguageService {\n        precedingTaskId: number;\n        type: TypeVendor.PROOFREAD_BY_VENDOR;\n        vendor: 'crowdin_language_service';\n        title: string;\n        description?: string;\n        deadline?: string;\n    }\n    interface CreateTaskPendingTaskVendorManual {\n        precedingTaskId: number;\n        type: TypeVendor.PROOFREAD_BY_VENDOR;\n        vendor: CreateTaskVendorManualByFileIds['vendor'];\n        title: string;\n        description?: string;\n        deadline?: string;\n    }\n    interface CreateTaskAssignee {\n        id: number;\n        wordsCount?: number;\n    }\n    type Status = 'todo' | 'in_progress' | 'done' | 'closed';\n    type RequestStatus = Extract<Status, 'todo' | 'in_progress'>;\n    enum Type {\n        TRANSLATE = 0,\n        PROOFREAD = 1\n    }\n    enum TypeVendor {\n        TRANSLATE_BY_VENDOR = 2,\n        PROOFREAD_BY_VENDOR = 3\n    }\n    interface Assignee {\n        id: number;\n        username: string;\n        fullName: string;\n        avatarUrl: string;\n        wordsCount: number;\n        wordsLeft: number;\n    }\n    interface AssignedTeam {\n        id: number;\n        wordsCount: number;\n    }\n    interface Progress {\n        total: number;\n        done: number;\n        percent: number;\n    }\n    type Expertise = 'standard' | 'mobile-applications' | 'software-it' | 'gaming-video-games' | 'technical-engineering' | 'marketing-consumer-media' | 'business-finance' | 'legal-certificate' | 'medical' | 'ad-words-banners' | 'automotive-aerospace' | 'scientific' | 'scientific-academic' | 'tourism' | 'training-employee-handbooks' | 'forex-crypto';\n    enum TranslatedExpertise {\n        ECONOMY = \"P\",\n        PROFESSIONAL = \"T\",\n        PREMIUM = \"R\"\n    }\n    type Tone = '' | 'Informal' | 'Friendly' | 'Business' | 'Formal' | 'other';\n    type Purpose = 'standard' | 'Personal use' | 'Business' | 'Online content' | 'App/Web localization' | 'Media content' | 'Semi-technical' | 'other';\n    type Subject = 'general' | 'accounting_finance' | 'aerospace_defence' | 'architecture' | 'art' | 'automotive' | 'certificates_diplomas_licences_cv_etc' | 'chemical' | 'civil_engineering_construction' | 'corporate_social_responsibility' | 'cosmetics' | 'culinary' | 'electronics_electrical_engineering' | 'energy_power_generation_oil_gas' | 'environment' | 'fashion' | 'games_viseogames_casino' | 'general_business_commerce' | 'history_archaeology' | 'information_technology' | 'insurance' | 'internet_e-commerce' | 'legal_documents_contracts' | 'literary_translations' | 'marketing_advertising_material_public_relations' | 'matematics_and_physics' | 'mechanical_manufacturing' | 'media_journalism_publishing' | 'medical_pharmaceutical' | 'music' | 'private_correspondence_letters' | 'religion' | 'science' | 'shipping_sailing_maritime' | 'social_science' | 'telecommunications' | 'travel_tourism';\n    interface ListTasksOptions extends PaginationOptions {\n        status?: TasksModel.Status;\n        assigneeId?: number;\n        orderBy?: string;\n    }\n    interface TaskSettingsTemplate {\n        id: number;\n        name: string;\n        config: TaskSettingsTemplateConfig;\n        createdAt: string;\n        updatedAt: string;\n    }\n    interface AddTaskSettingsTemplate {\n        name: string;\n        config: TaskSettingsTemplateConfig;\n    }\n    interface TaskSettingsTemplateConfig {\n        languages: {\n            languageId?: string;\n            userIds?: number[];\n            teamIds?: number[];\n        }[];\n    }\n    interface TaskComment {\n        id: number;\n        userId: number;\n        taskId: number;\n        text: string;\n        timeSpent: number;\n        createdAt: string;\n        updatedAt: string;\n    }\n    interface CreateTaskCommentRequest {\n        text?: string;\n        timeSpent?: number;\n    }\n}\n```\n\n##### teams/index.d.ts\n\n```typescript\nimport { CrowdinApi, Pagination, PaginationOptions, PatchRequest, ProjectRole, ProjectRoles, ResponseList, ResponseObject } from '../core';\nimport { ProjectsGroupsModel } from '../projectsGroups';\nexport declare class Teams extends CrowdinApi {\n    listGroupTeams(groupId: number, options?: TeamsModel.ListGroupTeamsOptions): Promise<ResponseList<TeamsModel.TeamGroup>>;\n    updateGroupTeams(groupId: number, request: PatchRequest[]): Promise<ResponseList<TeamsModel.TeamGroup>>;\n    getGroupTeam(groupId: number, teamId: number): Promise<ResponseObject<TeamsModel.TeamGroup>>;\n    listTeamProjectPermissions(teamId: number, options?: PaginationOptions): Promise<ResponseList<TeamsModel.ProjectPermissions>>;\n    editTeamProjectPermissions(teamId: number, request: PatchRequest[]): Promise<ResponseList<TeamsModel.ProjectPermissions>>;\n    addTeamToProject(projectId: number, request: TeamsModel.AddTeamToProjectRequest): Promise<TeamsModel.ProjectTeamResources>;\n    listTeams(options?: TeamsModel.ListTeamsOptions): Promise<ResponseList<TeamsModel.Team>>;\n    listTeams(limit?: number, offset?: number): Promise<ResponseList<TeamsModel.Team>>;\n    addTeam(request: TeamsModel.AddTeamRequest): Promise<ResponseObject<TeamsModel.Team>>;\n    getTeam(teamId: number): Promise<ResponseObject<TeamsModel.Team>>;\n    deleteTeam(teamId: number): Promise<void>;\n    editTeam(teamId: number, request: PatchRequest[]): Promise<ResponseObject<TeamsModel.Team>>;\n    teamMembersList(teamId: number, options?: PaginationOptions): Promise<ResponseList<TeamsModel.TeamMember>>;\n    teamMembersList(teamId: number, limit?: number, offset?: number): Promise<ResponseList<TeamsModel.TeamMember>>;\n    addTeamMembers(teamId: number, request: TeamsModel.AddTeamMembersRequest): Promise<TeamsModel.AddTeamMembersResponse>;\n    deleteAllTeamMembers(teamId: number): Promise<void>;\n    deleteTeamMember(teamId: number, memberId: number): Promise<void>;\n}\nexport declare namespace TeamsModel {\n    interface ListGroupTeamsOptions extends PaginationOptions {\n        orderBy?: string;\n    }\n    interface ProjectPermissions {\n        id: number;\n        roles: ProjectRole[];\n        project: ProjectsGroupsModel.Project | ProjectsGroupsModel.ProjectSettings;\n    }\n    interface AddTeamToProjectRequest {\n        teamId: number;\n        managerAccess?: boolean;\n        developerAccess?: boolean;\n        roles?: ProjectRole[];\n        accessToAllWorkflowSteps?: boolean;\n        permissions?: Permissions;\n    }\n    interface ListTeamsOptions extends PaginationOptions {\n        search?: string;\n        projectIds?: string;\n        projectRoles?: ProjectRoles[];\n        languageIds?: string;\n        groupIds?: string;\n        orderBy?: string;\n    }\n    interface ProjectTeamResources {\n        skipped: ProjectTeamResource;\n        added: ProjectTeamResource;\n    }\n    interface ProjectTeamResource {\n        id: number;\n        hasManagerAccess: boolean;\n        hasDeveloperAccess: boolean;\n        hasAccessToAllWorkflowSteps: boolean;\n        permissions: Permissions;\n        roles: ProjectRole[];\n    }\n    interface Permissions {\n        [lang: string]: {\n            workflowStepIds: number[] | 'all';\n        };\n    }\n    interface Team {\n        id: number;\n        name: string;\n        totalMembers: number;\n        webUrl: string;\n        createdAt: string;\n        updatedAt: string;\n    }\n    interface TeamGroup {\n        id: number;\n        team: Team;\n    }\n    interface AddTeamRequest {\n        name: string;\n    }\n    interface TeamMember {\n        id: number;\n        username: string;\n        firstName: string;\n        lastName: string;\n        avatarUrl: string;\n        addedAt: string;\n    }\n    interface AddTeamMembersRequest {\n        userIds: number[];\n    }\n    interface AddTeamMembersResponse {\n        skipped: ResponseObject<TeamMember>[];\n        added: ResponseObject<TeamMember>[];\n        pagination: Pagination;\n    }\n}\n```\n\n##### translationMemory/index.d.ts\n\n```typescript\nimport { CrowdinApi, DownloadLink, PaginationOptions, PatchRequest, ResponseList, ResponseObject, Status } from '../core';\nexport declare class TranslationMemory extends CrowdinApi {\n    listTm(options?: TranslationMemoryModel.ListTMsOptions): Promise<ResponseList<TranslationMemoryModel.TranslationMemory>>;\n    listTm(groupId?: number, limit?: number, offset?: number): Promise<ResponseList<TranslationMemoryModel.TranslationMemory>>;\n    addTm(request: TranslationMemoryModel.AddTranslationMemoryRequest): Promise<ResponseObject<TranslationMemoryModel.TranslationMemory>>;\n    getTm(tmId: number): Promise<ResponseObject<TranslationMemoryModel.TranslationMemory>>;\n    deleteTm(tmId: number): Promise<void>;\n    editTm(tmId: number, request: PatchRequest[]): Promise<ResponseObject<TranslationMemoryModel.TranslationMemory>>;\n    listTmSegments(tmId: number, options?: TranslationMemoryModel.ListSegmentsOptions): Promise<ResponseList<TranslationMemoryModel.TMSegment>>;\n    addTmSegment(tmId: number, request: TranslationMemoryModel.AddTMSegment): Promise<ResponseObject<TranslationMemoryModel.TMSegment>>;\n    clearTm(tmId: number): Promise<void>;\n    exportTm(tmId: number, request?: TranslationMemoryModel.ExportTranslationMemoryRequest): Promise<ResponseObject<Status<TranslationMemoryModel.ExportTranslationMemoryAttribute>>>;\n    checkExportStatus(tmId: number, exportId: string): Promise<ResponseObject<Status<TranslationMemoryModel.ExportTranslationMemoryAttribute>>>;\n    downloadTm(tmId: number, exportId: string): Promise<ResponseObject<DownloadLink>>;\n    concordanceSearch(projectId: number, request: TranslationMemoryModel.ConcordanceSearchRequest): Promise<ResponseList<TranslationMemoryModel.ConcordanceSearchResponse>>;\n    importTm(tmId: number, request: TranslationMemoryModel.ImportTranslationMemoryRequest): Promise<ResponseObject<Status<TranslationMemoryModel.ImportTranslationMemoryAttribute>>>;\n    checkImportStatus(tmId: number, importId: string): Promise<ResponseObject<Status<TranslationMemoryModel.ImportTranslationMemoryAttribute>>>;\n    getTmSegment(tmId: number, segmentId: number): Promise<ResponseObject<TranslationMemoryModel.TMSegment>>;\n    deleteTmSegment(tmId: number, segmentId: number): Promise<void>;\n    editTmSegment(tmId: number, segmentId: number, request: PatchRequest[]): Promise<ResponseObject<TranslationMemoryModel.TMSegment>>;\n    deleteTmSegmentRecord(tmId: number, segmentId: number, recordId: number): Promise<void>;\n    editTmSegmentRecord(tmId: number, segmentId: number, recordId: number, request: PatchRequest[]): Promise<ResponseObject<TranslationMemoryModel.TMSegment>>;\n    addTmSegmentRecords(tmId: number, segmentId: number, request: TranslationMemoryModel.AddTMSegment): Promise<ResponseObject<TranslationMemoryModel.TMSegment>>;\n}\nexport declare namespace TranslationMemoryModel {\n    interface TranslationMemory {\n        id: number;\n        groupId: number;\n        userId: number;\n        name: string;\n        languageId: string;\n        languageIds: string[];\n        segmentsCount: number;\n        defaultProjectIds: number[];\n        projectIds: number[];\n        createdAt: string;\n        webUrl: string;\n    }\n    interface AddTranslationMemoryRequest {\n        name: string;\n        languageId: string;\n        groupId?: number;\n    }\n    interface ConcordanceSearchRequest {\n        sourceLanguageId: string;\n        targetLanguageId: string;\n        autoSubstitution: boolean;\n        minRelevant: number;\n        expressions: string[];\n        expression?: string;\n    }\n    interface ConcordanceSearchResponse {\n        tm: TranslationMemory;\n        recordId: number;\n        source: string;\n        target: string;\n        relevant: number;\n        substituted: string;\n        updatedAt: string;\n    }\n    interface ExportTranslationMemoryRequest {\n        sourceLanguageId?: number;\n        targetLanguageId?: number;\n        format?: Format;\n    }\n    interface ImportTranslationMemoryRequest {\n        storageId: number;\n        firstLineContainsHeader?: boolean;\n        scheme?: Scheme;\n    }\n    interface ExportTranslationMemoryAttribute {\n        sourceLanguageId: string;\n        targetLanguageId: string;\n        format: string;\n    }\n    interface ImportTranslationMemoryAttribute {\n        tmId: number;\n        storageId: number;\n        firstLineContainsHeader: number;\n        scheme: Scheme;\n    }\n    type Format = 'tmx' | 'csv' | 'xlsx';\n    interface Scheme {\n        [key: string]: number;\n    }\n    interface ListTMsOptions extends PaginationOptions {\n        groupId?: number;\n        userId?: number;\n        orderBy?: string;\n    }\n    interface ListSegmentsOptions extends PaginationOptions {\n        croql?: string;\n        orderBy?: string;\n    }\n    interface TMSegment {\n        id: number;\n        records: TMSegmentRecord[];\n    }\n    interface TMSegmentRecord {\n        id: number;\n        languageId: string;\n        text: string;\n        usageCount: number;\n        createdBy: number;\n        updatedBy: number;\n        createdAt: string;\n        updatedAt: string;\n    }\n    interface AddTMSegment {\n        records: AddTMSegmentRecord[];\n    }\n    interface AddTMSegmentRecord {\n        languageId: string;\n        text: string;\n    }\n}\n```\n\n##### translationStatus/index.d.ts\n\n```typescript\nimport { CrowdinApi, PaginationOptions, ResponseList } from '../core';\nimport { LanguagesModel } from '../languages';\nexport declare class TranslationStatus extends CrowdinApi {\n    getBranchProgress(projectId: number, branchId: number, options?: PaginationOptions): Promise<ResponseList<TranslationStatusModel.LanguageProgress>>;\n    getBranchProgress(projectId: number, branchId: number, limit?: number, offset?: number): Promise<ResponseList<TranslationStatusModel.LanguageProgress>>;\n    getDirectoryProgress(projectId: number, directoryId: number, options?: PaginationOptions): Promise<ResponseList<TranslationStatusModel.LanguageProgress>>;\n    getDirectoryProgress(projectId: number, directoryId: number, limit?: number, offset?: number): Promise<ResponseList<TranslationStatusModel.LanguageProgress>>;\n    getFileProgress(projectId: number, fileId: number, options?: PaginationOptions): Promise<ResponseList<TranslationStatusModel.LanguageProgress>>;\n    getFileProgress(projectId: number, fileId: number, limit?: number, offset?: number): Promise<ResponseList<TranslationStatusModel.LanguageProgress>>;\n    getLanguageProgress(projectId: number, languageId: string, options?: PaginationOptions): Promise<ResponseList<TranslationStatusModel.FileProgress>>;\n    getLanguageProgress(projectId: number, languageId: string, limit?: number, offset?: number): Promise<ResponseList<TranslationStatusModel.FileProgress>>;\n    getProjectProgress(projectId: number, options?: PaginationOptions): Promise<ResponseList<TranslationStatusModel.LanguageProgress>>;\n    getProjectProgress(projectId: number, limit?: number, offset?: number, languageIds?: string): Promise<ResponseList<TranslationStatusModel.LanguageProgress>>;\n    listQaCheckIssues(projectId: number, options?: TranslationStatusModel.ListQaCheckIssuesOptions): Promise<ResponseList<TranslationStatusModel.QaCheck>>;\n    listQaCheckIssues(projectId: number, limit?: number, offset?: number, category?: TranslationStatusModel.Category, validation?: TranslationStatusModel.Validation, languageIds?: string): Promise<ResponseList<TranslationStatusModel.QaCheck>>;\n}\nexport declare namespace TranslationStatusModel {\n    interface LanguageProgress {\n        words: Words;\n        phrases: Words;\n        translationProgress: number;\n        approvalProgress: number;\n        eTag: string;\n        languageId: string;\n        language: LanguagesModel.Language;\n    }\n    interface FileProgress {\n        words: Words;\n        phrases: Words;\n        translationProgress: number;\n        approvalProgress: number;\n        branchId: number;\n        fileId: number;\n        eTag: string;\n    }\n    interface Words {\n        total: number;\n        translated: number;\n        approved: number;\n        preTranslateAppliedTo: number;\n    }\n    type Category = 'empty' | 'variables' | 'tags' | 'punctuation' | 'symbol_register' | 'spaces' | 'size' | 'special_symbols' | 'wrong_translation' | 'spellcheck' | 'icu';\n    type Validation = 'empty_string_check' | 'empty_suggestion_check' | 'max_length_check' | 'tags_check' | 'mismatch_ids_check' | 'cdata_check' | 'specials_symbols_check' | 'leading_newlines_check' | 'trailing_newlines_check' | 'leading_spaces_check' | 'trailing_spaces_check' | 'multiple_spaces_check' | 'custom_blocked_variables_check' | 'highest_priority_custom_variables_check' | 'highest_priority_variables_check' | 'c_variables_check' | 'python_variables_check' | 'rails_variables_check' | 'java_variables_check' | 'dot_net_variables_check' | 'twig_variables_check' | 'php_variables_check' | 'freemarker_variables_check' | 'lowest_priority_variable_check' | 'lowest_priority_custom_variables_check' | 'punctuation_check' | 'spaces_before_punctuation_check' | 'spaces_after_punctuation_check' | 'non_breaking_spaces_check' | 'capitalize_check' | 'multiple_uppercase_check' | 'parentheses_check' | 'entities_check' | 'escaped_quotes_check' | 'wrong_translation_issue_check' | 'spellcheck' | 'icu_check';\n    interface ListQaCheckIssuesOptions extends PaginationOptions {\n        category?: Category | Category[];\n        validation?: Validation | Validation[];\n        languageIds?: string;\n    }\n    interface QaCheck {\n        stringId: number;\n        languageId: string;\n        category: Category;\n        categoryDescription: string;\n        validation: Validation;\n        validationDescription: string;\n        pluralId: number;\n        text: string;\n    }\n    interface GetProjectProgressOptions extends PaginationOptions {\n        languageIds?: string;\n    }\n}\n```\n\n##### translations/index.d.ts\n\n```typescript\nimport { CrowdinApi, DownloadLink, PaginationOptions, PatchRequest, ResponseList, ResponseObject, Status } from '../core';\nimport { ProjectsGroupsModel } from '../projectsGroups';\nexport declare class Translations extends CrowdinApi {\n    listPreTranslations(projectId: number, options?: PaginationOptions): Promise<ResponseList<Status<TranslationsModel.PreTranslationStatusAttributes>>>;\n    preTranslationStatus(projectId: number, preTranslationId: string): Promise<ResponseObject<Status<TranslationsModel.PreTranslationStatusAttributes>>>;\n    applyPreTranslation(projectId: number, request: TranslationsModel.PreTranslateRequest | TranslationsModel.PreTranslateStringsRequest): Promise<ResponseObject<Status<TranslationsModel.PreTranslationStatusAttributes>>>;\n    editPreTranslation(projectId: number, preTranslationId: string, request: PatchRequest[]): Promise<ResponseObject<Status<TranslationsModel.PreTranslationStatusAttributes>>>;\n    getPreTranslationReport(projectId: number, preTranslationId: string): Promise<ResponseObject<TranslationsModel.PreTranslationReport>>;\n    buildProjectDirectoryTranslation(projectId: number, directoryId: number, request?: TranslationsModel.BuildProjectDirectoryTranslationRequest): Promise<ResponseObject<TranslationsModel.BuildProjectDirectoryTranslationResponse>>;\n    buildProjectFileTranslation(projectId: number, fileId: number, request: TranslationsModel.BuildProjectFileTranslationRequest, eTag?: string): Promise<ResponseObject<TranslationsModel.BuildProjectFileTranslationResponse>>;\n    listProjectBuilds(projectId: number, options?: TranslationsModel.ListProjectBuildsOptions): Promise<ResponseList<TranslationsModel.Build>>;\n    listProjectBuilds(projectId: number, branchId?: number, limit?: number, offset?: number): Promise<ResponseList<TranslationsModel.Build>>;\n    buildProject(projectId: number, request?: TranslationsModel.BuildRequest | TranslationsModel.PseudoBuildRequest): Promise<ResponseObject<TranslationsModel.Build>>;\n    uploadTranslation(projectId: number, languageId: string, request: TranslationsModel.UploadTranslationRequest): Promise<ResponseObject<TranslationsModel.UploadTranslationResponse>>;\n    uploadTranslationStrings(projectId: number, languageId: string, request: TranslationsModel.UploadTranslationStringsRequest): Promise<ResponseObject<TranslationsModel.UploadTranslationStringsResponse>>;\n    downloadTranslations(projectId: number, buildId: number): Promise<ResponseObject<DownloadLink>>;\n    checkBuildStatus(projectId: number, buildId: number): Promise<ResponseObject<TranslationsModel.Build>>;\n    cancelBuild(projectId: number, buildId: number): Promise<void>;\n    exportProjectTranslation(projectId: number, request: TranslationsModel.ExportProjectTranslationRequest): Promise<ResponseObject<DownloadLink>>;\n}\nexport declare namespace TranslationsModel {\n    interface PreTranslateRequest {\n        languageIds: string[];\n        fileIds: number[];\n        method?: Method;\n        engineId?: number;\n        aiPromptId?: number;\n        autoApproveOption?: AutoApproveOption;\n        duplicateTranslations?: boolean;\n        skipApprovedTranslations?: boolean;\n        translateUntranslatedOnly?: boolean;\n        translateWithPerfectMatchOnly?: boolean;\n        fallbackLanguages?: {\n            languageId?: string[];\n        };\n        labelIds?: number[];\n        excludeLabelIds?: number[];\n    }\n    interface PreTranslateStringsRequest {\n        languageIds: string[];\n        branchIds?: number[];\n        method?: Method;\n        engineId?: number;\n        aiPromptId?: number;\n        autoApproveOption?: AutoApproveOption;\n        duplicateTranslations?: boolean;\n        skipApprovedTranslations?: boolean;\n        translateUntranslatedOnly?: boolean;\n        translateWithPerfectMatchOnly?: boolean;\n        fallbackLanguages?: {\n            languageId: string[];\n        };\n        labelIds?: number[];\n        excludeLabelIds?: number[];\n    }\n    interface BuildProjectDirectoryTranslationRequest {\n        targetLanguageIds?: string[];\n        skipUntranslatedStrings?: boolean;\n        skipUntranslatedFiles?: boolean;\n        preserveFolderHierarchy?: boolean;\n        exportStringsThatPassedWorkflow?: boolean;\n        exportWithMinApprovalsCount?: number;\n        exportApprovedOnly?: boolean;\n    }\n    interface BuildProjectDirectoryTranslationResponse {\n        id: number;\n        projectId: number;\n        status: BuildStatus;\n        progress: number;\n        createdAt: string;\n        updatedAt: string;\n        finishedAt: string;\n    }\n    type BuildStatus = 'created' | 'inProgress' | 'canceled' | 'failed' | 'finished';\n    interface BuildProjectFileTranslationRequest {\n        targetLanguageId: string;\n        exportAsXliff?: boolean;\n        skipUntranslatedStrings?: boolean;\n        skipUntranslatedFiles?: boolean;\n        exportApprovedOnly?: boolean;\n        exportWithMinApprovalsCount?: number;\n        exportStringsThatPassedWorkflow?: boolean;\n    }\n    interface BuildProjectFileTranslationResponse extends DownloadLink {\n        etag: string;\n    }\n    interface PreTranslationStatusAttributes {\n        languageIds: string[];\n        fileIds: number[];\n        branchIds: number[];\n        method: Method;\n        autoApproveOption: AutoApproveOption;\n        duplicateTranslations: boolean;\n        skipApprovedTranslations: boolean;\n        translateUntranslatedOnly: boolean;\n        translateWithPerfectMatchOnly: boolean;\n    }\n    type Method = 'tm' | 'mt' | 'ai';\n    type AutoApproveOption = 'all' | 'exceptAutoSubstituted' | 'perfectMatchOnly' | 'none';\n    type CharTransformation = 'asian' | 'european' | 'arabic' | 'cyrillic';\n    interface Build {\n        id: number;\n        projectId: number;\n        status: BuildStatus;\n        progress: number;\n        attributes: Attribute;\n        createdAt: string;\n        updatedAt: string;\n        finishedAt: string;\n    }\n    interface Attribute {\n        branchId: number;\n        directoryId: number;\n        targetLanguageIds: string[];\n        skipUntranslatedStrings: boolean;\n        skipUntranslatedFiles: boolean;\n        exportApprovedOnly: boolean;\n        exportWithMinApprovalsCount: number;\n        exportStringsThatPassedWorkflow: boolean;\n    }\n    interface BuildRequest {\n        branchId?: number;\n        targetLanguageIds?: string[];\n        skipUntranslatedStrings?: boolean;\n        skipUntranslatedFiles?: boolean;\n        exportApprovedOnly?: boolean;\n        exportWithMinApprovalsCount?: number;\n        exportStringsThatPassedWorkflow?: boolean;\n    }\n    interface PseudoBuildRequest {\n        pseudo: boolean;\n        branchId?: number;\n        prefix?: string;\n        suffix?: string;\n        lengthTransformation?: number;\n        charTransformation?: CharTransformation;\n    }\n    interface UploadTranslationRequest {\n        storageId: number;\n        fileId?: number;\n        importEqSuggestions?: boolean;\n        autoApproveImported?: boolean;\n        translateHidden?: boolean;\n        addToTm?: boolean;\n    }\n    interface UploadTranslationStringsRequest {\n        storageId: number;\n        branchId?: number;\n        importEqSuggestions?: boolean;\n        autoApproveImported?: boolean;\n        translateHidden?: boolean;\n        addToTm?: boolean;\n    }\n    interface UploadTranslationResponse {\n        projectId: number;\n        storageId: number;\n        languageId: string;\n        fileId: number;\n    }\n    interface UploadTranslationStringsResponse {\n        projectId: number;\n        storageId: number;\n        languageId: string;\n        branchId: number;\n    }\n    interface ExportProjectTranslationRequest {\n        targetLanguageId: string;\n        format?: string;\n        labelIds?: number[];\n        branchIds?: number[];\n        directoryIds?: number[];\n        fileIds?: number[];\n        skipUntranslatedStrings?: boolean;\n        skipUntranslatedFiles?: boolean;\n        exportApprovedOnly?: boolean;\n        exportWithMinApprovalsCount?: number;\n        exportStringsThatPassedWorkflow?: boolean;\n    }\n    interface ListProjectBuildsOptions extends PaginationOptions {\n        branchId?: number;\n    }\n    interface PreTranslationReport {\n        languages: TargetLanguage[];\n        preTranslateType: Method;\n    }\n    interface TargetLanguage {\n        id: string;\n        files: TargetLanguageFile[];\n        skipped: SkippedInfo;\n        skippedQaCheckCategories: ProjectsGroupsModel.CheckCategories;\n    }\n    interface TargetLanguageFile {\n        id: string;\n        statistics: TargetLanguageFileStatistics;\n    }\n    interface TargetLanguageFileStatistics {\n        phrases: number;\n        words: number;\n    }\n    interface SkippedInfo {\n        [key: string]: any;\n    }\n}\n```\n\n##### uploadStorage/index.d.ts\n\n```typescript\nimport { CrowdinApi, PaginationOptions, ResponseList, ResponseObject } from '../core';\nexport declare class UploadStorage extends CrowdinApi {\n    listStorages(options?: PaginationOptions): Promise<ResponseList<UploadStorageModel.Storage>>;\n    listStorages(limit?: number, offset?: number): Promise<ResponseList<UploadStorageModel.Storage>>;\n    addStorage(fileName: string, request: any, contentType?: string): Promise<ResponseObject<UploadStorageModel.Storage>>;\n    getStorage(storageId: number): Promise<ResponseObject<UploadStorageModel.Storage>>;\n    deleteStorage(storageId: number): Promise<void>;\n}\nexport declare namespace UploadStorageModel {\n    interface Storage {\n        id: number;\n        fileName: string;\n    }\n}\n```\n\n##### users/index.d.ts\n\n```typescript\nimport { CrowdinApi, Pagination, PaginationOptions, PatchRequest, ProjectRole, ProjectRoles, ResponseList, ResponseObject } from '../core';\nimport { ProjectsGroupsModel } from '../projectsGroups';\nimport { TeamsModel } from '../teams';\nexport declare class Users extends CrowdinApi {\n    listGroupManagers(groupId: number, options?: UsersModel.ListGroupManagersOptions): Promise<ResponseList<UsersModel.GroupManager>>;\n    updateGroupManagers(groupId: number, request: PatchRequest[]): Promise<ResponseList<UsersModel.GroupManager>>;\n    getGroupManager(groupId: number, userId: number): Promise<ResponseObject<UsersModel.GroupManager>>;\n    listProjectMembers(projectId: number, options?: UsersModel.ListProjectMembersOptions): Promise<ResponseList<UsersModel.ProjectMember | UsersModel.EnterpriseProjectMember>>;\n    listProjectMembers(projectId: number, search?: string, role?: UsersModel.Role, languageId?: string, limit?: number, offset?: number): Promise<ResponseList<UsersModel.ProjectMember | UsersModel.EnterpriseProjectMember>>;\n    addProjectMember(projectId: number, request: UsersModel.AddProjectMemberRequest): Promise<UsersModel.AddProjectMemberResponse>;\n    getProjectMemberPermissions(projectId: number, memberId: number): Promise<ResponseObject<UsersModel.ProjectMember | UsersModel.EnterpriseProjectMember>>;\n    replaceProjectMemberPermissions(projectId: number, memberId: number, request?: UsersModel.ReplaceProjectMemberRequest): Promise<ResponseObject<UsersModel.ProjectMember | UsersModel.EnterpriseProjectMember>>;\n    deleteMemberFromProject(projectId: number, memberId: number): Promise<void>;\n    listUsers(options?: UsersModel.ListUsersOptions): Promise<ResponseList<UsersModel.User>>;\n    listUsers(status?: UsersModel.Status, search?: string, twoFactor?: UsersModel.TwoFactor, limit?: number, offset?: number): Promise<ResponseList<UsersModel.User>>;\n    inviteUser(request: UsersModel.InviteUserRequest): Promise<ResponseObject<UsersModel.User>>;\n    getUserInfo(userId: number): Promise<ResponseObject<UsersModel.User>>;\n    deleteUser(userId: number): Promise<void>;\n    editUser(userId: number, request: PatchRequest[]): Promise<ResponseObject<UsersModel.User>>;\n    getAuthenticatedUser(): Promise<ResponseObject<UsersModel.User>>;\n    editAuthenticatedUser(request: PatchRequest[]): Promise<ResponseObject<UsersModel.User>>;\n    listUserProjectPermissions(userId: number, options?: PaginationOptions): Promise<ResponseList<UsersModel.ProjectPermissions>>;\n    editUserProjectPermissions(userId: number, request: PatchRequest[]): Promise<ResponseList<UsersModel.ProjectPermissions>>;\n    listUserProjectContributions(userId: number, options?: PaginationOptions): Promise<ResponseList<UsersModel.ProjectPermissions>>;\n}\nexport declare namespace UsersModel {\n    interface ListGroupManagersOptions extends PaginationOptions {\n        teamIds?: number[];\n        orderBy?: string;\n    }\n    interface ListProjectMembersOptions extends PaginationOptions {\n        search?: string;\n        role?: Role;\n        languageId?: string;\n        workflowStepId?: number;\n        orderBy?: string;\n    }\n    interface ListUsersOptions extends PaginationOptions {\n        status?: Status;\n        search?: string;\n        twoFactor?: TwoFactor;\n        orderBy?: string;\n        organizationRoles?: OrganizationRoles[];\n        teamId?: number;\n        projectIds?: string;\n        projectRoles?: ProjectRoles[];\n        languageIds?: string;\n        groupIds?: string;\n        lastSeenFrom?: string;\n        lastSeenTo?: string;\n    }\n    interface InviteUserRequest {\n        email: string;\n        firstName?: string;\n        lastName?: string;\n        timezone?: string;\n        adminAccess?: boolean;\n    }\n    interface User {\n        id: number;\n        username: string;\n        email: string;\n        firstName: string;\n        lastName: string;\n        status: Status;\n        avatarUrl: string;\n        fields: Record<string, any>;\n        createdAt: string;\n        lastSeen: string;\n        twoFactor: TwoFactor;\n        isAdmin: boolean;\n        timezone: string;\n        emailVerified: string;\n    }\n    type Status = 'active' | 'pending' | 'blocked';\n    type TwoFactor = 'enabled' | 'disabled';\n    type OrganizationRoles = 'admin' | 'manager' | 'vendor' | 'client';\n    interface GroupManager {\n        id: number;\n        user: User;\n        teams: TeamsModel.Team[];\n    }\n    interface ProjectMember {\n        id: number;\n        username: string;\n        fullName: string;\n        role: Role;\n        permissions: Permissions;\n        avatarUrl: string;\n        joinedAt: string;\n        timezone: string;\n        roles: ProjectRole[];\n    }\n    interface EnterpriseProjectMember {\n        id: number;\n        username: string;\n        firstName: string;\n        lastName: string;\n        isManager: boolean;\n        isDeveloperr: boolean;\n        managerOfGroup: Group;\n        accessToAllWorkflowSteps: boolean;\n        permissions: Permissions;\n        givenAccessAt: string;\n        roles: ProjectRole[];\n    }\n    interface Group {\n        id: number;\n        name: string;\n    }\n    type Role = 'all' | 'owner' | 'manager' | 'proofreader' | 'translator' | 'blocked';\n    type LanguageRole = 'proofreader' | 'translator' | 'denied';\n    interface AddProjectMemberRequest {\n        userIds?: number[];\n        usernames?: string[];\n        emails?: string[];\n        managerAccess?: boolean;\n        roles?: ProjectRole[];\n        developerAccess?: boolean;\n        accessToAllWorkflowSteps?: boolean;\n        permissions?: Permissions;\n    }\n    interface AddProjectMemberResponse {\n        skipped: ResponseObject<ProjectMember | EnterpriseProjectMember>[];\n        added: ResponseObject<ProjectMember | EnterpriseProjectMember>[];\n        pagination: Pagination;\n    }\n    interface ReplaceProjectMemberRequest {\n        managerAccess?: boolean;\n        developerAccess?: boolean;\n        roles?: ProjectRole[];\n        accessToAllWorkflowSteps?: boolean;\n        permissions?: Permissions;\n    }\n    interface ProjectPermissions {\n        id: number;\n        roles: ProjectRole[];\n        project: ProjectsGroupsModel.Project | ProjectsGroupsModel.ProjectSettings;\n        teams: TeamsModel.Team[];\n    }\n    interface Contributions {\n        id: number;\n        translated: Contribution;\n        approved: Contribution;\n        voted: Contribution;\n        commented: Contribution;\n        project: ProjectsGroupsModel.Project | ProjectsGroupsModel.ProjectSettings;\n    }\n    interface Contribution {\n        strings: number;\n        words?: number;\n    }\n    interface Permissions {\n        [lang: string]: string | {\n            workflowStepIds: number[] | 'all';\n        };\n    }\n}\n```\n\n##### vendors/index.d.ts\n\n```typescript\nimport { CrowdinApi, PaginationOptions, ResponseList } from '../core';\nexport declare class Vendors extends CrowdinApi {\n    listVendors(options?: PaginationOptions): Promise<ResponseList<VendorsModel.Vendor>>;\n    listVendors(limit?: number, offset?: number): Promise<ResponseList<VendorsModel.Vendor>>;\n}\nexport declare namespace VendorsModel {\n    interface Vendor {\n        id: number;\n        name: string;\n        description: string;\n        status: 'pending' | 'confirmed' | 'rejected';\n        webUrl: string;\n    }\n}\n```\n\n##### webhooks/index.d.ts\n\n```typescript\nimport { CrowdinApi, PaginationOptions, PatchRequest, ResponseList, ResponseObject } from '../core';\nexport declare class Webhooks extends CrowdinApi {\n    listWebhooks(projectId: number, options?: PaginationOptions): Promise<ResponseList<WebhooksModel.Webhook>>;\n    listWebhooks(projectId: number, limit?: number, offset?: number): Promise<ResponseList<WebhooksModel.Webhook>>;\n    addWebhook(projectId: number, request: WebhooksModel.AddWebhookRequest): Promise<ResponseObject<WebhooksModel.Webhook>>;\n    getWebhook(projectId: number, webhookId: number): Promise<ResponseObject<WebhooksModel.Webhook>>;\n    deleteWebhook(projectId: number, webhookId: number): Promise<void>;\n    editWebhook(projectId: number, webhookId: number, request: PatchRequest[]): Promise<ResponseObject<WebhooksModel.Webhook>>;\n}\nexport declare namespace WebhooksModel {\n    interface Webhook {\n        id: number;\n        projectId: number;\n        name: string;\n        url: string;\n        events: Event[];\n        headers: Record<string, string>;\n        payload: Record<string, any>;\n        isActive: boolean;\n        batchingEnabled: boolean;\n        requestType: RequestType;\n        contentType: ContentType;\n        createdAt: string;\n        updatedAt: string;\n    }\n    interface AddWebhookRequest {\n        name: string;\n        url: string;\n        events: Event[];\n        requestType: RequestType;\n        isActive?: boolean;\n        batchingEnabled?: boolean;\n        contentType?: ContentType;\n        headers?: Record<string, string>;\n        payload?: Record<string, any>;\n    }\n    type ContentType = 'multipart/form-data' | 'application/json' | 'application/x-www-form-urlencoded';\n    type Event = 'file.added' | 'file.updated' | 'file.reverted' | 'file.deleted' | 'file.translated' | 'file.approved' | 'project.translated' | 'project.approved' | 'project.built' | 'translation.updated' | 'string.added' | 'string.updated' | 'string.deleted' | 'stringComment.created' | 'stringComment.updated' | 'stringComment.deleted' | 'stringComment.restored' | 'suggestion.added' | 'suggestion.updated' | 'suggestion.deleted' | 'suggestion.approved' | 'suggestion.disapproved' | 'task.added' | 'task.statusChanged' | 'task.deleted';\n    type RequestType = 'POST' | 'GET';\n}\n```\n\n##### workflows/index.d.ts\n\n```typescript\nimport { CrowdinApi, PaginationOptions, PatchRequest, ResponseList, ResponseObject } from '../core';\nimport { SourceStringsModel } from '../sourceStrings';\nexport declare class Workflows extends CrowdinApi {\n    listWorkflowSteps(projectId: number, options?: PaginationOptions): Promise<ResponseList<WorkflowModel.WorkflowStep>>;\n    listWorkflowSteps(projectId: number, limit?: number, offset?: number): Promise<ResponseList<WorkflowModel.WorkflowStep>>;\n    getWorkflowStep(projectId: number, stepId: number): Promise<ResponseObject<WorkflowModel.WorkflowStep>>;\n    listStringsOnTheWorkflowStep(projectId: number, stepId: number, options?: WorkflowModel.ListStringsOntheWorkflowStepOptions): Promise<ResponseList<SourceStringsModel.String>>;\n    listWorkflowTemplates(options?: WorkflowModel.ListWorkflowTemplatesOptions): Promise<ResponseList<WorkflowModel.Workflow>>;\n    listWorkflowTemplates(groupId?: number, limit?: number, offset?: number): Promise<ResponseList<WorkflowModel.Workflow>>;\n    getWorkflowTemplateInfo(templateId: number): Promise<ResponseObject<WorkflowModel.Workflow>>;\n    updateWorkflowStepStringStatus(projectId: number, stepId: number, languageId: string, request: PatchRequest[]): Promise<ResponseList<WorkflowModel.WorkflowStepStringStatus>>;\n    getWorkflowStepStringStatus(projectId: number, stepId: number, languageId: string, options?: PaginationOptions): Promise<ResponseList<WorkflowModel.WorkflowStepStringStatus>>;\n}\nexport declare namespace WorkflowModel {\n    interface WorkflowStep {\n        id: number;\n        title: string;\n        type: string;\n        languages: string[];\n        config: {\n            assignees: {\n                [language: string]: number[];\n            };\n        };\n    }\n    interface ListWorkflowTemplatesOptions extends PaginationOptions {\n        groupId?: number;\n    }\n    interface ListStringsOntheWorkflowStepOptions extends PaginationOptions {\n        languageIds?: string;\n        orderBy?: string;\n        status?: 'todo' | 'done' | 'pending' | 'incomplete' | 'need_review';\n    }\n    interface Workflow {\n        id: number;\n        title: string;\n        description: string;\n        groupId: number;\n        isDefault: boolean;\n        webUrl: string;\n        steps: {\n            id: number;\n            languages: string[];\n            assignees: number[];\n            vendorId: number;\n            config: {\n                minRelevant: number;\n                autoSubstitution: boolean;\n            };\n            mtId: number;\n        }[];\n    }\n    interface WorkflowStepStringStatus {\n        stringId: number;\n        languageId: string;\n        stepId: number;\n        status: string;\n        output: string;\n    }\n}\n```\n\n<!-- CROWDIN_API_CLIENT_TYPES_END -->\n\n### App Metadata Storage\n\n#### Overview\n\nApp Metadata Storage is a built-in key-value storage system provided by the Crowdin Apps SDK. It allows your app to persist data across sessions without needing external databases or storage services.\n\n**Available Methods:**\n- `crowdinApp.saveMetadata(key, data, crowdinId)` - Save or update metadata (recommended)\n- `crowdinApp.getMetadata(key)` - Retrieve metadata\n- `crowdinApp.deleteMetadata(key)` - Delete metadata\n\n**Alternative approach:**\n- `crowdinModule.metadataStore.saveMetadata(key, data, crowdinId)`\n- `crowdinModule.metadataStore.getMetadata(key)`\n- `crowdinModule.metadataStore.deleteMetadata(key)`\n\n#### Official Documentation\n\n**üìö Complete Documentation:** Refer to Crowdin Apps SDK documentation for metadata storage\n\n**‚ö†Ô∏è CRITICAL**: Metadata is stored at the organization level. Always include `organizationId` in your keys to properly scope data.\n\n#### Common Examples\n\n**Save Metadata:**\n```typescript\napp.post('/api/save-data', async (req: Request, res: Response) => {\n    try {\n        const jwt = req.query.jwt as string;\n        const { data } = req.body;\n\n        if (!jwt) {\n            return res.status(400).json({ success: false, error: 'JWT token is required' });\n        }\n        \n        if (!crowdinApp.establishCrowdinConnection) {\n            return res.status(500).json({ success: false, error: 'Crowdin connection method not available' });\n        }\n\n        const connection = await crowdinApp.establishCrowdinConnection(jwt, undefined);\n\n        if (!connection.client) {\n            return res.status(500).json({ success: false, error: 'Crowdin API client not available' });\n        }\n\n        const userId = connection.context.jwtPayload.context.user_id;\n        const organizationId = connection.context.jwtPayload.context.organization_id;\n        \n        // Create a namespaced key\n        const key = `org_${organizationId}_user_${userId}_preferences`;\n        \n        // Save data to metadata storage\n        await crowdinApp.saveMetadata(key, data, connection.context.crowdinId);\n        res.json({ success: true, message: 'Data saved successfully' });\n    } catch (error) {\n        console.error('Save error:', error);\n        res.status(500).json({ success: false, error: 'Failed to save data' });\n    }\n});\n```\n\n**Get Metadata:**\n```typescript\napp.get('/api/get-data', async (req: Request, res: Response) => {\n    try {\n        const jwt = req.query.jwt as string;\n        \n        if (!jwt) {\n            return res.status(400).json({ success: false, error: 'JWT token is required' });\n        }\n        \n        if (!crowdinApp.establishCrowdinConnection) {\n            return res.status(500).json({ success: false, error: 'Crowdin connection method not available' });\n        }\n\n        const connection = await crowdinApp.establishCrowdinConnection(jwt, undefined);\n\n        if (!connection.client) {\n            return res.status(500).json({ success: false, error: 'Crowdin API client not available' });\n        }\n\n        const userId = connection.context.jwtPayload.context.user_id;\n        const organizationId = connection.context.jwtPayload.context.organization_id;\n        \n        const key = `org_${organizationId}_user_${userId}_preferences`;\n        \n        // Retrieve data from metadata storage\n        const data = await crowdinApp.getMetadata(key);\n            \n        // Handle case when no data exists\n        if (!data) {\n            return res.json({ \n                success: true, \n                data: null, \n                message: 'No data found' \n            });\n        }\n        \n        res.json({ success: true, data });\n    } catch (error) {\n        console.error('Get error:', error);\n        res.status(500).json({ success: false, error: 'Failed to retrieve data' });\n    }\n});\n```\n\n**Delete Metadata:**\n```typescript\napp.delete('/api/delete-data', async (req: Request, res: Response) => {\n    try {\n        const jwt = req.query.jwt as string;\n        \n        if (!jwt) {\n            return res.status(400).json({ success: false, error: 'JWT token is required' });\n        }\n        \n        if (!crowdinApp.establishCrowdinConnection) {\n            return res.status(500).json({ success: false, error: 'Crowdin connection method not available' });\n        }\n\n        const connection = await crowdinApp.establishCrowdinConnection(jwt, undefined);\n\n        if (!connection.client) {\n            return res.status(500).json({ success: false, error: 'Crowdin API client not available' });\n        }\n\n        const userId = connection.context.jwtPayload.context.user_id;\n        const organizationId = connection.context.jwtPayload.context.organization_id;\n        \n        const key = `org_${organizationId}_user_${userId}_preferences`;\n        \n        // Delete data from metadata storage\n        await crowdinApp.deleteMetadata(key);\n        res.json({ success: true, message: 'Data deleted successfully' });\n    } catch (error) {\n        console.error('Delete error:', error);\n        res.status(500).json({ success: false, error: 'Failed to delete data' });\n    }\n});\n```\n\n**Get All Metadata:**\n```typescript\napp.get('/api/all-metadata', async (req: Request, res: Response) => {\n    try {\n        const jwt = req.query.jwt as string;\n        \n        if (!jwt) {\n            return res.status(400).json({ success: false, error: 'JWT token is required' });\n        }\n        \n        if (!crowdinApp.establishCrowdinConnection) {\n            return res.status(500).json({ success: false, error: 'Crowdin connection method not available' });\n        }\n\n        const connection = await crowdinApp.establishCrowdinConnection(jwt, undefined);\n\n        if (!connection.client) {\n            return res.status(500).json({ success: false, error: 'Crowdin API client not available' });\n        }\n\n        // Retrieve all metadata records from storage\n        const allMetadata = await crowdinApp.storage.getAllMetadata();\n        \n        // allMetadata structure:\n        // [\n        //   {\n        //     id: \"org_123_user_456_preferences\",  // key\n        //     data: \"{\"theme\":\"dark\",\"lang\":\"en\"}\", // JSON stringified value\n        //     crowdin_id: \"domain\"     // crowdin identifier (from connection.context.crowdinId during save)\n        //   },\n        //   ...\n        // ]\n        \n        // Parse and format data\n        const formattedData = allMetadata.map(record => ({\n            key: record.id,\n            value: JSON.parse(record.data || '{}'),\n            crowdinId: record.crowdin_id\n        }));\n        \n        res.json({ success: true, metadata: formattedData, count: formattedData.length });\n    } catch (error) {\n        console.error('Error retrieving all metadata:', error);\n        res.status(500).json({ success: false, error: 'Failed to retrieve metadata' });\n    }\n});\n```\n\n**Store Complex Objects:**\n```typescript\n// Save complex user preferences\nconst preferences = {\n    theme: 'dark',\n    language: 'en',\n    notifications: {\n        email: true,\n        push: false,\n        digest: 'weekly'\n    },\n    lastUpdated: new Date().toISOString(),\n    settings: {\n        autoSave: true,\n        confirmActions: true\n    }\n};\n\nconst key = `org_${organizationId}_user_${userId}_preferences`;\nawait crowdinApp.saveMetadata(key, preferences, connection.context.crowdinId);\n\n// Retrieve and update\nconst currentPrefs = await crowdinApp.getMetadata(key) || {};\nconst updatedPrefs = {\n    ...currentPrefs,\n    theme: 'light',\n    lastUpdated: new Date().toISOString()\n};\nawait crowdinApp.saveMetadata(key, updatedPrefs, connection.context.crowdinId);\n```\n\n#### Best Practices\n\n1. **Always use namespaced keys**\n   ```typescript\n   // ‚úÖ CORRECT - includes organization and entity identifiers\n   const key = `org_${organizationId}_user_${userId}_preferences`;\n   const key = `org_${organizationId}_project_${projectId}_cache`;\n   \n   // ‚ùå WRONG - no organization scope, may cause conflicts\n   const key = `user_preferences`;\n   const key = `${userId}_data`;\n   ```\n\n2. **Handle missing data gracefully**\n   ```typescript\n   // ‚úÖ CORRECT - provide defaults for missing data\n   const data = await crowdinApp.getMetadata(key) || { \n       theme: 'auto', \n       language: 'en' \n   };\n   \n   // ‚úÖ CORRECT - check for null/undefined\n   const data = await crowdinApp.getMetadata(key);\n   if (!data) {\n       return defaultSettings;\n   }\n   \n   // ‚ùå WRONG - may cause errors if data is null\n   const theme = data.theme; // Error if data is null\n   ```\n\n3. **Always use the correct identifier for the third parameter**\n   ```typescript\n   // ‚úÖ CORRECT - when connection object is available\n   await crowdinApp.saveMetadata(key, data, connection.context.crowdinId);\n   \n   // ‚úÖ CORRECT - when using webhookContext (no connection object, crowdinApp not available)\n   await crowdinModule.metadataStore.saveMetadata(key, data, `${webhookContext.domain || webhookContext.organizationId}`);\n   \n   // ‚ùå WRONG - don't use organizationId directly\n   await crowdinApp.saveMetadata(key, data, String(organizationId));\n   ```\n\n4. **Use descriptive key patterns**\n   ```typescript\n   // ‚úÖ CORRECT - clear, hierarchical structure\n   `org_${orgId}_user_${userId}_preferences`\n   `org_${orgId}_project_${projectId}_settings`\n   `org_${orgId}_cache_${cacheType}_${identifier}`\n   \n   // ‚ùå WRONG - unclear, hard to maintain\n   `data_${id}`\n   `temp_storage`\n   ```\n\n5. **Handle errors properly**\n   ```typescript\n   // ‚úÖ CORRECT - comprehensive error handling\n   try {\n       await crowdinApp.saveMetadata(key, data, connection.context.crowdinId);\n       return { success: true };\n   } catch (error: any) {\n       console.error('Metadata save failed:', error);\n       return { \n           success: false, \n           error: 'Failed to save data'\n       };\n   }\n   ```\n\n7. **Store only JSON-serializable data**\n   ```typescript\n   // ‚úÖ CORRECT - simple JSON-serializable objects\n   const data = {\n       name: 'John',\n       age: 30,\n       preferences: ['option1', 'option2'],\n       metadata: { key: 'value' }\n   };\n   \n   // ‚ùå WRONG - functions, dates, circular references\n   const data = {\n       name: 'John',\n       callback: () => {},           // Functions don't serialize\n       created: new Date(),           // Dates become strings\n       circular: data                 // Circular reference\n   };\n   \n   // ‚úÖ CORRECT - convert dates to ISO strings\n   const data = {\n       name: 'John',\n       created: new Date().toISOString()\n   };\n   ```\n\n8. **NEVER use KVStore for configurations - use metadata storage instead**\n   ```typescript\n   // ‚úÖ CORRECT - use metadata storage for ALL configuration storage\n   const config = {\n       apiKey: userApiKey,\n       apiEndpoint: 'https://api.example.com',\n       languageMapping: { 'en': 'en-US' }\n   };\n   await crowdinApp.saveMetadata(\n       `config_org_${organizationId}`, \n       config, \n       connection.context.crowdinId\n   );\n   \n   // ‚úÖ CORRECT - read configuration from metadata storage\n   const config = await crowdinApp.getMetadata(`config_org_${organizationId}`) || {};\n   \n   // ‚ùå WRONG - using KVStore for configuration storage\n   const config = {\n       apiKey: userApiKey,\n       apiEndpoint: 'https://api.example.com',\n       languageMapping: { 'en': 'en-US' }\n   };\n   await env.KVStore.put(\n       `config_org_${organizationId}`, \n       JSON.stringify(config)\n   );\n   \n   // ‚ùå WRONG - reading configuration from KVStore\n   const configData = await env.KVStore.get(`config_org_${organizationId}`);\n   const config = JSON.parse(configData || '{}');\n   ```\n\n9. **Use crowdinApp.saveMetadata or crowdinModule.metadataStore.saveMetadata - both implement upsert**\n   ```typescript\n   // ‚úÖ CORRECT - implements upsert (insert or update)\n   await crowdinApp.saveMetadata(\n       key, \n       data, \n       connection.context.crowdinId\n   );\n   \n   // ‚úÖ CORRECT - also implements upsert (insert or update)\n   await crowdinModule.metadataStore.saveMetadata(\n       key, \n       data, \n       connection.context.crowdinId\n   );\n   \n   // ‚ùå WRONG - only insert, NOT upsert (will fail if key already exists)\n   await crowdinApp.storage.saveMetadata(\n       key, \n       data, \n       connection.context.crowdinId\n   );\n   ```\n\n### Cron Scheduling\n\n#### Overview\n\nCron Scheduling allows your app to execute background tasks at specified time intervals.\n\n#### Official Documentation\n\n**üìö Complete Documentation:** Refer to Crowdin Apps SDK documentation for cron scheduling\n\n**‚ö†Ô∏è CRITICAL**: Only specific cron intervals are supported. Using unsupported intervals will result in an error.\n\n#### Supported Intervals\n\nThe following cron expressions are supported:\n\n| Cron Expression | Description | Frequency |\n|----------------|-------------|-----------|\n| `0 * * * *` | Every hour | Runs at minute 0 of every hour |\n| `0 */3 * * *` | Every 3 hours | Runs at minute 0 every 3 hours |\n| `0 */6 * * *` | Every 6 hours | Runs at minute 0 every 6 hours |\n| `0 */12 * * *` | Every 12 hours | Runs at minute 0 every 12 hours |\n| `0 0 * * *` | Daily | Runs at midnight (00:00) every day |\n| `0 0 * * SUN` | Weekly | Runs at midnight (00:00) every Sunday |\n| `0 0 1 * *` | Monthly | Runs at midnight (00:00) on the 1st of each month |\n\n#### Common Examples\n\n**Simple Hourly Task:**\n```typescript\n// In worker/app.ts, after initializing crowdinApp\nconst crowdinApp = crowdinModule.addCrowdinEndpoints(app, configuration) as CrowdinAppUtilities;\n\n// Register cron job - runs every hour\ncrowdinApp.cron.schedule('0 * * * *', async () => {\n    try {\n        console.log('Hourly task started at', new Date().toISOString());\n        \n        // Perform your scheduled task\n        // Example: Check status, update cache, etc.\n        \n        console.log('Task completed');\n    } catch (error) {\n        console.error('Cron job error:', error);\n    }\n});\n```\n\n**Multiple Tasks for Same Schedule:**\n```typescript\n// In worker/app.ts, after initializing crowdinApp\nconst crowdinApp = crowdinModule.addCrowdinEndpoints(app, configuration) as CrowdinAppUtilities;\n\n// Both tasks will run daily at midnight\ncrowdinApp.cron.schedule('0 0 * * *', async () => {\n    try {\n        console.log('Daily cleanup started');\n        // Cleanup old data\n    } catch (error) {\n        console.error('Cleanup error:', error);\n    }\n});\n\ncrowdinApp.cron.schedule('0 0 * * *', async () => {\n    try {\n        console.log('Daily report started');\n        // Generate reports\n    } catch (error) {\n        console.error('Report error:', error);\n    }\n});\n```\n\n**Using Crowdin API Client in Cron Jobs:**\n```typescript\n// In worker/app.ts, after initializing crowdinApp\nconst crowdinApp = crowdinModule.addCrowdinEndpoints(app, configuration) as CrowdinAppUtilities;\n\n// Register cron job that processes data for multiple organizations\ncrowdinApp.cron.schedule('0 0 * * *', async () => {\n    try {\n        console.log('Daily sync started');\n        \n        // Get all metadata records\n        const allMetadata = await crowdinApp.storage.getAllMetadata();\n        \n        if (!allMetadata || allMetadata.length === 0) {\n            console.log('No metadata found, skipping sync');\n            return;\n        }\n        \n        // Filter metadata by pattern using regex (e.g., find all organization configs)\n        const configPattern = /^org_(\\d+)_config$/;\n        const orgConfigs = allMetadata.filter(record => \n            configPattern.test(record.id)\n        );\n        \n        console.log(`Found ${orgConfigs.length} organization configs to process`);\n        \n        // Process each organization separately\n        for (const configRecord of orgConfigs) {\n            try {\n                const match = configRecord.id.match(configPattern);\n                const organizationId = match?.[1];\n                const crowdinId = configRecord.crowdin_id; // domain or organizationId\n                const configData = JSON.parse(configRecord.data || '{}');\n                \n                console.log(`Processing organization ${organizationId}`);\n                \n                // Create individual Crowdin API client for this organization\n                const encryptedData = crowdinApp.encryptCrowdinConnection({\n                    crowdinId,\n                    extra: {}, // Always pass empty object\n                });\n                \n                const { client } = await crowdinApp.dencryptCrowdinConnection(encryptedData, true);\n                \n                // Use client to make API calls for this specific organization\n                const projects = await client.projectsGroupsApi.withFetchAll().listProjects();\n                console.log(`Organization ${organizationId}: Found ${projects.data.length} projects`);\n                \n                // Process organization-specific configuration\n                if (configData.autoSync) {\n                    console.log(`Organization ${organizationId}: Auto-sync enabled, processing...`);\n                    // Perform sync operations\n                }\n                \n            } catch (error) {\n                console.error(`Error processing organization ${organizationId}:`, error);\n                // Continue with next organization\n            }\n        }\n        \n        console.log('Daily sync completed');\n    } catch (error) {\n        console.error('Cron job error:', error);\n    }\n});\n```\n\n#### Best Practices\n\n1. **Use appropriate intervals for your task**\n   ```typescript\n   // ‚úÖ CORRECT - frequent checks for time-sensitive tasks\n   crowdinApp.cron.schedule('0 * * * *', async () => {\n       // Hourly notification checks\n   });\n   \n   // ‚úÖ CORRECT - less frequent for resource-intensive tasks\n   crowdinApp.cron.schedule('0 0 * * *', async () => {\n       // Daily cleanup or report generation\n   });\n   \n   // ‚ùå WRONG - using unsupported interval\n   crowdinApp.cron.schedule('*/5 * * * *', async () => {\n       // Every 5 minutes - NOT SUPPORTED\n   });\n   ```\n\n2. **Handle errors gracefully**\n   ```typescript\n   // ‚úÖ CORRECT - catch and log errors\n   crowdinApp.cron.schedule('0 * * * *', async () => {\n       try {\n           await performTask();\n       } catch (error) {\n           console.error('Cron job failed:', error);\n           // Log error but don't throw - let job complete\n       }\n   });\n   \n   // ‚ùå WRONG - unhandled errors\n   crowdinApp.cron.schedule('0 * * * *', async () => {\n       await performTask(); // May crash if it throws\n   });\n   ```\n\n3. **Keep cron jobs lightweight**\n   ```typescript\n   // ‚úÖ CORRECT - efficient processing\n   crowdinApp.cron.schedule('0 0 * * *', async () => {\n       const startTime = Date.now();\n       console.log('Task started');\n       \n       // Perform lightweight operations\n       await quickCleanup();\n       \n       console.log(`Completed in ${Date.now() - startTime}ms`);\n   });\n   \n   // ‚ùå WRONG - heavy processing that may timeout\n   crowdinApp.cron.schedule('0 * * * *', async () => {\n       // Processing millions of records - may timeout\n       const allData = await fetchAllData();\n       await processAll(allData);\n   });\n   ```\n\n4. **Always await async operations**\n   ```typescript\n   // ‚úÖ CORRECT - await all async operations\n   crowdinApp.cron.schedule('0 * * * *', async () => {\n       await saveData();\n       await processQueue();\n       console.log('All tasks completed');\n   });\n   \n   // ‚úÖ CORRECT - setTimeout with proper promise wrapper\n   crowdinApp.cron.schedule('0 * * * *', async () => {\n       await new Promise((resolve) => {\n           setTimeout(async () => {\n               await processData();\n               resolve();\n           }, 1000);\n       });\n   });\n   \n   // ‚ùå WRONG - promise without await (will not complete)\n   crowdinApp.cron.schedule('0 * * * *', async () => {\n       saveData(); // This will NOT complete before cron job ends\n       console.log('Done'); // Logs immediately, but saveData is not finished\n   });\n   \n   // ‚ùå WRONG - setTimeout without proper promise wrapper\n   crowdinApp.cron.schedule('0 * * * *', async () => {\n       setTimeout(async () => {\n           await processData(); // This will NOT execute\n       }, 1000);\n   });\n   ```\n\n5. **Log execution for debugging**\n   ```typescript\n   // ‚úÖ CORRECT - comprehensive logging\n   crowdinApp.cron.schedule('0 */6 * * *', async () => {\n       const startTime = Date.now();\n       console.log(`Cron job started at ${new Date().toISOString()}`);\n       \n       try {\n           await performTask();\n           console.log(`Completed in ${Date.now() - startTime}ms`);\n       } catch (error) {\n           console.error(`Failed after ${Date.now() - startTime}ms:`, error);\n       }\n   });\n   ```\n\n### Webhooks\n\n#### Overview\n\nWebhooks allow your app to subscribe to events that occur in Crowdin projects or organizations. When a subscribed event happens, Crowdin automatically sends the event data to your app's callback function.\n\n#### Official Documentation\n\n**üìö Complete Documentation:** [Crowdin Webhooks](https://crowdin.github.io/app-project-module/tools/webhook/)\n\n**üìö Available Events:** [Webhook Events List](https://support.crowdin.com/developer/webhooks/)\n\n**‚ö†Ô∏è CRITICAL**: Only use event names from the official events list. Invalid event names will be ignored.\n\n#### Configuration\n\nConfigure webhooks in your app configuration in `worker/app.ts`:\n\n```typescript\nconst configuration: ClientConfig = {\n    // ... other configuration ...\n    \n    // Webhook subscriptions\n    webhooks: [\n        {\n            // List of events to subscribe to\n            events: ['file.added', 'file.updated', 'file.deleted'],\n            \n            // Callback function that handles events\n            callback({ client, events, webhookContext }) {\n                console.log('Received events:', events);\n                console.log('Organization:', webhookContext.organizationId);\n                console.log('User:', webhookContext.userId);\n                \n                // Process events here\n                events.forEach(event => {\n                    console.log('Event:', event.event, 'Project:', event.file.project.id);\n                });\n            },\n            \n            deferResponse: true\n        },\n        {\n            // You can have multiple webhook subscriptions\n            events: ['suggestion.updated', 'string.added'],\n            callback({ client, events, webhookContext }) {\n                // Handle translation events\n            },\n            \n            deferResponse: true\n        }\n    ]\n};\n```\n\n#### Common Examples\n\n**File Events:**\n```typescript\nwebhooks: [\n    {\n        events: ['file.added', 'file.updated', 'file.deleted', 'file.reverted'],\n        async callback({ client, events, webhookContext }) {\n            for (const event of events) {\n                console.log(`File ${event.event} in project ${event.file.project.id}`);\n                console.log('File details:', event.file);\n                \n                // Example: Get project details when file is added\n                if (event.event === 'file.added') {\n                    const project = await client.projectsGroupsApi.getProject(event.file.project.id);\n                    console.log('Project name:', project.data.name);\n                }\n            }\n        },\n        deferResponse: true\n    }\n]\n```\n\n#### Callback Parameters\n\nThe callback function receives an object with three properties:\n\n```typescript\ninterface WebhookCallback {\n    /**\n     * Crowdin API client - use to make API calls\n     * Same client as connection.client in endpoints\n     */\n    client: CrowdinApi;\n    \n    /**\n     * Array of webhook event objects\n     * Multiple events may be batched together\n     */\n    events: WebhookEvent[];\n    \n    /**\n     * Context information about the webhook\n     */\n    webhookContext: {\n        /** Crowdin domain (e.g., \"crowdin.com\") */\n        domain: string;\n        \n        /** Organization ID where event occurred */\n        organizationId: number;\n        \n        /** User ID who installed the application */\n        userId: number;\n        \n        /** Agent ID (if authenticationType is \"crowdin_agent\") */\n        agentId?: number;\n    };\n}\n```\n\n#### Common Event Types\n\n**Project Events:**\n- `project.created` - New project added\n- `project.deleted` - Project deleted\n- `project.translated` - Project fully translated\n- `project.approved` - Project reviewed\n- `project.built` - Project built\n\n**Group Events:**\n- `group.created` - New group added\n- `group.deleted` - Group deleted\n\n**File Events:**\n- `file.added` - New file added to project\n- `file.updated` - File updated\n- `file.deleted` - File deleted from project\n- `file.reverted` - File reverted to previous version\n- `file.translated` - File fully translated\n- `file.approved` - File reviewed\n\n**String Events:**\n- `string.added` - New source string added\n- `string.updated` - Source string updated\n- `string.deleted` - Source string deleted\n\n**Translation Events:**\n- `suggestion.added` - String translation added\n- `suggestion.updated` - String translation updated\n- `suggestion.deleted` - String translation deleted\n- `suggestion.approved` - String translation approved\n- `suggestion.disapproved` - String translation disapproved\n\n**Comment Events:**\n- `stringComment.created` - String comment added\n- `stringComment.updated` - String comment updated\n- `stringComment.deleted` - String comment deleted\n- `stringComment.restored` - String comment restored\n\n**Task Events:**\n- `task.added` - New task added\n- `task.statusChanged` - Task status changed\n- `task.updated` - Task updated\n- `task.deleted` - Task deleted\n\n#### Best Practices\n\n1. **Always set deferResponse to true**\n   ```typescript\n   // ‚úÖ CORRECT - deferResponse is set to true\n   webhooks: [\n       {\n           events: ['file.added'],\n           callback({ client, events, webhookContext }) {\n               console.log('Processing events');\n           },\n           deferResponse: true  // REQUIRED!\n       }\n   ]\n   \n   // ‚ùå WRONG - missing deferResponse\n   webhooks: [\n       {\n           events: ['file.added'],\n           callback({ client, events, webhookContext }) {\n               console.log('Processing events');\n           }\n           // Missing deferResponse: true - this will cause issues!\n       }\n   ]\n   ```\n\n2. **Handle multiple events in batch**\n   ```typescript\n   // ‚úÖ CORRECT - process all events\n   callback({ client, events, webhookContext }) {\n       events.forEach(event => {\n           console.log('Processing event:', event.event);\n       });\n   }\n   \n   // ‚ùå WRONG - only processes first event\n   callback({ client, events, webhookContext }) {\n       const event = events[0];\n       console.log('Processing event:', event.event);\n   }\n   ```\n\n3. **Handle errors gracefully**\n   ```typescript\n   // ‚úÖ CORRECT - catches and logs errors\n   async callback({ client, events, webhookContext }) {\n       for (const event of events) {\n           try {\n               await processEvent(event);\n           } catch (error) {\n               console.error('Failed to process event:', event.event, error);\n               // Continue processing other events\n           }\n       }\n   }\n   ```\n\n4. **Check event type before processing**\n   ```typescript\n   // ‚úÖ CORRECT - checks event type\n   callback({ client, events, webhookContext }) {\n       events.forEach(event => {\n           if (event.event === 'file.added') {\n               console.log('New file:', event.file?.name);\n           } else if (event.event === 'file.updated') {\n               console.log('Updated file:', event.file?.name);\n           }\n       });\n   }\n   ```\n\n5. **Use webhookContext for scoping**\n   ```typescript\n   // ‚úÖ CORRECT - uses context for organization-specific logic\n   async callback({ client, events, webhookContext }) {\n       const orgId = webhookContext.organizationId;\n       const userId = webhookContext.userId;\n       \n       // Store event in metadata\n       const key = `org_${orgId}_events_${Date.now()}`;\n       // await crowdinModule.metadataStore.saveMetadata(key, events, `${webhookContext.domain || webhookContext.organizationId}`);\n   }\n   ```\n\n6. **Don't perform long-running operations**\n   ```typescript\n   // ‚úÖ CORRECT - quick processing, delegate heavy work\n   async callback({ client, events, webhookContext }) {\n       // Quick logging\n       console.log('Received', events.length, 'events');\n       \n       // Store for later processing\n       const key = `org_${webhookContext.organizationId}_queue`;\n       // await crowdinModule.metadataStore.saveMetadata(key, events, `${webhookContext.domain || webhookContext.organizationId}`);\n   }\n   \n   // ‚ö†Ô∏è PROBLEMATIC - long-running operation blocks webhook\n   async callback({ client, events, webhookContext }) {\n       // This might timeout\n       for (const event of events) {\n           await processLargeFile(event.file?.id);\n           await sendMultipleNotifications(event);\n           await updateExternalDatabase(event);\n       }\n   }\n   ```\n\n#### Event Object Structure\n\nEach event type has its own interface with specific fields. Use these interfaces to understand which data is available for each event:\n\n```typescript\n// ============================================================================\n// SHARED MODELS - Reusable data structures\n// ============================================================================\n\ninterface ProjectModel {\n    id: number;\n    name: string;\n    identifier: string;\n    sourceLanguageId: string;\n    targetLanguageIds: string[];\n}\n\ninterface UserModel {\n    id: number;\n    username: string;\n}\n\ninterface LanguageModel {\n    id: string;\n    name: string;\n}\n\ninterface FileModelBase {\n    id: number;\n    name: string;\n    title: string;\n    type: string;\n    path: string;\n    branchId: number | null;\n    directoryId: number | null;\n}\n\ninterface FileModel extends FileModelBase {\n    project: ProjectModel;\n}\n\ninterface GroupModel {\n    id: number;\n    name: string;\n    parentId: number | null;\n}\n\ninterface StringModelBase {\n    id: number;\n    identifier: string;\n    text: string;\n    context: string | null;\n    isHidden: boolean;\n}\n\ninterface StringModel extends StringModelBase {\n    file: FileModelBase;\n    project: ProjectModel;\n}\n\ninterface TranslationModelBase {\n    id: number;\n    text: string;\n}\n\ninterface TranslationModel extends TranslationModelBase {\n    user: UserModel;\n    targetLanguage: LanguageModel;\n    string: StringModel;\n}\n\ninterface TaskModel {\n    id: number;\n    type: 0 | 1; // 0 - Translate, 1 - Proofread\n    title: string;\n    status: 'todo' | 'in_progress' | 'done' | 'closed' | 'pending' | 'review';\n    sourceLanguage: LanguageModel;\n    targetLanguage: LanguageModel;\n    project: ProjectModel;\n    taskCreator: UserModel;\n}\n\ninterface CommentModelBase {\n    id: number;\n    text: string;\n    type: 'issue' | 'comment';\n    issueType: 'general_question' | 'translation_mistake' |  'context_request' |  'source_mistake';\n    issueStatus: 'resolved' | 'unresolved';\n}\n\ninterface CommentModel extends CommentModelBase {\n    string: StringModel;\n    targetLanguage: LanguageModel;\n    user: UserModel;\n    commentResolver: UserModel | null;\n}\n\ninterface BuildModel {\n    id: number;\n    downloadUrl: string;\n    project: ProjectModel;\n}\n\n// ============================================================================\n// BASE EVENT INTERFACES\n// ============================================================================\n\ninterface BaseEventWithUser {\n    user: UserModel;\n}\n\ninterface BaseProjectEvent {\n    project: ProjectModel;\n}\n\ninterface BaseGroupEvent {\n    group: GroupModel;\n}\n\ninterface BaseFileEvent {\n    file: FileModel;\n}\n\ninterface BaseStringEvent {\n    string: StringModel;\n}\n\ninterface BaseTranslationEvent {\n    translation: TranslationModel;\n}\n\ninterface BaseTaskEvent {\n    task: TaskModel;\n}\n\ninterface BaseCommentEvent {\n    comment: CommentModel;\n}\n\n// ============================================================================\n// PROJECT EVENTS\n// ============================================================================\n\ninterface ProjectCreatedEvent extends BaseProjectEvent, BaseEventWithUser {\n    event: 'project.created';\n}\n\ninterface ProjectDeletedEvent extends BaseProjectEvent, BaseEventWithUser {\n    event: 'project.deleted';\n}\n\ninterface ProjectTranslatedEvent extends BaseProjectEvent {\n    event: 'project.translated';\n    targetLanguage: LanguageModel;\n}\n\ninterface ProjectApprovedEvent extends BaseProjectEvent {\n    event: 'project.approved';\n    targetLanguage: LanguageModel;\n}\n\ninterface ProjectBuiltEvent {\n    event: 'project.built';\n    build: BuildModel;\n}\n\n// ============================================================================\n// GROUP EVENTS\n// ============================================================================\n\ninterface GroupCreatedEvent extends BaseGroupEvent, BaseEventWithUser {\n    event: 'group.created';\n}\n\ninterface GroupDeletedEvent extends BaseGroupEvent, BaseEventWithUser {\n    event: 'group.deleted';\n}\n\n// ============================================================================\n// FILE EVENTS\n// ============================================================================\n\ninterface FileAddedEvent extends BaseFileEvent, BaseEventWithUser {\n    event: 'file.added';\n}\n\ninterface FileUpdatedEvent extends BaseFileEvent, BaseEventWithUser {\n    event: 'file.updated';\n}\n\ninterface FileDeletedEvent extends BaseFileEvent, BaseEventWithUser {\n    event: 'file.deleted';\n}\n\ninterface FileRevertedEvent extends BaseFileEvent, BaseEventWithUser {\n    event: 'file.reverted';\n}\n\ninterface FileTranslatedEvent extends BaseFileEvent {\n    event: 'file.translated';\n    targetLanguage: LanguageModel;\n}\n\ninterface FileApprovedEvent extends BaseFileEvent {\n    event: 'file.approved';\n    targetLanguage: LanguageModel;\n}\n\n// ============================================================================\n// STRING EVENTS\n// ============================================================================\n\ninterface StringAddedEvent extends BaseStringEvent, BaseEventWithUser {\n    event: 'string.added';\n}\n\ninterface StringUpdatedEvent extends BaseStringEvent, BaseEventWithUser {\n    event: 'string.updated';\n}\n\ninterface StringDeletedEvent extends BaseStringEvent, BaseEventWithUser {\n    event: 'string.deleted';\n}\n\n// ============================================================================\n// TRANSLATION/SUGGESTION EVENTS\n// ============================================================================\n\ninterface SuggestionAddedEvent extends BaseTranslationEvent {\n    event: 'suggestion.added';\n}\n\ninterface SuggestionUpdatedEvent extends BaseTranslationEvent {\n    event: 'suggestion.updated';\n}\n\ninterface SuggestionDeletedEvent extends BaseTranslationEvent {\n    event: 'suggestion.deleted';\n}\n\ninterface SuggestionApprovedEvent extends BaseTranslationEvent {\n    event: 'suggestion.approved';\n}\n\ninterface SuggestionDisapprovedEvent extends BaseTranslationEvent {\n    event: 'suggestion.disapproved';\n}\n\ninterface TranslationUpdatedEvent {\n    event: 'translation.updated';\n    newTranslation: TranslationModel;\n}\n\n// ============================================================================\n// COMMENT EVENTS\n// ============================================================================\n\ninterface StringCommentCreatedEvent extends BaseCommentEvent {\n    event: 'stringComment.created';\n}\n\ninterface StringCommentUpdatedEvent extends BaseCommentEvent {\n    event: 'stringComment.updated';\n}\n\ninterface StringCommentDeletedEvent extends BaseCommentEvent {\n    event: 'stringComment.deleted';\n}\n\ninterface StringCommentRestoredEvent extends BaseCommentEvent {\n    event: 'stringComment.restored';\n}\n\n// ============================================================================\n// TASK EVENTS\n// ============================================================================\n\ninterface TaskAddedEvent extends BaseTaskEvent {\n    event: 'task.added';\n}\n\ninterface TaskStatusChangedEvent extends BaseTaskEvent {\n    event: 'task.statusChanged';\n}\n\ninterface TaskUpdatedEvent extends BaseTaskEvent {\n    event: 'task.updated';\n}\n\ninterface TaskDeletedEvent extends BaseTaskEvent {\n    event: 'task.deleted';\n}\n\n// ============================================================================\n// UNION TYPE - All possible webhook events\n// ============================================================================\n\ntype WebhookEvent = \n    // Project events\n    | ProjectCreatedEvent\n    | ProjectDeletedEvent\n    | ProjectTranslatedEvent\n    | ProjectApprovedEvent\n    | ProjectBuiltEvent\n    // Group events\n    | GroupCreatedEvent\n    | GroupDeletedEvent\n    // File events\n    | FileAddedEvent\n    | FileUpdatedEvent\n    | FileDeletedEvent\n    | FileRevertedEvent\n    | FileTranslatedEvent\n    | FileApprovedEvent\n    // String events\n    | StringAddedEvent\n    | StringUpdatedEvent\n    | StringDeletedEvent\n    // Translation/Suggestion events\n    | SuggestionAddedEvent\n    | SuggestionUpdatedEvent\n    | SuggestionDeletedEvent\n    | SuggestionApprovedEvent\n    | SuggestionDisapprovedEvent\n    | TranslationUpdatedEvent\n    // Comment events\n    | StringCommentCreatedEvent\n    | StringCommentUpdatedEvent\n    | StringCommentDeletedEvent\n    | StringCommentRestoredEvent\n    // Task events\n    | TaskAddedEvent\n    | TaskStatusChangedEvent\n    | TaskUpdatedEvent\n    | TaskDeletedEvent;\n```\n\n## Frontend Development\n\n### Crowdin Apps JS API\n\n#### Official Documentation\n\nThe `AP` object provides the Crowdin Apps JS API for interacting with the Crowdin application context.\n\n**üìö Complete API Reference:** https://support.crowdin.com/developer/crowdin-apps-js/\n\n**‚ö†Ô∏è CRITICAL**: Only use methods and types from the Crowdin Apps JS API definitions below.\n\n**Do NOT invent methods or properties that are not listed here.**\n\n#### Common Examples\n\n**Get Context (Promise-based):**\n```typescript\n// Promisified helper\nconst getContext = (): Promise<any> => {\n    return new Promise(resolve => window.AP.getContext(resolve));\n};\n\n// Usage\nconst context = await getContext();\nconsole.log('Project ID:', context.project_id);\n```\n\n**Get JWT Token (Promise-based):**\n```typescript\n// Promisified helper\nconst getJwtToken = (): Promise<string> => {\n    return new Promise(resolve => window.AP.getJwtToken(resolve));\n};\n\n// Usage with fetch\nconst token = await getJwtToken();\nconst response = await fetch(`/api/endpoint?jwt=${token}`);\nconst data = await response.json();\n```\n\n#### Best Practices\n\n1. **Handle errors gracefully**\n   ```typescript\n   try {\n       const context = await getContext();\n       if (!context.organization_id) {\n           throw new Error('Organization ID not found');\n       }\n       // Your code\n   } catch (error) {\n       console.error('Failed to get context:', error);\n   }\n   ```\n\n#### Complete Type Definitions\n\n##### Global AP Object Structure\n\n```typescript\ndeclare namespace AP {\n    // Global Actions\n    function getContext(callback: (context: Context) => void): void;\n    function getJwtToken(callback: (token: string) => void): void;\n    function getTheme(): 'light' | 'dark';\n    function redirect(path: string): void;\n}\n```\n\n##### Type Definitions\n\n```typescript\n// Context Information\ninterface Context {\n    project_id: number;\n    organization_id: number;\n}\n```\n\n## Development Workflow\n\n### 1. Configure Your App Identity\n\n**‚ö†Ô∏è Important**: You MUST update the configuration in `worker/app.ts` before deployment:\n\n```typescript\nconst configuration: ClientConfig = {\n    name: \"Your App Name\",           // Change this to your app's display name\n    identifier: \"your-app-id\",       // Change to unique identifier (lowercase, hyphens)\n    description: \"Your app description\", // Change to describe your app's purpose\n    // ... rest of configuration\n}\n```\n\n**Note**: The `identifier` must be unique across all Crowdin apps. Use format like: `company-custom-mt`\n\n### 2. Key Files to Modify\n\n- `worker/app.ts` - Add new API endpoints here\n- `src/pages/HomePage.tsx` - Main page component (customize for your app logic)\n- `src/components/app-sidebar.tsx` - Sidebar navigation (customize menu items)\n- `src/components/layout/AppLayout.tsx` - Application layout (customize layout structure)\n- `src/index.css` - Customize global styles and Tailwind theme\n- `tailwind.config.js` - Add custom colors and extend theme"
    }
  }
]